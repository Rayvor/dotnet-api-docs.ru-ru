<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0f4a1bb9f35be38e9a01180a5f34792030a72e08" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75158573" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="41960-101">Предоставляет пул потоков, который можно использовать для выполнения задач, отправки рабочих элементов, обработки асинхронного ввода-вывода, ожидания от имени других потоков и обработки таймеров.</span><span class="sxs-lookup"><span data-stu-id="41960-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-102">Многие приложения создают потоки, которые тратят много времени на спящий режим, ожидая возникновения события.</span><span class="sxs-lookup"><span data-stu-id="41960-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="41960-103">Другие потоки могут войти в спящее состояние только для периодического опроса на наличие изменений или сведений о состоянии обновления.</span><span class="sxs-lookup"><span data-stu-id="41960-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="41960-104">Пул потоков позволяет более эффективно использовать потоки, предоставляя приложению пул рабочих потоков, управляемых системой.</span><span class="sxs-lookup"><span data-stu-id="41960-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="41960-105">Примеры операций, использующих потоки пула потоков, включают следующее.</span><span class="sxs-lookup"><span data-stu-id="41960-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="41960-106">При создании <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601> объекта для асинхронного выполнения некоторой задачи по умолчанию задача запланирована на выполнение в потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="41960-107">Асинхронные таймеры используют пул потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="41960-108">Потоки из пула потоков выполняют обратные вызовы из класса <xref:System.Threading.Timer?displayProperty=nameWithType> и вызывают события из класса <xref:System.Timers.Timer?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="41960-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="41960-109">При использовании зарегистрированных дескрипторов ожидания системный поток отслеживает состояние дескрипторов ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="41960-110">По завершении операции ожидания рабочий поток из пула потоков выполняет соответствующую функцию обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="41960-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="41960-111">При вызове метода <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> для постановки в очередь метода для выполнения в потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="41960-112">Это можно сделать, передав методу делегат <xref:System.Threading.WaitCallback>.</span><span class="sxs-lookup"><span data-stu-id="41960-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="41960-113">Делегат имеет сигнатуру</span><span class="sxs-lookup"><span data-stu-id="41960-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="41960-114">где `state` — это объект, содержащий данные, которые будут использоваться делегатом.</span><span class="sxs-lookup"><span data-stu-id="41960-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="41960-115">Фактические данные могут быть переданы делегату путем вызова метода <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="41960-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="41960-116">Потоки в пуле управляемых потоков являются фоновыми потоками.</span><span class="sxs-lookup"><span data-stu-id="41960-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="41960-117">То есть `true`их свойства <xref:System.Threading.Thread.IsBackground%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="41960-118">Это означает, что поток <xref:System.Threading.ThreadPool> не будет работать с приложением после выхода из всех передних потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="41960-119">Когда пул потоков повторно использует поток, он не очищает данные в локальном хранилище потока или в полях, помеченных атрибутом <xref:System.ThreadStaticAttribute>.</span><span class="sxs-lookup"><span data-stu-id="41960-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="41960-120">Таким образом, когда метод проверяет локальное хранилище потока или поля, помеченные атрибутом <xref:System.ThreadStaticAttribute>, найденные значения могут остаться в более раннем использовании потока пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="41960-121">Кроме того, можно ставить в очередь рабочие элементы, не связанные с операцией ожидания, в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="41960-122">Чтобы запросить обработку рабочего элемента потоком в пуле потоков, вызовите метод <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="41960-123">Этот метод принимает в качестве параметра ссылку на метод или делегат, который будет вызываться потоком, выбранным из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="41960-124">Невозможно отменить рабочий элемент после его постановки в очередь.</span><span class="sxs-lookup"><span data-stu-id="41960-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="41960-125">Таймеры очереди и зарегистрированные операции ожидания также используют пул потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="41960-126">Функции обратного вызова помещаются в очередь пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="41960-127">Для каждого процесса существует один пул потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-127">There is one thread pool per process.</span></span> <span data-ttu-id="41960-128">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] размер по умолчанию пула потоков для процесса зависит от нескольких факторов, таких как размер виртуального адресного пространства.</span><span class="sxs-lookup"><span data-stu-id="41960-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="41960-129">Процесс может вызвать метод <xref:System.Threading.ThreadPool.GetMaxThreads%2A> для определения количества потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="41960-130">Число потоков в пуле потоков можно изменить с помощью метода <xref:System.Threading.ThreadPool.SetMaxThreads%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="41960-131">Каждый поток использует размер стека по умолчанию и выполняется с приоритетом по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="41960-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="41960-132">Неуправляемый код, в котором размещается .NET Framework, может изменять размер пула потоков с помощью функции `CorSetMaxThreads`, определенной в файле mscoree. h.</span><span class="sxs-lookup"><span data-stu-id="41960-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="41960-133">Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не достигнет минимального значения для каждой категории.</span><span class="sxs-lookup"><span data-stu-id="41960-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="41960-134">При достижении минимального значения пул потоков может создавать дополнительные потоки в этой категории или ожидать завершения некоторых задач.</span><span class="sxs-lookup"><span data-stu-id="41960-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="41960-135">Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] пул потоков создает и уничтожает рабочие потоки в целях оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени.</span><span class="sxs-lookup"><span data-stu-id="41960-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="41960-136">Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое их количество может усиливать конкуренцию за ресурсы.</span><span class="sxs-lookup"><span data-stu-id="41960-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="41960-137">Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.</span><span class="sxs-lookup"><span data-stu-id="41960-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="41960-138">Для получения этих минимальных значений можно использовать метод <xref:System.Threading.ThreadPool.GetMinThreads%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="41960-139">Для увеличения минимального числа потоков можно использовать метод <xref:System.Threading.ThreadPool.SetMinThreads%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="41960-140">Однако необоснованное увеличение этих значений может привести к снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="41960-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="41960-141">Если одновременно запускается слишком много задач, все они могут выполняться слишком медленно.</span><span class="sxs-lookup"><span data-stu-id="41960-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="41960-142">В большинстве случаев пул потоков работает наилучшим образом, если он использует собственный алгоритм выделения потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41960-143">В следующем примере поток основного приложения ставит в очередь метод с именем `ThreadProc` для выполнения в потоке пула потоков, заждет одну секунду, а затем завершает работу.</span><span class="sxs-lookup"><span data-stu-id="41960-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="41960-144">Метод `ThreadProc` просто отображает сообщение.</span><span class="sxs-lookup"><span data-stu-id="41960-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="41960-145">Если закомментировать вызов метода <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>, основной поток завершается до выполнения метода в потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="41960-146">Пул потоков использует фоновые потоки, которые не сохраняют выполнение приложения, если все потоки переднего плана завершаются.</span><span class="sxs-lookup"><span data-stu-id="41960-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="41960-147">(Это простой пример состояния гонки.)</span><span class="sxs-lookup"><span data-stu-id="41960-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="41960-148">Данный тип потокобезопасен.</span><span class="sxs-lookup"><span data-stu-id="41960-148">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="41960-149">Потоки и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="41960-149">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="41960-150">Группирование управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="41960-150">The Managed Thread Pooling</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="41960-151">Связывает дескриптор операционной системы с объектом <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="41960-151">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="41960-152">Структура <see cref="T:System.IntPtr" />, хранящая дескриптор.</span><span class="sxs-lookup"><span data-stu-id="41960-152">An <see cref="T:System.IntPtr" /> that holds the handle.</span></span> <span data-ttu-id="41960-153">Дескриптор должен быть открыт для перекрывающегося ввода-вывода в неуправляемой области.</span><span class="sxs-lookup"><span data-stu-id="41960-153">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="41960-154">Связывает дескриптор операционной системы с объектом <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="41960-154">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="41960-155">Значение <see langword="true" />, если дескриптор является связанным; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="41960-155"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="41960-156">У вызывающего объекта отсутствует необходимое разрешение.</span><span class="sxs-lookup"><span data-stu-id="41960-156">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="41960-157">для возможности вызова неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="41960-157">for the ability to call unmanaged code.</span></span> <span data-ttu-id="41960-158">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="41960-158">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="41960-159">Объект <see cref="T:System.Runtime.InteropServices.SafeHandle" />, содержащий дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="41960-159">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span></span> <span data-ttu-id="41960-160">Дескриптор должен быть открыт для перекрывающегося ввода-вывода в неуправляемой области.</span><span class="sxs-lookup"><span data-stu-id="41960-160">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="41960-161">Связывает дескриптор операционной системы с объектом <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="41960-161">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="41960-162">Значение <see langword="true" />, если дескриптор является связанным; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="41960-162"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-163">Параметр `osHandle` должен быть <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, который является производным от абстрактного <xref:System.Runtime.InteropServices.SafeHandle> класса.</span><span class="sxs-lookup"><span data-stu-id="41960-163">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="41960-164"><paramref name="osHandle" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="41960-164"><paramref name="osHandle" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="41960-165">для возможности вызова неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="41960-165">for the ability to call unmanaged code.</span></span> <span data-ttu-id="41960-166">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="41960-166">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CompletedWorkItemCount">
      <MemberSignature Language="C#" Value="public static long CompletedWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 CompletedWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long CompletedWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedWorkItemCount : int64" Usage="System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41960-167">Возвращает количество рабочих элементов, обработанных на данный момент.</span><span class="sxs-lookup"><span data-stu-id="41960-167">Gets the number of work items that have been processed so far.</span></span></summary>
        <value><span data-ttu-id="41960-168">Количество рабочих элементов, обработанных на данный момент.</span><span class="sxs-lookup"><span data-stu-id="41960-168">The number of work items that have been processed so far.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="41960-169">Если реализация пула потоков может иметь различные типы рабочих элементов, счетчик включает все типы.</span><span class="sxs-lookup"><span data-stu-id="41960-169">If a thread pool implementation may have different types of work items, the count includes all types.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="41960-170">Количество доступных рабочих потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-170">The number of available worker threads.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="41960-171">Количество доступных потоков асинхронного ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="41960-171">The number of available asynchronous I/O threads.</span></span></param>
        <summary><span data-ttu-id="41960-172">Возвращает разницу между максимальным числом потоков пула, возвращаемых методом <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />, и числом активных в данный момент потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-172">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-173">Когда <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> возвращает значение, переменная, заданная параметром `workerThreads`, содержит количество дополнительных рабочих потоков, которые могут быть запущены, а переменная, заданная `completionPortThreads`, содержит количество дополнительных потоков асинхронного ввода-вывода, которые могут быть запущены.</span><span class="sxs-lookup"><span data-stu-id="41960-173">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="41960-174">Если нет доступных потоков, дополнительные запросы пула потоков остаются в очереди до тех пор, пока потоки пула потоков не станут доступными.</span><span class="sxs-lookup"><span data-stu-id="41960-174">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41960-175">В следующем примере отображается количество рабочих потоков и потоков ввода-вывода, доступных при запуске простого приложения.</span><span class="sxs-lookup"><span data-stu-id="41960-175">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="41960-176">Максимальное количество рабочих потоков в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-176">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="41960-177">Максимальное количество потоков асинхронного ввода-вывода в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-177">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="41960-178">Возвращает количество запросов к пулу потоков, которые могут быть активными одновременно.</span><span class="sxs-lookup"><span data-stu-id="41960-178">Retrieves the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="41960-179">Все запросы, превышающие это количество, остаются в очереди до тех пор, пока потоки пула не станут доступны.</span><span class="sxs-lookup"><span data-stu-id="41960-179">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-180">Когда <xref:System.Threading.ThreadPool.GetMaxThreads%2A> возвращает значение, переменная, заданная параметром `workerThreads`, содержит максимальное количество рабочих потоков, разрешенных в пуле потоков, а переменная, заданная `completionPortThreads`, содержит максимальное число потоков асинхронного ввода-вывода, разрешенных в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-180">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="41960-181">Можно использовать метод <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> для определения фактического числа потоков в пуле потоков в любое заданное время.</span><span class="sxs-lookup"><span data-stu-id="41960-181">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="41960-182">Можно использовать <xref:System.Threading.ThreadPool.SetMaxThreads%2A>, чтобы задать максимальное число рабочих потоков и асинхронных потоков ввода-вывода в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-182">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="41960-183">Вы можете поставить в очередь столько запросов пула потоков, сколько позволяет системная память.</span><span class="sxs-lookup"><span data-stu-id="41960-183">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="41960-184">Если количество запросов превышает количество потоков пула потоков, дополнительные запросы остаются в очереди до тех пор, пока потоки пула потоков не станут доступными.</span><span class="sxs-lookup"><span data-stu-id="41960-184">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41960-185">В следующем примере кода показано, как получить количество максимального и доступного количества потоков в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-185">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="41960-186">Рабочий элемент поставлен в очередь, который использует `FileStream` для асинхронной записи в два файла.</span><span class="sxs-lookup"><span data-stu-id="41960-186">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="41960-187">Методы обратного вызова перекрываются по времени.</span><span class="sxs-lookup"><span data-stu-id="41960-187">The callback methods are timed to overlap.</span></span> <span data-ttu-id="41960-188">Рабочий поток обрабатывает рабочий элемент и, в зависимости от скорости и количества процессоров на компьютере, один или два потока портов завершения обрабатывают операции записи.</span><span class="sxs-lookup"><span data-stu-id="41960-188">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="41960-189">При возвращении метода содержит минимальное количество рабочих потоков, которые создаются пулом потоков по требованию.</span><span class="sxs-lookup"><span data-stu-id="41960-189">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="41960-190">При возвращении метода содержит минимальное количество потоков асинхронного ввода-вывода, которые создаются пулом потоков по требованию.</span><span class="sxs-lookup"><span data-stu-id="41960-190">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="41960-191">Возвращает минимальное число потоков, создаваемых пулом потоков по требованию по мере поступления новых запросов перед переходом на алгоритм управления созданием и уничтожением потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-191">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-192">Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не достигнет минимального значения для каждой категории.</span><span class="sxs-lookup"><span data-stu-id="41960-192">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="41960-193">По умолчанию минимальное число потоков равно количеству процессоров в системе.</span><span class="sxs-lookup"><span data-stu-id="41960-193">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="41960-194">По достижении минимального значения пул потоков может создавать дополнительные потоки в этой категории или дожидаться завершения некоторых задач.</span><span class="sxs-lookup"><span data-stu-id="41960-194">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="41960-195">Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], пул потоков создает и уничтожает потоки, чтобы оптимизировать пропускную способность, которая определяется как количество задач, завершенных за единицу времени.</span><span class="sxs-lookup"><span data-stu-id="41960-195">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="41960-196">Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое их количество может усиливать конкуренцию за ресурсы.</span><span class="sxs-lookup"><span data-stu-id="41960-196">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="41960-197">Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.</span><span class="sxs-lookup"><span data-stu-id="41960-197">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41960-198">В следующем примере минимальное количество рабочих потоков устанавливается равным четырем и сохраняется исходное значение минимального числа потоков завершения асинхронного ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="41960-198">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="PendingWorkItemCount">
      <MemberSignature Language="C#" Value="public static long PendingWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 PendingWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PendingWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long PendingWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PendingWorkItemCount : int64" Usage="System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41960-199">Возвращает количество рабочих элементов, находящихся в настоящее время в очереди на обработку.</span><span class="sxs-lookup"><span data-stu-id="41960-199">Gets the number of work items that are currently queued to be processed.</span></span></summary>
        <value><span data-ttu-id="41960-200">Число рабочих элементов, находящихся в очереди для обработки.</span><span class="sxs-lookup"><span data-stu-id="41960-200">The number of work items that are currently queued to be processed.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="41960-201">Если реализация пула потоков может иметь различные типы рабочих элементов, то счетчик включает все типы, которые можно относить, а это могут быть только рабочие элементы пользователя, включая задачи.</span><span class="sxs-lookup"><span data-stu-id="41960-201">If a thread pool implementation may have different types of work items, the count includes all types that can be tracked, which may only be the user work items, including tasks.</span></span> <span data-ttu-id="41960-202">Некоторые реализации могут также включать таймер очереди и обратные вызовы ожидания в числе.</span><span class="sxs-lookup"><span data-stu-id="41960-202">Some implementations may also include queued timer and wait callbacks in the count.</span></span> <span data-ttu-id="41960-203">В Windows счетчик вряд ли будет включать в себя количество завершенных операций ввода-вывода, так как они передаются непосредственно в порт завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="41960-203">On Windows, the count is unlikely to include the number of pending IO completions, because they are posted directly to an IO completion port.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="41960-204">Помещает метод в очередь на выполнение.</span><span class="sxs-lookup"><span data-stu-id="41960-204">Queues a method for execution.</span></span> <span data-ttu-id="41960-205">Метод выполняется, когда становится доступен поток из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-205">The method executes when a thread pool thread becomes available.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="41960-206">Делегат <see cref="T:System.Threading.WaitCallback" />, представляющий метод, который требуется выполнить.</span><span class="sxs-lookup"><span data-stu-id="41960-206">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span></span></param>
        <summary><span data-ttu-id="41960-207">Помещает метод в очередь на выполнение.</span><span class="sxs-lookup"><span data-stu-id="41960-207">Queues a method for execution.</span></span> <span data-ttu-id="41960-208">Метод выполняется, когда становится доступен поток из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-208">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="41960-209">Значение <see langword="true" />, если метод успешно помещен в очередь. Если рабочий элемент не может быть помещен очередь, выдается исключение <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="41960-209"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-210">Данные, необходимые для метода в очереди, можно поместить в поля экземпляра класса, в котором определен метод, или можно использовать перегрузку <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>, которая принимает объект, содержащий необходимые данные.</span><span class="sxs-lookup"><span data-stu-id="41960-210">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="41960-211">Visual Basic пользователи могут опустить конструктор <xref:System.Threading.WaitCallback> и просто использовать оператор `AddressOf` при передаче метода обратного вызова в <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-211">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="41960-212">Visual Basic автоматически вызывает правильный конструктор делегата.</span><span class="sxs-lookup"><span data-stu-id="41960-212">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="41960-213">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="41960-213">Version Information</span></span>  
 <span data-ttu-id="41960-214">В .NET Framework версии 2,0 значение свойства <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> распространяется на рабочие потоки, помещенные в очередь с помощью метода <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-214">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="41960-215">В более ранних версиях сведения о субъекте не распространяются.</span><span class="sxs-lookup"><span data-stu-id="41960-215">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41960-216">В следующем примере перегрузка метода <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> используется для постановки в очередь задачи, представленной методом `ThreadProc`, для выполнения в случае, когда поток становится доступным.</span><span class="sxs-lookup"><span data-stu-id="41960-216">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="41960-217">Эта перегрузка не предоставляет сведений о задачах.</span><span class="sxs-lookup"><span data-stu-id="41960-217">No task information is supplied with this overload.</span></span> <span data-ttu-id="41960-218">Таким образом, информация, доступная для метода `ThreadProc`, ограничена объектом, которому принадлежит метод.</span><span class="sxs-lookup"><span data-stu-id="41960-218">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="41960-219"><paramref name="callBack" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="41960-219"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41960-220">Среда CLR является размещенной, а основное приложение не поддерживает это действие.</span><span class="sxs-lookup"><span data-stu-id="41960-220">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="41960-221">Пул управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="41960-221">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="41960-222">Делегат <see cref="T:System.Threading.WaitCallback" />, представляющий выполняемый метод.</span><span class="sxs-lookup"><span data-stu-id="41960-222">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="41960-223">Объект, содержащий данные, используемые методом.</span><span class="sxs-lookup"><span data-stu-id="41960-223">An object containing data to be used by the method.</span></span></param>
        <summary><span data-ttu-id="41960-224">Помещает метод в очередь на выполнение и указывает объект, содержащий данные для использования методом.</span><span class="sxs-lookup"><span data-stu-id="41960-224">Queues a method for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="41960-225">Метод выполняется, когда становится доступен поток из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-225">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="41960-226">Значение <see langword="true" />, если метод успешно помещен в очередь. Если рабочий элемент не может быть помещен очередь, выдается исключение <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="41960-226"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-227">Если метод обратного вызова требует сложных данных, можно определить класс для хранения данных.</span><span class="sxs-lookup"><span data-stu-id="41960-227">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="41960-228">Visual Basic пользователи могут опустить конструктор <xref:System.Threading.WaitCallback> и просто использовать оператор `AddressOf` при передаче метода обратного вызова в <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-228">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="41960-229">Visual Basic автоматически вызывает правильный конструктор делегата.</span><span class="sxs-lookup"><span data-stu-id="41960-229">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="41960-230">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="41960-230">Version Information</span></span>  
 <span data-ttu-id="41960-231">В .NET Framework версии 2,0 значение свойства <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> распространяется на рабочие потоки, помещенные в очередь с помощью метода <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-231">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="41960-232">В более ранних версиях сведения о субъекте не распространяются.</span><span class="sxs-lookup"><span data-stu-id="41960-232">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41960-233">В следующем примере пул потоков .NET используется для вычисления `Fibonacci`ного результата для пяти чисел в диапазоне от 20 до 40.</span><span class="sxs-lookup"><span data-stu-id="41960-233">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="41960-234">Каждый результат `Fibonacci` представлен классом `Fibonacci`, который предоставляет метод с именем `ThreadPoolCallback`, выполняющий вычисление.</span><span class="sxs-lookup"><span data-stu-id="41960-234">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="41960-235">Создается объект, представляющий каждое значение `Fibonacci`, а затем метод `ThreadPoolCallback` передается в объект <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, который назначает для выполнения метода доступный в пуле поток.</span><span class="sxs-lookup"><span data-stu-id="41960-235">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="41960-236">Поскольку каждому объекту `Fibonacci` присвоено произвольное значение для вычисления, и поскольку каждый поток будет конкурировать за процессорное время, нельзя заранее определить, сколько времени потребуется для вычисления всех пяти результатов.</span><span class="sxs-lookup"><span data-stu-id="41960-236">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="41960-237">Именно поэтому во время конструирования каждому объекту `Fibonacci` передается экземпляр класса <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="41960-237">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="41960-238">Каждый объект сигнализирует предоставленному объекту события о завершении его вычисления, что позволяет основному потоку блокировать выполнение с <xref:System.Threading.WaitHandle.WaitAll%2A> до тех пор, пока не будет вычислен результат для всех пяти `Fibonacci`ных объектов.</span><span class="sxs-lookup"><span data-stu-id="41960-238">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="41960-239">После этого метод `Main` отображает каждый результат `Fibonacci`.</span><span class="sxs-lookup"><span data-stu-id="41960-239">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41960-240">Среда CLR является размещенной, а основное приложение не поддерживает это действие.</span><span class="sxs-lookup"><span data-stu-id="41960-240">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="41960-241"><paramref name="callBack" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="41960-241"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="41960-242">Пул управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="41960-242">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><span data-ttu-id="41960-243">Тип элементов <paramref name="state" />.</span><span class="sxs-lookup"><span data-stu-id="41960-243">The type of elements of <paramref name="state" />.</span></span></typeparam>
        <param name="callBack"><span data-ttu-id="41960-244"><see cref="T:System.Action`1" /> для представления выполняемого метода.</span><span class="sxs-lookup"><span data-stu-id="41960-244">An <see cref="T:System.Action`1" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="41960-245">Объект, содержащий данные, используемые методом.</span><span class="sxs-lookup"><span data-stu-id="41960-245">An object containing data to be used by the method.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="41960-246"><see langword="true" />, чтобы предпочитать ставить рабочий элемент в очередь близко к текущему потоку; <see langword="false" />, чтобы предпочитать ставить рабочий элемент в общую очередь пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-246"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="41960-247">Помещает метод, определенный делегатом <see cref="T:System.Action`1" />, в очередь на выполнение и указывает данные для этого метода.</span><span class="sxs-lookup"><span data-stu-id="41960-247">Queues a method specified by an <see cref="T:System.Action`1" /> delegate for execution, and provides data to be used by the method.</span></span> <span data-ttu-id="41960-248">Метод выполняется, когда становится доступен поток из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-248">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="41960-249">Значение <see langword="true" />, если метод успешно помещен в очередь. Если рабочий элемент не может быть помещен очередь, выдается исключение <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="41960-249"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span>
<span data-ttu-id="41960-250">.</span><span class="sxs-lookup"><span data-stu-id="41960-250">.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="41960-251">Регистрирует делегат, ожидающий объект <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="41960-251">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="41960-252">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="41960-252">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="41960-253">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="41960-253">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="41960-254">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</span><span class="sxs-lookup"><span data-stu-id="41960-254">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="41960-255">Передаваемый делегату объект.</span><span class="sxs-lookup"><span data-stu-id="41960-255">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="41960-256">Время ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="41960-256">The time-out in milliseconds.</span></span> <span data-ttu-id="41960-257">Если параметр <paramref name="millisecondsTimeOutInterval" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="41960-257">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="41960-258">Если параметр <paramref name="millisecondsTimeOutInterval" /> равен -1, время ожидания функции никогда не истекает.</span><span class="sxs-lookup"><span data-stu-id="41960-258">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="41960-259">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span><span class="sxs-lookup"><span data-stu-id="41960-259"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="41960-260">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа со знаком.</span><span class="sxs-lookup"><span data-stu-id="41960-260">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="41960-261">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, инкапсулирующий собственный дескриптор.</span><span class="sxs-lookup"><span data-stu-id="41960-261">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-262">По завершении использования <xref:System.Threading.RegisteredWaitHandle>, возвращаемого этим методом, вызовите его метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, чтобы освободить ссылки на маркер ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-262">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="41960-263">Рекомендуется всегда вызывать метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, даже если для `executeOnlyOnce`задано `true`.</span><span class="sxs-lookup"><span data-stu-id="41960-263">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="41960-264">Сборка мусора более эффективна при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, а не в зависимости от метода завершения зарегистрированного обработчика ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-264">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="41960-265">Метод <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> помещает указанный делегат в очередь в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-265">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="41960-266">Рабочий поток будет выполнять делегат при возникновении одного из следующих событий:</span><span class="sxs-lookup"><span data-stu-id="41960-266">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="41960-267">Указанный объект находится в сигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="41960-267">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="41960-268">Интервал времени ожидания истекает.</span><span class="sxs-lookup"><span data-stu-id="41960-268">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="41960-269">Метод <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> проверяет текущее состояние <xref:System.Threading.WaitHandle>указанного объекта.</span><span class="sxs-lookup"><span data-stu-id="41960-269">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="41960-270">Если состояние объекта не сигнальо, метод регистрирует операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-270">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="41960-271">Операция ожидания выполняется потоком из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-271">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="41960-272">Делегат выполняется рабочим потоком, когда состояние объекта становится сигнальным или истекает интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-272">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="41960-273">Если параметр `timeOutInterval` не равен 0 (нулю), а параметр `executeOnlyOnce` имеет значение `false`, таймер сбрасывается каждый раз, когда событие получает сигнал, или истекает интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-273">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="41960-274">Использование <xref:System.Threading.Mutex> для `waitObject` не обеспечивает взаимного исключения для обратных вызовов, так как базовый API Windows использует флаг `WT_EXECUTEDEFAULT` по умолчанию, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-274">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="41960-275">Вместо <xref:System.Threading.Mutex>используйте <xref:System.Threading.Semaphore> с максимальным значением счетчика, равным 1.</span><span class="sxs-lookup"><span data-stu-id="41960-275">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="41960-276">Чтобы отменить операцию ожидания, вызовите метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="41960-276">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="41960-277">Поток ожидания использует функцию Win32 `WaitForMultipleObjects` для отслеживания зарегистрированных операций ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-277">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="41960-278">Поэтому, если необходимо использовать один и тот же собственный обработчик операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, необходимо дублировать этот обработчик с помощью функции `DuplicateHandle` Win32.</span><span class="sxs-lookup"><span data-stu-id="41960-278">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="41960-279">Обратите внимание, что объект события, переданный в <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, не должен передаваться, так как поток ожидания может не обнаружить, что событие сообщается перед сбросом.</span><span class="sxs-lookup"><span data-stu-id="41960-279">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="41960-280">Перед возвращением функция изменяет состояние некоторых типов объектов синхронизации.</span><span class="sxs-lookup"><span data-stu-id="41960-280">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="41960-281">Изменение происходит только для объекта, сигнальное состояние которого привело к удовлетворению условия ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-281">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="41960-282">Например, количество семафоров уменьшается на единицу.</span><span class="sxs-lookup"><span data-stu-id="41960-282">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="41960-283">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="41960-283">Version Information</span></span>  
 <span data-ttu-id="41960-284">Начиная с версии .NET Framework 2,0, значение свойства <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> распространяется на рабочие потоки, помещенные в очередь с помощью метода <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-284">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="41960-285">В более ранних версиях сведения о субъекте не распространяются.</span><span class="sxs-lookup"><span data-stu-id="41960-285">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="41960-286">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</span><span class="sxs-lookup"><span data-stu-id="41960-286">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="41960-287">Пул управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="41960-287">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="41960-288">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="41960-288">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="41960-289">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="41960-289">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="41960-290">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</span><span class="sxs-lookup"><span data-stu-id="41960-290">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="41960-291">Передаваемый делегату объект.</span><span class="sxs-lookup"><span data-stu-id="41960-291">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="41960-292">Время ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="41960-292">The time-out in milliseconds.</span></span> <span data-ttu-id="41960-293">Если параметр <paramref name="millisecondsTimeOutInterval" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="41960-293">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="41960-294">Если параметр <paramref name="millisecondsTimeOutInterval" /> равен -1, время ожидания функции никогда не истекает.</span><span class="sxs-lookup"><span data-stu-id="41960-294">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="41960-295">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span><span class="sxs-lookup"><span data-stu-id="41960-295"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="41960-296">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 64-разрядного целого числа со знаком.</span><span class="sxs-lookup"><span data-stu-id="41960-296">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="41960-297">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, инкапсулирующий собственный дескриптор.</span><span class="sxs-lookup"><span data-stu-id="41960-297">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-298">По завершении использования <xref:System.Threading.RegisteredWaitHandle>, возвращаемого этим методом, вызовите его метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, чтобы освободить ссылки на маркер ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-298">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="41960-299">Рекомендуется всегда вызывать метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, даже если для `executeOnlyOnce`задано `true`.</span><span class="sxs-lookup"><span data-stu-id="41960-299">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="41960-300">Сборка мусора более эффективна при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, а не в зависимости от метода завершения зарегистрированного обработчика ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-300">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="41960-301">Метод <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> помещает указанный делегат в очередь в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-301">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="41960-302">Рабочий поток будет выполнять делегат при возникновении одного из следующих событий:</span><span class="sxs-lookup"><span data-stu-id="41960-302">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="41960-303">Указанный объект находится в сигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="41960-303">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="41960-304">Интервал времени ожидания истекает.</span><span class="sxs-lookup"><span data-stu-id="41960-304">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="41960-305">Метод <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> проверяет текущее состояние <xref:System.Threading.WaitHandle>указанного объекта.</span><span class="sxs-lookup"><span data-stu-id="41960-305">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="41960-306">Если состояние объекта не сигнальо, метод регистрирует операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-306">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="41960-307">Операция ожидания выполняется потоком из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-307">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="41960-308">Делегат выполняется рабочим потоком, когда состояние объекта становится сигнальным или истекает интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-308">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="41960-309">Если параметр `timeOutInterval` не равен 0 (нулю), а параметр `executeOnlyOnce` имеет значение `false`, таймер сбрасывается каждый раз, когда событие получает сигнал, или истекает интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-309">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="41960-310">Использование <xref:System.Threading.Mutex> для `waitObject` не обеспечивает взаимного исключения для обратных вызовов, так как базовый API Windows использует флаг `WT_EXECUTEDEFAULT` по умолчанию, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-310">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="41960-311">Вместо <xref:System.Threading.Mutex>используйте <xref:System.Threading.Semaphore> с максимальным значением счетчика, равным 1.</span><span class="sxs-lookup"><span data-stu-id="41960-311">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="41960-312">Чтобы отменить операцию ожидания, вызовите метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="41960-312">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="41960-313">Поток ожидания использует функцию Win32 `WaitForMultipleObjects` для отслеживания зарегистрированных операций ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-313">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="41960-314">Поэтому, если необходимо использовать один и тот же собственный обработчик операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, необходимо дублировать этот обработчик с помощью функции `DuplicateHandle` Win32.</span><span class="sxs-lookup"><span data-stu-id="41960-314">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="41960-315">Обратите внимание, что объект события, переданный в <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, не должен передаваться, так как поток ожидания может не обнаружить, что событие сообщается перед сбросом.</span><span class="sxs-lookup"><span data-stu-id="41960-315">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="41960-316">Перед возвращением функция изменяет состояние некоторых типов объектов синхронизации.</span><span class="sxs-lookup"><span data-stu-id="41960-316">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="41960-317">Изменение происходит только для объекта, сигнальное состояние которого привело к удовлетворению условия ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-317">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="41960-318">Например, количество семафоров уменьшается на единицу.</span><span class="sxs-lookup"><span data-stu-id="41960-318">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="41960-319">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="41960-319">Version Information</span></span>  
 <span data-ttu-id="41960-320">Начиная с версии .NET Framework 2,0, значение свойства <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> распространяется на рабочие потоки, помещенные в очередь с помощью метода <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-320">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="41960-321">В более ранних версиях сведения о субъекте не распространяются.</span><span class="sxs-lookup"><span data-stu-id="41960-321">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="41960-322">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</span><span class="sxs-lookup"><span data-stu-id="41960-322">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="41960-323">Пул управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="41960-323">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="41960-324">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="41960-324">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="41960-325">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="41960-325">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="41960-326">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</span><span class="sxs-lookup"><span data-stu-id="41960-326">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="41960-327">Передаваемый делегату объект.</span><span class="sxs-lookup"><span data-stu-id="41960-327">The object passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="41960-328">Время ожидания, представленное объектом <see cref="T:System.TimeSpan" />.</span><span class="sxs-lookup"><span data-stu-id="41960-328">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="41960-329">Если параметр <paramref name="timeout" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="41960-329">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="41960-330">Если параметр <paramref name="timeout" /> равен -1, время ожидания функции никогда не истекает.</span><span class="sxs-lookup"><span data-stu-id="41960-330">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="41960-331">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span><span class="sxs-lookup"><span data-stu-id="41960-331"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="41960-332">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая значение <see cref="T:System.TimeSpan" /> для времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-332">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="41960-333">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, инкапсулирующий собственный дескриптор.</span><span class="sxs-lookup"><span data-stu-id="41960-333">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-334">По завершении использования <xref:System.Threading.RegisteredWaitHandle>, возвращаемого этим методом, вызовите его метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, чтобы освободить ссылки на маркер ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-334">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="41960-335">Рекомендуется всегда вызывать метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, даже если для `executeOnlyOnce`задано `true`.</span><span class="sxs-lookup"><span data-stu-id="41960-335">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="41960-336">Сборка мусора более эффективна при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, а не в зависимости от метода завершения зарегистрированного обработчика ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-336">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="41960-337">Метод <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> помещает указанный делегат в очередь в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-337">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="41960-338">Рабочий поток будет выполнять делегат при возникновении одного из следующих событий:</span><span class="sxs-lookup"><span data-stu-id="41960-338">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="41960-339">Указанный объект находится в сигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="41960-339">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="41960-340">Интервал времени ожидания истекает.</span><span class="sxs-lookup"><span data-stu-id="41960-340">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="41960-341">Метод <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> проверяет текущее состояние <xref:System.Threading.WaitHandle>указанного объекта.</span><span class="sxs-lookup"><span data-stu-id="41960-341">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="41960-342">Если состояние объекта не сигнальо, метод регистрирует операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-342">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="41960-343">Операция ожидания выполняется потоком из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-343">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="41960-344">Делегат выполняется рабочим потоком, когда состояние объекта становится сигнальным или истекает интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-344">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="41960-345">Если параметр `timeOutInterval` не равен 0 (нулю), а параметр `executeOnlyOnce` имеет значение `false`, таймер сбрасывается каждый раз, когда событие получает сигнал, или истекает интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-345">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="41960-346">Использование <xref:System.Threading.Mutex> для `waitObject` не обеспечивает взаимного исключения для обратных вызовов, так как базовый API Windows использует флаг `WT_EXECUTEDEFAULT` по умолчанию, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-346">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="41960-347">Вместо <xref:System.Threading.Mutex>используйте <xref:System.Threading.Semaphore> с максимальным значением счетчика, равным 1.</span><span class="sxs-lookup"><span data-stu-id="41960-347">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="41960-348">Чтобы отменить операцию ожидания, вызовите метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="41960-348">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="41960-349">Поток ожидания использует функцию Win32 `WaitForMultipleObjects` для отслеживания зарегистрированных операций ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-349">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="41960-350">Поэтому, если необходимо использовать один и тот же собственный обработчик операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, необходимо дублировать этот обработчик с помощью функции `DuplicateHandle` Win32.</span><span class="sxs-lookup"><span data-stu-id="41960-350">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="41960-351">Обратите внимание, что объект события, переданный в <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, не должен передаваться, так как поток ожидания может не обнаружить, что событие сообщается перед сбросом.</span><span class="sxs-lookup"><span data-stu-id="41960-351">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="41960-352">Перед возвращением функция изменяет состояние некоторых типов объектов синхронизации.</span><span class="sxs-lookup"><span data-stu-id="41960-352">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="41960-353">Изменение происходит только для объекта, сигнальное состояние которого привело к удовлетворению условия ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-353">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="41960-354">Например, количество семафоров уменьшается на единицу.</span><span class="sxs-lookup"><span data-stu-id="41960-354">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="41960-355">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="41960-355">Version Information</span></span>  
 <span data-ttu-id="41960-356">Начиная с версии .NET Framework 2,0, значение свойства <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> распространяется на рабочие потоки, помещенные в очередь с помощью метода <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-356">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="41960-357">В более ранних версиях сведения о субъекте не распространяются.</span><span class="sxs-lookup"><span data-stu-id="41960-357">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="41960-358">Значение параметра <paramref name="timeout" /> меньше –1.</span><span class="sxs-lookup"><span data-stu-id="41960-358">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41960-359">Значение параметра <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="41960-359">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="41960-360">Пул управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="41960-360">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="41960-361">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="41960-361">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="41960-362">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="41960-362">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="41960-363">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</span><span class="sxs-lookup"><span data-stu-id="41960-363">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="41960-364">Передаваемый делегату объект.</span><span class="sxs-lookup"><span data-stu-id="41960-364">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="41960-365">Время ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="41960-365">The time-out in milliseconds.</span></span> <span data-ttu-id="41960-366">Если параметр <paramref name="millisecondsTimeOutInterval" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="41960-366">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="41960-367">Если параметр <paramref name="millisecondsTimeOutInterval" /> равен -1, время ожидания функции никогда не истекает.</span><span class="sxs-lookup"><span data-stu-id="41960-367">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="41960-368">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span><span class="sxs-lookup"><span data-stu-id="41960-368"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="41960-369">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа без знака.</span><span class="sxs-lookup"><span data-stu-id="41960-369">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="41960-370">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-370">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-371">По завершении использования <xref:System.Threading.RegisteredWaitHandle>, возвращаемого этим методом, вызовите его метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, чтобы освободить ссылки на маркер ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-371">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="41960-372">Рекомендуется всегда вызывать метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, даже если для `executeOnlyOnce`задано `true`.</span><span class="sxs-lookup"><span data-stu-id="41960-372">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="41960-373">Сборка мусора более эффективна при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, а не в зависимости от метода завершения зарегистрированного обработчика ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-373">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="41960-374">Метод <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> помещает указанный делегат в очередь в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-374">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="41960-375">Рабочий поток будет выполнять делегат при возникновении одного из следующих событий:</span><span class="sxs-lookup"><span data-stu-id="41960-375">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="41960-376">Указанный объект находится в сигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="41960-376">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="41960-377">Интервал времени ожидания истекает.</span><span class="sxs-lookup"><span data-stu-id="41960-377">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="41960-378">Метод <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> проверяет текущее состояние <xref:System.Threading.WaitHandle>указанного объекта.</span><span class="sxs-lookup"><span data-stu-id="41960-378">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="41960-379">Если состояние объекта не сигнальо, метод регистрирует операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-379">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="41960-380">Операция ожидания выполняется потоком из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-380">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="41960-381">Делегат выполняется рабочим потоком, когда состояние объекта становится сигнальным или истекает интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-381">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="41960-382">Если параметр `timeOutInterval` не равен 0 (нулю), а параметр `executeOnlyOnce` имеет значение `false`, таймер сбрасывается каждый раз, когда событие получает сигнал, или истекает интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-382">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="41960-383">Использование <xref:System.Threading.Mutex> для `waitObject` не обеспечивает взаимного исключения для обратных вызовов, так как базовый API Windows использует флаг `WT_EXECUTEDEFAULT` по умолчанию, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-383">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="41960-384">Вместо <xref:System.Threading.Mutex>используйте <xref:System.Threading.Semaphore> с максимальным значением счетчика, равным 1.</span><span class="sxs-lookup"><span data-stu-id="41960-384">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="41960-385">Чтобы отменить операцию ожидания, вызовите метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="41960-385">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="41960-386">Поток ожидания использует функцию Win32 `WaitForMultipleObjects` для отслеживания зарегистрированных операций ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-386">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="41960-387">Поэтому, если необходимо использовать один и тот же собственный обработчик операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, необходимо дублировать этот обработчик с помощью функции `DuplicateHandle` Win32.</span><span class="sxs-lookup"><span data-stu-id="41960-387">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="41960-388">Обратите внимание, что объект события, переданный в <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, не должен передаваться, так как поток ожидания может не обнаружить, что событие сообщается перед сбросом.</span><span class="sxs-lookup"><span data-stu-id="41960-388">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="41960-389">Перед возвращением функция изменяет состояние некоторых типов объектов синхронизации.</span><span class="sxs-lookup"><span data-stu-id="41960-389">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="41960-390">Изменение происходит только для объекта, сигнальное состояние которого привело к удовлетворению условия ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-390">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="41960-391">Например, количество семафоров уменьшается на единицу.</span><span class="sxs-lookup"><span data-stu-id="41960-391">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="41960-392">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="41960-392">Version Information</span></span>  
 <span data-ttu-id="41960-393">Начиная с версии .NET Framework 2,0, значение свойства <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> распространяется на рабочие потоки, помещенные в очередь с помощью метода <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-393">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="41960-394">В более ранних версиях сведения о субъекте не распространяются.</span><span class="sxs-lookup"><span data-stu-id="41960-394">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41960-395">В следующем примере показано, как использовать метод <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> для выполнения указанного метода обратного вызова при получении сигнала о заданном дескрипторе ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-395">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="41960-396">В этом примере метод обратного вызова `WaitProc`, а маркер ожидания — <xref:System.Threading.AutoResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="41960-396">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="41960-397">В примере определяется класс `TaskInfo`, в котором хранятся сведения, передаваемые обратному вызову при его выполнении.</span><span class="sxs-lookup"><span data-stu-id="41960-397">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="41960-398">В примере создается объект `TaskInfo` и назначается часть строковых данных.</span><span class="sxs-lookup"><span data-stu-id="41960-398">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="41960-399"><xref:System.Threading.RegisteredWaitHandle>, возвращаемый методом <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, назначается полю `Handle` объекта `TaskInfo`, чтобы метод обратного вызова получил доступ к <xref:System.Threading.RegisteredWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="41960-399">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="41960-400">Помимо указания `TaskInfo` в качестве объекта для передачи в метод обратного вызова, вызов метода <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> указывает <xref:System.Threading.AutoResetEvent>, к которому будет ожидать задача, делегат <xref:System.Threading.WaitOrTimerCallback>, представляющий метод обратного вызова `WaitProc`, интервал времени ожидания, а также несколько обратных вызовов.</span><span class="sxs-lookup"><span data-stu-id="41960-400">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="41960-401">Когда основной поток передает <xref:System.Threading.AutoResetEvent>, вызывая его метод <xref:System.Threading.EventWaitHandle.Set%2A>, вызывается делегат <xref:System.Threading.WaitOrTimerCallback>.</span><span class="sxs-lookup"><span data-stu-id="41960-401">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="41960-402">Метод `WaitProc` проверяет <xref:System.Threading.RegisteredWaitHandle>, чтобы определить, было ли истекло время ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-402">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="41960-403">Если обратный вызов был вызван из-за того, что дескриптор ожидания был сигнальным, метод `WaitProc` отменяет регистрацию <xref:System.Threading.RegisteredWaitHandle>и останавливает дополнительные обратные вызовы.</span><span class="sxs-lookup"><span data-stu-id="41960-403">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="41960-404">В случае истечения времени ожидания задача будет продолжать ожидание.</span><span class="sxs-lookup"><span data-stu-id="41960-404">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="41960-405">Метод `WaitProc` завершается печатью сообщения на консоль.</span><span class="sxs-lookup"><span data-stu-id="41960-405">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="41960-406">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</span><span class="sxs-lookup"><span data-stu-id="41960-406">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="41960-407">Пул управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="41960-407">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="41960-408">Максимальное количество рабочих потоков в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-408">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="41960-409">Максимальное количество потоков асинхронного ввода-вывода в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-409">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="41960-410">Задает количество запросов к пулу потоков, которые могут быть активными одновременно.</span><span class="sxs-lookup"><span data-stu-id="41960-410">Sets the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="41960-411">Все запросы, превышающие это количество, остаются в очереди до тех пор, пока потоки пула не станут доступны.</span><span class="sxs-lookup"><span data-stu-id="41960-411">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <returns><span data-ttu-id="41960-412">Значение <see langword="true" />, если изменение выполнено успешно; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="41960-412"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-413">Невозможно задать максимальное количество рабочих потоков или потоков завершения ввода-вывода на число, меньшее числа процессоров на компьютере.</span><span class="sxs-lookup"><span data-stu-id="41960-413">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="41960-414">Чтобы определить, сколько процессоров имеется, извлеките значение свойства <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="41960-414">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="41960-415">Кроме того, нельзя задать максимальное количество рабочих потоков или потоков завершения ввода-вывода на число, меньшее, чем соответствующее минимальное количество рабочих потоков или потоков завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="41960-415">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="41960-416">Чтобы определить минимальный размер пула потоков, вызовите метод <xref:System.Threading.ThreadPool.GetMinThreads%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-416">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="41960-417">Если среда CLR размещена, например службы IIS (IIS) или SQL Server, узел может ограничить или запретить изменения размера пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-417">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="41960-418">Будьте внимательны при изменении максимального числа потоков в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-418">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="41960-419">Хотя код может быть полезен, изменения могут оказать негативное воздействие на используемые библиотеки кода.</span><span class="sxs-lookup"><span data-stu-id="41960-419">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="41960-420">Установка слишком большого размера пула потоков может вызвать проблемы с производительностью.</span><span class="sxs-lookup"><span data-stu-id="41960-420">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="41960-421">Если в одно и то же время выполняется слишком много потоков, то затраты на переключение задач становятся значительным фактором.</span><span class="sxs-lookup"><span data-stu-id="41960-421">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="41960-422">для возможности управления потоками.</span><span class="sxs-lookup"><span data-stu-id="41960-422">for the ability to control threads.</span></span> <span data-ttu-id="41960-423">Значение разрешения: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="41960-423">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="41960-424">Минимальное количество рабочих потоков, которые создаются пулом потоков по требованию.</span><span class="sxs-lookup"><span data-stu-id="41960-424">The minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="41960-425">Минимальное количество потоков асинхронного ввода-вывода, которые создаются пулом потоков по требованию.</span><span class="sxs-lookup"><span data-stu-id="41960-425">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="41960-426">Задает минимальное число потоков, создаваемых пулом потоков по требованию по мере поступления новых запросов перед переходом на алгоритм управления созданием и уничтожением потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-426">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <returns><span data-ttu-id="41960-427">Значение <see langword="true" />, если изменение выполнено успешно; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="41960-427"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-428">Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не достигнет минимального значения для каждой категории.</span><span class="sxs-lookup"><span data-stu-id="41960-428">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="41960-429">По достижении минимального значения пул потоков может создавать дополнительные потоки в этой категории или дожидаться завершения некоторых задач.</span><span class="sxs-lookup"><span data-stu-id="41960-429">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="41960-430">Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], пул потоков создает и уничтожает потоки, чтобы оптимизировать пропускную способность, которая определяется как количество задач, завершенных за единицу времени.</span><span class="sxs-lookup"><span data-stu-id="41960-430">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="41960-431">Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое их количество может усиливать конкуренцию за ресурсы.</span><span class="sxs-lookup"><span data-stu-id="41960-431">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="41960-432">Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.</span><span class="sxs-lookup"><span data-stu-id="41960-432">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="41960-433">Если указать отрицательное число или число, превышающее максимальное число потоков пула активных потоков (полученное с помощью <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> возвращает `false` и не изменяет ни одно из минимальных значений.</span><span class="sxs-lookup"><span data-stu-id="41960-433">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="41960-434">По умолчанию минимальное число потоков равно количеству процессоров в системе.</span><span class="sxs-lookup"><span data-stu-id="41960-434">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="41960-435">Для увеличения минимального числа потоков можно использовать метод <xref:System.Threading.ThreadPool.SetMinThreads%2A>.</span><span class="sxs-lookup"><span data-stu-id="41960-435">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="41960-436">Однако необоснованное увеличение этих значений может привести к снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="41960-436">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="41960-437">Если одновременно запускается слишком много задач, все они могут выполняться слишком медленно.</span><span class="sxs-lookup"><span data-stu-id="41960-437">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="41960-438">В большинстве случаев пул потоков будет работать лучше с собственным алгоритмом выделения потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-438">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="41960-439">Уменьшение минимального значения до количества процессоров может также привести к снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="41960-439">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41960-440">В следующем примере минимальное количество рабочих потоков устанавливается равным четырем и сохраняется исходное значение минимального числа потоков завершения асинхронного ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="41960-440">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="41960-441">для возможности управления потоками.</span><span class="sxs-lookup"><span data-stu-id="41960-441">for the ability to control threads.</span></span> <span data-ttu-id="41960-442">Значение разрешения: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="41960-442">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="ThreadCount">
      <MemberSignature Language="C#" Value="public static int ThreadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ThreadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.ThreadCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ThreadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ThreadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadCount : int" Usage="System.Threading.ThreadPool.ThreadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41960-443">Возвращает текущее количество потоков в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-443">Gets the number of thread pool threads that currently exist.</span></span></summary>
        <value><span data-ttu-id="41960-444">Число потоков пула потоков, которые в настоящее время существуют.</span><span class="sxs-lookup"><span data-stu-id="41960-444">The number of thread pool threads that currently exist.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="41960-445">Если реализация пула потоков может иметь различные типы потоков, счетчик включает все типы.</span><span class="sxs-lookup"><span data-stu-id="41960-445">If a thread pool implementation may have different types of threads, the count includes all types.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="overlapped"><span data-ttu-id="41960-446">Помещаемая в очередь структура <see cref="T:System.Threading.NativeOverlapped" />.</span><span class="sxs-lookup"><span data-stu-id="41960-446">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span></span></param>
        <summary><span data-ttu-id="41960-447">Помещает в очередь на выполнение операцию перекрывающегося ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="41960-447">Queues an overlapped I/O operation for execution.</span></span></summary>
        <returns><span data-ttu-id="41960-448">Значение <see langword="true" />, если операция была успешна помещена в очередь порта завершения ввода-вывода; в противном случае значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="41960-448"><see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-449">Сведения об использовании собственных перекрывающихся операций ввода-вывода Win32 см. в разделе класс <xref:System.Threading.Overlapped>, структура <xref:System.Threading.NativeOverlapped> и структура `OVERLAPPED` в пакете SDK для платформы Win32.</span><span class="sxs-lookup"><span data-stu-id="41960-449">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="41960-450">Использование метода <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> может случайно открыть брешь в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="41960-450">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="41960-451">Управление доступом для кода основывается на проверке разрешений всех вызывающих объектов в стеке.</span><span class="sxs-lookup"><span data-stu-id="41960-451">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="41960-452">Когда работа помещается в очередь потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, стек потока пула потоков не имеет контекста фактических вызывающих объектов.</span><span class="sxs-lookup"><span data-stu-id="41960-452">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="41960-453">Вредоносный код может использовать эту возможность, чтобы избежать проверок разрешений.</span><span class="sxs-lookup"><span data-stu-id="41960-453">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="41960-454">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="41960-454">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="41960-455">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="41960-455">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="41960-456">Рабочий элемент, который вызывается, когда потоку в пуле потоков назначается рабочий элемент.</span><span class="sxs-lookup"><span data-stu-id="41960-456">The work item to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="41960-457"><see langword="true" />, чтобы предпочитать ставить рабочий элемент в очередь близко к текущему потоку; <see langword="false" />, чтобы предпочитать ставить рабочий элемент в общую очередь пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-457"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="41960-458">Помещает указанный объект рабочего элемента в очередь в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-458">Queues the specified work item object to the thread pool.</span></span></summary>
        <returns><span data-ttu-id="41960-459">Значение <see langword="true" />, если метод завершается успешно. Если рабочий элемент не удалось поместить в очередь, создается исключение <see cref="T:System.OutOfMemoryException" />.</span><span class="sxs-lookup"><span data-stu-id="41960-459"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="41960-460">Пул потоков вызовет метод <xref:System.Threading.IThreadPoolWorkItem.Execute> рабочего элемента.</span><span class="sxs-lookup"><span data-stu-id="41960-460">The thread pool will invoke the work item's <xref:System.Threading.IThreadPoolWorkItem.Execute> method.</span></span> <span data-ttu-id="41960-461">Этот рабочий элемент отвечает за распространение <xref:System.Threading.ExecutionContext>, если это необходимо; пул потоков не сделает этого.</span><span class="sxs-lookup"><span data-stu-id="41960-461">It is the responsibility of that work item to propagate <xref:System.Threading.ExecutionContext> if it's needed; the thread pool will not do so.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="41960-462"><paramref name="callback" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="41960-462"><paramref name="callback" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="41960-463">Рабочий элемент — <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="41960-463">The work item is a <see cref="T:System.Threading.Tasks.Task" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="41960-464">Не удается поместить в очередь рабочий элемент.</span><span class="sxs-lookup"><span data-stu-id="41960-464">The work item could not be queued.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="41960-465">Метод <see cref="T:System.Threading.WaitCallback" />, представляющий делегат, который вызывается, когда потоку в пуле потоков назначается рабочий элемент.</span><span class="sxs-lookup"><span data-stu-id="41960-465">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="state"><span data-ttu-id="41960-466">Объект, передаваемый делегату при вызове его из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-466">The object that is passed to the delegate when serviced from the thread pool.</span></span></param>
        <summary><span data-ttu-id="41960-467">Помещает указанный делегат в очередь пула потоков, но не распространяет вызывающий стек на рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="41960-467">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="41960-468">Значение <see langword="true" />, если метод завершается успешно. Если рабочий элемент не удалось поместить в очередь, создается исключение <see cref="T:System.OutOfMemoryException" />.</span><span class="sxs-lookup"><span data-stu-id="41960-468"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-469">В отличие от метода <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> не распространяет вызывающий стек в рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="41960-469">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="41960-470">Это позволяет коду потерять вызывающий стек и тем самым повысить привилегии безопасности.</span><span class="sxs-lookup"><span data-stu-id="41960-470">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="41960-471">Использование <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> может случайно открыть брешь в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="41960-471">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="41960-472">Управление доступом для кода основывается на проверке разрешений всех вызывающих объектов в стеке.</span><span class="sxs-lookup"><span data-stu-id="41960-472">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="41960-473">Когда работа помещается в очередь потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, стек потока пула потоков не будет иметь контекста фактических вызывающих объектов.</span><span class="sxs-lookup"><span data-stu-id="41960-473">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="41960-474">Вредоносный код может использовать эту возможность, чтобы избежать проверок разрешений.</span><span class="sxs-lookup"><span data-stu-id="41960-474">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="41960-475">У вызывающего объекта отсутствует необходимое разрешение.</span><span class="sxs-lookup"><span data-stu-id="41960-475">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="41960-476">Возникла ситуация нехватки памяти.</span><span class="sxs-lookup"><span data-stu-id="41960-476">An out-of-memory condition was encountered.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="41960-477">Не удается поместить в очередь рабочий элемент.</span><span class="sxs-lookup"><span data-stu-id="41960-477">The work item could not be queued.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="41960-478"><paramref name="callBack" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="41960-478"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="41960-479">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="41960-479">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="41960-480">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="41960-480">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="41960-481">Пул управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="41960-481">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><span data-ttu-id="41960-482">Тип элементов <paramref name="state" />.</span><span class="sxs-lookup"><span data-stu-id="41960-482">The type of elements of <paramref name="state" />.</span></span></typeparam>
        <param name="callBack"><span data-ttu-id="41960-483">Делегат, представляющий выполняемый метод.</span><span class="sxs-lookup"><span data-stu-id="41960-483">A delegate representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="41960-484">Объект, содержащий данные, используемые методом.</span><span class="sxs-lookup"><span data-stu-id="41960-484">An object containing data to be used by the method.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="41960-485"><see langword="true" />, чтобы предпочитать ставить рабочий элемент в очередь близко к текущему потоку; <see langword="false" />, чтобы предпочитать ставить рабочий элемент в общую очередь пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-485"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="41960-486">Помещает метод, определенный делегатом <see cref="T:System.Action`1" />, в очередь на выполнение и указывает объект, содержащий данные для этого метода.</span><span class="sxs-lookup"><span data-stu-id="41960-486">Queues a method specified by an <see cref="T:System.Action`1" /> delegate for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="41960-487">Метод выполняется, когда становится доступен поток из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-487">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="41960-488">Значение <see langword="true" />, если метод успешно помещен в очередь. Если рабочий элемент не может быть помещен очередь, выдается исключение <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="41960-488"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="41960-489"><paramref name="callback" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="41960-489"><paramref name="callback" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41960-490">Не удается поместить в очередь рабочий элемент.</span><span class="sxs-lookup"><span data-stu-id="41960-490">The work item could not be queued.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="41960-491">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, но не распространяет вызывающий стек на рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="41960-491">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="41960-492">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="41960-492">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="41960-493">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="41960-493">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="41960-494">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</span><span class="sxs-lookup"><span data-stu-id="41960-494">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="41960-495">Передаваемый делегату объект.</span><span class="sxs-lookup"><span data-stu-id="41960-495">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="41960-496">Время ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="41960-496">The time-out in milliseconds.</span></span> <span data-ttu-id="41960-497">Если параметр <paramref name="millisecondsTimeOutInterval" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="41960-497">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="41960-498">Если параметр <paramref name="millisecondsTimeOutInterval" /> равен -1, время ожидания функции никогда не истекает.</span><span class="sxs-lookup"><span data-stu-id="41960-498">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="41960-499">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span><span class="sxs-lookup"><span data-stu-id="41960-499"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="41960-500">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа со знаком.</span><span class="sxs-lookup"><span data-stu-id="41960-500">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="41960-501">Этот метод не распространяет вызывающий стек на рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="41960-501">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="41960-502">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-502">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-503">В отличие от метода <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек в рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="41960-503">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="41960-504">Это позволяет коду потерять вызывающий стек и тем самым повысить привилегии безопасности.</span><span class="sxs-lookup"><span data-stu-id="41960-504">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="41960-505">Использование <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может случайно открыть брешь в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="41960-505">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="41960-506">Управление доступом для кода основывается на проверке разрешений всех вызывающих объектов в стеке.</span><span class="sxs-lookup"><span data-stu-id="41960-506">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="41960-507">Когда работа помещается в очередь потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек потока пула потоков не будет иметь контекста фактических вызывающих объектов.</span><span class="sxs-lookup"><span data-stu-id="41960-507">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="41960-508">Вредоносный код может использовать эту возможность, чтобы избежать проверок разрешений.</span><span class="sxs-lookup"><span data-stu-id="41960-508">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="41960-509">Использование <xref:System.Threading.Mutex> для `waitObject` не обеспечивает взаимного исключения для обратных вызовов, так как базовый API Windows использует флаг `WT_EXECUTEDEFAULT` по умолчанию, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-509">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="41960-510">По завершении использования <xref:System.Threading.RegisteredWaitHandle>, возвращаемого этим методом, вызовите его метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, чтобы освободить ссылки на маркер ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-510">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="41960-511">Рекомендуется всегда вызывать метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, даже если для `executeOnlyOnce`задано `true`.</span><span class="sxs-lookup"><span data-stu-id="41960-511">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="41960-512">Сборка мусора более эффективна при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, а не в зависимости от метода завершения зарегистрированного обработчика ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-512">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="41960-513">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</span><span class="sxs-lookup"><span data-stu-id="41960-513">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="41960-514">У вызывающего объекта отсутствует необходимое разрешение.</span><span class="sxs-lookup"><span data-stu-id="41960-514">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="41960-515">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="41960-515">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="41960-516">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="41960-516">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="41960-517">Пул управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="41960-517">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="41960-518">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="41960-518">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="41960-519">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="41960-519">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="41960-520">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</span><span class="sxs-lookup"><span data-stu-id="41960-520">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="41960-521">Передаваемый делегату объект.</span><span class="sxs-lookup"><span data-stu-id="41960-521">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="41960-522">Время ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="41960-522">The time-out in milliseconds.</span></span> <span data-ttu-id="41960-523">Если параметр <paramref name="millisecondsTimeOutInterval" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="41960-523">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="41960-524">Если параметр <paramref name="millisecondsTimeOutInterval" /> равен -1, время ожидания функции никогда не истекает.</span><span class="sxs-lookup"><span data-stu-id="41960-524">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="41960-525">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span><span class="sxs-lookup"><span data-stu-id="41960-525"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="41960-526">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 64-разрядного целого числа со знаком.</span><span class="sxs-lookup"><span data-stu-id="41960-526">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="41960-527">Этот метод не распространяет вызывающий стек на рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="41960-527">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="41960-528">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-528">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-529">В отличие от метода <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек в рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="41960-529">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="41960-530">Это позволяет коду потерять вызывающий стек и тем самым повысить привилегии безопасности.</span><span class="sxs-lookup"><span data-stu-id="41960-530">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="41960-531">Использование <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может случайно открыть брешь в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="41960-531">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="41960-532">Управление доступом для кода основывается на проверке разрешений всех вызывающих объектов в стеке.</span><span class="sxs-lookup"><span data-stu-id="41960-532">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="41960-533">Когда работа помещается в очередь потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек потока пула потоков не будет иметь контекста фактических вызывающих объектов.</span><span class="sxs-lookup"><span data-stu-id="41960-533">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="41960-534">Вредоносный код может использовать эту возможность, чтобы избежать проверок разрешений.</span><span class="sxs-lookup"><span data-stu-id="41960-534">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="41960-535">Использование <xref:System.Threading.Mutex> для `waitObject` не обеспечивает взаимного исключения для обратных вызовов, так как базовый API Windows использует флаг `WT_EXECUTEDEFAULT` по умолчанию, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-535">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="41960-536">По завершении использования <xref:System.Threading.RegisteredWaitHandle>, возвращаемого этим методом, вызовите его метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, чтобы освободить ссылки на маркер ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-536">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="41960-537">Рекомендуется всегда вызывать метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, даже если для `executeOnlyOnce`задано `true`.</span><span class="sxs-lookup"><span data-stu-id="41960-537">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="41960-538">Сборка мусора более эффективна при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, а не в зависимости от метода завершения зарегистрированного обработчика ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-538">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="41960-539">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</span><span class="sxs-lookup"><span data-stu-id="41960-539">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="41960-540">У вызывающего объекта отсутствует необходимое разрешение.</span><span class="sxs-lookup"><span data-stu-id="41960-540">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="41960-541">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="41960-541">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="41960-542">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="41960-542">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="41960-543">Пул управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="41960-543">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="41960-544">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="41960-544">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="41960-545">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="41960-545">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="41960-546">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</span><span class="sxs-lookup"><span data-stu-id="41960-546">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="41960-547">Передаваемый делегату объект.</span><span class="sxs-lookup"><span data-stu-id="41960-547">The object that is passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="41960-548">Время ожидания, представленное объектом <see cref="T:System.TimeSpan" />.</span><span class="sxs-lookup"><span data-stu-id="41960-548">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="41960-549">Если параметр <paramref name="timeout" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="41960-549">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="41960-550">Если параметр <paramref name="timeout" /> равен -1, время ожидания функции никогда не истекает.</span><span class="sxs-lookup"><span data-stu-id="41960-550">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="41960-551">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span><span class="sxs-lookup"><span data-stu-id="41960-551"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="41960-552">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая значение <see cref="T:System.TimeSpan" /> для времени ожидания. Этот метод не распространяет вызывающий стек на рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="41960-552">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="41960-553">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-553">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-554">В отличие от метода <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек в рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="41960-554">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="41960-555">Это позволяет коду потерять вызывающий стек и тем самым повысить привилегии безопасности.</span><span class="sxs-lookup"><span data-stu-id="41960-555">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="41960-556">Использование <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может случайно открыть брешь в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="41960-556">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="41960-557">Управление доступом для кода основывается на проверке разрешений всех вызывающих объектов в стеке.</span><span class="sxs-lookup"><span data-stu-id="41960-557">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="41960-558">Когда работа помещается в очередь потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек потока пула потоков не будет иметь контекста фактических вызывающих объектов.</span><span class="sxs-lookup"><span data-stu-id="41960-558">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="41960-559">Вредоносный код может использовать эту возможность, чтобы избежать проверок разрешений.</span><span class="sxs-lookup"><span data-stu-id="41960-559">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="41960-560">Использование <xref:System.Threading.Mutex> для `waitObject` не обеспечивает взаимного исключения для обратных вызовов, так как базовый API Windows использует флаг `WT_EXECUTEDEFAULT` по умолчанию, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-560">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="41960-561">По завершении использования <xref:System.Threading.RegisteredWaitHandle>, возвращаемого этим методом, вызовите его метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, чтобы освободить ссылки на маркер ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-561">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="41960-562">Рекомендуется всегда вызывать метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, даже если для `executeOnlyOnce`задано `true`.</span><span class="sxs-lookup"><span data-stu-id="41960-562">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="41960-563">Сборка мусора более эффективна при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, а не в зависимости от метода завершения зарегистрированного обработчика ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-563">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="41960-564">Значение параметра <paramref name="timeout" /> меньше –1.</span><span class="sxs-lookup"><span data-stu-id="41960-564">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41960-565">Значение параметра <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="41960-565">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="41960-566">У вызывающего объекта отсутствует необходимое разрешение.</span><span class="sxs-lookup"><span data-stu-id="41960-566">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="41960-567">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="41960-567">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="41960-568">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="41960-568">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="41960-569">Пул управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="41960-569">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="41960-570">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="41960-570">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="41960-571">Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="41960-571">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="41960-572">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</span><span class="sxs-lookup"><span data-stu-id="41960-572">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="41960-573">Передаваемый делегату объект.</span><span class="sxs-lookup"><span data-stu-id="41960-573">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="41960-574">Время ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="41960-574">The time-out in milliseconds.</span></span> <span data-ttu-id="41960-575">Если параметр <paramref name="millisecondsTimeOutInterval" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="41960-575">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="41960-576">Если параметр <paramref name="millisecondsTimeOutInterval" /> равен -1, время ожидания функции никогда не истекает.</span><span class="sxs-lookup"><span data-stu-id="41960-576">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="41960-577">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</span><span class="sxs-lookup"><span data-stu-id="41960-577"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="41960-578">Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа без знака.</span><span class="sxs-lookup"><span data-stu-id="41960-578">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span> <span data-ttu-id="41960-579">Этот метод не распространяет вызывающий стек на рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="41960-579">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="41960-580">Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-580">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41960-581">В отличие от метода <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек в рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="41960-581">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="41960-582">Это позволяет коду потерять вызывающий стек и тем самым повысить привилегии безопасности.</span><span class="sxs-lookup"><span data-stu-id="41960-582">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="41960-583">Использование <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может случайно открыть брешь в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="41960-583">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="41960-584">Управление доступом для кода основывается на проверке разрешений всех вызывающих объектов в стеке.</span><span class="sxs-lookup"><span data-stu-id="41960-584">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="41960-585">Когда работа помещается в очередь потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек потока пула потоков не будет иметь контекста фактических вызывающих объектов.</span><span class="sxs-lookup"><span data-stu-id="41960-585">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="41960-586">Вредоносный код может использовать эту возможность, чтобы избежать проверок разрешений.</span><span class="sxs-lookup"><span data-stu-id="41960-586">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="41960-587">Использование <xref:System.Threading.Mutex> для `waitObject` не обеспечивает взаимного исключения для обратных вызовов, так как базовый API Windows использует флаг `WT_EXECUTEDEFAULT` по умолчанию, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="41960-587">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="41960-588">По завершении использования <xref:System.Threading.RegisteredWaitHandle>, возвращаемого этим методом, вызовите его метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, чтобы освободить ссылки на маркер ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-588">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="41960-589">Рекомендуется всегда вызывать метод <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, даже если для `executeOnlyOnce`задано `true`.</span><span class="sxs-lookup"><span data-stu-id="41960-589">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="41960-590">Сборка мусора более эффективна при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>, а не в зависимости от метода завершения зарегистрированного обработчика ожидания.</span><span class="sxs-lookup"><span data-stu-id="41960-590">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="41960-591">У вызывающего объекта отсутствует необходимое разрешение.</span><span class="sxs-lookup"><span data-stu-id="41960-591">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="41960-592">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="41960-592">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="41960-593">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="41960-593">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="41960-594">Пул управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="41960-594">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
