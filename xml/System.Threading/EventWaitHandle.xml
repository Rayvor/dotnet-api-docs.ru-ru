<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4972e7bfcb06d5aaa6fa68e2f875825fb944008f" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73380780" /></Metadata><TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="29afb-101">Представляет событие синхронизации потока.</span><span class="sxs-lookup"><span data-stu-id="29afb-101">Represents a thread synchronization event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29afb-102">Класс <xref:System.Threading.EventWaitHandle> позволяет потокам взаимодействовать друг с другом посредством сигнализации.</span><span class="sxs-lookup"><span data-stu-id="29afb-102">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling.</span></span> <span data-ttu-id="29afb-103">Как правило, один или несколько потоков блокируют <xref:System.Threading.EventWaitHandle> до тех пор, пока незаблокированный поток не вызовет метод <xref:System.Threading.EventWaitHandle.Set%2A>, освобождая один или несколько заблокированных потоков.</span><span class="sxs-lookup"><span data-stu-id="29afb-103">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads.</span></span> <span data-ttu-id="29afb-104">Поток может сообщить <xref:System.Threading.EventWaitHandle>, а затем заблокировать его, вызвав метод `static` (`Shared` в Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="29afb-104">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="29afb-105">Класс <xref:System.Threading.EventWaitHandle> предоставляет доступ к событиям именованной системной синхронизации.</span><span class="sxs-lookup"><span data-stu-id="29afb-105">The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.</span></span>  
  
 <span data-ttu-id="29afb-106">Поведение <xref:System.Threading.EventWaitHandle>, для которого получен сигнал, зависит от режима сброса.</span><span class="sxs-lookup"><span data-stu-id="29afb-106">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode.</span></span> <span data-ttu-id="29afb-107"><xref:System.Threading.EventWaitHandle>, созданная с флагом <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>, автоматически сбрасывается при получении сигнала после освобождения одного ожидающего потока.</span><span class="sxs-lookup"><span data-stu-id="29afb-107">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="29afb-108"><xref:System.Threading.EventWaitHandle>, созданный с помощью флага <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>, находится в сигнальном состоянии, пока не будет вызван его метод <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="29afb-108">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="29afb-109">События автоматического сброса предоставляют монопольный доступ к ресурсу.</span><span class="sxs-lookup"><span data-stu-id="29afb-109">Automatic reset events provide exclusive access to a resource.</span></span> <span data-ttu-id="29afb-110">Если событие с автоматическим сбросом создается при отсутствии потоков в состоянии ожидания, оно сохраняет свой статус, пока не получит обращение от потока.</span><span class="sxs-lookup"><span data-stu-id="29afb-110">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="29afb-111">Тогда событие освобождает поток и немедленно сбрасывается, блокируя следующие потоки.</span><span class="sxs-lookup"><span data-stu-id="29afb-111">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
 <span data-ttu-id="29afb-112">События ручного сброса подобны шлюзам.</span><span class="sxs-lookup"><span data-stu-id="29afb-112">Manual reset events are like gates.</span></span> <span data-ttu-id="29afb-113">Если событие не сообщается, потоки, ожидающие, будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-113">When the event is not signaled, threads that wait on it will block.</span></span> <span data-ttu-id="29afb-114">Когда событие получает сигнал, освобождаются все ожидающие потоки, и событие остается сигнальным (то есть последующие ожидания не блокируются), пока не будет вызван метод <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="29afb-114">When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="29afb-115">События ручного сброса полезны, когда один поток должен завершить действие до того, как другие потоки смогут продолжать работу.</span><span class="sxs-lookup"><span data-stu-id="29afb-115">Manual reset events are useful when one thread must complete an activity before other threads can proceed.</span></span>  
  
 <span data-ttu-id="29afb-116"><xref:System.Threading.EventWaitHandle> объекты можно использовать с `static`(`Shared` в Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> и <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> методов.</span><span class="sxs-lookup"><span data-stu-id="29afb-116"><xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="29afb-117">Дополнительные сведения см. в разделе [взаимодействие потоков или сигнализация](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling) статьи [Общие сведения о примитивах синхронизации](~/docs/standard/threading/overview-of-synchronization-primitives.md) .</span><span class="sxs-lookup"><span data-stu-id="29afb-117">For more information, see the [Thread interaction, or signaling](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling) section of the [Overview of synchronization primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md) article.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="29afb-118">В следующем примере кода используется перегрузка метода <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>, позволяющая основному потоку сообщить о заблокированном потоке, а затем подождать, пока поток не завершит задачу.</span><span class="sxs-lookup"><span data-stu-id="29afb-118">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="29afb-119">Пример запускает пять потоков и позволяет блокировать их на <xref:System.Threading.EventWaitHandle>, созданном с флагом <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>, а затем освобождает один поток каждый раз, когда пользователь нажимает клавишу ВВОД.</span><span class="sxs-lookup"><span data-stu-id="29afb-119">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="29afb-120">Затем этот пример помещает в очередь еще пять потоков и освобождает их все с помощью <xref:System.Threading.EventWaitHandle>, созданного с флагом <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="29afb-120">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="29afb-121">Данный тип потокобезопасен.</span><span class="sxs-lookup"><span data-stu-id="29afb-121">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="29afb-122">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="29afb-122">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="29afb-123">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="29afb-123">Overview of synchronization primitives</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="29afb-124">Инициализирует новый экземпляр класса <see cref="T:System.Threading.EventWaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-124">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="29afb-125">Значение <see langword="true" /> для задания начального состояния сигнальным; <see langword="false" /> для задания несигнального начального состояния.</span><span class="sxs-lookup"><span data-stu-id="29afb-125"><see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="29afb-126">Одно из значений <see cref="T:System.Threading.EventResetMode" />, которое определяет, выполняется ли сброс события автоматически или вручную.</span><span class="sxs-lookup"><span data-stu-id="29afb-126">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <summary><span data-ttu-id="29afb-127">Выполняет инициализацию нового экземпляра класса <see cref="T:System.Threading.EventWaitHandle" />, определяя, получает ли сигнал, ожидающий дескриптор, и производится ли сброс автоматически или вручную.</span><span class="sxs-lookup"><span data-stu-id="29afb-127">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29afb-128">Если начальное состояние события является несигнальным, потоки, ожидающие события, будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-128">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="29afb-129">Если начальное состояние сигнальное и для `mode`указан флаг <xref:System.Threading.EventResetMode.ManualReset>, потоки, ожидающие события, не будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-129">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="29afb-130">Если начальное состояние сигнальное, а `mode` имеет <xref:System.Threading.EventResetMode.AutoReset>, первый поток, ожидающий события, будет немедленно освобожден, после чего событие будет сброшено, и последующие потоки будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-130">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="29afb-131">В следующем примере кода используется перегрузка метода <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>, позволяющая основному потоку сообщить о заблокированном потоке, а затем подождать, пока поток не завершит задачу.</span><span class="sxs-lookup"><span data-stu-id="29afb-131">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="29afb-132">Пример запускает пять потоков и позволяет блокировать их на <xref:System.Threading.EventWaitHandle>, созданном с флагом <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>, а затем освобождает один поток каждый раз, когда пользователь нажимает клавишу ВВОД.</span><span class="sxs-lookup"><span data-stu-id="29afb-132">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses ENTER key.</span></span> <span data-ttu-id="29afb-133">Затем этот пример помещает в очередь еще пять потоков и освобождает их все с помощью <xref:System.Threading.EventWaitHandle>, созданного с флагом <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="29afb-133">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="29afb-134">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="29afb-134">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="29afb-135">Значение <see langword="true" /> обозначает, что именованное событие получит исходное сигнальное состояние, если такое событие создается в результате этого вызова; значение <see langword="false" /> устанавливает несигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="29afb-135"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="29afb-136">Одно из значений <see cref="T:System.Threading.EventResetMode" />, которое определяет, выполняется ли сброс события автоматически или вручную.</span><span class="sxs-lookup"><span data-stu-id="29afb-136">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="29afb-137">Имя события синхронизации на уровне системы.</span><span class="sxs-lookup"><span data-stu-id="29afb-137">The name of a system-wide synchronization event.</span></span></param>
        <summary><span data-ttu-id="29afb-138">Выполняет инициализацию нового экземпляра класса <see cref="T:System.Threading.EventWaitHandle" />, определяющего получает ли сигнал дескриптор ожидания, если он был создан в результате данного вызова, сбрасывается ли он автоматически или вручную, а также имя системного события синхронизации.</span><span class="sxs-lookup"><span data-stu-id="29afb-138">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29afb-139">Если `name` является `null` или пустой строкой, то создается локальный <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="29afb-139">If `name` is `null` or an empty string, a local <xref:System.Threading.EventWaitHandle> is created.</span></span>  
  
 <span data-ttu-id="29afb-140">Если системное событие с именем, указанным для параметра `name`, уже существует, параметр `initialState` игнорируется.</span><span class="sxs-lookup"><span data-stu-id="29afb-140">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="29afb-141">При использовании этого конструктора для именованных системных событий укажите `false` для `initialState`.</span><span class="sxs-lookup"><span data-stu-id="29afb-141">When using this constructor for named system events, specify `false` for `initialState`.</span></span> <span data-ttu-id="29afb-142">Этот конструктор не дает возможности определить, было ли создано именованное системное событие, поэтому вы не можете делать никаких предположений о состоянии именованного события.</span><span class="sxs-lookup"><span data-stu-id="29afb-142">This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</span></span> <span data-ttu-id="29afb-143">Чтобы определить, было ли именованное событие создано, используйте конструктор <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> или конструктор <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29>.</span><span class="sxs-lookup"><span data-stu-id="29afb-143">To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.</span></span>  
  
 <span data-ttu-id="29afb-144">Если начальное состояние события является несигнальным, потоки, ожидающие события, будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-144">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="29afb-145">Если начальное состояние сигнальное и для `mode`указан флаг <xref:System.Threading.EventResetMode.ManualReset>, потоки, ожидающие события, не будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-145">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="29afb-146">Если начальное состояние сигнальное, а `mode` имеет <xref:System.Threading.EventResetMode.AutoReset>, первый поток, ожидающий события, будет немедленно освобожден, после чего событие будет сброшено, и последующие потоки будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-146">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="29afb-147">Произошла ошибка Win32.</span><span class="sxs-lookup"><span data-stu-id="29afb-147">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="29afb-148">Именованное событие уже существует и имеет настройки управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-148">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="29afb-149">Именованное событие нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</span><span class="sxs-lookup"><span data-stu-id="29afb-149">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="29afb-150">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span><span class="sxs-lookup"><span data-stu-id="29afb-150"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="29afb-151">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="29afb-151">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="29afb-152">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="29afb-152">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="29afb-153">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="29afb-153">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string * bool -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="29afb-154">Значение <see langword="true" /> обозначает, что именованное событие получит исходное сигнальное состояние, если такое событие создается в результате этого вызова; значение <see langword="false" /> устанавливает несигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="29afb-154"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="29afb-155">Одно из значений <see cref="T:System.Threading.EventResetMode" />, которое определяет, выполняется ли сброс события автоматически или вручную.</span><span class="sxs-lookup"><span data-stu-id="29afb-155">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="29afb-156">Имя события синхронизации на уровне системы.</span><span class="sxs-lookup"><span data-stu-id="29afb-156">The name of a system-wide synchronization event.</span></span></param>
        <param name="createdNew"><span data-ttu-id="29afb-157">Когда данный метод возвращает значение, он содержит <see langword="true" />, если было создано локальное событие (то есть, если <paramref name="name" /> имеет значение <see langword="null" /> или пустую строку) или было создано системное событие с заданным именем; либо значение <see langword="false" />, если указанное именованное событие уже существовало.</span><span class="sxs-lookup"><span data-stu-id="29afb-157">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span></span> <span data-ttu-id="29afb-158">Этот параметр передается неинициализированным.</span><span class="sxs-lookup"><span data-stu-id="29afb-158">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="29afb-159">Инициализирует новый экземпляр класса <see cref="T:System.Threading.EventWaitHandle" /> и указывает следующие сведения: передавать ли сигнал в дескриптор ожидания при первичном запуске в результате этого вызова; выполнять ли сброс автоматически или вручную; имя системного события синхронизации; логическая переменная для сохранения информации о том, было ли создано именованное системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-159">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29afb-160">Если системное событие с именем, указанным для параметра `name`, уже существует, параметр `initialState` игнорируется.</span><span class="sxs-lookup"><span data-stu-id="29afb-160">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="29afb-161">После вызова этого конструктора используйте значение в переменной, заданной для параметра `ref` (`ByRef` параметр в Visual Basic)`createdNew`, чтобы определить, существовало ли именованное системное событие или оно было создано.</span><span class="sxs-lookup"><span data-stu-id="29afb-161">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="29afb-162">Если начальное состояние события является несигнальным, потоки, ожидающие события, будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-162">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="29afb-163">Если начальное состояние сигнальное и для `mode`указан флаг <xref:System.Threading.EventResetMode.ManualReset>, потоки, ожидающие события, не будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-163">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="29afb-164">Если начальное состояние сигнальное, а `mode` имеет <xref:System.Threading.EventResetMode.AutoReset>, первый поток, ожидающий события, будет немедленно освобожден, после чего событие будет сброшено, и последующие потоки будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-164">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="29afb-165">Произошла ошибка Win32.</span><span class="sxs-lookup"><span data-stu-id="29afb-165">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="29afb-166">Именованное событие уже существует и имеет настройки управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-166">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="29afb-167">Именованное событие нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</span><span class="sxs-lookup"><span data-stu-id="29afb-167">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="29afb-168">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span><span class="sxs-lookup"><span data-stu-id="29afb-168"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="29afb-169">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="29afb-169">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="29afb-170">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="29afb-170">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="29afb-171">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="29afb-171">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string * bool * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="29afb-172">Значение <see langword="true" /> обозначает, что именованное событие получит исходное сигнальное состояние, если такое событие создается в результате этого вызова; значение <see langword="false" /> устанавливает несигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="29afb-172"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="29afb-173">Одно из значений <see cref="T:System.Threading.EventResetMode" />, которое определяет, выполняется ли сброс события автоматически или вручную.</span><span class="sxs-lookup"><span data-stu-id="29afb-173">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="29afb-174">Имя события синхронизации на уровне системы.</span><span class="sxs-lookup"><span data-stu-id="29afb-174">The name of a system-wide synchronization event.</span></span></param>
        <param name="createdNew"><span data-ttu-id="29afb-175">Когда данный метод возвращает значение, он содержит <see langword="true" />, если было создано локальное событие (то есть, если <paramref name="name" /> имеет значение <see langword="null" /> или пустую строку) или было создано системное событие с заданным именем; либо значение <see langword="false" />, если указанное именованное событие уже существовало.</span><span class="sxs-lookup"><span data-stu-id="29afb-175">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span></span> <span data-ttu-id="29afb-176">Этот параметр передается неинициализированным.</span><span class="sxs-lookup"><span data-stu-id="29afb-176">This parameter is passed uninitialized.</span></span></param>
        <param name="eventSecurity"><span data-ttu-id="29afb-177">Объект <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />, определяющий настройки управления доступом для применения к именованному системному событию.</span><span class="sxs-lookup"><span data-stu-id="29afb-177">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span></span></param>
        <summary><span data-ttu-id="29afb-178">Инициализирует новый экземпляр класса <see cref="T:System.Threading.EventWaitHandle" /> с указанием следующих сведений: передавать ли сигнал в дескриптор ожидания при первичном запуске в результате этого вызова, выполнять ли сброс автоматически или вручную, имя системного события синхронизации, логическая переменная для сохранения информации о том, было ли создано именованное системное событие, правила управления доступом для именованного события, если оно создается.</span><span class="sxs-lookup"><span data-stu-id="29afb-178">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29afb-179">Используйте этот конструктор, чтобы применить безопасность управления доступом к именованному системному событию при его создании, предотвращая управление событием другим кодом.</span><span class="sxs-lookup"><span data-stu-id="29afb-179">Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</span></span>  
  
 <span data-ttu-id="29afb-180">Этот конструктор инициализирует объект <xref:System.Threading.EventWaitHandle>, представляющий системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-180">This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event.</span></span> <span data-ttu-id="29afb-181">Можно создать несколько <xref:System.Threading.EventWaitHandle> объектов, представляющих одно и то же системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-181">You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.</span></span>  
  
 <span data-ttu-id="29afb-182">Если системное событие не существует, оно создается с указанной защитой управления доступом.</span><span class="sxs-lookup"><span data-stu-id="29afb-182">If the system event does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="29afb-183">Если событие существует, заданная безопасность контроля доступа игнорируется.</span><span class="sxs-lookup"><span data-stu-id="29afb-183">If the event exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="29afb-184">Вызывающий объект имеет полный контроль над вновь созданным <xref:System.Threading.EventWaitHandle> объектом, даже если `eventSecurity` запрещает или не может предоставить некоторые права доступа для текущего пользователя.</span><span class="sxs-lookup"><span data-stu-id="29afb-184">The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="29afb-185">Однако если текущий пользователь пытается получить другой объект <xref:System.Threading.EventWaitHandle> для представления того же именованного события, используя либо конструктор, либо метод <xref:System.Threading.EventWaitHandle.OpenExisting%2A>, применяется безопасность управления доступом Windows.</span><span class="sxs-lookup"><span data-stu-id="29afb-185">However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="29afb-186">Если системное событие с именем, указанным для параметра `name`, уже существует, параметр `initialState` игнорируется.</span><span class="sxs-lookup"><span data-stu-id="29afb-186">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="29afb-187">После вызова этого конструктора используйте значение в переменной, заданной для параметра `ref` (`ByRef` параметр в Visual Basic) `createdNew`, чтобы определить, существовало ли именованное системное событие или оно было создано.</span><span class="sxs-lookup"><span data-stu-id="29afb-187">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="29afb-188">Если начальное состояние события является несигнальным, потоки, ожидающие события, будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-188">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="29afb-189">Если начальное состояние сигнальное и для `mode`указан флаг <xref:System.Threading.EventResetMode.ManualReset>, потоки, ожидающие события, не будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-189">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="29afb-190">Если начальное состояние сигнальное, а `mode` имеет <xref:System.Threading.EventResetMode.AutoReset>, первый поток, ожидающий события, будет немедленно освобожден, после чего событие будет сброшено, и последующие потоки будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="29afb-190">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="29afb-191">В следующем примере кода демонстрируется поведение перекрестной обработки именованного системного события с защитой управления доступом.</span><span class="sxs-lookup"><span data-stu-id="29afb-191">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="29afb-192">В примере используется перегрузка метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> для проверки существования именованного события.</span><span class="sxs-lookup"><span data-stu-id="29afb-192">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="29afb-193">Если событие не существует, оно создается с первоначальным владельцем и безопасностью контроля доступа, которая запрещает текущему пользователю право использовать событие, но предоставляет право на чтение и изменение для события.</span><span class="sxs-lookup"><span data-stu-id="29afb-193">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="29afb-194">Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="29afb-194">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="29afb-195">Исключение перехвачено, и в примере используется перегрузка метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> для ожидания события с правами, необходимыми для чтения и изменения разрешений.</span><span class="sxs-lookup"><span data-stu-id="29afb-195">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="29afb-196">После изменения разрешений открывается событие с правами, необходимыми для его ожидания и сигналом.</span><span class="sxs-lookup"><span data-stu-id="29afb-196">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="29afb-197">Если запустить скомпилированный пример из третьего командного окна, пример выполняется с использованием новых разрешений.</span><span class="sxs-lookup"><span data-stu-id="29afb-197">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="29afb-198">Произошла ошибка Win32.</span><span class="sxs-lookup"><span data-stu-id="29afb-198">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="29afb-199">Именованное событие уже существует и имеет настройки управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-199">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="29afb-200">Именованное событие нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</span><span class="sxs-lookup"><span data-stu-id="29afb-200">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="29afb-201">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span><span class="sxs-lookup"><span data-stu-id="29afb-201"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="29afb-202">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="29afb-202">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="29afb-203">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="29afb-203">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="29afb-204">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="29afb-204">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="29afb-205">Возвращает объект <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />, представляющий управление доступом для именованного системного события, представленного объектом <see cref="T:System.Threading.EventWaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-205">Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</span></span></summary>
        <returns><span data-ttu-id="29afb-206">Объект <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />, представляющий параметры безопасности управления доступом для именованного системного события.</span><span class="sxs-lookup"><span data-stu-id="29afb-206">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29afb-207">Метод <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> использует следующее сочетание флагов (в сочетании с побитовой операцией OR) для поиска разрешений: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>и <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="29afb-207">The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="29afb-208">Пользователь должен иметь <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> прав для вызова этого метода, и событие должно быть открыто с флагом <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="29afb-208">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="29afb-209">В следующем примере кода демонстрируется поведение перекрестной обработки именованного системного события с защитой управления доступом.</span><span class="sxs-lookup"><span data-stu-id="29afb-209">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="29afb-210">В примере используется перегрузка метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> для проверки существования именованного события.</span><span class="sxs-lookup"><span data-stu-id="29afb-210">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="29afb-211">Если событие не существует, оно создается с первоначальным владельцем и безопасностью контроля доступа, которая запрещает текущему пользователю право использовать событие, но предоставляет право на чтение и изменение для события.</span><span class="sxs-lookup"><span data-stu-id="29afb-211">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="29afb-212">Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="29afb-212">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="29afb-213">Исключение перехвачено, и в примере используется перегрузка метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> для ожидания события с правами, необходимыми для чтения и изменения разрешений.</span><span class="sxs-lookup"><span data-stu-id="29afb-213">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="29afb-214">После того как разрешения считаны, с помощью метода <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> и изменились, событие открывается с правами, необходимыми для его ожидания и сигнала.</span><span class="sxs-lookup"><span data-stu-id="29afb-214">After the permissions have been read, using the <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method, and changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="29afb-215">Если запустить скомпилированный пример из третьего командного окна, пример выполняется с использованием новых разрешений.</span><span class="sxs-lookup"><span data-stu-id="29afb-215">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="29afb-216">Текущий объект <see cref="T:System.Threading.EventWaitHandle" /> представляет именованное системное событие, а пользователь не имеет <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-216">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span></span>  
  
<span data-ttu-id="29afb-217">- или -</span><span class="sxs-lookup"><span data-stu-id="29afb-217">-or-</span></span> 
<span data-ttu-id="29afb-218">Текущий объект <see cref="T:System.Threading.EventWaitHandle" /> представляет именованное системное событие, но оно не было открыто с правами <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-218">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="29afb-219">Не поддерживается для Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="29afb-219">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="29afb-220">Метод <see cref="M:System.Threading.WaitHandle.Close" /> ранее вызывался для этого <see cref="T:System.Threading.EventWaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-220">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="29afb-221">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="29afb-221">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="29afb-222">Открывает указанное именованное событие синхронизации, если оно уже существует.</span><span class="sxs-lookup"><span data-stu-id="29afb-222">Opens a specified named synchronization event, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="29afb-223">Имя системного события синхронизации, которое нужно открыть.</span><span class="sxs-lookup"><span data-stu-id="29afb-223">The name of the system synchronization event to open.</span></span></param>
        <summary><span data-ttu-id="29afb-224">Открывает указанное именованное событие синхронизации, если оно уже существует.</span><span class="sxs-lookup"><span data-stu-id="29afb-224">Opens the specified named synchronization event, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="29afb-225">Объект, представляющий именованное системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-225">An  object that represents the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29afb-226">Метод <xref:System.Threading.EventWaitHandle.OpenExisting%2A> пытается открыть указанное именованное системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-226">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event.</span></span> <span data-ttu-id="29afb-227">Если системное событие не существует, этот метод создает исключение, а не создает системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-227">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="29afb-228">Чтобы создать системное событие, если оно еще не существует, используйте один из <xref:System.Threading.EventWaitHandle.%23ctor%2A> конструкторов с параметром `name`.</span><span class="sxs-lookup"><span data-stu-id="29afb-228">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="29afb-229">Несколько вызовов этого метода, которые используют одно и то же значение для `name`, не обязательно возвращают один и тот же объект <xref:System.Threading.EventWaitHandle>, хотя возвращаемые объекты представляют одно и то же именованное системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-229">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 <span data-ttu-id="29afb-230">Перегрузка этого метода эквивалентна вызову перегрузки метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> и указанию прав <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> в сочетании с помощью побитовой операции или.</span><span class="sxs-lookup"><span data-stu-id="29afb-230">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="29afb-231">Задание флага <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> позволяет потоку ожидать именованное системное событие, а указание флага <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> позволяет потоку вызывать методы <xref:System.Threading.EventWaitHandle.Set%2A> и <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="29afb-231">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="29afb-232">В следующем примере кода демонстрируется поведение перекрестной обработки именованного системного события с защитой управления доступом.</span><span class="sxs-lookup"><span data-stu-id="29afb-232">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="29afb-233">В примере используется перегрузка метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> для проверки существования именованного события.</span><span class="sxs-lookup"><span data-stu-id="29afb-233">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="29afb-234">Если событие не существует, оно создается с первоначальным владельцем и безопасностью контроля доступа, которая запрещает текущему пользователю право использовать событие, но предоставляет право на чтение и изменение для события.</span><span class="sxs-lookup"><span data-stu-id="29afb-234">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="29afb-235">Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="29afb-235">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="29afb-236">Исключение перехвачено, и в примере используется перегрузка метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> для ожидания события с правами, необходимыми для чтения и изменения разрешений.</span><span class="sxs-lookup"><span data-stu-id="29afb-236">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="29afb-237">После изменения разрешений открывается событие с правами, необходимыми для его ожидания и сигналом.</span><span class="sxs-lookup"><span data-stu-id="29afb-237">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="29afb-238">Если запустить скомпилированный пример из третьего командного окна, пример выполняется с использованием новых разрешений.</span><span class="sxs-lookup"><span data-stu-id="29afb-238">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="29afb-239">Параметр <paramref name="name" /> равен пустой строке.</span><span class="sxs-lookup"><span data-stu-id="29afb-239"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="29afb-240">- или -</span><span class="sxs-lookup"><span data-stu-id="29afb-240">-or-</span></span> 
 <span data-ttu-id="29afb-241">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span><span class="sxs-lookup"><span data-stu-id="29afb-241"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="29afb-242">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-242"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="29afb-243">Именованное системное событие не существует.</span><span class="sxs-lookup"><span data-stu-id="29afb-243">The named system event does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="29afb-244">Произошла ошибка Win32.</span><span class="sxs-lookup"><span data-stu-id="29afb-244">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="29afb-245">Именованное событие существует, но у пользователя нет необходимых для его использования прав доступа.</span><span class="sxs-lookup"><span data-stu-id="29afb-245">The named event exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="29afb-246">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="29afb-246">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="29afb-247">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="29afb-247">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="29afb-248">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="29afb-248">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="29afb-249">Имя системного события синхронизации, которое нужно открыть.</span><span class="sxs-lookup"><span data-stu-id="29afb-249">The name of the system synchronization event to open.</span></span></param>
        <param name="rights"><span data-ttu-id="29afb-250">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</span><span class="sxs-lookup"><span data-stu-id="29afb-250">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="29afb-251">Открывает указанное именованное событие синхронизации, если оно уже существует, с требуемыми правами доступа.</span><span class="sxs-lookup"><span data-stu-id="29afb-251">Opens the specified named synchronization event, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="29afb-252">Объект, представляющий именованное системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-252">An object that represents the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29afb-253">Параметр `rights` должен включать флаг <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>, чтобы разрешить потокам ожидать события, а флаг <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> разрешает потокам вызывать методы <xref:System.Threading.EventWaitHandle.Set%2A> и <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="29afb-253">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="29afb-254">Метод <xref:System.Threading.EventWaitHandle.OpenExisting%2A> пытается открыть существующее именованное системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-254">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event.</span></span> <span data-ttu-id="29afb-255">Если системное событие не существует, этот метод создает исключение, а не создает системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-255">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="29afb-256">Чтобы создать системное событие, если оно еще не существует, используйте один из <xref:System.Threading.EventWaitHandle.%23ctor%2A> конструкторов с параметром `name`.</span><span class="sxs-lookup"><span data-stu-id="29afb-256">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="29afb-257">Несколько вызовов этого метода, которые используют одно и то же значение для `name`, не обязательно возвращают один и тот же объект <xref:System.Threading.EventWaitHandle>, хотя возвращаемые объекты представляют одно и то же именованное системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-257">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="29afb-258">В следующем примере кода демонстрируется поведение перекрестной обработки именованного системного события с защитой управления доступом.</span><span class="sxs-lookup"><span data-stu-id="29afb-258">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="29afb-259">В примере используется перегрузка метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> для проверки существования именованного события.</span><span class="sxs-lookup"><span data-stu-id="29afb-259">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="29afb-260">Если событие не существует, оно создается с первоначальным владельцем и безопасностью контроля доступа, которая запрещает текущему пользователю право использовать событие, но предоставляет право на чтение и изменение для события.</span><span class="sxs-lookup"><span data-stu-id="29afb-260">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="29afb-261">Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="29afb-261">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="29afb-262">Исключение перехвачено, и в примере используется перегрузка метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> для ожидания события с правами, необходимыми для чтения и изменения разрешений.</span><span class="sxs-lookup"><span data-stu-id="29afb-262">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="29afb-263">После изменения разрешений открывается событие с правами, необходимыми для его ожидания и сигналом.</span><span class="sxs-lookup"><span data-stu-id="29afb-263">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="29afb-264">Если запустить скомпилированный пример из третьего командного окна, пример выполняется с использованием новых разрешений.</span><span class="sxs-lookup"><span data-stu-id="29afb-264">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="29afb-265">Параметр <paramref name="name" /> равен пустой строке.</span><span class="sxs-lookup"><span data-stu-id="29afb-265"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="29afb-266">- или -</span><span class="sxs-lookup"><span data-stu-id="29afb-266">-or-</span></span> 
 <span data-ttu-id="29afb-267">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span><span class="sxs-lookup"><span data-stu-id="29afb-267"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="29afb-268">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-268"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="29afb-269">Именованное системное событие не существует.</span><span class="sxs-lookup"><span data-stu-id="29afb-269">The named system event does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="29afb-270">Произошла ошибка Win32.</span><span class="sxs-lookup"><span data-stu-id="29afb-270">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="29afb-271">Именованное событие уже существует, но пользователь не имеет требуемых прав для безопасного доступа.</span><span class="sxs-lookup"><span data-stu-id="29afb-271">The named event exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="29afb-272">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="29afb-272">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="29afb-273">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="29afb-273">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="29afb-274">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="29afb-274">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="29afb-275">Задает несигнальное состояние события, вызывая блокирование потоков.</span><span class="sxs-lookup"><span data-stu-id="29afb-275">Sets the state of the event to nonsignaled, causing threads to block.</span></span></summary>
        <returns><span data-ttu-id="29afb-276"><see langword="true" />, если операция прошла успешно; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-276"><see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="29afb-277">Метод <see cref="M:System.Threading.WaitHandle.Close" /> ранее вызывался для этого <see cref="T:System.Threading.EventWaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-277">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="29afb-278">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="29afb-278">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="29afb-279">Задает сигнальное состояние события, позволяя одному или нескольким ожидающим потокам продолжить.</span><span class="sxs-lookup"><span data-stu-id="29afb-279">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</span></span></summary>
        <returns><span data-ttu-id="29afb-280">Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-280"><see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29afb-281">Для <xref:System.Threading.EventWaitHandle> с <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (включая <xref:System.Threading.AutoResetEvent>) метод <xref:System.Threading.EventWaitHandle.Set%2A> освобождает один поток.</span><span class="sxs-lookup"><span data-stu-id="29afb-281">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread.</span></span> <span data-ttu-id="29afb-282">Если нет ожидающих потоков, дескриптор ожидания остается сигнальным до тех пор, пока поток не попытается его подождать или пока не будет вызван метод <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="29afb-282">If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="29afb-283">Нет никакой гарантии, что каждый вызов метода <xref:System.Threading.EventWaitHandle.Set%2A> приведет к освобождению потока из <xref:System.Threading.EventWaitHandle>, чей режим перезагрузки <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="29afb-283">There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span></span> <span data-ttu-id="29afb-284">Если два вызова находятся слишком близко друг к другу, так что второй вызов происходит до освобождения потока, освобождается только один поток.</span><span class="sxs-lookup"><span data-stu-id="29afb-284">If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</span></span> <span data-ttu-id="29afb-285">Это так, как если бы второй вызов не происходил.</span><span class="sxs-lookup"><span data-stu-id="29afb-285">It is as if the second call did not happen.</span></span> <span data-ttu-id="29afb-286">Кроме того, если <xref:System.Threading.EventWaitHandle.Set%2A> вызывается, когда нет потоков, ожидающих обработки, и <xref:System.Threading.EventWaitHandle> уже имеет сигнал, вызов не действует.</span><span class="sxs-lookup"><span data-stu-id="29afb-286">Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.</span></span>  
  
 <span data-ttu-id="29afb-287">Для <xref:System.Threading.EventWaitHandle> с <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (включая <xref:System.Threading.ManualResetEvent>) вызов метода <xref:System.Threading.EventWaitHandle.Set%2A> оставляет дескриптор ожидания в сигнальном состоянии до тех пор, пока не будет вызван метод <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="29afb-287">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="29afb-288">В следующем примере кода используется перегрузка метода <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>, позволяющая основному потоку сообщить о заблокированном потоке, а затем подождать, пока поток не завершит задачу.</span><span class="sxs-lookup"><span data-stu-id="29afb-288">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="29afb-289">Пример запускает пять потоков и позволяет блокировать их на <xref:System.Threading.EventWaitHandle>, созданном с флагом <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>, а затем освобождает один поток каждый раз, когда пользователь нажимает клавишу ВВОД.</span><span class="sxs-lookup"><span data-stu-id="29afb-289">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="29afb-290">Затем этот пример помещает в очередь еще пять потоков и освобождает их все с помощью <xref:System.Threading.EventWaitHandle>, созданного с флагом <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="29afb-290">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="29afb-291">Метод <see cref="M:System.Threading.WaitHandle.Close" /> ранее вызывался для этого <see cref="T:System.Threading.EventWaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-291">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="29afb-292">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="29afb-292">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="eventSecurity"><span data-ttu-id="29afb-293">Объект <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />, определяющий настройки управления доступом для применения к именованному системному событию.</span><span class="sxs-lookup"><span data-stu-id="29afb-293">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span></span></param>
        <summary><span data-ttu-id="29afb-294">Задает защиту управления доступом для именованного системного события.</span><span class="sxs-lookup"><span data-stu-id="29afb-294">Sets the access control security for a named system event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29afb-295">Пользователь должен иметь <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> прав для вызова этого метода, и событие должно быть открыто с флагом <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="29afb-295">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="29afb-296">В следующем примере кода демонстрируется поведение перекрестной обработки именованного системного события с защитой управления доступом.</span><span class="sxs-lookup"><span data-stu-id="29afb-296">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="29afb-297">В примере используется перегрузка метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> для проверки существования именованного события.</span><span class="sxs-lookup"><span data-stu-id="29afb-297">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="29afb-298">Если событие не существует, оно создается с первоначальным владельцем и безопасностью контроля доступа, которая запрещает текущему пользователю право использовать событие, но предоставляет право на чтение и изменение для события.</span><span class="sxs-lookup"><span data-stu-id="29afb-298">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="29afb-299">Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="29afb-299">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="29afb-300">Исключение перехвачено, и в примере используется перегрузка метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> для ожидания события с правами, необходимыми для чтения и изменения разрешений.</span><span class="sxs-lookup"><span data-stu-id="29afb-300">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="29afb-301">После изменения разрешений с помощью метода <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> открывается событие с правами, необходимыми для его ожидания и сигналом.</span><span class="sxs-lookup"><span data-stu-id="29afb-301">After the permissions are changed, using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="29afb-302">Если запустить скомпилированный пример из третьего командного окна, пример выполняется с использованием новых разрешений.</span><span class="sxs-lookup"><span data-stu-id="29afb-302">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="29afb-303">Свойство <paramref name="eventSecurity" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-303"><paramref name="eventSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="29afb-304">Пользователь не имеет <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-304">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span></span>  
  
<span data-ttu-id="29afb-305">- или -</span><span class="sxs-lookup"><span data-stu-id="29afb-305">-or-</span></span> 
<span data-ttu-id="29afb-306">Событие не было открыто с <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-306">The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="29afb-307">Текущий объект <see cref="T:System.Threading.EventWaitHandle" /> не представляет именованное системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-307">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="29afb-308">Для данного объекта <see cref="M:System.Threading.WaitHandle.Close" /> ранее вызывался метод <see cref="T:System.Threading.EventWaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-308">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="29afb-309">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="29afb-309">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="29afb-310">Открывает указанное именованное событие синхронизации, если оно уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</span><span class="sxs-lookup"><span data-stu-id="29afb-310">Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * EventWaitHandle -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="29afb-311">Имя системного события синхронизации, которое нужно открыть.</span><span class="sxs-lookup"><span data-stu-id="29afb-311">The name of the system synchronization event to open.</span></span></param>
        <param name="result"><span data-ttu-id="29afb-312">При возврате этого метода содержит объект <see cref="T:System.Threading.EventWaitHandle" />, представляющий именованное событие синхронизации, если вызов завершился успешно, или значение <see langword="null" />, если вызов завершился неудачно.</span><span class="sxs-lookup"><span data-stu-id="29afb-312">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="29afb-313">Этот параметр обрабатывается как неинициализированный.</span><span class="sxs-lookup"><span data-stu-id="29afb-313">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="29afb-314">Открывает указанное именованное событие синхронизации, если оно уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</span><span class="sxs-lookup"><span data-stu-id="29afb-314">Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="29afb-315">Значение <see langword="true" />, если именованное событие синхронизации открылось успешно. В противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-315"><see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29afb-316">Если именованное событие синхронизации не существует, этот метод не создает его.</span><span class="sxs-lookup"><span data-stu-id="29afb-316">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="29afb-317">Чтобы создать системное событие, если оно еще не существует, используйте один из <xref:System.Threading.EventWaitHandle.%23ctor%2A> конструкторов с параметром `name`.</span><span class="sxs-lookup"><span data-stu-id="29afb-317">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="29afb-318">Если вы не уверены, существует ли именованное событие синхронизации, используйте эту перегрузку метода вместо перегрузки метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>, которая вызывает исключение, если событие синхронизации не существует.</span><span class="sxs-lookup"><span data-stu-id="29afb-318">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="29afb-319">Перегрузка этого метода эквивалентна вызову перегрузки метода <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> и указанию прав <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> в сочетании с помощью побитовой операции или.</span><span class="sxs-lookup"><span data-stu-id="29afb-319">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="29afb-320">Задание флага <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> позволяет потоку ожидать именованное системное событие, а указание флага <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> позволяет потоку вызывать методы <xref:System.Threading.EventWaitHandle.Set%2A> и <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="29afb-320">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="29afb-321">Несколько вызовов этого метода, которые используют одно и то же значение для `name`, не обязательно возвращают один и тот же объект <xref:System.Threading.EventWaitHandle>, хотя возвращаемые объекты представляют одно и то же именованное системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-321">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="29afb-322">Параметр <paramref name="name" /> равен пустой строке.</span><span class="sxs-lookup"><span data-stu-id="29afb-322"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="29afb-323">- или -</span><span class="sxs-lookup"><span data-stu-id="29afb-323">-or-</span></span> 
 <span data-ttu-id="29afb-324">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span><span class="sxs-lookup"><span data-stu-id="29afb-324"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="29afb-325"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-325"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="29afb-326">Произошла ошибка Win32.</span><span class="sxs-lookup"><span data-stu-id="29afb-326">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="29afb-327">Именованное событие уже существует, но пользователь не имеет требуемых прав для безопасного доступа.</span><span class="sxs-lookup"><span data-stu-id="29afb-327">The named event exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="29afb-328">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="29afb-328">requires full trust for the immediate caller.</span></span> <span data-ttu-id="29afb-329">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="29afb-329">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights * EventWaitHandle -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="29afb-330">Имя системного события синхронизации, которое нужно открыть.</span><span class="sxs-lookup"><span data-stu-id="29afb-330">The name of the system synchronization event to open.</span></span></param>
        <param name="rights"><span data-ttu-id="29afb-331">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</span><span class="sxs-lookup"><span data-stu-id="29afb-331">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="29afb-332">При возврате этого метода содержит объект <see cref="T:System.Threading.EventWaitHandle" />, представляющий именованное событие синхронизации, если вызов завершился успешно, или значение <see langword="null" />, если вызов завершился неудачно.</span><span class="sxs-lookup"><span data-stu-id="29afb-332">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="29afb-333">Этот параметр обрабатывается как неинициализированный.</span><span class="sxs-lookup"><span data-stu-id="29afb-333">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="29afb-334">Открывает заданное именованное событие синхронизации, если оно уже существует, с требуемыми правами доступа и возвращает значение, указывающее, успешно ли выполнена операция.</span><span class="sxs-lookup"><span data-stu-id="29afb-334">Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="29afb-335">Значение <see langword="true" />, если именованное событие синхронизации открылось успешно. В противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-335"><see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29afb-336">Если именованное событие синхронизации не существует, этот метод не создает его.</span><span class="sxs-lookup"><span data-stu-id="29afb-336">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="29afb-337">Чтобы создать системное событие, если оно еще не существует, используйте один из <xref:System.Threading.EventWaitHandle.%23ctor%2A> конструкторов с параметром `name`.</span><span class="sxs-lookup"><span data-stu-id="29afb-337">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="29afb-338">Если вы не уверены, существует ли именованное событие синхронизации, используйте эту перегрузку метода вместо перегрузки метода <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>, которая вызывает исключение, если событие синхронизации не существует.</span><span class="sxs-lookup"><span data-stu-id="29afb-338">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="29afb-339">Параметр `rights` должен включать флаг <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>, чтобы разрешить потокам ожидать события, а флаг <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> разрешает потокам вызывать методы <xref:System.Threading.EventWaitHandle.Set%2A> и <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="29afb-339">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="29afb-340">Несколько вызовов этого метода, которые используют одно и то же значение для `name`, не обязательно возвращают один и тот же объект <xref:System.Threading.EventWaitHandle>, хотя возвращаемые объекты представляют одно и то же именованное системное событие.</span><span class="sxs-lookup"><span data-stu-id="29afb-340">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="29afb-341">Параметр <paramref name="name" /> равен пустой строке.</span><span class="sxs-lookup"><span data-stu-id="29afb-341"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="29afb-342">- или -</span><span class="sxs-lookup"><span data-stu-id="29afb-342">-or-</span></span> 
 <span data-ttu-id="29afb-343">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span><span class="sxs-lookup"><span data-stu-id="29afb-343"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="29afb-344">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="29afb-344"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="29afb-345">Произошла ошибка Win32.</span><span class="sxs-lookup"><span data-stu-id="29afb-345">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="29afb-346">Именованное событие уже существует, но пользователь не имеет требуемых прав для безопасного доступа.</span><span class="sxs-lookup"><span data-stu-id="29afb-346">The named event exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="29afb-347">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="29afb-347">requires full trust for the immediate caller.</span></span> <span data-ttu-id="29afb-348">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="29afb-348">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>
