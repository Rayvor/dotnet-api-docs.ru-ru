<Type Name="Selector" FullName="System.Windows.Controls.Primitives.Selector">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d77ab669078accf24b046a44cc73523fa2888894" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70457160" /></Metadata><TypeSignature Language="C#" Value="public abstract class Selector : System.Windows.Controls.ItemsControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract Selector extends System.Windows.Controls.ItemsControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.Selector" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Selector&#xA;Inherits ItemsControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Selector abstract : System::Windows::Controls::ItemsControl" />
  <TypeSignature Language="F#" Value="type Selector = class&#xA;    inherit ItemsControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ItemsControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("SelectionChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("SelectedIndex")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет элемент управления, позволяющий пользователю выбрать один из его дочерних элементов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Primitives.Selector>— Это <xref:System.Windows.Controls.ItemsControl>, то есть может содержать коллекцию объектов любого типа (например, строку, изображение или панель). Дополнительные сведения см. в описании класса <xref:System.Windows.Controls.ItemsControl>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Selector ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Selector();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Controls.Primitives.Selector" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSelectedHandler">
      <MemberSignature Language="C#" Value="public static void AddSelectedHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddSelectedHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.AddSelectedHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddSelectedHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddSelectedHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddSelectedHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Controls.Primitives.Selector.AddSelectedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, отслеживающий данное событие.</param>
        <param name="handler">Добавляемый обработчик событий.</param>
        <summary>Добавляет обработчик для вложенного события <see cref="E:System.Windows.Controls.Primitives.Selector.Selected" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddUnselectedHandler">
      <MemberSignature Language="C#" Value="public static void AddUnselectedHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUnselectedHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.AddUnselectedHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUnselectedHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUnselectedHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddUnselectedHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Controls.Primitives.Selector.AddUnselectedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, отслеживающий данное событие.</param>
        <param name="handler">Добавляемый обработчик событий.</param>
        <summary>Добавляет обработчик для вложенного события <see cref="E:System.Windows.Controls.Primitives.Selector.Unselected" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected override void ClearContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.ClearContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="override this.ClearContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="selector.ClearContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">Элемент контейнера элементов.</param>
        <param name="item">Элемент данных.</param>
        <summary>Возвращает контейнер элементов в состояние, в котором он находился перед вызовом метода <see cref="M:System.Windows.Controls.ItemsControl.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Primitives.Selector.ClearContainerForItemOverride%2A><xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType> очищает присоединенное свойство, когда контейнер элементов удаляется из визуального дерева.  Это делается, так что контейнеры элементов правильно работают <xref:System.Windows.Controls.Primitives.Selector> , когда использует повторное использование контейнеров.  Дополнительные сведения см <xref:System.Windows.Controls.VirtualizationMode> . в статьях и "перезапуск контейнера" в разделе [Оптимизация производительности: элементы управления](~/docs/framework/wpf/advanced/optimizing-performance-controls.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsSelected">
      <MemberSignature Language="C#" Value="public static bool GetIsSelected (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsSelected(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.GetIsSelected(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsSelected (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsSelected(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetIsSelected : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Controls.Primitives.Selector.GetIsSelected element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Объект для запроса свойства <see cref="P:System.Windows.Controls.Primitives.Selector.IsSelected" />.</param>
        <summary>Получает значение присоединенного свойства <see cref="P:System.Windows.Controls.Primitives.Selector.IsSelected" />, указывающее, выбран ли элемент.</summary>
        <returns>Логическое значение; <see langword="true" />, если свойство <see cref="P:System.Windows.Controls.Primitives.Selector.IsSelected" /> — <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsSelectionActive">
      <MemberSignature Language="C#" Value="public static bool GetIsSelectionActive (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsSelectionActive(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.GetIsSelectionActive(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsSelectionActive (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsSelectionActive(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetIsSelectionActive : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Controls.Primitives.Selector.GetIsSelectionActive element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, из которого считывается значение вложенного свойства зависимостей.</param>
        <summary>Возвращает значение, указывающее, имеет ли <see cref="T:System.Windows.Controls.Primitives.Selector" /> фокус ввода от клавиатуры.</summary>
        <returns>Значение свойства; <see langword="true" />, если фокус клавиатуры находится в <see cref="T:System.Windows.Controls.Primitives.Selector" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSelected">
      <MemberSignature Language="C#" Value="see GetIsSelected, and SetIsSelected" />
      <MemberSignature Language="ILAsm" Value="see GetIsSelected, and SetIsSelected" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.Selector.IsSelected" />
      <MemberSignature Language="VB.NET" Value="see GetIsSelected, and SetIsSelected" />
      <MemberSignature Language="F#" Value="see GetIsSelected, and SetIsSelected" Usage="see GetIsSelected, and SetIsSelected" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, выделен ли элемент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте присоединенное свойство, чтобы выбрать элемент в, <xref:System.Windows.Controls.Primitives.Selector> когда не нужно явно создавать контейнер элементов. <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A> Контейнер элемента — это класс, представляющий элемент в <xref:System.Windows.Controls.Primitives.Selector>.  <xref:System.Windows.Controls.TabItem>, <xref:System.Windows.Controls.ListBoxItem> <xref:System.Windows.Controls.Primitives.Selector>и <xref:System.Windows.Controls.ComboBoxItem> являются контейнерами элементов для элементов управления, которые наследуют от, и каждый из них определяет свойство, которое было **выбрано** .  
  
 Если вы не создаете контейнер элементов явным образом, [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] неявно создаете его и присваивает свойству " **выбрали** " в контейнере элемента значение <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>. Это единственный момент времени <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType> чтения.  <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>не обновляется при изменении выбора элемента.  
  
 При явном создании контейнера элементов следует использовать свойство, которое было **выбрано** для этого класса.  
  
<a name="dependencyPropertyInfo_IsSelected"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.Primitives.Selector.IsSelectedProperty>, зарегистрировано как прикрепленное|  
|Свойства метаданных, для которых задано значение`true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
   
  
## Examples  
 В приведенном ниже примере <xref:System.Windows.Controls.ListBox> создается объект, <xref:System.Windows.Controls.CheckBox> содержащий два элемента управления.  В этом примере явно не создается объект <xref:System.Windows.Controls.ListBoxItem> <xref:System.Windows.Controls.CheckBox>для, поэтому он задается <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType> непосредственно для <xref:System.Windows.Controls.CheckBox>каждого из них.  Чтобы проиллюстрировать, <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType> что не Обновлено, в примере <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A> свойство первого флажка привязывается к <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>. Когда пользователь отменяет выбор элемента в <xref:System.Windows.Controls.ListBox> <xref:System.Windows.Controls.CheckBox> , остается установленным.  Аналогично, проверка или извлечение <xref:System.Windows.Controls.CheckBox> не влияет на <xref:System.Windows.Controls.CheckBox> выбор в <xref:System.Windows.Controls.ListBox>. В примере выполняется привязка <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A> второго <xref:System.Windows.Controls.CheckBox> объекта к <xref:System.Windows.Controls.ListBoxItem.IsSelected%2A?displayProperty=nameWithType>.  В этом случае отмените выбор элемента в <xref:System.Windows.Controls.ListBox> , чтобы снять флажок, и снимите флажок, чтобы снять флажок напротив элемента.  
  
```xaml
<ListBox Name="listBox1" SelectionMode="Multiple">
  <CheckBox Selector.IsSelected="True" 
            IsChecked="{Binding RelativeSource={RelativeSource Self}, 
                        Path=(Selector.IsSelected), Mode=TwoWay}">
    CheckBox.IsChecked is bound to Selector.IsChecked, which is set only
    once.
  </CheckBox>

  <CheckBox ListBox.IsSelected="True" 
            IsChecked="{Binding RelativeSource={RelativeSource 
                        AncestorType={x:Type ListBoxItem}}, 
                        Path=IsSelected, Mode=TwoWay}">
    CheckBox.IsChecked is bound to ListBoxItem.IsChecked, which is
    updated throughout the duration of the application.
  </CheckBox>
</ListBox>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSelectedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsSelectedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsSelectedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.Selector.IsSelectedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsSelectedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsSelectedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsSelectedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.Selector.IsSelectedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Controls.Primitives.Selector.IsSelected" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSelectionActive">
      <MemberSignature Language="C#" Value="see GetIsSelectionActive" />
      <MemberSignature Language="ILAsm" Value="see GetIsSelectionActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.Selector.IsSelectionActive" />
      <MemberSignature Language="VB.NET" Value="see GetIsSelectionActive" />
      <MemberSignature Language="F#" Value="see GetIsSelectionActive" Usage="see GetIsSelectionActive" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, указывающее, имеет ли значение, возвращаемое объектом <see cref="T:System.Windows.Controls.Primitives.Selector" />, фокус ввода от клавиатуры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 Это редкий случай присоединяемого свойства только для чтения. Его нельзя задать в XAML; он существует, чтобы можно было проверить его значение для выбранных элементов в коде.  
  
<a name="dependencyPropertyInfo_IsSelectionActive"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.Primitives.Selector.IsSelectionActiveProperty>|  
|Свойства метаданных, для которых задано значение`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSelectionActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsSelectionActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsSelectionActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.Selector.IsSelectionActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsSelectionActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsSelectionActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsSelectionActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.Selector.IsSelectionActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Controls.Primitives.Selector.IsSelectionActive" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronizedWithCurrentItem">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsSynchronizedWithCurrentItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; IsSynchronizedWithCurrentItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItem" />
      <MemberSignature Language="VB.NET" Value="Public Property IsSynchronizedWithCurrentItem As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; IsSynchronizedWithCurrentItem { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronizedWithCurrentItem : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.NullableBoolConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.NullableBoolConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должен ли <see cref="T:System.Windows.Controls.Primitives.Selector" /> поддерживать синхронизацию <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedItem" /> с текущим элементом в свойстве <see cref="P:System.Windows.Controls.ItemsControl.Items" />.</summary>
        <value><see langword="true" />, если <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedItem" /> всегда синхронизируется с текущим элементом; <see cref="T:System.Windows.Controls.ItemCollection" />; <see langword="false" />, если <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedItem" /> никогда не синхронизируется с текущим элементом; <see langword="null" />, если <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedItem" /> синхронизируется с текущим элементом, только когда <see cref="T:System.Windows.Controls.Primitives.Selector" /> использует <see cref="T:System.Windows.Data.CollectionView" />.  Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно задать <xref:System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItem%2A> для `true` свойства значение, чтобы гарантировать, что <xref:System.Windows.Controls.ItemCollection.CurrentItem%2A> выбранный элемент всегда соответствует свойству в <xref:System.Windows.Controls.ItemCollection>. Например, предположим, что есть два <xref:System.Windows.Controls.ListBox> элемента управления <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> со свойством, для которых задан один и тот же источник.  Для параметра в обоих списках убедитесь, что выбранный элемент в каждом из них <xref:System.Windows.Controls.ListBox> одинаков. <xref:System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItem%2A> `true`  
  
<a name="xamlAttributeUsage_IsSynchronizedWithCurrentItem"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <*объект* `IsSynchronizedWithCurrentItem`=" <xref:System.Boolean> "/>  
  
-или-
  
 <*объект* `IsSynchronizedWithCurrentItem`=" {} "/>  
  
<a name="dependencyPropertyInfo_IsSynchronizedWithCurrentItem"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItemProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
   
  
## Examples  
 В следующем примере два <xref:System.Windows.Controls.ListBox> элемента управления привязываются к одному и тому же. <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> Поскольку <xref:System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItem%2A> параметр имеет `true` значение ON <xref:System.Windows.Controls.ListBox>, выбранный элемент всегда одинаков для обоих элементов управления  
  
 [!code-xaml[Selector#2](~/samples/snippets/csharp/VS_Snippets_Wpf/Selector/CS/Window1.xaml#2)]
 [!code-xaml[Selector#4](~/samples/snippets/csharp/VS_Snippets_Wpf/Selector/CS/Window1.xaml#4)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronizedWithCurrentItemProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsSynchronizedWithCurrentItemProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsSynchronizedWithCurrentItemProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItemProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsSynchronizedWithCurrentItemProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsSynchronizedWithCurrentItemProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsSynchronizedWithCurrentItemProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItemProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItem" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected override void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInitialized : EventArgs -&gt; unit" Usage="selector.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные о событии.</param>
        <summary>Создает событие <see cref="E:System.Windows.FrameworkElement.Initialized" />. Этот метод вызывается всякий раз, когда <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> имеет внутреннее значение <see langword="true" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected override void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="selector.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.UIElement.IsKeyboardFocusWithin" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsChanged">
      <MemberSignature Language="C#" Value="protected override void OnItemsChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnItemsChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnItemsChanged (e As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnItemsChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnItemsChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="selector.OnItemsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события.</param>
        <summary>Обновляет текущее выделение при изменении элемента в <see cref="T:System.Windows.Controls.Primitives.Selector" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsSourceChanged">
      <MemberSignature Language="C#" Value="protected override void OnItemsSourceChanged (System.Collections.IEnumerable oldValue, System.Collections.IEnumerable newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnItemsSourceChanged(class System.Collections.IEnumerable oldValue, class System.Collections.IEnumerable newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.OnItemsSourceChanged(System.Collections.IEnumerable,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnItemsSourceChanged (oldValue As IEnumerable, newValue As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnItemsSourceChanged(System::Collections::IEnumerable ^ oldValue, System::Collections::IEnumerable ^ newValue);" />
      <MemberSignature Language="F#" Value="override this.OnItemsSourceChanged : System.Collections.IEnumerable * System.Collections.IEnumerable -&gt; unit" Usage="selector.OnItemsSourceChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Collections.IEnumerable" />
        <Parameter Name="newValue" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="oldValue">Прежнее значение источника.</param>
        <param name="newValue">Новое значение источника.</param>
        <summary>Вызывается при изменении источника элемента в селекторе.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (System.Windows.Controls.SelectionChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.Windows.Controls.SelectionChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.OnSelectionChanged(System.Windows.Controls.SelectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As SelectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(System::Windows::Controls::SelectionChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanged : System.Windows.Controls.SelectionChangedEventArgs -&gt; unit&#xA;override this.OnSelectionChanged : System.Windows.Controls.SelectionChangedEventArgs -&gt; unit" Usage="selector.OnSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.SelectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события.</param>
        <summary>Вызывается при изменении выделения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected override void PrepareContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void PrepareContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub PrepareContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void PrepareContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="override this.PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="selector.PrepareContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="item" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, используемый для отображения заданного элемента.</param>
        <param name="item">Указанный отображаемый элемент.</param>
        <summary>Подготавливает указанный элемент для отображения заданного элемента.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSelectedHandler">
      <MemberSignature Language="C#" Value="public static void RemoveSelectedHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveSelectedHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.RemoveSelectedHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveSelectedHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveSelectedHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveSelectedHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Controls.Primitives.Selector.RemoveSelectedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, отслеживающий данное событие.</param>
        <param name="handler">Удаляемый обработчик событий.</param>
        <summary>Удаляет обработчик для вложенного события <see cref="E:System.Windows.Controls.Primitives.Selector.Selected" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveUnselectedHandler">
      <MemberSignature Language="C#" Value="public static void RemoveUnselectedHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUnselectedHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.RemoveUnselectedHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUnselectedHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUnselectedHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveUnselectedHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Controls.Primitives.Selector.RemoveUnselectedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, отслеживающий данное событие.</param>
        <param name="handler">Удаляемый обработчик событий.</param>
        <summary>Удаляет обработчик для вложенного события <see cref="E:System.Windows.Controls.Primitives.Selector.Unselected" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Selected">
      <MemberSignature Language="C#" Value="see AddSelectedHandler, and RemoveSelectedHandler" />
      <MemberSignature Language="ILAsm" Value="see AddSelectedHandler, and RemoveSelectedHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.Selector.Selected" />
      <MemberSignature Language="VB.NET" Value="see AddSelectedHandler, and RemoveSelectedHandler" />
      <MemberSignature Language="F#" Value="see AddSelectedHandler, and RemoveSelectedHandler" Usage="see AddSelectedHandler, and RemoveSelectedHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возникает при выборе элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_Selected"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.Primitives.Selector.SelectedEvent>|  
|Стратегия маршрутизации|Восходящей маршрутизации|  
|делегат|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 В следующих примерах показано, как использовать <xref:System.Windows.Controls.Primitives.Selector.Selected> событие <xref:System.Windows.Controls.ListBox> с элементом управления. Первый пример вызывает событие, а второй показывает, как справиться с событием.  
  
 [!code-xml[ListBoxItems_snip#SelectorEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxItems_snip/CSharp/Window1.xaml#selectorevents)]  
  
 [!code-csharp[ListBoxItems_snip#SelectorSelected](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxItems_snip/CSharp/Window1.xaml.cs#selectorselected)]
 [!code-vb[ListBoxItems_snip#SelectorSelected](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxItems_snip/visualbasic/window1.xaml.vb#selectorselected)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SelectedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SelectedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.Selector.SelectedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SelectedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SelectedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SelectedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Primitives.Selector.SelectedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.Controls.Primitives.Selector.Selected" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedIndex">
      <MemberSignature Language="C#" Value="public int SelectedIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectedIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.Selector.SelectedIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectedIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedIndex : int with get, set" Usage="System.Windows.Controls.Primitives.Selector.SelectedIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка индекса первого элемента в текущем выделенном фрагменте или возврат значения минус один (-1), если выделенный фрагмент пуст.</summary>
        <value>Индекс первого элемента в текущем выделении. Значением по умолчанию является минус один (-1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если поддерживает выбор одного элемента <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> , свойство возвращает индекс выбранного элемента. <xref:System.Windows.Controls.Primitives.Selector> Если объект <xref:System.Windows.Controls.Primitives.Selector> поддерживает множественный выбор <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> , возвращает индекс элемента, выбранного пользователем первым.  
  
 <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> Параметр <xref:System.Windows.Controls.Primitives.Selector>  в, который поддерживает множественные выборки, очищает существующие выбранные элементы и устанавливает выделение для элемента, указанного в индексе. <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A>Возвращает значение-1, если выделение пусто.  
  
 Если для параметра <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> задано значение меньше-1 <xref:System.ArgumentException> , создается исключение.  Если задано <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> значение больше или равно числу дочерних элементов, значение игнорируется.  
  
<a name="dependencyPropertyInfo_SelectedIndex"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.Primitives.Selector.SelectedIndexProperty>|  
|Свойства метаданных, для которых задано значение`true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Journal%2A>|  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Windows.Controls.ListBox> и <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> присваивается свойству значение 1, которое выбирает второй элемент в <xref:System.Windows.Controls.ListBox>.  
  
 [!code-xaml[ListBoxItems_snip#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxItems_snip/CSharp/Window1.xaml#2)]  
  
 В следующем примере <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> свойство используется для определения того, является ли элемент с индексом 0 первым элементом в выделенном фрагменте.  
  
 [!code-csharp[ListBoxItems_snip#SelectorSelectedIndex](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxItems_snip/CSharp/Window1.xaml.cs#selectorselectedindex)]
 [!code-vb[ListBoxItems_snip#SelectorSelectedIndex](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxItems_snip/visualbasic/window1.xaml.vb#selectorselectedindex)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedIndexProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SelectedIndexProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SelectedIndexProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.Selector.SelectedIndexProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SelectedIndexProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SelectedIndexProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SelectedIndexProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.Selector.SelectedIndexProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedIndex" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedItem">
      <MemberSignature Language="C#" Value="public object SelectedItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SelectedItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.Selector.SelectedItem" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedItem As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SelectedItem { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedItem : obj with get, set" Usage="System.Windows.Controls.Primitives.Selector.SelectedItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает первый элемент в текущем выделении или возвращает значение NULL, если выделение является пустым.</summary>
        <value>Первый элемент в текущем выделении или <see langword="null" />, если выделение является пустым.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если поддерживает выбор одного элемента <xref:System.Windows.Controls.Primitives.Selector.SelectedItem%2A> , свойство возвращает выбранный элемент. <xref:System.Windows.Controls.Primitives.Selector> Если объект <xref:System.Windows.Controls.Primitives.Selector> поддерживает множественный выбор <xref:System.Windows.Controls.Primitives.Selector.SelectedItem%2A> , возвращает элемент, выбранный пользователем первым.  
  
 <xref:System.Windows.Controls.Primitives.Selector.SelectedItem%2A> Параметр <xref:System.Windows.Controls.Primitives.Selector>  в, поддерживающий выбор нескольких вариантов, очищает существующие выбранные элементы и устанавливает для выбранного элемента указанный элемент.  
  
<a name="dependencyPropertyInfo_SelectedItem"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.Primitives.Selector.SelectedItemProperty>|  
|Свойства метаданных, для которых задано значение`true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Journal%2A>|  
  
   
  
## Examples  
 В следующем примере возвращается <xref:System.Windows.Controls.Primitives.Selector.SelectedItem%2A> <xref:System.Windows.Controls.ListBox>из.  
  
 [!code-csharp[ListBoxEvent#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxEvent/CSharp/Pane1.xaml.cs#2)]
 [!code-vb[ListBoxEvent#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxEvent/VisualBasic/Pane1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedItemProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SelectedItemProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SelectedItemProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.Selector.SelectedItemProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SelectedItemProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SelectedItemProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SelectedItemProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.Selector.SelectedItemProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedItem" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedValue">
      <MemberSignature Language="C#" Value="public object SelectedValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SelectedValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.Selector.SelectedValue" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SelectedValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedValue : obj with get, set" Usage="System.Windows.Controls.Primitives.Selector.SelectedValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedItem" />, получаемое посредством <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedValuePath" />.</summary>
        <value>Значение выбранного элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство определяет путь к свойству, которое используется для определения значения <xref:System.Windows.Controls.Primitives.Selector.SelectedValue%2A> свойства. <xref:System.Windows.Controls.Primitives.Selector.SelectedValuePath%2A> При <xref:System.Windows.Controls.Primitives.Selector.SelectedValue%2A> задании значения x попытается выбрать элемент, значение которого равно x; если такой элемент не найден, выделение снимается.  
  
<a name="dependencyPropertyInfo_SelectedValue"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.Primitives.Selector.SelectedValueProperty>|  
|Свойства метаданных, для которых задано значение`true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Journal%2A>|  
  
   
  
## Examples  
 В следующем примере выполняется привязка <xref:System.Windows.Controls.ListBox> к `Employee` коллекции объектов. <xref:System.Windows.Controls.Primitives.Selector.SelectedValuePath%2A> В примере задается <xref:System.Windows.Controls.Primitives.Selector.SelectedValue%2A> значение `@EmployeeNumber` и для `12345`.  При этом выбирается `Employee` объект `12345` , имеющий значение `EmployeeNumber`.  В этом примере также привязывается <xref:System.Windows.Controls.TextBlock> <xref:System.Windows.Controls.Primitives.Selector.SelectedValue%2A> к <xref:System.Windows.Controls.ListBox>элементу.  Когда пользователь изменяет выбор в <xref:System.Windows.Controls.ListBox> <xref:System.Windows.Controls.TextBlock> , он обновляется для отображения номера сотрудника текущего выбранного сотрудника.  
  
 [!code-xaml[Selector#2](~/samples/snippets/csharp/VS_Snippets_Wpf/Selector/CS/Window1.xaml#2)]
 [!code-xaml[Selector#3](~/samples/snippets/csharp/VS_Snippets_Wpf/Selector/CS/Window1.xaml#3)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.XmlDataProvider" />
      </Docs>
    </Member>
    <Member MemberName="SelectedValuePath">
      <MemberSignature Language="C#" Value="public string SelectedValuePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedValuePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.Selector.SelectedValuePath" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedValuePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SelectedValuePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedValuePath : string with get, set" Usage="System.Windows.Controls.Primitives.Selector.SelectedValuePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает путь, используемый для получения <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedValue" /> из <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedItem" />.</summary>
        <value>Путь, используемый для получения <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedValue" />. Значение по умолчанию - пустая строка.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство определяет путь к свойству, которое используется для определения значения <xref:System.Windows.Controls.Primitives.Selector.SelectedValue%2A> свойства. <xref:System.Windows.Controls.Primitives.Selector.SelectedValuePath%2A>  
  
<a name="dependencyPropertyInfo_SelectedValuePath"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.Primitives.Selector.SelectedValuePathProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
   
  
## Examples  
 В следующем примере выполняется привязка <xref:System.Windows.Controls.ListBox> к `Employee` коллекции объектов. <xref:System.Windows.Controls.Primitives.Selector.SelectedValuePath%2A> В примере задается <xref:System.Windows.Controls.Primitives.Selector.SelectedValue%2A> значение `@EmployeeNumber` и для `12345`.  При этом выбирается `Employee` объект `12345` , имеющий значение `EmployeeNumber`.  В этом примере также привязывается <xref:System.Windows.Controls.TextBlock> <xref:System.Windows.Controls.Primitives.Selector.SelectedValue%2A> к <xref:System.Windows.Controls.ListBox>элементу.  Когда пользователь изменяет выбор в <xref:System.Windows.Controls.ListBox> <xref:System.Windows.Controls.TextBlock> , он обновляется для отображения номера сотрудника текущего выбранного сотрудника.  
  
 [!code-xaml[Selector#2](~/samples/snippets/csharp/VS_Snippets_Wpf/Selector/CS/Window1.xaml#2)] 
 [!code-xaml[Selector#3](~/samples/snippets/csharp/VS_Snippets_Wpf/Selector/CS/Window1.xaml#3)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.XmlDataProvider" />
      </Docs>
    </Member>
    <Member MemberName="SelectedValuePathProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SelectedValuePathProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SelectedValuePathProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.Selector.SelectedValuePathProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SelectedValuePathProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SelectedValuePathProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SelectedValuePathProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.Selector.SelectedValuePathProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedValuePath" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedValueProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SelectedValueProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SelectedValueProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.Selector.SelectedValueProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SelectedValueProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SelectedValueProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SelectedValueProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.Selector.SelectedValueProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.Primitives.Selector.SelectedValue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.SelectionChangedEventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.SelectionChangedEventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.Selector.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionChanged As SelectionChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::SelectionChangedEventHandler ^ SelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanged : System.Windows.Controls.SelectionChangedEventHandler " Usage="member this.SelectionChanged : System.Windows.Controls.SelectionChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.SelectionChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает при изменении текущего выделения в <see cref="T:System.Windows.Controls.Primitives.Selector" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает при внесении изменений в выделенный фрагмент. Выбор можно изменить не только с помощью взаимодействия с пользователем, но и с помощью привязки, а также других наборов значений.  
  
<a name="routedEventInfo_SelectionChanged"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.Primitives.Selector.SelectionChangedEvent>|  
|Стратегия маршрутизации|Восходящей маршрутизации|  
|делегат|<xref:System.Windows.Controls.SelectionChangedEventHandler>|  
  
   
  
## Examples  
 В следующем примере показано, как присоединить <xref:System.Windows.Controls.Primitives.Selector.SelectionChanged> событие к элементу управления "список".  
  
 [!code-xaml[ListBoxEvent#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxEvent/CSharp/Pane1.xaml#1)]  
  
 В следующем примере показано, <xref:System.Windows.Controls.Primitives.Selector.SelectionChanged> как выполнить обработку события.  
  
 [!code-csharp[ListBoxEvent#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxEvent/CSharp/Pane1.xaml.cs#2)]
 [!code-vb[ListBoxEvent#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxEvent/VisualBasic/Pane1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SelectionChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SelectionChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.Selector.SelectionChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SelectionChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SelectionChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SelectionChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Primitives.Selector.SelectionChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.Controls.Primitives.Selector.SelectionChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsSelected">
      <MemberSignature Language="C#" Value="public static void SetIsSelected (System.Windows.DependencyObject element, bool isSelected);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIsSelected(class System.Windows.DependencyObject element, bool isSelected) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.Selector.SetIsSelected(System.Windows.DependencyObject,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIsSelected (element As DependencyObject, isSelected As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIsSelected(System::Windows::DependencyObject ^ element, bool isSelected);" />
      <MemberSignature Language="F#" Value="static member SetIsSelected : System.Windows.DependencyObject * bool -&gt; unit" Usage="System.Windows.Controls.Primitives.Selector.SetIsSelected (element, isSelected)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="isSelected" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element">Объект, свойство которого следует установить.</param>
        <param name="isSelected">Задаваемое значение.</param>
        <summary>Задает значение свойства, указывающее, выделен ли элемент в <see cref="T:System.Windows.Controls.Primitives.Selector" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unselected">
      <MemberSignature Language="C#" Value="see AddUnselectedHandler, and RemoveUnselectedHandler" />
      <MemberSignature Language="ILAsm" Value="see AddUnselectedHandler, and RemoveUnselectedHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.Selector.Unselected" />
      <MemberSignature Language="VB.NET" Value="see AddUnselectedHandler, and RemoveUnselectedHandler" />
      <MemberSignature Language="F#" Value="see AddUnselectedHandler, and RemoveUnselectedHandler" Usage="see AddUnselectedHandler, and RemoveUnselectedHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возникает при снятии выделения элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_Unselected"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.Primitives.Selector.UnselectedEvent>|  
|Стратегия маршрутизации|Восходящей маршрутизации|  
|делегат|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 В следующих примерах показано, как использовать <xref:System.Windows.Controls.Primitives.Selector.Unselected> событие <xref:System.Windows.Controls.ListBox> с элементом управления и как создать обработчик событий.  
  
 [!code-xml[ListBoxItems_snip#SelectorEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxItems_snip/CSharp/Window1.xaml#selectorevents)]  
  
 [!code-csharp[ListBoxItems_snip#SelectorUnselected](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxItems_snip/CSharp/Window1.xaml.cs#selectorunselected)]
 [!code-vb[ListBoxItems_snip#SelectorUnselected](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxItems_snip/visualbasic/window1.xaml.vb#selectorunselected)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnselectedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnselectedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnselectedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.Selector.UnselectedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnselectedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnselectedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnselectedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Primitives.Selector.UnselectedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.Controls.Primitives.Selector.Unselected" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
