<Type Name="ServiceBehaviorAttribute" FullName="System.ServiceModel.ServiceBehaviorAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1b89a648a4ad568eab392ff9b9e8c24917e01881" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70612736" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceBehaviorAttribute : Attribute, System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceBehaviorAttribute extends System.Attribute implements class System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceBehaviorAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceBehaviorAttribute&#xA;Inherits Attribute&#xA;Implements IServiceBehavior" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBehaviorAttribute sealed : Attribute, System::ServiceModel::Description::IServiceBehavior" />
  <TypeSignature Language="F#" Value="type ServiceBehaviorAttribute = class&#xA;    inherit Attribute&#xA;    interface IServiceBehavior" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IServiceBehavior</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Задает поведение внутреннего выполнения реализации контракта службы.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Примените атрибут <xref:System.ServiceModel.ServiceBehaviorAttribute> к реализации службы, чтобы задать поведение выполнения в масштабе всей службы. (Чтобы задать поведение выполнения на уровне метода, используйте <xref:System.ServiceModel.OperationBehaviorAttribute> атрибут.) Этот атрибут может применяться только к реализациям служб. Рабочие примеры см. в разделе " [служба: примеры поведения](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90))".  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute>свойства — это функция модели программирования Windows Communication Foundation (WCF), которая обеспечивает общие функции, которые разработчикам в противном случае необходимо реализовать. Дополнительные сведения об этих и других поведении см. в разделе [Определение поведения службы во время выполнения](~/docs/framework/wcf/specifying-service-run-time-behavior.md). Дополнительные сведения о базовых свойствах среды выполнения, заданных для некоторых из следующих свойств, см. [в разделе Расширение ServiceHost и уровня модели службы](~/docs/framework/wcf/extending/extending-servicehost-and-the-service-model-layer.md).  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> задает тип фильтра, который использует система диспетчера для определения расположения конечной точки, обрабатывающей запросы.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> автоматически завершает сеанс после закрытия канала и завершения обработки остающихся сообщений службой.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> контролирует внутреннюю модель потоков, обеспечивая поддержку служб с повторными входящими вызовами или многопоточных служб.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> используется для объявления имени, используемого в атрибуте `name` элемента `<service>` в файле конфигурации.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> позволяет среде выполнения игнорировать дополнительную информацию о сериализации, которая не требуется для обработки сообщения.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> определяет, возвращаются ли необработанные исключения в службе в качестве ошибок SOAP. Это предназначено только для отладки.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> задает, будут ли и, если будут, когда службы и объекты служб удаляться во время обмена с клиентом.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> ограничивает число сериализуемых элементов в графе объекта.  
  
-   Свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> и <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> контролируют имя и пространство имен для выражения WSDL элемента службы.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> определяет, удаляется ли объект службы по завершении транзакции.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> определяет, завершаются ли ожидающие обработки транзакции при завершении сеанса.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> задает уровень изоляции транзакций, поддерживаемый контрактом.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> задает период времени, в течение которого транзакция должна быть завершена или прервана.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> определяет, следует ли автоматически синхронизировать входящие вызовы метода с потоком пользовательского интерфейса.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> сообщает системе, должна ли она подтверждать, что заголовки SOAP, отмеченные как `MustUnderstand`, фактически были поняты.  
  
 Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> также можно задать с помощью файла конфигурации приложения. Дополнительные сведения см. в разделе <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A>.  
  
   
  
## Examples  
 В следующем примере кода показаны свойства <xref:System.ServiceModel.ServiceBehaviorAttribute>. Класс `BehaviorService` использует атрибут <xref:System.ServiceModel.ServiceBehaviorAttribute>, чтобы указать следующее.  
  
-   Объект службы удаляется по завершении транзакции.  
  
-   Для каждого сеанса существует один объект службы.  
  
-   Служба является однопоточной и не поддерживает повторные входящие вызовы.  
  
 Более того, на уровне операций значения <xref:System.ServiceModel.OperationBehaviorAttribute> указывают, что метод `TxWork` автоматически выполняет зачисление в поток транзакций или создает для этого новую транзакцию; транзакция выполняется автоматически, если не выдается необработанное исключение.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Чтобы следующий пример кода выполнялся правильно, базовая привязка должна поддерживать поток транзакций. Для поддержки потока транзакций с использованием <xref:System.ServiceModel.WSHttpBinding> можно, например, задать для свойства <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> значение `true` в коде или в файле конфигурации приложения. В следующем примере кода показан файл конфигурации для предыдущего примера.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationBehaviorAttribute" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)">Служба: пример поведения</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBehaviorAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBehaviorAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.ServiceBehaviorAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для атрибута <xref:System.ServiceModel.ServiceBehaviorAttribute> по умолчанию заданы следующие значения.  
  
-   Для <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> задано значение <xref:System.ServiceModel.AddressFilterMode.Exact>.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> — `true`.  
  
-   Для <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> задано значение <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> является полным именем пространства имен типа без информации о сборке.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> — `false`.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> равно 64 КБ.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> является именем типа службы без информации о пространстве имен или сборке.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> — `"http://tempuri.org"`.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> — `true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> — `false`.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> имеет значение `true`.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> — `false`.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> — <xref:System.Transactions.IsolationLevel.Unspecified>.  
  
-   Свойству <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> задано значение <xref:System.TimeSpan.Zero>.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> — `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressFilterMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AddressFilterMode AddressFilterMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AddressFilterMode AddressFilterMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AddressFilterMode As AddressFilterMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AddressFilterMode AddressFilterMode { System::ServiceModel::AddressFilterMode get(); void set(System::ServiceModel::AddressFilterMode value); };" />
      <MemberSignature Language="F#" Value="member this.AddressFilterMode : System.ServiceModel.AddressFilterMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AddressFilterMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает <see cref="T:System.ServiceModel.AddressFilterMode" />, используемый диспетчером для маршрутизации входящих сообщений на правильную конечную точку.</summary>
        <value>Объект <see cref="T:System.ServiceModel.AddressFilterMode" />, используемый диспетчером для маршрутизации входящих сообщений на правильную конечную точку.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Данное значение не является одним из значений <see cref="T:System.ServiceModel.AddressFilterMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutomaticSessionShutdown">
      <MemberSignature Language="C#" Value="public bool AutomaticSessionShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticSessionShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticSessionShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutomaticSessionShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticSessionShutdown : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, следует ли автоматически завершать сеанс, когда клиент закрывает выходной сеанс.</summary>
        <value>Значение <see langword="true" />, если служба автоматически завершает сеанс при закрытии клиентом выходящего сеанса; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию, когда клиент закрывает выходящий сеанс, а служба закончила обработку всех оставшихся сообщений, сервер завершает сеанс. Присвоение свойству <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> значения `false` предотвращает автоматическое завершение сеанса сервером и разрешает пользовательское управление временем существования сеанса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcurrencyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ConcurrencyMode ConcurrencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ConcurrencyMode ConcurrencyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ConcurrencyMode As ConcurrencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ConcurrencyMode ConcurrencyMode { System::ServiceModel::ConcurrencyMode get(); void set(System::ServiceModel::ConcurrencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.ConcurrencyMode : System.ServiceModel.ConcurrencyMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает поддержку службой одного потока, нескольких потоков или повторных входящих вызовов.</summary>
        <value>Одно из значений <see cref="T:System.ServiceModel.ConcurrencyMode" />; значение по умолчанию — <see cref="F:System.ServiceModel.ConcurrencyMode.Single" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство указывает, может ли экземпляр службы обрабатывать один поток или несколько потоков, выполняемых одновременно, и поддерживаются ли повторные входящие вызовы в однопоточном режиме.  
  
> [!NOTE]
>  Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> взаимодействует с некоторыми другими параметрами. Например, если значение <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> задано как <xref:System.ServiceModel.InstanceContextMode.Single>, служба сможет обрабатывать в конкретный момент времени только одно сообщение, пока значение <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> также не будет задано как <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Это свойство также задает поведение в сочетании со свойством <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType>. Дополнительные сведения см. в разделе [сеансы, создание экземпляров и параллелизм](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Установка для параметра <xref:System.ServiceModel.ConcurrencyMode> значения <xref:System.ServiceModel.ConcurrencyMode.Single> приводит к тому, что система не дает экземплярам службы одновременно выполнять более одного потока, что позволяет избежать решения вопросов многопоточности. Значение <xref:System.ServiceModel.ConcurrencyMode.Multiple> означает, что объекты службы могут выполняться несколькими потоками одновременно. В этом случае необходимо обеспечить безопасность потоков.  
  
 <xref:System.ServiceModel.ConcurrencyMode.Reentrant>также разрешает доступ только к одному потоку за раз; во время обработки операции никакое другое сообщение не может войти в операцию. Если во время операции вызов другой службы исчезает, текущее сообщение теряет блокировку операции, которая может обрабатывать другие сообщения. Когда вызов службы возвращается, блокировка восстанавливается и исходное сообщение продолжает обрабатываться до завершения или до возникновения другого вызова операции.  
  
> [!IMPORTANT]
>  Несмотря на то, что экземпляры службы ограничиваются только одним потоком выполнения за раз, необходимо также установить значение <xref:System.ServiceModel.Description.ServiceThrottlingBehavior.MaxConcurrentCalls%2A> 1, чтобы гарантировать отсутствие неупорядоченных сообщений. <xref:System.ServiceModel.ConcurrencyMode.Single>  
>   
>  Кроме того, вы несете ответственность за сохранение состояния объекта до выноски, поэтому необходимо подтвердить, что локальные данные операции являются допустимыми после выноски. Обратите внимание, что экземпляр службы разблокируется только путем вызова другой службы по каналу WCF. В этом случае вызванная служба может повторно войти в первую службу через обратный вызов. Если первая служба не допускает повторные входящие вызовы, последовательность вызовов приводит к взаимоблокировке. Дополнительные сведения см. в разделе <xref:System.ServiceModel.ConcurrencyMode>.  
  
 Во время любого исходящего вызова из обрабатывающей операции нелокальные в отношении операции данные могут быть изменены. (Данные локального состояния гарантированно действительны, когда исходное сообщение возобновляет обработку.) В результате перед исходящим вызовом необходимо убедиться, что нелокальные данные допустимы для других входящих вызовов, и повторно проверить нелокальные данные после возврата исходящего вызова.  
  
 В следующем псевдокоде показан необходимый шаблон для успешной поддержки повторных входящих вызовов.  
  
```csharp  
public void MyMethod()  
{  
  this.SomeNonLocalDataState;  
  // Here you need to clean nonlocal state for other users  
  OutboundProxy proxy = new OutboundProxy();  
  int returnValue = proxy.CallOutOfOperation();  
  // Ensure that this.SomeNonLocalDataState is valid for continued use.  
  this.ModifyNonLocalState;  
  return returnValue;  
}  
  
```  
  
 С помощью шаблона асинхронных вызовов Begin/End для исходящего вызова, когда <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> является <xref:System.ServiceModel.ConcurrencyMode.Reentrant>, выдается исключение. Для асинхронных исходящих вызовов требуется операция, при которой <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> является <xref:System.ServiceModel.ConcurrencyMode.Multiple>, и в этом случае следует обработать проблемы синхронизации.  
  
 Обычно в случае прибытия сообщения для экземпляра, нарушающего режим параллелизма, сообщение ожидает доступности экземпляра или истечения срока своего действия.  
  
 Кроме того, если для параметра <xref:System.ServiceModel.ConcurrencyMode> задано значение <xref:System.ServiceModel.ConcurrencyMode.Single> и если повторный входящий вызов блокируется во время ожидания освобождения экземпляра, система обнаруживает взаимоблокировку и выдает исключение.  
  
> [!NOTE]
>  Во время выполнения выдается <xref:System.InvalidOperationException>, если <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> является `true`, когда свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> задано как <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
 Обратите внимание, что необходимо явно задать <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> `false`, если имеется операция с <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType>, заданным как true, и задается <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> как <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. В противном случае будет выдано исключение проверки, поскольку значение по умолчанию <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> — `true`.  
  
 Существует взаимодействие <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> и других свойств, которые могут изменить поведение среды выполнения. Полное описание этих взаимодействий см. в разделе [сеансы, создание экземпляров и параллелизм](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
   
  
## Examples  
 В следующем примере кода показано различие между использованием значений <xref:System.ServiceModel.ConcurrencyMode.Single>, <xref:System.ServiceModel.ConcurrencyMode.Reentrant> и <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Этот пример не компилируется без реальной реализации, но демонстрирует тип гарантии того, что Windows Communication Foundation (WCF) делает и что означает код операции.  
  
 [!code-csharp[C_BestPractices-Concurrency#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_bestpractices-concurrency/cs/reentrantandmultiple.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Данное значение не является одним из значений <see cref="T:System.ServiceModel.ConcurrencyMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, используемое для поиска элемента службы в файле конфигурации приложения.</summary>
        <value>Значение, которое требуется найти в файле конфигурации. Значением по умолчанию является полное имя типа без информации о сборке.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте это значение, чтобы задать определенную службу в файле конфигурации.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение — null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значением является пустая строка.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, обеспечивается ли отправка с упорядочением службой.</summary>
        <value>Значение <see langword="true" />, если обеспечивается отправка с упорядочением службой; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public object GetWellKnownSingleton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetWellKnownSingleton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.GetWellKnownSingleton" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWellKnownSingleton () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetWellKnownSingleton();" />
      <MemberSignature Language="F#" Value="member this.GetWellKnownSingleton : unit -&gt; obj" Usage="serviceBehaviorAttribute.GetWellKnownSingleton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает объект, реализующий службу и используемый в качестве одноэлементного экземпляра службы, или выводит <see langword="null" />, если одноэлементный экземпляр отсутствует.</summary>
        <returns>Реализация службы. Значение по умолчанию — <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, отличное от `null`, предоставляет экземпляр службы, в который отправляются все сообщения, адресованные службе.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExtensionDataObject">
      <MemberSignature Language="C#" Value="public bool IgnoreExtensionDataObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreExtensionDataObject" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreExtensionDataObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreExtensionDataObject { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreExtensionDataObject : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, требуется ли передавать по линии связи неизвестные данные сериализации.</summary>
        <value><see langword="true" />, если неизвестные данные сериализации никогда не передаются; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если тип реализует <xref:System.Runtime.Serialization.IExtensibleDataObject> интерфейс, он сохраняет все дополнительные данные, о которых он не знает, при десериализации в этот тип. Например, если тип `Person` имеет члены `FirstName` и `LastName` и для него поступает элемент `PhoneNumber`, этот элемент сохраняется. При последующей сериализации типа объект `PhoneNumber` создается заново. Проблема заключается в том, что схема `Person` , экспортируемая этой службой, `FirstName` имеет `LastName`только и, поэтому Windows Communication Foundation (WCF) создает недопустимый экземпляр. Если важно строгое соответствие схеме, можно установить для параметра <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> значение `true`, чтобы отключить повторное создание поведения.  
  
 Независимо от <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> параметра, WCF всегда обрабатывает известные данные (как в, так и за ее пределами) и не создает исключения при подаче дополнительных данных. Это свойство также можно задать с помощью [ &lt;элемента dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) в файле конфигурации приложения.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> и реализация <xref:System.Runtime.Serialization.IExtensibleDataObject>. В этом примере, где для <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> задано `false`, известные клиенту дополнительные данные передаются клиенту и обратно.  
  
 [!code-csharp[DCAContainerNoValidation#1](~/samples/snippets/csharp/VS_Snippets_CFX/dcacontainernovalidation/cs/services.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeExceptionDetailInFaults">
      <MemberSignature Language="C#" Value="public bool IncludeExceptionDetailInFaults { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeExceptionDetailInFaults" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeExceptionDetailInFaults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeExceptionDetailInFaults { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeExceptionDetailInFaults : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, что общие необработанные исключения выполнения должны преобразовываться в исключения <see cref="T:System.ServiceModel.FaultException`1" /> типа <see cref="T:System.ServiceModel.ExceptionDetail" /> и передаваться в виде сообщения об ошибке. Задавайте значение <see langword="true" /> только во время разработки для устранения неполадок службы.</summary>
        <value><see langword="true" />, если необработанное исключение должно возвращаться в виде ошибок SOAP; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы разрешить отправку информации об исключениях клиентам для целей отладки, для свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> следует задать значение `true`. Для этого свойства требуется привязка, поддерживающая либо обмен сообщениями типа «запрос-ответ», либо дуплексный обмен.  
  
 Во всех управляемых приложениях обработка ошибок представлена объектами <xref:System.Exception>. В приложениях на основе SOAP, таких как приложения WCF, методы, реализующие операции службы, обмениваются сведениями об ошибках с помощью сообщений о сбоях SOAP. Поскольку приложения WCF выполняются в обоих типах систем ошибок, все управляемые сведения об исключениях, которые необходимо отправить клиенту, должны быть преобразованы из исключений в ошибки SOAP. Дополнительные сведения см. [в разделе Указание и обработка ошибок в контрактах и службах](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).  
  
 Во время разработки может понадобиться, чтобы служба также отправляла клиенту другие исключения для упрощения отладки. Эта возможность предназначается только для этапа разработки, ее не следует использовать в рабочих версиях служб.  
  
 Чтобы упростить процесс отладки, присвойте <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> параметру `true` значение либо в коде, либо с помощью файла конфигурации приложения.  
  
 Когда эта функция включена, служба автоматически возвращает вызывающему объекту информацию о более безопасных исключениях. Эти ошибки выглядят для клиента как объекты <xref:System.ServiceModel.FaultException%601> типа <xref:System.ServiceModel.ExceptionDetail>.  
  
> [!IMPORTANT]
>  Параметр <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> , `true`  позволяющий клиентам получать сведения об исключениях методов внутренних служб; рекомендуется только в целях временной отладки приложения службы. Кроме того, WSDL для метода, который возвращает такие необработанные управляемые исключения, не содержит контракт для исключения <xref:System.ServiceModel.FaultException%601> типа <xref:System.ServiceModel.ExceptionDetail>. В клиентах должна быть предусмотрена возможность принятия неизвестной ошибки SOAP для правильного получения отладочной информации.  
  
 Установка этого свойства в `true` также может быть выполнена с помощью файла конфигурации приложения [ &lt;и элемента serviceDebug&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicedebug.md) , как показано в следующем примере кода.  
  
 [!code-xml[OperationBehaviorAttribute1#10](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#10)]   
   
  
## Examples  
 В следующем примере кода показаны свойства <xref:System.ServiceModel.ServiceBehaviorAttribute>. Класс `BehaviorService` использует атрибут <xref:System.ServiceModel.ServiceBehaviorAttribute>, чтобы указать следующее.  
  
-   Для потока пользовательского интерфейса вызываются методы реализации.  
  
-   Для каждого сеанса существует один объект службы.  
  
-   Служба является однопоточной и не поддерживает повторные входящие вызовы.  
  
 Более того, на уровне операций значения <xref:System.ServiceModel.OperationBehaviorAttribute> указывают, что метод `TxWork` автоматически выполняет зачисление в поток транзакций или создает для этого новую транзакцию; транзакция выполняется автоматически, если не выдается необработанное исключение.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Чтобы следующий пример кода выполнялся правильно, базовая привязка должна поддерживать поток транзакций. Для поддержки потока транзакций с использованием <xref:System.ServiceModel.WSHttpBinding> можно, например, задать для свойства <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> значение `true` в коде или в файле конфигурации приложения. В следующем примере кода показан файл конфигурации для предыдущего примера.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContextMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContextMode InstanceContextMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.InstanceContextMode InstanceContextMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceContextMode As InstanceContextMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContextMode InstanceContextMode { System::ServiceModel::InstanceContextMode get(); void set(System::ServiceModel::InstanceContextMode value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContextMode : System.ServiceModel.InstanceContextMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContextMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, когда создаются новые объекты службы.</summary>
        <value>Одно из значений <see cref="T:System.ServiceModel.InstanceContextMode" />; значением по умолчанию является <see cref="F:System.ServiceModel.InstanceContextMode.PerSession" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.ServiceModel.InstanceContextMode>, чтобы указать, когда создаются новые объекты службы. Поскольку объект службы не подключен напрямую к каналу связи, время существования объектов службы не зависит от времени существования канала между клиентом и служебным приложением. Значение по умолчанию, <xref:System.ServiceModel.InstanceContextMode.PerSession>, направляет приложению службы инструкции создать новый объект службы, когда между клиентом и приложением службы устанавливается новый сеанс связи. Последующие вызовы в одном и том же сеансе обрабатываются тем же объектом.  
  
 <xref:System.ServiceModel.InstanceContextMode.PerSession> указывает, что каждый объект службы обрабатывает запросы из одного клиентского канала.  
  
> [!NOTE]
>  Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> взаимодействует с некоторыми другими параметрами. Например, если значение <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> задано как <xref:System.ServiceModel.InstanceContextMode.Single>, служба сможет обрабатывать в конкретный момент времени только одно сообщение, пока значение <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> также не будет задано как <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Это свойство также задает поведение в сочетании со свойством <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType>. Дополнительные сведения см. в разделе [сеансы, создание экземпляров и параллелизм](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Для поведения времени существования одного элемента (например, если ведущее приложение вызывает конструктор <xref:System.ServiceModel.ServiceHost.%23ctor%2A> и передает объект для использования в качестве службы), класс службы должен задавать <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> как `Single`, в противном случае во время выполнения выдается исключение.  
  
   
  
## Examples  
 В следующем примере кода показаны свойства <xref:System.ServiceModel.ServiceBehaviorAttribute>. Класс `BehaviorService` использует атрибут <xref:System.ServiceModel.ServiceBehaviorAttribute>, чтобы указать следующее.  
  
-   Для потока пользовательского интерфейса вызываются методы реализации.  
  
-   Для каждого сеанса существует один объект службы.  
  
-   Служба является однопоточной и не поддерживает повторные входящие вызовы.  
  
 Более того, на уровне операций значения <xref:System.ServiceModel.OperationBehaviorAttribute> указывают, что метод `TxWork` автоматически выполняет зачисление в поток транзакций или создает для этого новую транзакцию; транзакция выполняется автоматически, если не выдается необработанное исключение.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Чтобы следующий пример кода выполнялся правильно, базовая привязка должна поддерживать поток транзакций. Для поддержки потока транзакций с использованием <xref:System.ServiceModel.WSHttpBinding> можно, например, задать для свойства <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> значение `true` в коде или в файле конфигурации приложения. В следующем примере кода показан файл конфигурации для предыдущего примера.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Данное значение не является одним из значений <see cref="T:System.ServiceModel.InstanceContextMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxItemsInObjectGraph">
      <MemberSignature Language="C#" Value="public int MaxItemsInObjectGraph { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxItemsInObjectGraph" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxItemsInObjectGraph As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxItemsInObjectGraph { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxItemsInObjectGraph : int with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество элементов, допустимое в сериализованном объекте.</summary>
        <value>Максимальное количество элементов, разрешенное в объекте. Значение по умолчанию — 65 536 байт (64 КБ).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> используется для задания ограничения количества сериализуемых элементов в графе объекта. Это свойство также можно задать с помощью [ &lt;элемента dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) в файле конфигурации приложения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение атрибута имени в элементе службы в языке WSDL.</summary>
        <value>Значение атрибута имени в элементе <see langword="&lt;wsdl:service&gt;" /> при экспорте.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение целевого пространства имен для службы в языке WSDL.</summary>
        <value>Значение атрибута <see langword="targetNamespace" /> для элемента <see langword="&lt;wsdl:definitions&gt;" />, содержащего элемент <see langword="&lt;wsdl:service&gt;" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ReleaseServiceInstanceOnTransactionComplete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Property ReleaseServiceInstanceOnTransactionComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReleaseServiceInstanceOnTransactionComplete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReleaseServiceInstanceOnTransactionComplete : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли объект службы выпускаться после успешного выполнения текущей транзакции.</summary>
        <value>Значение <see langword="true" />, если объект службы должен выпускаться; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что необходимо явно задать <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> `false`, если имеется операция с <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType>, заданным как true, и задается <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> как <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. В противном случае будет выдано исключение проверки, поскольку значение по умолчанию <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> — `true`.  
  
 Кроме того, важно понимать, что если служба создается путем передачи объекта службы в конструктор <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType>, значение этого свойства считается `false`.  
  
   
  
## Examples  
 В следующем примере кода уровень изоляции транзакции задается как <xref:System.Transactions.IsolationLevel.ReadCommitted>, отключается поддержка параллельных транзакций, требуется потоковая транзакция из вызова операции и автоматически фиксируется транзакция в службе в случае отсутствия необработанных исключений.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 Чтобы следующий пример кода выполнялся правильно, базовая привязка должна поддерживать поток транзакций. Для поддержки потока транзакций с использованием <xref:System.ServiceModel.WSHttpBinding> можно, например, задать для свойства <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> значение `true` в коде или в файле конфигурации приложения. В следующем примере кода показан файл конфигурации для предыдущего примера.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public void SetWellKnownSingleton (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetWellKnownSingleton(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetWellKnownSingleton (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetWellKnownSingleton(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetWellKnownSingleton : obj -&gt; unit" Usage="serviceBehaviorAttribute.SetWellKnownSingleton value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Одноэлементный экземпляр службы.</param>
        <summary>Задает объект, реализующий службу и используемый в качестве одноэлементного экземпляра службы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это обеспечивает экземпляр службы, в который отправляются все сообщения, адресованные службе.  
  
 Если для <xref:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton%2A> задано значение, отличное от `null`, <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> должен быть задан как <xref:System.ServiceModel.InstanceContextMode.Single>, в противном случае будет выдано исключение <xref:System.InvalidOperationException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeConfigurationName">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeConfigurationName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeConfigurationName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeConfigurationName () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeConfigurationName();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeConfigurationName : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeConfigurationName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, изменилось ли значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> относительно значения по умолчанию и нужно ли его сериализовать.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReleaseServiceInstanceOnTransactionComplete () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReleaseServiceInstanceOnTransactionComplete : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, изменилось ли значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> относительно значения по умолчанию и нужно ли его сериализовать.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionAutoCompleteOnSessionClose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionAutoCompleteOnSessionClose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionAutoCompleteOnSessionClose () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionAutoCompleteOnSessionClose();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionAutoCompleteOnSessionClose : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, изменилось ли значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> относительно значения по умолчанию и нужно ли его сериализовать.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionIsolationLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionIsolationLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionIsolationLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionIsolationLevel();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionIsolationLevel : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, изменилось ли значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> относительно значения по умолчанию и нужно ли его сериализовать.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionTimeout">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionTimeout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionTimeout () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionTimeout();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionTimeout : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionTimeout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, изменилось ли значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> относительно значения по умолчанию и нужно ли его сериализовать.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.AddBindingParameters">
      <MemberSignature Language="C#" Value="void IServiceBehavior.AddBindingParameters (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase, System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase, class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase, System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^ endpoints, System::ServiceModel::Channels::BindingParameterCollection ^ parameters) = System::ServiceModel::Description::IServiceBehavior::AddBindingParameters;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
        <Parameter Name="endpoints" Type="System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <param name="description">Описание службы.</param>
        <param name="serviceHostBase">Узел службы.</param>
        <param name="endpoints">Конечные точки службы.</param>
        <param name="parameters">Объекты данных, необходимые для привязок для поддержки поведения.</param>
        <summary>Передает пользовательские объекты данных в привязки, поддерживающие свойства поведения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior">
      <MemberSignature Language="C#" Value="void IServiceBehavior.ApplyDispatchBehavior (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::ApplyDispatchBehavior;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Описание службы.</param>
        <param name="serviceHostBase">Узел службы.</param>
        <summary>Настраивает среду выполнения службы для поддержки свойств поведения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.Validate">
      <MemberSignature Language="C#" Value="void IServiceBehavior.Validate (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.Validate(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.Validate(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::Validate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Описание службы.</param>
        <param name="serviceHostBase">Узел службы.</param>
        <summary>Подтверждает, что описание службы и ее узел способны поддерживать поведение.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool TransactionAutoCompleteOnSessionClose { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionAutoCompleteOnSessionClose As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionAutoCompleteOnSessionClose { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionAutoCompleteOnSessionClose : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, завершаются ли автоматически ожидающие транзакции при завершении текущего сеанса без ошибок.</summary>
        <value>Значение <see langword="true" />, если ожидающие транзакции должны завершаться при закрытии текущего сеанса без ошибок; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public System.Transactions.IsolationLevel TransactionIsolationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Transactions.IsolationLevel TransactionIsolationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionIsolationLevel As IsolationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Transactions::IsolationLevel TransactionIsolationLevel { System::Transactions::IsolationLevel get(); void set(System::Transactions::IsolationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionIsolationLevel : System.Transactions.IsolationLevel with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Transactions.IsolationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает уровень изоляции транзакции для новых транзакций, созданных в службе, и входящих транзакций, передаваемых от клиента.</summary>
        <value>Значение <see cref="T:System.Transactions.IsolationLevel" />, задающее уровень изоляции транзакции. Значение по умолчанию — <see cref="F:System.Transactions.IsolationLevel.Unspecified" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Уровень изоляции, в котором выполняется транзакция, определяет способ обработки данных при внесении изменений в другие транзакции и длительность хранения блокировок в транзакции для защиты от этих изменений. Например, значение по умолчанию <xref:System.Transactions.IsolationLevel.Unspecified> определяет, что до завершения выполнения транзакции запрещены обновление и вставка.  
  
 Это свойство также можно использовать для ограничения уровня изоляции входящих транзакций, передаваемых от клиента.  
  
   
  
## Examples  
 В следующем примере кода уровень изоляции транзакции задается как <xref:System.Transactions.IsolationLevel.ReadCommitted>, не поддерживаются параллельные транзакции, требуется потоковая транзакция из вызова метода и автоматически фиксируется транзакция в случае отсутствия необработанных исключений.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 Чтобы следующий пример кода выполнялся правильно, базовая привязка должна поддерживать поток транзакций. Для поддержки потока транзакций с использованием <xref:System.ServiceModel.WSHttpBinding> можно, например, задать для свойства <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> значение `true` в коде или в файле конфигурации приложения. В следующем примере кода показан файл конфигурации для предыдущего примера.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Данное значение не является одним из значений <see cref="T:System.Transactions.IsolationLevel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionTimeout">
      <MemberSignature Language="C#" Value="public string TransactionTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionTimeout As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionTimeout { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionTimeout : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает период времени, в течение которого транзакция должна быть завершена.</summary>
        <value>Объект <see cref="T:System.TimeSpan" />, представляющий время, в течение которого транзакция должна быть завершена; по истечении этого времени транзакция будет прервана автоматически.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение задает свойство <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout%2A?displayProperty=nameWithType>. Это свойство также можно задать с помощью [ &lt;элемента сервицетимеаутс&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicetimeouts.md) в файле конфигурации приложения.  
  
   
  
## Examples  
 В следующем файле конфигурации задается период времени ожидания транзакции три минуты.  
  
 [!code-csharp[SBA.TransactionTimeout#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactiontimeout/cs/services.cs#2)]
 [!code-vb[SBA.TransactionTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactiontimeout/vb/services.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение — null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.TimeSpan.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSynchronizationContext">
      <MemberSignature Language="C#" Value="public bool UseSynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSynchronizationContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSynchronizationContext { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseSynchronizationContext : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, следует ли использовать текущий контекст синхронизации для выбора потока исполнения.</summary>
        <value><see langword="true" />, если все вызовы службы должны запускаться в потоке, указанном контекстом <see cref="T:System.Threading.SynchronizationContext" />; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется для обеспечения сходства потоков пользовательского интерфейса, требуемого некоторыми приложениями. Например, приложение Windows Forms можно зарегистрировать как одноэлементный объект службы. В этом случае все вызовы службы должны выполняться в потоке Windows Forms. В ситуации по умолчанию, в которой для <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> задано `true`, все вызовы службы синхронизируются для выполнения в потоке от <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMustUnderstand">
      <MemberSignature Language="C#" Value="public bool ValidateMustUnderstand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateMustUnderstand" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateMustUnderstand As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateMustUnderstand { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateMustUnderstand : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, кем выполняется принудительная обработка заголовка SOAP <see langword="MustUnderstand" />: системой или приложением.</summary>
        <value><see langword="true" />, если обработка заголовка SOAP <see langword="MustUnderstand" /> должна выполняться системой; в противном случае — <see langword="false" />, что означает, что эта обработка выполняется приложением. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A>, чтобы отключить принудительную проверку заголовков поступающих сообщений. При нормальном выполнении заголовки сообщений сравниваются со свойством <xref:System.ServiceModel.Channels.MessageHeaders.UnderstoodHeaders%2A> для подтверждения того, что поступающие заголовки явно обрабатываются службой. Чтобы отключить эту проверку, задайте значение `false`. Если установлено значение `false`, то приложение должно проверять заголовки с отметкой «MustUnderstand="true"» и возвращать ошибку, если один или несколько из них непонятны. Это полезно, если приложение должно принимать любые входящие сообщения SOAP (например, при использовании типизированных или нетипизированных сообщений) и выполнять пользовательскую обработку заголовков.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
