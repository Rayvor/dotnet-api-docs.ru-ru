<Type Name="InputBinding" FullName="System.Windows.Input.InputBinding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="697417fa3ee8b000496b692c1ccf139a3699c1bd" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75177046" /></Metadata><TypeSignature Language="C#" Value="public class InputBinding : System.Windows.Freezable, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InputBinding extends System.Windows.Freezable implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.InputBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class InputBinding&#xA;Inherits Freezable&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class InputBinding : System::Windows::Freezable, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type InputBinding = class&#xA;    inherit Freezable&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-3.0">System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет привязку между <see cref="T:System.Windows.Input.InputGesture" /> и командой. Этой командой потенциально является <see cref="T:System.Windows.Input.RoutedCommand" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете указать, что вводимые пользователем данные вызывают команду, создав <xref:System.Windows.Input.InputBinding>. Когда пользователь выполняет указанные входные данные, выполняется <xref:System.Windows.Input.ICommand>, для которого задано свойство <xref:System.Windows.Input.InputBinding.Command%2A>.  
  
 Можно указать, что <xref:System.Windows.Input.InputBinding> вызывает команду, определенную для объекта, создав привязку к свойствам <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>и <xref:System.Windows.Input.InputBinding.CommandTarget%2A>. Это позволяет определить пользовательскую команду и связать ее с введенными пользователем данными. Дополнительные сведения см. во втором примере в разделе "примеры".  
  
 <xref:System.Windows.Input.InputBinding> можно определить на определенном объекте или на уровне класса путем регистрации <xref:System.Windows.Input.CommandManager.RegisterClassInputBinding%2A> с <xref:System.Windows.Input.CommandManager>.  
  
 Сам класс <xref:System.Windows.Input.InputBinding> не поддерживает использование XAML, так как не предоставляет общедоступный конструктор без параметров (есть конструктор без параметров, но он защищен). Однако производные классы могут предоставлять открытый конструктор, поэтому могут устанавливать свойства производного класса, наследуемые от <xref:System.Windows.Input.InputBinding> с использованием XAML. Два существующих класса, производных от <xref:System.Windows.Input.InputBinding>, которые можно создать в XAML и могут задавать свойства в XAML, — <xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding>. Типичное свойство в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] программировании, которое задается в XAML, и принимает один или несколько <xref:System.Windows.Input.InputBinding> объектов в качестве значений свойства <xref:System.Windows.UIElement.InputBindings%2A?displayProperty=nameWithType>.  
  
<a name="xamlObjectElementUsage_InputBinding"></a>   
## <a name="xaml-object-element-usage"></a>Использование элемента объекта XAML  
 \<*инпутбиндингдериведкласс.../*>  
  
<a name="xamlValues_InputBinding"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `inputBindingDerivedClass`  
 Производный класс <xref:System.Windows.Input.InputBinding>, поддерживающий синтаксис элемента объекта, например <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding>. См. заметки.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Windows.Input.KeyBinding> для привязки <xref:System.Windows.Input.KeyGesture> к команде <xref:System.Windows.Input.ApplicationCommands.Open%2A>. При выполнении жеста клавиши вызывается команда Open.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 В следующих примерах показано, как привязать пользовательскую команду к <xref:System.Windows.Input.InputBinding> объектам. В этих примерах создается приложение, позволяющее пользователю изменить цвет фона, выполнив одно из следующих действий:  
  
-   Нажатие кнопки.  
  
-   Нажав клавиши CTRL + C.  
  
-   Щелчок правой кнопкой мыши <xref:System.Windows.Controls.StackPanel> (за пределами <xref:System.Windows.Controls.ListBox>).  
  
 В первом примере создается класс с именем `SimpleDelegateCommand`. Этот класс принимает делегат, чтобы объект, создающий команду, мог определить действие, выполняемое при выполнении команды. `SimpleDelegateCommand` также определяет свойства, указывающие, какой ввод ключа и мыши вызывает команду. `GestureKey` и `GestureModifier` указать ввод с клавиатуры; `MouseGesture` задает ввод с помощью мыши.  
  
 [!code-csharp[InputCommandBinding#DelegateCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#delegatecommand)]
 [!code-vb[InputCommandBinding#DelegateCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#delegatecommand)]  
  
 В следующем примере создается и инициализируется `ColorChangeCommand`, который является `SimpleDelegateCommand`. В примере также определяется метод, выполняемый при вызове команды, и устанавливаются свойства `GestureKey`, `GestureModifier`и `MouseGesture`. Приложение вызовет метод `InitializeCommand` при запуске программы, например в конструкторе <xref:System.Windows.Window>.  
  
 [!code-csharp[InputCommandBinding#InitializeCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#initializecommand)]
 [!code-vb[InputCommandBinding#InitializeCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#initializecommand)]  
  
 Наконец, в следующем примере создается пользовательский интерфейс. В примере добавляется <xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding> в <xref:System.Windows.Controls.StackPanel>, содержащий <xref:System.Windows.Controls.Button> и <xref:System.Windows.Controls.ListBox>. Когда пользователь выбирает элемент в <xref:System.Windows.Controls.ListBox>, он может изменить цвет фона на выбранный цвет. В каждом случае свойство `CommandParameter` привязано к выбранному элементу в <xref:System.Windows.Controls.ListBox>, а свойство `Command` привязано к `ColorChangeCommand`. Свойства <xref:System.Windows.Input.KeyBinding.Key%2A?displayProperty=nameWithType>, <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>и <xref:System.Windows.Input.MouseBinding.MouseAction%2A?displayProperty=nameWithType> привязаны к соответствующим свойствам класса `SimpleDelegateCommand`.  
  
 [!code-xaml[InputCommandBinding#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.UIElement.InputBindings" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Input.InputBinding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InputBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InputBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Предоставляет базовую инициализацию для производных от <see cref="T:System.Windows.Input.InputBinding" /> классов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding> не технически является абстрактным классом, но конструктор без параметров является намеренно защищенным доступом. Это влияет на <xref:System.Windows.Input.InputBinding> "абстрактный" класс для XAML. В [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] существуют свойства, которые используют XAML, которые предполагают объекты типа <xref:System.Windows.Input.InputBinding>, но нельзя указать экземпляр <xref:System.Windows.Input.InputBinding> в XAML. Вместо этого можно указать один из конкретного устройства <xref:System.Windows.Input.InputBinding> производных классов как значения, например <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При реализации пользовательского <see cref="T:System.Windows.Input.InputBinding" />, поддерживающего использование XAML, используйте этот конструктор для базовой инициализации.</para></block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InputBinding (System.Windows.Input.ICommand command, System.Windows.Input.InputGesture gesture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Input.ICommand command, class System.Windows.Input.InputGesture gesture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor(System.Windows.Input.ICommand,System.Windows.Input.InputGesture)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (command As ICommand, gesture As InputGesture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InputBinding(System::Windows::Input::ICommand ^ command, System::Windows::Input::InputGesture ^ gesture);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.InputBinding : System.Windows.Input.ICommand * System.Windows.Input.InputGesture -&gt; System.Windows.Input.InputBinding" Usage="new System.Windows.Input.InputBinding (command, gesture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="command" Type="System.Windows.Input.ICommand" />
        <Parameter Name="gesture" Type="System.Windows.Input.InputGesture" />
      </Parameters>
      <Docs>
        <param name="command">Команда, связываемая с <paramref name="gesture" />.</param>
        <param name="gesture">Жест ввода, который необходимо связать с <paramref name="command" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Input.InputBinding" /> с указанным именем команды и жестом ввода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если разработчик программного обеспечения использует существующие классы привязки входных данных, этот конструктор обычно не будет использоваться даже при определении пользовательских команд. Вместо этого вы будете использовать конструкторы производных классов (<xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding>) или этот конструктор будет использоваться как базовый экземпляр пользовательского класса. Хотя класс <xref:System.Windows.Input.InputBinding> поддерживает различные устройства ввода в принципе, на практике необходимо выбрать устройство, которое будет представлять входная привязка. Для входной привязки можно задать только одно <xref:System.Windows.Input.InputBinding.Gesture%2A> значение, а жесты зависят от конкретного устройства.  
  
   
  
## Examples  
 В следующем примере показано, как использовать этот конструктор для связывания <xref:System.Windows.Input.KeyGesture> с <xref:System.Windows.Input.RoutedCommand>.  
  
 [!code-csharp[commandlibrarysnippets#InputBindingAddingCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#inputbindingaddingcommand)]
 [!code-vb[commandlibrarysnippets#InputBindingAddingCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#inputbindingaddingcommand)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="command" /> или <paramref name="gesture" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект, используемый для клонирования.</param>
        <summary>Копирует базовые (не анимационные) значения свойств заданного объекта.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект, используемый для клонирования.</param>
        <summary>Копирует текущие значения свойств заданного объекта.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Input.InputBinding.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Windows.Input.ICommand" />, связанный с этой входной привязкой.</summary>
        <value>Связанная команда.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Windows.Input.InputBinding> не поддерживает использование XAML, так как не предоставляет общедоступный конструктор без параметров (он имеет конструктор без параметров, но он защищен). Однако производные классы могут предоставлять открытый конструктор, поэтому могут использовать свойства, унаследованные от <xref:System.Windows.Input.InputBinding>. Два существующих <xref:System.Windows.Input.InputBinding> производных классов, которые можно создать с помощью XAML и могут задавать свойства с использованием XAML, — <xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding>.  
  
 <xref:System.Windows.Input.ICommand> ссылается на преобразователь типов, который позволяет использовать определенные существовавшие <xref:System.Windows.Input.ICommand> реализации для указания значений в виде строки. Это поведение преобразования типа задает форму значения атрибута для этого свойства. Можно также привязать свойства <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>и <xref:System.Windows.Input.InputBinding.CommandTarget%2A> к <xref:System.Windows.Input.ICommand>, определенному для объекта. Это позволяет определить пользовательскую команду и связать ее с введенными пользователем данными. Дополнительные сведения см. во втором примере в <xref:System.Windows.Input.InputBinding>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <`inputBindingDerivedClass` `Command`= "<xref:System.Windows.Input.ICommand>"/>  
  
<a name="xamlPropertyElementUsage_Command"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Command>  
    <iCommandImplementation/>  
  </inputBindingDerivedClass.Command>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `inputBindingDerivedClass`  
 Производный класс <xref:System.Windows.Input.InputBinding>, поддерживающий синтаксис элемента объекта, например <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding>. См. заметки.  
  
 `iCommandImplementation`  
 Реализация объекта <xref:System.Windows.Input.ICommand>, которая поддерживает синтаксис элемента объекта (имеет открытый конструктор без параметров).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Windows.Input.KeyBinding> для привязки <xref:System.Windows.Input.KeyGesture> к команде <xref:System.Windows.Input.ApplicationCommands.Open%2A?displayProperty=nameWithType>. При выполнении жеста клавиши вызывается команда Open.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewkeybinding)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewkeybinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <see cref="P:System.Windows.Input.InputBinding.Command" /> равно <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.InputGesture" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Input.InputBinding.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает специфические для команды данные для конкретной команды.</summary>
        <value>Связанные с командой данные. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Input.InputBinding.CommandParameter%2A> используется для передачи определенной информации команде при ее выполнении. Тип данных определяется командой. Многие команды не предполагают параметров команды; для этих команд переданные параметры команды будут игнорироваться.  
  
 Если команда, с которой связана входная привязка, является <xref:System.Windows.Input.RoutedCommand>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A> входной привязки передается обработчикам <xref:System.Windows.Input.RoutedCommand> через <xref:System.Windows.Input.ExecutedRoutedEventArgs> и данные <xref:System.Windows.Input.CanExecuteRoutedEventArgs> событий при обработке команды.  
  
 Тип данных и назначение параметра команды определяются по-разному для каждой команды и могут быть `null`. Свойства <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>и <xref:System.Windows.Input.InputBinding.CommandTarget%2A> можно привязать к <xref:System.Windows.Input.ICommand>, определенному для объекта. Это позволяет определить пользовательскую команду и связать ее с введенными пользователем данными. Дополнительные сведения см. во втором примере в <xref:System.Windows.Input.InputBinding>.  
  
 Класс <xref:System.Windows.Input.InputBinding> не поддерживает использование XAML, так как не предоставляет общедоступный конструктор без параметров (он имеет конструктор без параметров, но он защищен). Однако производные классы могут предоставлять открытый конструктор, поэтому могут устанавливать свойства, унаследованные от <xref:System.Windows.Input.InputBinding> с использованием XAML. Два существующих <xref:System.Windows.Input.InputBinding> производных классов, которые могут быть созданы в XAML и могут задавать свойства в XAML, <xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<inputBindingDerivedClass CommandParameter="commandParameterString"/>  
```  
  
<a name="xamlPropertyElementUsage_CommandParameter"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.CommandParameter>  
    <commandParameterObject/>  
  </inputBindingDerivedClass.CommandParameter>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `inputBindingDerivedClass`  
 Производный класс <xref:System.Windows.Input.InputBinding>, поддерживающий синтаксис элемента объекта, например <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding>. См. заметки.  
  
 `commandParameterString`  
 Строка, обрабатываемая определенной командой. Строки — это общий тип, используемый для параметров команды, так как их можно легко задать в XAML. Ожидаемый формат строки и его назначение см. в документации по определенной команде, с которой связана входная привязка. Многие команды не предполагают параметров.  
  
 `commandParameterObject`  
 Объект, обрабатываемый определенной командой. Все существующие команды [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] используют строки. Поэтому этот синтаксис элемента свойства относится только к сценариям пользовательской команды. Для поддержки этого синтаксиса объект `commandParameterObject` должен также поддерживать синтаксис элемента объекта (должен иметь открытый конструктор без параметров).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Input.InputBinding.CommandParameter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Input.InputBinding.Command" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Input.InputBinding.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает для команды целевой элемент.</summary>
        <value>Целевой объект команды. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В системе команд Windows Presentation Foundation свойство <xref:System.Windows.Input.InputBinding.CommandTarget%2A> объекта <xref:System.Windows.Input.ICommandSource> применяется, только если <xref:System.Windows.Input.ICommand> является <xref:System.Windows.Input.RoutedCommand>. Если для <xref:System.Windows.Input.ICommandSource> задано значение <xref:System.Windows.Input.InputBinding.CommandTarget%2A>, и соответствующая команда — не <xref:System.Windows.Input.RoutedCommand>, целевой объект команды не учитывается.  
  
 При использовании с <xref:System.Windows.Input.RoutedCommand>целевым объектом команды является объект, в котором вызываются события <xref:System.Windows.Input.CommandManager.Executed> и <xref:System.Windows.Input.CommandManager.CanExecute>. Если свойство <xref:System.Windows.Input.InputBinding.CommandTarget%2A> не задано, то в качестве целевого объекта используется элемент с фокусом клавиатуры.  
  
 Сам класс <xref:System.Windows.Input.InputBinding> не поддерживает использование XAML, так как не предоставляет общедоступный конструктор без параметров (есть конструктор без параметров, но он защищен). Однако производные классы могут предоставлять открытый конструктор, поэтому могут устанавливать свойства, унаследованные от <xref:System.Windows.Input.InputBinding> с использованием XAML. Два существующих <xref:System.Windows.Input.InputBinding> производных классов, которые могут быть созданы в XAML и могут задавать свойства в XAML, <xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandTarget"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<inputBindingDerivedClass CommandTarget="bindingToTarget"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `inputBindingDerivedClass`  
 Производный класс <xref:System.Windows.Input.InputBinding>, поддерживающий синтаксис элемента объекта, например <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding>. См. заметки.  
  
 `bindingToTarget`  
 Строка, использующая тип синтаксиса привязки, который может возвращать ссылку на объект в существующем именованном элементе. См. заметки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Input.InputBinding.CommandTarget" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="inputBinding.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает экземпляр класса <see cref="T:System.Windows.Input.InputBinding" />.</summary>
        <returns>Новый объект.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Gesture">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Input.InputGesture Gesture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputGesture Gesture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Gesture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Gesture As InputGesture" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Input::InputGesture ^ Gesture { System::Windows::Input::InputGesture ^ get(); void set(System::Windows::Input::InputGesture ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Gesture : System.Windows.Input.InputGesture with get, set" Usage="System.Windows.Input.InputBinding.Gesture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputGesture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Windows.Input.InputGesture" />, связанный с этой входной привязкой.</summary>
        <value>Связанный жест. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Жест ввода — это действие, вызывающее команду. Примерами входных жестов в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] являются <xref:System.Windows.Input.KeyGesture> и <xref:System.Windows.Input.MouseGesture>. <xref:System.Windows.Input.KeyGesture> — это сочетание <xref:System.Windows.Input.Key> и набора <xref:System.Windows.Input.ModifierKeys>. <xref:System.Windows.Input.MouseGesture> — это сочетание <xref:System.Windows.Input.MouseAction> и набора <xref:System.Windows.Input.ModifierKeys>.  
  
 Сам класс <xref:System.Windows.Input.InputBinding> не поддерживает использование XAML, так как не предоставляет общедоступный конструктор без параметров (есть конструктор без параметров, но он защищен). Однако производные классы могут предоставлять открытый конструктор и, таким же, могут устанавливать свойства, унаследованные от <xref:System.Windows.Input.InputBinding> с использованием XAML. Два существующих <xref:System.Windows.Input.InputBinding> производных классов, которые могут быть созданы в XAML и могут задавать свойства в XAML, <xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_gesture"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <<xref:System.Windows.Input.KeyBinding> `Gesture`= "<xref:System.Windows.Input.KeyGesture>"/>  
  
-или-
  
 <<xref:System.Windows.Input.MouseBinding> `Gesture`= "<xref:System.Windows.Input.MouseGesture>"/>  
  
-или-
  
 <`inputBindingDerivedClass` `Gesture`= "<xref:System.Windows.Input.InputGesture>"/>  
  
<a name="xamlPropertyElementUsage_gesture"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Gesture>  
    <inputGestureImplementation/>  
  </inputBindingDerivedClass.Gesture>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_gesture"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `inputBindingDerivedClass`  
 Производный класс <xref:System.Windows.Input.InputBinding>, поддерживающий синтаксис элемента объекта, например <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding>. См. заметки.  
  
 `inputGestureImplementation`  
 Пользовательский производный класс <xref:System.Windows.Input.InputGesture>, который поддерживает синтаксис элемента объекта.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Windows.Input.KeyBinding> для привязки <xref:System.Windows.Input.KeyGesture> к <xref:System.Windows.Input.RoutedCommand>. При нажатии <xref:System.Windows.Input.KeyGesture> ALT + L вызывается команда <xref:System.Windows.Input.ApplicationCommands.Close%2A>.  
  
 [!code-xaml[commandlibrarysnippets#KeyBindingWithKeyAndModifiersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml#keybindingwithkeyandmodifiersxaml)]  
  
 [!code-csharp[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#keybindingwithkeyandmodifiers)]
 [!code-vb[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#keybindingwithkeyandmodifiers)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyGesture" />
        <altmember cref="T:System.Windows.Input.MouseGesture" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект, используемый для клонирования.</param>
        <summary>Создает экземпляр замороженной копии заданного объекта <see cref="T:System.Windows.Freezable" />, используя базовые (не анимационные) значения свойства.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект, используемый для клонирования.</param>
        <summary>Создает текущий экземпляр замороженной копии указанного объекта <see cref="T:System.Windows.Freezable" />. Если объект имеет анимированные свойства зависимостей, копируются их текущие анимированные значения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
