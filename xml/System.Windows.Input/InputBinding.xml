<Type Name="InputBinding" FullName="System.Windows.Input.InputBinding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="37250b1651d5943ef4919b9ad6f4ea73ea95ee5d" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65004768" /></Metadata><TypeSignature Language="C#" Value="public class InputBinding : System.Windows.Freezable, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InputBinding extends System.Windows.Freezable implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.InputBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class InputBinding&#xA;Inherits Freezable&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class InputBinding : System::Windows::Freezable, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type InputBinding = class&#xA;    inherit Freezable&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-3.0">System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет привязку между <see cref="T:System.Windows.Input.InputGesture" /> и командой. Этой командой потенциально является <see cref="T:System.Windows.Input.RoutedCommand" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно указать, что ввод данных пользователем вызывает команду, создав <xref:System.Windows.Input.InputBinding>. Когда пользователь выполняет входного значения <xref:System.Windows.Input.ICommand> , имеет значение <xref:System.Windows.Input.InputBinding.Command%2A> свойства выполняется.  
  
 Можно указать, что <xref:System.Windows.Input.InputBinding> вызывает команду, которая определяется в объект путем создания привязки на <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, и <xref:System.Windows.Input.InputBinding.CommandTarget%2A> свойства. Это дает возможность определить пользовательскую команду и связать его с входными данными пользователя. Дополнительные сведения см. во втором примере в разделе «примеры».  
  
 <xref:System.Windows.Input.InputBinding> Можно определить на конкретный объект или на уровне класса, зарегистрировав <xref:System.Windows.Input.CommandManager.RegisterClassInputBinding%2A> с <xref:System.Windows.Input.CommandManager>.  
  
 <xref:System.Windows.Input.InputBinding> Сам класс не поддерживает использование XAML, так как он не предоставляет открытый конструктор по умолчанию (конструктор по умолчанию, но он защищен). Однако производные классы могут предоставлять открытый конструктор и таким образом можно задать свойства в производном классе, от которой наследуются, <xref:System.Windows.Input.InputBinding> с использованием XAML. Два существующих <xref:System.Windows.Input.InputBinding>-производные классы, которые может быть создано в XAML и свойства можно задать в XAML, <xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding>. Обычно свойство в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] программирования то есть задать в XAML и принимает один или несколько <xref:System.Windows.Input.InputBinding> объектов в качестве значения — <xref:System.Windows.UIElement.InputBindings%2A?displayProperty=nameWithType> свойство.  
  
<a name="xamlObjectElementUsage_InputBinding"></a>   
## <a name="xaml-object-element-usage"></a>Использование элемента объекта XAML  
 \<*inputBindingDerivedClass.../*>  
  
<a name="xamlValues_InputBinding"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `inputBindingDerivedClass`  
 Класс, производный от <xref:System.Windows.Input.InputBinding> , поддерживает синтаксис объектных элементов, таких как <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding>. См. заметки.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Windows.Input.KeyBinding> для привязки <xref:System.Windows.Input.KeyGesture> для <xref:System.Windows.Input.ApplicationCommands.Open%2A> команды. При выполнении ключа жеста, вызывается команду «Открыть».  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 Следующие примеры показывают, как привязать пользовательскую команду для <xref:System.Windows.Input.InputBinding> объектов. Эти примеры создайте приложение, позволяющее пользователю изменять цвет фона, выполнив одно из следующих действий:  
  
-   Нажатие кнопки.  
  
-   Нажатие клавиш CTRL + C.  
  
-   Щелкните правой кнопкой мыши <xref:System.Windows.Controls.StackPanel> (за пределами <xref:System.Windows.Controls.ListBox>).  
  
 В первом примере создается класс с именем `SimpleDelegateCommand`. Этот класс принимает делегат, таким образом, чтобы объект создания команды можно определить действие, которое происходит, когда выполняется команда. `SimpleDelegateCommand` также определяет свойства, указывающие, что ключ и мыши входных данных вызывает команду. `GestureKey` и `GestureModifier` укажите клавиатуры; `MouseGesture` указывает входные данные мыши.  
  
 [!code-csharp[InputCommandBinding#DelegateCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#delegatecommand)]
 [!code-vb[InputCommandBinding#DelegateCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#delegatecommand)]  
  
 Следующий пример создает и инициализирует `ColorChangeCommand`, который является `SimpleDelegateCommand`. В примере также определяется метод, который выполняется, когда вызывается команда и задает `GestureKey`, `GestureModifier`, и `MouseGesture` свойства. Приложение будет вызывать `InitializeCommand` метод в начале программы, например конструктор <xref:System.Windows.Window>.  
  
 [!code-csharp[InputCommandBinding#InitializeCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#initializecommand)]
 [!code-vb[InputCommandBinding#InitializeCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#initializecommand)]  
  
 Наконец в следующем примере создается пользовательский интерфейс. В примере добавляется <xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding> для <xref:System.Windows.Controls.StackPanel> , содержащий <xref:System.Windows.Controls.Button> и <xref:System.Windows.Controls.ListBox>. Когда пользователь выбирает элемент в <xref:System.Windows.Controls.ListBox>, он или она можно изменить цвет фона для выбранного цвета. В каждом случае `CommandParameter` свойство привязано к выбранному элементу в <xref:System.Windows.Controls.ListBox>и `Command` свойство привязано к `ColorChangeCommand`. <xref:System.Windows.Input.KeyBinding.Key%2A?displayProperty=nameWithType>, <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>, И <xref:System.Windows.Input.MouseBinding.MouseAction%2A?displayProperty=nameWithType> свойства привязаны к соответствующим свойствам `SimpleDelegateCommand` класса.  
  
 [!code-xaml[InputCommandBinding#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.UIElement.InputBindings" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Input.InputBinding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InputBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InputBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Предоставляет базовую инициализацию для производных от <see cref="T:System.Windows.Input.InputBinding" /> классов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding> не является технически абстрактный класс, но конструктор по умолчанию, то намеренно защищенный доступ. Это имеет стал <xref:System.Windows.Input.InputBinding> «абстрактный» класс для XAML. Существующие свойства в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] , имеющих использований XAML, которые ожидают объектов типа <xref:System.Windows.Input.InputBinding>, но нельзя указать <xref:System.Windows.Input.InputBinding> экземпляр в XAML. Вместо этого можно указать один из конкретного устройства <xref:System.Windows.Input.InputBinding> производных классов как значения, например <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы реализуете пользовательское <see cref="T:System.Windows.Input.InputBinding" /> , поддерживающий использование XAML, используйте этот конструктор для базовую инициализацию.</para></block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InputBinding (System.Windows.Input.ICommand command, System.Windows.Input.InputGesture gesture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Input.ICommand command, class System.Windows.Input.InputGesture gesture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor(System.Windows.Input.ICommand,System.Windows.Input.InputGesture)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (command As ICommand, gesture As InputGesture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InputBinding(System::Windows::Input::ICommand ^ command, System::Windows::Input::InputGesture ^ gesture);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.InputBinding : System.Windows.Input.ICommand * System.Windows.Input.InputGesture -&gt; System.Windows.Input.InputBinding" Usage="new System.Windows.Input.InputBinding (command, gesture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="command" Type="System.Windows.Input.ICommand" />
        <Parameter Name="gesture" Type="System.Windows.Input.InputGesture" />
      </Parameters>
      <Docs>
        <param name="command">Команда, связываемая с <paramref name="gesture" />.</param>
        <param name="gesture">Жест ввода, который должен быть сопоставлен <paramref name="command" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Input.InputBinding" /> с указанным именем команды и жестом ввода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы являетесь разработчиком программного обеспечения, используя существующие классы привязки ввода, вы обычно будет не использовать этот конструктор, даже при определении пользовательских команд. Вместо этого вы будет использовать конструкторы производных классов (<xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding>), или этот конструктор будет использоваться в качестве базового экземпляра пользовательского класса. Несмотря на то что <xref:System.Windows.Input.InputBinding> класс поддерживает различные устройства ввода, в принципе, на практике, необходимо выбрать устройство, которое будет представлять входной привязке. Только можно задать только один <xref:System.Windows.Input.InputBinding.Gesture%2A> значение на входную привязку и жесты зависят от конкретного устройства.  
  
   
  
## Examples  
 В следующем примере показано, как этот конструктор используется для связывания <xref:System.Windows.Input.KeyGesture> с <xref:System.Windows.Input.RoutedCommand>.  
  
 [!code-csharp[commandlibrarysnippets#InputBindingAddingCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#inputbindingaddingcommand)]
 [!code-vb[commandlibrarysnippets#InputBindingAddingCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#inputbindingaddingcommand)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="command" /> или <paramref name="gesture" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект, используемый для клонирования.</param>
        <summary>Копирует базовые (не анимационные) значения свойств заданного объекта.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект, используемый для клонирования.</param>
        <summary>Копирует текущие значения свойств заданного объекта.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Input.InputBinding.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Windows.Input.ICommand" />, связанный с этой входной привязкой.</summary>
        <value>Связанная команда.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding> Класс не поддерживает использование XAML, так как он не предоставляет открытый конструктор по умолчанию (он имеет конструктор по умолчанию, но он защищен). Тем не менее производные классы могут предоставлять открытый конструктор и таким образом, можно использовать свойства, которые наследуются от <xref:System.Windows.Input.InputBinding>. Два существующих <xref:System.Windows.Input.InputBinding> , производные классы, которые может быть создано в XAML и можно задать свойства с помощью XAML использований <xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding>.  
  
 <xref:System.Windows.Input.ICommand> ссылается на преобразователь типов, позволяющий определенных существующий <xref:System.Windows.Input.ICommand> реализаций для указания значений в виде строки. Это поведение преобразования типов задает значение атрибута из этого свойства. Можно также привязать <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, и <xref:System.Windows.Input.InputBinding.CommandTarget%2A> свойства <xref:System.Windows.Input.ICommand> , определенному в объект. Это дает возможность определить пользовательскую команду и связать его с входными данными пользователя. Дополнительные сведения см. во втором примере в <xref:System.Windows.Input.InputBinding>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <`inputBindingDerivedClass` `Command`="<xref:System.Windows.Input.ICommand>"/>  
  
<a name="xamlPropertyElementUsage_Command"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Command>  
    <iCommandImplementation/>  
  </inputBindingDerivedClass.Command>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `inputBindingDerivedClass`  
 Класс, производный от <xref:System.Windows.Input.InputBinding> , поддерживает синтаксис объектных элементов, таких как <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding>. См. заметки.  
  
 `iCommandImplementation`  
 Реализация объекта <xref:System.Windows.Input.ICommand> , поддерживает синтаксис объектных элементов (имеет открытый конструктор по умолчанию).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Windows.Input.KeyBinding> для привязки <xref:System.Windows.Input.KeyGesture> для <xref:System.Windows.Input.ApplicationCommands.Open%2A?displayProperty=nameWithType> команды. При выполнении ключа жеста, вызывается команду «Открыть».  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewkeybinding)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewkeybinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <see cref="P:System.Windows.Input.InputBinding.Command" /> равно <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.InputGesture" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Input.InputBinding.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает специфические для команды данные для конкретной команды.</summary>
        <value>Связанные с командой данные. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding.CommandParameter%2A> Свойство используется для передачи определенные сведения в команду при ее выполнении. Тип данных определяется с помощью команды. Многие команды не ожидают параметров команды; для этих команд все параметры команды, передаваемые будет игнорироваться.  
  
 Если входной привязки, связанные с командой является <xref:System.Windows.Input.RoutedCommand>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A> входной привязки передается <xref:System.Windows.Input.RoutedCommand> через <xref:System.Windows.Input.ExecutedRoutedEventArgs> и <xref:System.Windows.Input.CanExecuteRoutedEventArgs> данные события при обработке команды.  
  
 Тип данных и назначение параметра команды определяются по-разному для каждой команды и может быть `null`. Можно привязать <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, и <xref:System.Windows.Input.InputBinding.CommandTarget%2A> свойства <xref:System.Windows.Input.ICommand> , определенному в объект. Это дает возможность определить пользовательскую команду и связать его с входными данными пользователя. Дополнительные сведения см. во втором примере в <xref:System.Windows.Input.InputBinding>.  
  
 <xref:System.Windows.Input.InputBinding> Класс не поддерживает использование XAML, так как он не предоставляет открытый конструктор по умолчанию (он имеет конструктор по умолчанию, но он защищен). Тем не менее производные классы могут предоставлять открытый конструктор и таким образом, можно задать свойства, которые наследуются от <xref:System.Windows.Input.InputBinding> с использованием XAML. Два существующих <xref:System.Windows.Input.InputBinding> производные классы, которые может быть создано в XAML и свойства можно задать в XAML, <xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<inputBindingDerivedClass CommandParameter="commandParameterString"/>  
```  
  
<a name="xamlPropertyElementUsage_CommandParameter"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.CommandParameter>  
    <commandParameterObject/>  
  </inputBindingDerivedClass.CommandParameter>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `inputBindingDerivedClass`  
 Класс, производный от <xref:System.Windows.Input.InputBinding> , поддерживает синтаксис объектных элементов, таких как <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding>. См. заметки.  
  
 `commandParameterString`  
 Строка, которая обрабатывается определенной команды. Строки являются распространенным типом, используемым для параметров команды, так как их можно легко задать в XAML. Требуется строка формата и ее назначение см. в документации для той или иной команды, с которой связана эта входная привязка. Многие команды не ожидают параметров.  
  
 `commandParameterObject`  
 Объект, обрабатываемый определенной команды. Все существующие [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] команды используют строки. Таким образом этот синтаксис элемента свойства относится только к пользовательской команды сценариев. Для поддержки этого синтаксиса `commandParameterObject` объект также должен поддерживать синтаксис объектных элементов (должен иметь открытый конструктор по умолчанию).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Input.InputBinding.CommandParameter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Input.InputBinding.Command" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Input.InputBinding.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает для команды целевой элемент.</summary>
        <value>Целевой объект команды. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В системе команд системы, Windows Presentation Foundation <xref:System.Windows.Input.InputBinding.CommandTarget%2A> свойство <xref:System.Windows.Input.ICommandSource> объект является применимо, только если <xref:System.Windows.Input.ICommand> является <xref:System.Windows.Input.RoutedCommand>. Если для <xref:System.Windows.Input.ICommandSource> задано значение <xref:System.Windows.Input.InputBinding.CommandTarget%2A>, и соответствующая команда — не <xref:System.Windows.Input.RoutedCommand>, целевой объект команды не учитывается.  
  
 При использовании с <xref:System.Windows.Input.RoutedCommand>, целью команды является объект, для которого <xref:System.Windows.Input.CommandManager.Executed> и <xref:System.Windows.Input.CommandManager.CanExecute> событий. Если <xref:System.Windows.Input.InputBinding.CommandTarget%2A> свойство не задано, элемент с фокусом клавиатуры используется в качестве целевого объекта.  
  
 <xref:System.Windows.Input.InputBinding> Сам класс не поддерживает использование XAML, так как он не предоставляет открытый конструктор по умолчанию (конструктор по умолчанию, но он защищен). Тем не менее производные классы могут предоставлять открытый конструктор и таким образом, можно задать свойства, которые наследуются от <xref:System.Windows.Input.InputBinding> с использованием XAML. Два существующих <xref:System.Windows.Input.InputBinding> производные классы, которые может быть создано в XAML и свойства можно задать в XAML, <xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandTarget"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<inputBindingDerivedClass CommandTarget="bindingToTarget"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `inputBindingDerivedClass`  
 Класс, производный от <xref:System.Windows.Input.InputBinding> , поддерживает синтаксис объектных элементов, таких как <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding>. См. заметки.  
  
 `bindingToTarget`  
 Строка, использует тип синтаксиса привязки, который может возвращать ссылку на существующий объект с именем элемента. См. заметки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Input.InputBinding.CommandTarget" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="inputBinding.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает экземпляр класса <see cref="T:System.Windows.Input.InputBinding" />.</summary>
        <returns>Новый объект.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Gesture">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Input.InputGesture Gesture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputGesture Gesture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Gesture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Gesture As InputGesture" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Input::InputGesture ^ Gesture { System::Windows::Input::InputGesture ^ get(); void set(System::Windows::Input::InputGesture ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Gesture : System.Windows.Input.InputGesture with get, set" Usage="System.Windows.Input.InputBinding.Gesture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputGesture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Windows.Input.InputGesture" />, связанный с этой входной привязкой.</summary>
        <value>Связанный жест. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Жест ввода, который является действие, которое вызывает команду. Примеры входных жестов в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] являются <xref:System.Windows.Input.KeyGesture> и <xref:System.Windows.Input.MouseGesture>. Объект <xref:System.Windows.Input.KeyGesture> представляет собой сочетание <xref:System.Windows.Input.Key> и набор <xref:System.Windows.Input.ModifierKeys>. Объект <xref:System.Windows.Input.MouseGesture> представляет собой сочетание <xref:System.Windows.Input.MouseAction> и набор <xref:System.Windows.Input.ModifierKeys>.  
  
 <xref:System.Windows.Input.InputBinding> Сам класс не поддерживает использование XAML, так как он не предоставляет открытый конструктор по умолчанию (конструктор по умолчанию, но он защищен). Тем не менее производные классы могут предоставлять открытый конструктор и таким образом, можно задать свойства, унаследованные от <xref:System.Windows.Input.InputBinding> с использованием XAML. Два существующих <xref:System.Windows.Input.InputBinding> производные классы, которые может быть создано в XAML и свойства можно задать в XAML, <xref:System.Windows.Input.KeyBinding> и <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_gesture"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <<xref:System.Windows.Input.KeyBinding> `Gesture`="<xref:System.Windows.Input.KeyGesture>"/>  
  
-или-
  
 <<xref:System.Windows.Input.MouseBinding> `Gesture`="<xref:System.Windows.Input.MouseGesture>"/>  
  
-или-
  
 <`inputBindingDerivedClass` `Gesture`="<xref:System.Windows.Input.InputGesture>"/>  
  
<a name="xamlPropertyElementUsage_gesture"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Gesture>  
    <inputGestureImplementation/>  
  </inputBindingDerivedClass.Gesture>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_gesture"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `inputBindingDerivedClass`  
 Класс, производный от <xref:System.Windows.Input.InputBinding> , поддерживает синтаксис объектных элементов, таких как <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding>. См. заметки.  
  
 `inputGestureImplementation`  
 Пользовательский производный класс <xref:System.Windows.Input.InputGesture> , поддерживает синтаксис объектных элементов.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Windows.Input.KeyBinding> для привязки <xref:System.Windows.Input.KeyGesture> для <xref:System.Windows.Input.RoutedCommand>. Когда <xref:System.Windows.Input.KeyGesture> нажатии ALT + L, <xref:System.Windows.Input.ApplicationCommands.Close%2A> вызове команды.  
  
 [!code-xaml[commandlibrarysnippets#KeyBindingWithKeyAndModifiersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml#keybindingwithkeyandmodifiersxaml)]  
  
 [!code-csharp[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#keybindingwithkeyandmodifiers)]
 [!code-vb[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#keybindingwithkeyandmodifiers)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyGesture" />
        <altmember cref="T:System.Windows.Input.MouseGesture" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект, используемый для клонирования.</param>
        <summary>Создает экземпляр замороженной копии заданного объекта <see cref="T:System.Windows.Freezable" />, используя базовые (не анимационные) значения свойства.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект, используемый для клонирования.</param>
        <summary>Создает текущий экземпляр замороженной копии указанного объекта <see cref="T:System.Windows.Freezable" />. Если объект имеет анимированные свойства зависимостей, копируются их текущие анимированные значения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>