<Type Name="SecurityTokenHandler" FullName="System.IdentityModel.Tokens.SecurityTokenHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="db6ee2647211996474244058d82b42c4ff2a279b" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70467850" /></Metadata><TypeSignature Language="C#" Value="public abstract class SecurityTokenHandler : System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenHandler extends System.Object implements class System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenHandler&#xA;Implements ICustomIdentityConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenHandler abstract : System::IdentityModel::Configuration::ICustomIdentityConfiguration" />
  <TypeSignature Language="F#" Value="type SecurityTokenHandler = class&#xA;    interface ICustomIdentityConfiguration" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IdentityModel.Configuration.ICustomIdentityConfiguration</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Абстрактный базовый класс для обработчиков токенов безопасности.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Класс является базовым классом, из которого наследуются все обработчики маркеров безопасности. Обработчик маркеров безопасности отвечает за следующее:  
  
-   Проверка маркеров безопасности (<xref:System.IdentityModel.Tokens.SecurityToken>) типа, который предназначен для обработки и упаковки утверждений, содержащихся в маркере, <xref:System.Security.Claims.ClaimsIdentity> в объект.  
  
-   Сериализация и десериализация маркеров безопасности типа, предназначенного для обработки.  
  
-   Сериализация и десериализация предложений идентификатора ключа (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>), которые ссылаются на токены типа, предназначенного для обработки в элементах и из `<wsse:SecurityTokenReference>` них.  
  
-   Создание маркеров безопасности из <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor> объекта, переданного реализациями <xref:System.IdentityModel.SecurityTokenService> класса.  
  
-   Создание предложений идентификатора ключа из маркера безопасности для реализации <xref:System.IdentityModel.SecurityTokenService> класса.  
  
 Windows Identity Foundation (WIF) поставляется со следующими обработчиками маркеров безопасности:  
  
-   <xref:System.IdentityModel.Tokens.EncryptedSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.KerberosSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MembershipUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.RsaSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.Saml2SecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SamlSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.UserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.WindowsUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.X509SecurityTokenHandler>  
  
 Большинство из этих классов предоставляют дополнительные члены, которые реализуют функциональные возможности, характерные для обработки маркеров, для которых предназначен класс. Во многих случаях может быть лучше наследовать от одного из этих классов, а не непосредственно от <xref:System.IdentityModel.Tokens.SecurityTokenHandler> класса.  
  
 Обработчик маркеров безопасности можно добавить или удалить из коллекции обработчиков маркеров, указав [ &lt;Add&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md), [ &lt;Remove&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md)или [ &lt;Clear&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/clear.md) . элементы в элементе [&gt; securityTokenHandlers в файле конфигурации. &lt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) Доступ к <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection%2A> объекту, содержащему параметры конфигурации для коллекции обработчиков, можно получить с помощью свойства и коллекции обработчиков, членом которой является обработчик маркеров, к которому можно получить доступ из свойства. <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration> Можно переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> метод для обработки любых пользовательских элементов конфигурации, принимаемых обработчиком.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Класс предоставляет несколько других свойств и методов. В зависимости от функциональности, которую вы выбираете для реализации, можно переопределить некоторые или все эти члены.  
  
 Необходимо переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> свойство <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> и метод, чтобы предоставить инфраструктуре WIF сведения о типе маркера безопасности, для обработки которого предназначен класс.  
  
 Функции проверки, сериализации и десериализации предоставляются через свойства или методы, которые указывают, может ли обработчик выполнять определенную функцию в сочетании с методом или методами, реализующими эту функциональность. В следующем списке применяются пары свойств или методов, которые указывают функциональность с помощью методов, реализующих эту функцию:  
  
-   Свойство и метод: проверяет маркер и упаковывает утверждения, содержащиеся в маркере, <xref:System.Security.Claims.ClaimsIdentity>в. <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A>  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> Свойство <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A>  и методы: Сериализация маркера.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> Методы <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A>  и методы: десериализация маркера.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A> Метод <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A>  и метод: десериализация предложений идентификатора ключа.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> Метод <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A>  и метод: сериализация предложений идентификатора ключа.  
  
 Методы и вызываются из конвейера <xref:System.IdentityModel.SecurityTokenService> в реализациях класса. <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A>  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> Метод вызывается инфраструктурой WIF для определения того, был ли уже получен указанный токен. По умолчанию этот метод `false`возвращает значение, которое указывает на то, что токен еще не был получен. Можно переопределить метод и предоставить логику для обнаружения воспроизводимых токенов.  
  
   
  
## Examples  
 Примеры кода во всех <xref:System.IdentityModel.Tokens.SecurityTokenHandler> разделах взяты `Custom Token` из примера. Этот пример предоставляет пользовательские классы, которые позволяют обрабатывать простые веб-маркеры (SWT). Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md). В следующем коде XML показано, как добавить обработчик токенов SWT в коллекцию обработчиков маркеров.  
  
```xml  
<system.identityModel>  
  <identityConfiguration saveBootstrapContext="true">  
    <issuerTokenResolver type="SimpleWebToken.CustomIssuerTokenResolver, SimpleWebToken">  
      <AddAudienceKeyPair  symmetricKey="wAVkldQiFypTQ+kdNdGWCYCHRcee8XmXxOvgmak8vSY=" audience="http://localhost:19851/" />  
    </issuerTokenResolver>  
    <issuerNameRegistry type="RelyingParty.TrustedIssuerNameRegistry, RelyingParty"/>  
    <audienceUris>  
      <add value="http://localhost:19851/"/>  
    </audienceUris>  
    <securityTokenHandlers>  
      <add type="SimpleWebToken.SimpleWebTokenHandler, SimpleWebToken" />  
    </securityTokenHandlers>  
  </identityConfiguration>  
</system.identityModel>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SecurityToken" />
    <altmember cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" />
    <altmember cref="T:System.IdentityModel.SecurityTokenService" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Вызывается из конструкторов в производных классах для инициализации класса <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadKeyIdentifierClause (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, размещаемое на начальном элементе. Средство чтения не должно предваряться этим методом.</param>
        <summary>Возвращает значение, указывающее, является ли элемент xml, на которое ссылается указанное средство чтения XML, предложением идентификатора ключа, которое может десериализоваться этим экземпляром.</summary>
        <returns>Значение <see langword="true" />, если метод <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" /> может считывать элемент; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию `false` возвращает значение, указывающее, что невозможно прочитать предложение идентификатора ключа.  
  
 Производный класс проверяет элемент, на который ссылается средство чтения, чтобы определить, может ли экземпляр выполнить десериализацию предложения идентификатора ключа. Обычно это выполняется с помощью вызова <xref:System.Xml.XmlReader.IsStartElement%2A?displayProperty=nameWithType> метода с указанными строками элемента и пространства имен. При переопределении <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>необходимо также <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> переопределить метод, чтобы предоставить логику для десериализации предложения идентификатора ключа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, показывающее, может ли указанный токен десериализоваться как токен типа, обработанного этим экземпляром.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (tokenString As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : string -&gt; bool&#xA;override this.CanReadToken : string -&gt; bool" Usage="securityTokenHandler.CanReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Строка токена для чтения</param>
        <summary>Возвращает значение, показывающее, может ли указанная строка десериализоваться как токен типа, обработанного этим экземпляром.</summary>
        <returns>Значение <see langword="true" />, если метод <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" /> может считывать элемент; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию всегда возвращает значение `false`.  
  
 При переопределении этого метода необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> метод, чтобы предоставить логику для десериализации маркера.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, размещаемое на начальном элементе. Средство чтения не должно предваряться этим методом.</param>
        <summary>Возвращает значение, указывающее, является ли элемент xml, на которое ссылается указанное средство чтения XML, считываемым, как токен типа, обрабатываемого этим экземпляром.</summary>
        <returns>Значение <see langword="true" />, если метод <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" /> может считывать элемент; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию всегда возвращает значение `false`.  
  
 Производный класс проверяет элемент, на который ссылается средство чтения, чтобы определить, может ли экземпляр выполнить десериализацию маркера безопасности. Обычно это выполняется с помощью вызова <xref:System.Xml.XmlReader.IsStartElement%2A> метода с указанными строками элемента и пространства имен. При переопределении <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>необходимо также <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> переопределить метод или <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> метод, чтобы предоставить логику для десериализации предложения идентификатора ключа.  
  
   
  
## Examples  
 В следующем коде показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> метод, чтобы определить, может ли маркер быть прочитан обработчиком. Код берется из `Custom Token` примера. Этот пример предоставляет пользовательские классы, которые позволяют обрабатывать простые веб-маркеры (SWT). Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public virtual bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли этот обработчик поддерживать проверку токенов безопасности.</summary>
        <value>Значение <see langword="true" />, если класс может проверять токены безопасности; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы реализовать проверку в производном классе, Переопределите это свойство, `true` чтобы оно возвращало и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> переопределяет метод для реализации логики проверки.  
  
   
  
## Examples  
 В следующем коде показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> свойство, чтобы указать, что пользовательский обработчик может проверить маркеры. Код берется из `Custom Token` примера. Этот пример предоставляет пользовательские классы, которые позволяют обрабатывать простые веб-маркеры (SWT). Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanWriteKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanWriteKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool&#xA;override this.CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool" Usage="securityTokenHandler.CanWriteKeyIdentifierClause securityKeyIdentifierClause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="securityKeyIdentifierClause">Предложение идентификатора ключа для проверки.</param>
        <summary>Возвращает значение, показывающее, может ли указанная конструкция идентификатора ключа быть сериализована этим экземпляром.</summary>
        <returns>Значение <see langword="true" />, если можно сериализовать конструкцию идентификатора ключа; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию всегда возвращает значение `false`.  
  
 При переопределении <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A>необходимо также <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> переопределить метод, чтобы предоставить логику для сериализации предложения идентификатора ключа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли этот обработчик сериализовать токены безопасности.</summary>
        <value><see langword="true" />, если класс может выполнять сериализацию токенов; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы реализовать сериализацию в производном классе, Переопределите это свойство, `true` чтобы оно возвращало и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> переопределяет методы для реализации логики сериализации.  
  
   
  
## Examples  
 В следующем коде показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> свойство, чтобы указать, что пользовательский обработчик может сериализовать маркеры. Код берется из `Custom Token` примера. Этот пример предоставляет пользовательские классы, которые позволяют обрабатывать простые веб-маркеры (SWT). Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Configuration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberSignature Language="VB.NET" Value="Public Property Configuration As SecurityTokenHandlerConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ Configuration { System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Configuration : System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration with get, set" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration" />, который предоставляет конфигурацию для текущего экземпляра.</summary>
        <value>Объект конфигурации для текущего экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство обычно задается инфраструктурой конфигурации [ &lt;&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlerconfiguration.md) из элемента секурититокенхандлерконфигуратион в файле конфигурации во время запуска приложения. <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A>  
  
 В производных классах для доступа <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> к параметрам конфигурации используется свойство. Например, к реестру имен издателя, используемому <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> в методе, <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.IssuerNameRegistry%2A?displayProperty=nameWithType> можно обращаться из свойства объекта конфигурации.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainingCollection">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainingCollection As SecurityTokenHandlerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ ContainingCollection { System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainingCollection : System.IdentityModel.Tokens.SecurityTokenHandlerCollection" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию обработчиков токена, содержащую текущий экземпляр.</summary>
        <value>коллекция обработчиков токена, содержащая текущий экземпляр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При добавлении обработчика маркеров к <xref:System.IdentityModel.Tokens.SecurityTokenHandlerCollection> экземпляру это свойство устанавливается автоматически.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenReference">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference (System.IdentityModel.Tokens.SecurityToken token, bool attached);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference(class System.IdentityModel.Tokens.SecurityToken token, bool attached) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference(System.IdentityModel.Tokens.SecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSecurityTokenReference (token As SecurityToken, attached As Boolean) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ CreateSecurityTokenReference(System::IdentityModel::Tokens::SecurityToken ^ token, bool attached);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.CreateSecurityTokenReference (token, attached)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="attached" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="token">Токен, для которого требуется создать ссылку.</param>
        <param name="attached">Значение <see langword="true" />, если должна быть создана присоединенная ссылка; значение <see langword="false" />, если должна быть создана неприсоединенная ссылка.</param>
        <summary>При переопределении в производном классе создает ссылку токена безопасности для токенов, обрабатываемых этим классом. Этот метод обычно вызывается службой токенов безопасности (STS).</summary>
        <returns>Предложение идентификатора ключа, ссылающееся на указанный токен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает <xref:System.NotImplementedException> исключение.  
  
 Производные классы переопределяют этот метод, чтобы вернуть предложение идентификатора<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>ключа (), которое можно использовать для `<wsse:SecurityTokenReference>` создания элемента для указанного токена.  
  
 Вызывается из реализаций <xref:System.IdentityModel.SecurityTokenService> класса.  
  
 Как правило, <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause> не требуется использовать, кроме случаев, когда создается пользовательская служба маркеров безопасности. Когда служба маркеров безопасности возвращает маркер безопасности, выданный маркер безопасности содержит ссылки на прикрепленные и неприкрепленные маркеры безопасности. Прикрепленные ссылки указывают на маркеры безопасности, содержащиеся в заголовке безопасности сообщения SOAP, а неприкрепленные ссылки указывают на маркеры безопасности, не входящие в заголовок безопасности сообщения SOAP. Обычно эти ссылки подтверждают подлинность выданного маркера безопасности.  
  
   
  
## Examples  
 В следующем коде показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> метод, чтобы создать предложение идентификатора ключа из указанного токена. Код берется из `Custom Token` примера. Этот пример предоставляет пользовательские классы, которые позволяют обрабатывать простые веб-маркеры (SWT). Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">Дескриптор токена безопасности, на основании которого создается токен. Свойства дескриптора токена задаются до вызова этого метода.</param>
        <summary>При переопределении в производном классе создает токен безопасности с помощью заданного дескриптора токена. Этот метод вызывается службой токенов безопасности (STS).</summary>
        <returns>токен безопасности, соответствующий свойствам дескриптора токена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает <xref:System.NotImplementedException> исключение.  
  
 Вызывается из реализаций <xref:System.IdentityModel.SecurityTokenService> класса.  
  
   
  
## Examples  
 В следующем коде показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> метод для создания и возврата маркера из дескриптора маркера. Код берется из `Custom Token` примера. Этот пример предоставляет пользовательские классы, которые позволяют обрабатывать простые веб-маркеры (SWT). Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetectReplayedToken">
      <MemberSignature Language="C#" Value="protected virtual void DetectReplayedToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DetectReplayedToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DetectReplayedToken (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DetectReplayedToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.DetectReplayedToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Токен для проверки воспроизведения.</param>
        <summary>При переопределении в производном классе вызывает исключение, если обнаруживается, что указанный токен используется повторно.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию не выполняет никаких действий.  
  
 Производные классы должны вызывать <xref:System.IdentityModel.Tokens.SecurityTokenReplayDetectedException> исключение, если токен уже используется.  
  
 Windows Identity Foundation (WIF) предоставляет <xref:System.IdentityModel.Tokens.TokenReplayCache> класс, из которого могут быть получены кэши воспроизведения, [ &lt;и элемент конфигурации tokenReplayCache&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/tokenreplaycache.md) , который можно использовать для настройки кэша воспроизведения, используемого токеном. обработчики в приложении; Однако точная реализация <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> метода является конструктором производного класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public abstract string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="securityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает набор универсальных кодов ресурса (URI), которые используются в запросах для идентификации токена обрабатываемого этим классом типа.</summary>
        <returns>Набор универсальных кодов ресурсов (URI), определяющих тип токенов, поддерживаемый этим обработчиком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Доступ к маркеру, обрабатываемому текущим экземпляром, осуществляется <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> через свойство. <xref:System.Type> <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> Метод возвращает набор допустимых идентификаторов, которые можно использовать в сообщениях для ссылки на тип токена. Например, значение URI, используемое в `<wst:TokenType>` элементе `<wst:RequestSecurityToken>` в элементе для запроса определенного вида <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType%2A?displayProperty=nameWithType> маркера (представленного свойством в объектной модели).  
  
   
  
## Examples  
 В следующем коде показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> метод для возврата идентификаторов типа маркера для пользовательского токена. Код берется из `Custom Token` примера. Этот пример предоставляет пользовательские классы, которые позволяют обрабатывать простые веб-маркеры (SWT). Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#17](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#17)]  
[!code-csharp[WifRcCustomToken#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public virtual void LoadCustomConfiguration (System.Xml.XmlNodeList nodelist);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList nodelist) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadCustomConfiguration (nodelist As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadCustomConfiguration(System::Xml::XmlNodeList ^ nodelist);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit&#xA;override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="securityTokenHandler.LoadCustomConfiguration nodelist" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IdentityModel.Configuration.ICustomIdentityConfiguration.LoadCustomConfiguration(System.Xml.XmlNodeList)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodelist" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="nodelist">XML-элемент конфигурации. Каждый узел в списке имеет тип <see cref="T:System.Xml.XmlElement" />.</param>
        <summary>При переопределении в производном классе загружает пользовательскую конфигурацию из XML-кода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> Метод вызывается инфраструктурой конфигурации. При вызове этого метода объект `nodelist` будет содержать дочерние элементы верхнего уровня элемента [ &lt;Add&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) обработчика маркеров из файла конфигурации. Каждая из них, в свою очередь, может содержать атрибуты или дочерние элементы в зависимости от схемы конфигурации, определяемой для производного класса.  
  
 Реализация по умолчанию создает <xref:System.NotImplementedException>исключение. Переопределите этот метод в производном классе, чтобы включить инициализацию обработчика маркеров безопасности из файла конфигурации.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadKeyIdentifierClause (reader As XmlReader) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ ReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.ReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, расположенный в начальном элементе XML, который десериализуется в предложение идентификатора ключа.</param>
        <summary>При переопределении в производном классе десериализует XML-код, на который имеется ссылка в указанном модуле чтения XML, в конструкцию идентификатора ключа, который ссылается на токен, обрабатываемый производным классом.</summary>
        <returns>Предложение идентификатора ключа, десериализованное из XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод, чтобы предоставить логику для десериализации предложения идентификатора ключа из XML. При переопределении этого метода следует также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе десериализует заданный XML-код в токен обрабатываемого этим производным классом типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (tokenString As String) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Строка, подлежащая десериализации.</param>
        <summary>При переопределении в производном классе десериализует заданную строку в токен обрабатываемого этим производным классом типа.</summary>
        <returns>Токен безопасности, который был десериализован из указанной строки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 По умолчанию этот метод создает <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод, чтобы обеспечить возможность десериализации токена безопасности из строки. При переопределении этого метода следует также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, размещаемое на начальном элементе токена.</param>
        <summary>При переопределении в производном классе десериализует десериализует XML-код, на который имеется ссылка в указанном модуле чтения XML, в токен обрабатываемого этим производным классом типа.</summary>
        <returns>Токен безопасности, который был десериализован из XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 По умолчанию этот метод создает <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод, чтобы предоставить логику для десериализации маркера безопасности из XML. При переопределении этого метода следует также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> метод. Как правило, в производных классах, если метод не может десериализовать токен из упоминаемого XML- <xref:System.Xml.XmlException>документа, он создает исключение.  
  
   
  
## Examples  
 В следующем коде показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> метод для чтения пользовательского токена из указанного модуля чтения XML. Код берется из `Custom Token` примера. Этот пример предоставляет пользовательские классы, которые позволяют обрабатывать простые веб-маркеры (SWT). Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#7)]  
[!code-csharp[WifRcCustomToken#8](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#8)]  
[!code-csharp[WifRcCustomToken#14](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, размещаемое на начальном элементе токена.</param>
        <param name="tokenResolver">сопоставитель токена, содержащий внештатные и кэшированных токены.</param>
        <summary>При переопределении в производном классе десериализует XML-код, на который имеется ссылка в указанном модуле чтения XML, в токен, обрабатываемый производным классом, путем использования заданного сопоставителя токенов.</summary>
        <returns>Токен безопасности, который был десериализован из XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Реализация по умолчанию игнорирует `tokenResolver` параметр и делегирует вызов <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> методу.  
  
 Переопределите этот метод, чтобы предоставить логику для десериализации маркера безопасности из XML. При переопределении этого метода следует также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> метод. Как правило, в производных классах, если метод не может десериализовать токен из упоминаемого XML- <xref:System.Xml.XmlException>документа, он создает исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public abstract Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает тип токена безопасности, обрабатываемого этим экземпляром.</summary>
        <value>Тип токена безопасности, обрабатываемого этим экземпляром.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство необходимо переопределить в производных классах и вернуть <xref:System.Type> маркер безопасности (<xref:System.IdentityModel.Tokens.SecurityToken>), который обрабатывается производным классом.  
  
   
  
## Examples  
 В следующем коде показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> свойство, чтобы оно <xref:System.Type> возвращало маркеры безопасности, обрабатываемые пользовательским обработчиком. Код берется из `Custom Token` примера. Этот пример предоставляет пользовательские классы, которые позволяют обрабатывать простые веб-маркеры (SWT). Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#18](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationFailure">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationFailure (System.IdentityModel.Tokens.SecurityToken token, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationFailure(class System.IdentityModel.Tokens.SecurityToken token, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationFailure(System.IdentityModel.Tokens.SecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationFailure (token As SecurityToken, errorMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationFailure(System::IdentityModel::Tokens::SecurityToken ^ token, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationFailure : System.IdentityModel.Tokens.SecurityToken * string -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationFailure (token, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">Токен безопасности, который проверяется.</param>
        <param name="errorMessage">Сообщение для записи в трассировку.</param>
        <summary>Трассирует событие сбоя во время проверки токенов безопасности, если трассировка включена.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует вызывать из <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метода при сбое проверки маркера.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationSuccess">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationSuccess (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationSuccess(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationSuccess(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationSuccess (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationSuccess(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationSuccess : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationSuccess token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Проверенный токен.</param>
        <summary>Трассирует успешную проверку событий токен безопасности, если трассировка включена.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует вызывать из <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метода после успешной проверки маркера.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;&#xA;override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="securityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Токен для проверки.</param>
        <summary>При переопределении в производном классе проверяет указанный токен безопасности. Токен должен иметь тип, обрабатываемый производным классом.</summary>
        <returns>Идентификаторы, содержащееся в токене.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает <xref:System.NotImplementedException> исключение.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> Метод вызывается инфраструктурой для проверки и извлечения утверждений из десериализованного маркера безопасности. Эти утверждения возвращаются в коллекции <xref:System.Security.Claims.ClaimsIdentity> объектов, возвращаемых методом. В типичном случае эта коллекция будет содержать одно удостоверение.  
  
 В производных классах проверка обычно включает проверку предполагаемой аудитории, указанной в маркере, для URI аудитории, <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.AudienceRestriction%2A?displayProperty=nameWithType> указанных в свойстве объекта конфигурации обработчика токенов <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> , указанного в свойстве. Эти URI обычно задаются в файле [ &lt;&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/audienceuris.md) конфигурации в элементе audienceUris. Если аудиторию не удается проверить, <xref:System.IdentityModel.Tokens.AudienceUriValidationFailedException> должно быть выдано исключение.  
  
 При обработке маркера издатель обычно проверяется путем передачи маркера издателя в один из <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> методов <xref:System.IdentityModel.Tokens.IssuerNameRegistry> объекта, настроенного <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> для обработчика через свойство. Реестр имен издателей обычно настраивается с [ &lt;помощью&gt; элемента IssuerNameRegistry](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/issuernameregistry.md) в файле конфигурации. <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> Возвращает имя издателя. Это имя должно использоваться для задания <xref:System.Security.Claims.Claim.Issuer%2A?displayProperty=nameWithType> свойства в утверждениях, содержащихся в токене. Если в реестре имен издателя не содержится запись для маркера издателя, <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> возвращается значение. `null` В этом случае a <xref:System.IdentityModel.Tokens.SecurityTokenException> обычно вызывается в производных классах, но это поведение наблюдается в конструкторе класса.  
  
   
  
## Examples  
 В следующем коде показано переопределение <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метода для обработчика маркеров безопасности, обрабатывающего простые веб-маркеры (SWT). Код берется из `CustomToken` примера. Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#9](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#9)]  
  
 В следующем коде показан `CreateClaims` метод, который вызывается из переопределения <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метода в предыдущем примере. Этот метод возвращает <xref:System.Security.Claims.ClaimsIdentity> объект, созданный на основе утверждений в токене. Код берется из `CustomToken` примера. Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#15](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#15)]  
  
 В следующем коде показан `ValidateSignature` метод, который вызывается из переопределения <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метода в простом обработчике веб-токена. Этот метод проверяет сигнатуру токена с помощью настроенного <xref:System.IdentityModel.Tokens.IssuerTokenResolver>. Код берется из `CustomToken` примера. Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#12](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#12)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 В следующем коде показан `ValidateAudience` метод, который вызывается из переопределения <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метода в простом обработчике веб-токена. Этот метод проверяет аудиторию, содержащуюся в маркере, по URI аудитории, указанным в конфигурации. Код берется из `CustomToken` примера. Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#13](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual void WriteKeyIdentifierClause (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteKeyIdentifierClause(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteKeyIdentifierClause(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit&#xA;override this.WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit" Usage="securityTokenHandler.WriteKeyIdentifierClause (writer, securityKeyIdentifierClause)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="writer">Модуль записи XML.</param>
        <param name="securityKeyIdentifierClause">Конструкция идентификатора ключа для сериализации.</param>
        <summary>При переопределении в производном классе сериализует указанную конструкцию идентификатора ключа в формат XML. Предложения идентификатора ключа должно иметь тип, поддерживаемый производным классом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод, чтобы предоставить логику для сериализации предложения идентификатора ключа в XML. При переопределении этого метода следует также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе сериализует указанный токен безопасности. Токен должен иметь тип, обрабатываемый производным классом.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual string WriteToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string WriteToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (token As SecurityToken) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ WriteToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string&#xA;override this.WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string" Usage="securityTokenHandler.WriteToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Токен для сериализации.</param>
        <summary>При переопределении в производном классе сериализует указанный токен безопасности в строку. Токен должен иметь тип, обрабатываемый производным классом.</summary>
        <returns>Сериализованный токен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод, чтобы предоставить логику сериализации маркера безопасности в XML. При переопределении этого метода необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">Модуль записи XML.</param>
        <param name="token">Токен для сериализации.</param>
        <summary>При переопределении в производном классе сериализует указанный токен безопасности в формат XML. Токен должен иметь тип, обрабатываемый производным классом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод, чтобы предоставить логику сериализации маркера безопасности в XML. При переопределении этого метода необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> свойство.  
  
   
  
## Examples  
 В следующем коде показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> метод для сериализации пользовательского токена. Код берется из `Custom Token` примера. Этот пример предоставляет пользовательские классы, которые позволяют обрабатывать простые веб-маркеры (SWT). Сведения об этом образце и других примерах, доступных для WIF, и о том, где их можно скачать, см. в разделе [индекс примера кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#10](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#10)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
