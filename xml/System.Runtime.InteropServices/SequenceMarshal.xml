<Type Name="SequenceMarshal" FullName="System.Runtime.InteropServices.SequenceMarshal">
  <Metadata><Meta Name="ms.openlocfilehash" Value="27d77a7e5ba98f686fec3d0edf3b2ba9acb34ea5" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70342016" /></Metadata><TypeSignature Language="C#" Value="public static class SequenceMarshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit SequenceMarshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SequenceMarshal" />
  <TypeSignature Language="VB.NET" Value="Public Class SequenceMarshal" />
  <TypeSignature Language="C++ CLI" Value="public ref class SequenceMarshal abstract sealed" />
  <TypeSignature Language="F#" Value="type SequenceMarshal = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="1ffbf-101">Предоставляет коллекцию методов для взаимодействия с <see cref="T:System.Buffers.ReadOnlySequence`1" />.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-101">Provides a collection of methods for interoperating with <see cref="T:System.Buffers.ReadOnlySequence`1" />.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="TryGetArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetArray&lt;T&gt; (System.Buffers.ReadOnlySequence&lt;T&gt; sequence, out ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetArray&lt;T&gt;(valuetype System.Buffers.ReadOnlySequence`1&lt;!!T&gt; sequence, [out] valuetype System.ArraySegment`1&lt;!!T&gt;&amp; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetArray(Of T) (sequence As ReadOnlySequence(Of T), ByRef segment As ArraySegment(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryGetArray(System::Buffers::ReadOnlySequence&lt;T&gt; sequence, [Runtime::InteropServices::Out] ArraySegment&lt;T&gt; % segment);" />
      <MemberSignature Language="F#" Value="static member TryGetArray : System.Buffers.ReadOnlySequence&lt;'T&gt; * ArraySegment -&gt; bool" Usage="System.Runtime.InteropServices.SequenceMarshal.TryGetArray (sequence, segment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" />
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="1ffbf-102">Тип последовательности, доступной только для чтения.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-102">The type of the read-only sequence.</span></span></typeparam>
        <param name="sequence"><span data-ttu-id="1ffbf-103">Доступная только для чтения последовательность, из которой будет извлечен сегмент массива.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-103">The read-only sequence from which the array segment will be retrieved.</span></span></param>
        <param name="segment"><span data-ttu-id="1ffbf-104">Возвращаемый сегмент массива.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-104">The returned array segment.</span></span></param>
        <summary><span data-ttu-id="1ffbf-105">Возвращает сегмент массива из базовой последовательности, доступной только для чтения.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-105">Gets an array segment from the underlying read-only sequence.</span></span></summary>
        <returns><span data-ttu-id="1ffbf-106">Значение <see langword="true" />, если можно извлечь сегмент массива; в противном случае — значение <see langword="false" /> и возвращается сегмент массива по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-106"><see langword="true" /> if it's possible to retrieve the array segment; otherwise, <see langword="false" /> and a default array segment is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetReadOnlyMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetReadOnlyMemory&lt;T&gt; (System.Buffers.ReadOnlySequence&lt;T&gt; sequence, out ReadOnlyMemory&lt;T&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetReadOnlyMemory&lt;T&gt;(valuetype System.Buffers.ReadOnlySequence`1&lt;!!T&gt; sequence, [out] valuetype System.ReadOnlyMemory`1&lt;!!T&gt;&amp; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetReadOnlyMemory(Of T) (sequence As ReadOnlySequence(Of T), ByRef memory As ReadOnlyMemory(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryGetReadOnlyMemory(System::Buffers::ReadOnlySequence&lt;T&gt; sequence, [Runtime::InteropServices::Out] ReadOnlyMemory&lt;T&gt; % memory);" />
      <MemberSignature Language="F#" Value="static member TryGetReadOnlyMemory : System.Buffers.ReadOnlySequence&lt;'T&gt; * ReadOnlyMemory -&gt; bool" Usage="System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory (sequence, memory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" />
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="1ffbf-107">Тип последовательности, доступной только для чтения.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-107">The type of the read-only sequence.</span></span></typeparam>
        <param name="sequence"><span data-ttu-id="1ffbf-108">Доступная только для чтения последовательность, из которой будет извлечена память.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-108">The read-only sequence from which the memory will be retrieved.</span></span></param>
        <param name="memory"><span data-ttu-id="1ffbf-109">Возвращенная память только для чтения типа T.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-109">The returned read-only memory of type T.</span></span></param>
        <summary><span data-ttu-id="1ffbf-110">Пытается получить доступную только для чтения память из указанной последовательности, доступной только для чтения.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-110">Attempts to retrieve a read-only memory from the specified read-only sequence.</span></span></summary>
        <returns><span data-ttu-id="1ffbf-111">Значение <see langword="true" />, если можно получить доступную только для чтения память; в противном случае —значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-111"><see langword="true" /> if the read-only memory can be retrieved; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetReadOnlySequenceSegment&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetReadOnlySequenceSegment&lt;T&gt; (System.Buffers.ReadOnlySequence&lt;T&gt; sequence, out System.Buffers.ReadOnlySequenceSegment&lt;T&gt; startSegment, out int startIndex, out System.Buffers.ReadOnlySequenceSegment&lt;T&gt; endSegment, out int endIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetReadOnlySequenceSegment&lt;T&gt;(valuetype System.Buffers.ReadOnlySequence`1&lt;!!T&gt; sequence, [out] class System.Buffers.ReadOnlySequenceSegment`1&lt;!!T&gt;&amp; startSegment, [out] int32&amp; startIndex, [out] class System.Buffers.ReadOnlySequenceSegment`1&lt;!!T&gt;&amp; endSegment, [out] int32&amp; endIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetReadOnlySequenceSegment(Of T) (sequence As ReadOnlySequence(Of T), ByRef startSegment As ReadOnlySequenceSegment(Of T), ByRef startIndex As Integer, ByRef endSegment As ReadOnlySequenceSegment(Of T), ByRef endIndex As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryGetReadOnlySequenceSegment(System::Buffers::ReadOnlySequence&lt;T&gt; sequence, [Runtime::InteropServices::Out] System::Buffers::ReadOnlySequenceSegment&lt;T&gt; ^ % startSegment, [Runtime::InteropServices::Out] int % startIndex, [Runtime::InteropServices::Out] System::Buffers::ReadOnlySequenceSegment&lt;T&gt; ^ % endSegment, [Runtime::InteropServices::Out] int % endIndex);" />
      <MemberSignature Language="F#" Value="static member TryGetReadOnlySequenceSegment : System.Buffers.ReadOnlySequence&lt;'T&gt; * ReadOnlySequenceSegment * int * ReadOnlySequenceSegment * int -&gt; bool" Usage="System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment (sequence, startSegment, startIndex, endSegment, endIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" />
        <Parameter Name="startSegment" Type="System.Buffers.ReadOnlySequenceSegment&lt;T&gt;" RefType="out" />
        <Parameter Name="startIndex" Type="System.Int32" RefType="out" />
        <Parameter Name="endSegment" Type="System.Buffers.ReadOnlySequenceSegment&lt;T&gt;" RefType="out" />
        <Parameter Name="endIndex" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="1ffbf-112">Тип последовательности, доступной только для чтения.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-112">The type of the read-only sequence.</span></span></typeparam>
        <param name="sequence"><span data-ttu-id="1ffbf-113">Доступная только для чтения последовательность, из которой будет извлечен сегмент последовательности только для чтения.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-113">The read-only sequence from which the read-only sequence segment will be retrieved.</span></span></param>
        <param name="startSegment"><span data-ttu-id="1ffbf-114">Начальный сегмент последовательности только для чтения.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-114">The beginning read-only sequence segment.</span></span></param>
        <param name="startIndex"><span data-ttu-id="1ffbf-115">Начальная позиция.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-115">The initial position.</span></span></param>
        <param name="endSegment"><span data-ttu-id="1ffbf-116">Конечный сегмент последовательности только для чтения.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-116">The ending read-only sequence segment.</span></span></param>
        <param name="endIndex"><span data-ttu-id="1ffbf-117">Конечная позиция.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-117">The final position.</span></span></param>
        <summary><span data-ttu-id="1ffbf-118">Пытается получить доступный только для чтения сегмент последовательности из указанной последовательности, доступной только для чтения.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-118">Attempts to retrieve a read-only sequence segment from the specified read-only sequence.</span></span></summary>
        <returns><span data-ttu-id="1ffbf-119">Значение <see langword="true" />, если можно получить доступный только для чтения сегмент последовательности; в противном случае —значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-119"><see langword="true" /> if the read-only sequence segment can be retrieved; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryRead&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryRead&lt;T&gt; (ref System.Buffers.SequenceReader&lt;byte&gt; reader, out T value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryRead&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Buffers.SequenceReader`1&lt;unsigned int8&gt;&amp; reader, [out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryRead(Of T As Structure) (ByRef reader As SequenceReader(Of Byte), ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool TryRead(System::Buffers::SequenceReader&lt;System::Byte&gt; % reader, [Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member TryRead : SequenceReader * 'T -&gt; bool (requires 'T : struct)" Usage="System.Runtime.InteropServices.SequenceMarshal.TryRead (reader, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Buffers.SequenceReader&lt;System.Byte&gt;" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="value" Type="T" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="1ffbf-120">Тип значения.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-120">The type of the value.</span></span></typeparam>
        <param name="reader"><span data-ttu-id="1ffbf-121">Ссылка на средство чтения последовательности.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-121">A reference to the sequence reader.</span></span></param>
        <param name="value"><span data-ttu-id="1ffbf-122">Возвращаемое значение, если чтение прошло успешно.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-122">The returned value if the read was successful.</span></span> <span data-ttu-id="1ffbf-123"><paramref name="value" /> будет иметь значение <see langword="default" />, если завершится сбоем (из-за нехватки места).</span><span class="sxs-lookup"><span data-stu-id="1ffbf-123"><paramref name="value" /> will be <see langword="default" /> if failed (due to lack of space).</span></span></param>
        <summary><span data-ttu-id="1ffbf-124">Пытается прочитать указанный тип из буфера.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-124">Attempts to read the specified type out of the buffer.</span></span> <span data-ttu-id="1ffbf-125">Использовать этот метод с произвольными структурами небезопасно — дополнительные сведения см. в примечаниях.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-125">It's dangerous to use this method with arbitrary structs - see remarks for more information.</span></span></summary>
        <returns><span data-ttu-id="1ffbf-126">Значение <see langword="true" />, если попытка чтения была успешной; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-126"><see langword="true" /> if the read attempt was successful, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> <span data-ttu-id="1ffbf-127">Read — это прямая копия битов.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-127">The read is a straight copy of bits.</span></span> <span data-ttu-id="1ffbf-128">Если структура зависит от конкретного состояния ее членов, это может привести к исключениям.</span><span class="sxs-lookup"><span data-stu-id="1ffbf-128">If a struct depends on the specific state of its members to behave correctly, this can lead to exceptions.</span></span> <span data-ttu-id="1ffbf-129">При чтении знаков с прямым порядком байтов используйте явные перегрузки, такие как [триреадлиттлиндиан (секуенцереадер\<Byte >, Int32)](xref:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian%2A).</span><span class="sxs-lookup"><span data-stu-id="1ffbf-129">If you're reading endian specific integers, use the explicit overloads such as [TryReadLittleEndian(SequenceReader\<Byte>, Int32)](xref:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian%2A).</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
