<Type Name="SequenceMarshal" FullName="System.Runtime.InteropServices.SequenceMarshal">
  <Metadata><Meta Name="ms.openlocfilehash" Value="487339d6814c5fbc0a74c07285523aab90d1fc98" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73389948" /></Metadata><TypeSignature Language="C#" Value="public static class SequenceMarshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit SequenceMarshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SequenceMarshal" />
  <TypeSignature Language="VB.NET" Value="Public Class SequenceMarshal" />
  <TypeSignature Language="C++ CLI" Value="public ref class SequenceMarshal abstract sealed" />
  <TypeSignature Language="F#" Value="type SequenceMarshal = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет коллекцию методов для взаимодействия с <see cref="T:System.Buffers.ReadOnlySequence`1" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="TryGetArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetArray&lt;T&gt; (System.Buffers.ReadOnlySequence&lt;T&gt; sequence, out ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetArray&lt;T&gt;(valuetype System.Buffers.ReadOnlySequence`1&lt;!!T&gt; sequence, [out] valuetype System.ArraySegment`1&lt;!!T&gt;&amp; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetArray(Of T) (sequence As ReadOnlySequence(Of T), ByRef segment As ArraySegment(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryGetArray(System::Buffers::ReadOnlySequence&lt;T&gt; sequence, [Runtime::InteropServices::Out] ArraySegment&lt;T&gt; % segment);" />
      <MemberSignature Language="F#" Value="static member TryGetArray : System.Buffers.ReadOnlySequence&lt;'T&gt; * ArraySegment -&gt; bool" Usage="System.Runtime.InteropServices.SequenceMarshal.TryGetArray (sequence, segment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" />
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип последовательности, доступной только для чтения.</typeparam>
        <param name="sequence">Доступная только для чтения последовательность, из которой будет извлечен сегмент массива.</param>
        <param name="segment">Возвращаемый сегмент массива.</param>
        <summary>Возвращает сегмент массива из базовой последовательности, доступной только для чтения.</summary>
        <returns>Значение <see langword="true" />, если можно извлечь сегмент массива; в противном случае — значение <see langword="false" /> и возвращается сегмент массива по умолчанию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetReadOnlyMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetReadOnlyMemory&lt;T&gt; (System.Buffers.ReadOnlySequence&lt;T&gt; sequence, out ReadOnlyMemory&lt;T&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetReadOnlyMemory&lt;T&gt;(valuetype System.Buffers.ReadOnlySequence`1&lt;!!T&gt; sequence, [out] valuetype System.ReadOnlyMemory`1&lt;!!T&gt;&amp; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetReadOnlyMemory(Of T) (sequence As ReadOnlySequence(Of T), ByRef memory As ReadOnlyMemory(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryGetReadOnlyMemory(System::Buffers::ReadOnlySequence&lt;T&gt; sequence, [Runtime::InteropServices::Out] ReadOnlyMemory&lt;T&gt; % memory);" />
      <MemberSignature Language="F#" Value="static member TryGetReadOnlyMemory : System.Buffers.ReadOnlySequence&lt;'T&gt; * ReadOnlyMemory -&gt; bool" Usage="System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory (sequence, memory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" />
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип последовательности, доступной только для чтения.</typeparam>
        <param name="sequence">Доступная только для чтения последовательность, из которой будет извлечена память.</param>
        <param name="memory">Возвращенная память только для чтения типа T.</param>
        <summary>Пытается получить доступную только для чтения память из указанной последовательности, доступной только для чтения.</summary>
        <returns>Значение <see langword="true" />, если можно получить доступную только для чтения память; в противном случае —значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetReadOnlySequenceSegment&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetReadOnlySequenceSegment&lt;T&gt; (System.Buffers.ReadOnlySequence&lt;T&gt; sequence, out System.Buffers.ReadOnlySequenceSegment&lt;T&gt; startSegment, out int startIndex, out System.Buffers.ReadOnlySequenceSegment&lt;T&gt; endSegment, out int endIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetReadOnlySequenceSegment&lt;T&gt;(valuetype System.Buffers.ReadOnlySequence`1&lt;!!T&gt; sequence, [out] class System.Buffers.ReadOnlySequenceSegment`1&lt;!!T&gt;&amp; startSegment, [out] int32&amp; startIndex, [out] class System.Buffers.ReadOnlySequenceSegment`1&lt;!!T&gt;&amp; endSegment, [out] int32&amp; endIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetReadOnlySequenceSegment(Of T) (sequence As ReadOnlySequence(Of T), ByRef startSegment As ReadOnlySequenceSegment(Of T), ByRef startIndex As Integer, ByRef endSegment As ReadOnlySequenceSegment(Of T), ByRef endIndex As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryGetReadOnlySequenceSegment(System::Buffers::ReadOnlySequence&lt;T&gt; sequence, [Runtime::InteropServices::Out] System::Buffers::ReadOnlySequenceSegment&lt;T&gt; ^ % startSegment, [Runtime::InteropServices::Out] int % startIndex, [Runtime::InteropServices::Out] System::Buffers::ReadOnlySequenceSegment&lt;T&gt; ^ % endSegment, [Runtime::InteropServices::Out] int % endIndex);" />
      <MemberSignature Language="F#" Value="static member TryGetReadOnlySequenceSegment : System.Buffers.ReadOnlySequence&lt;'T&gt; * ReadOnlySequenceSegment * int * ReadOnlySequenceSegment * int -&gt; bool" Usage="System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment (sequence, startSegment, startIndex, endSegment, endIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" />
        <Parameter Name="startSegment" Type="System.Buffers.ReadOnlySequenceSegment&lt;T&gt;" RefType="out" />
        <Parameter Name="startIndex" Type="System.Int32" RefType="out" />
        <Parameter Name="endSegment" Type="System.Buffers.ReadOnlySequenceSegment&lt;T&gt;" RefType="out" />
        <Parameter Name="endIndex" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип последовательности, доступной только для чтения.</typeparam>
        <param name="sequence">Доступная только для чтения последовательность, из которой будет извлечен сегмент последовательности только для чтения.</param>
        <param name="startSegment">Начальный сегмент последовательности только для чтения.</param>
        <param name="startIndex">Начальная позиция.</param>
        <param name="endSegment">Конечный сегмент последовательности только для чтения.</param>
        <param name="endIndex">Конечная позиция.</param>
        <summary>Пытается получить доступный только для чтения сегмент последовательности из указанной последовательности, доступной только для чтения.</summary>
        <returns>Значение <see langword="true" />, если можно получить доступный только для чтения сегмент последовательности; в противном случае —значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryRead&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryRead&lt;T&gt; (ref System.Buffers.SequenceReader&lt;byte&gt; reader, out T value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryRead&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Buffers.SequenceReader`1&lt;unsigned int8&gt;&amp; reader, [out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryRead(Of T As Structure) (ByRef reader As SequenceReader(Of Byte), ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool TryRead(System::Buffers::SequenceReader&lt;System::Byte&gt; % reader, [Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member TryRead : SequenceReader * 'T -&gt; bool (requires 'T : struct)" Usage="System.Runtime.InteropServices.SequenceMarshal.TryRead (reader, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Buffers.SequenceReader&lt;System.Byte&gt;" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" RefType="out" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип значения.</typeparam>
        <param name="reader">Ссылка на средство чтения последовательности.</param>
        <param name="value">Возвращаемое значение, если чтение прошло успешно. <paramref name="value" /> будет иметь значение <see langword="default" />, если завершится сбоем (из-за нехватки места).</param>
        <summary>Пытается прочитать указанный тип из буфера. Использовать этот метод с произвольными структурами небезопасно — дополнительные сведения см. в примечаниях.</summary>
        <returns>Значение <see langword="true" />, если попытка чтения была успешной; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> Read — это прямая копия битов. Если структура зависит от конкретного состояния ее членов, это может привести к исключениям. При чтении знаков с прямым порядком байтов используйте явные перегрузки, такие как [триреадлиттлиндиан (секуенцереадер\<Byte >, Int32)](xref:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian%2A).

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
