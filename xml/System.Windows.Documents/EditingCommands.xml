<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <Metadata><Meta Name="ms.openlocfilehash" Value="42f8c0d175aa546d564a5d631302619e015aea19" /><Meta Name="ms.sourcegitcommit" Value="f1d16425528e237257ca3b58eb49217a514849ea" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="04/24/2019" /><Meta Name="ms.locfileid" Value="64275551" /></Metadata><TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class EditingCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class EditingCommands abstract sealed" />
  <TypeSignature Language="F#" Value="type EditingCommands = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет стандартный набор команд изменения.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице показаны команды редактирования и связанного по умолчанию ключевых жестов (с именами ключей из <xref:System.Windows.Input.Key> и <xref:System.Windows.Input.ModifierKeys> перечисления).  
  
|Команда изменения|Ключевой жест по умолчанию|  
|---------------------|-------------------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|Нет знак клавиши по умолчанию|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`+`Shift`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|Нет знак клавиши по умолчанию|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`+`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`+`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`+`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`+`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`+`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`+`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`+`Shift`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`+`Shift`+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`+`U`|  
  
 Команды перемещения курсора и расширения команды выбора, совместно используют общий набор жестов ключа по умолчанию, общие разницей, добавление <xref:System.Windows.Input.ModifierKeys.Shift> клавишу, чтобы отличать команды выбора из команды перемещения курсора.  Например <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> команда имеет ключевой жест по умолчанию из <xref:System.Windows.Input.Key.Left>и соответствующих <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> команда имеет ключевой жест по умолчанию из <xref:System.Windows.Input.ModifierKeys.Shift> + <xref:System.Windows.Input.Key.Left>.  
  
 Вообще говоря, определения команд, предоставляемых <xref:System.Windows.Documents.EditingCommands> класс не следует использовать параметры команды ( `parameter` ожидаемый параметр <xref:System.Windows.Input.ICommand.Execute%2A> метод).  
  
 Дополнительные сведения о командах и их выполнении см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignCenter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignCenter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignCenter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />, которая запрашивает, чтобы текущий абзац или выборка абзацев выравнивались по центру.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="E" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда работает в <xref:System.Windows.Documents.Paragraph> уровень.  Если эта команда вызывается по части выборки содержимого в абзац (включая пустое выделение, если курсор находится в пределах абзаца), запрошенное действие применяется ко всему абзацу.  Если эта команда вызывается по выборке, которая охватывает несколько абзацев, эффект применяется ко всему содержимому каждого абзаца, который участвует в выделении.  
  
 Следующий рисунок является примером содержимого по центру.  
  
 ![Снимок экрана: Значение свойства TextAlign для Center](~/add/media/flowdoc-textalign-center.png "снимок экрана: Значение свойства TextAlign для Center")  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignJustify As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignJustify { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignJustify : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />, которая запрашивает выравнивание данного абзаца или выборки абзацев.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="J" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда работает в <xref:System.Windows.Documents.Paragraph> уровень.  Если эта команда вызывается по части выборки содержимого в абзац (включая пустое выделение, если курсор находится в пределах абзаца), запрошенное действие применяется ко всему абзацу.  Если эта команда вызывается по выборке, которая охватывает несколько абзацев, эффект применяется ко всем абзацам в выделении.  
  
 Когда содержимое выровнено, интервал по горизонтали в пределах каждой строки содержимого корректируются таким образом, чтобы выровненные строки были равны или приблизительно равной ширины.  Содержимое обычно выравнивается, чтобы создать сглаживания на краях содержимого.  
  
 Так как это часто короче, чем остальные, последняя строка в абзаце может остаться не выровненной после вызова этой команды.  
  
 На следующем рисунке показана выровнено содержимого (по левому краю).  
  
 ![Снимок экрана: Содержимое не выровнено](~/add/media/content-unjustified.png "снимок экрана: Содержимое не выровнено")  
  
 Следующий рисунок показывает то же содержимое после выравнивания.  
  
 ![Снимок экрана содержимого по ширине текста](~/add/media/content-justified.png "снимок содержимого по ширине текста")  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignLeft : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />, которая запрашивает выравнивание по левому краю выборки содержимого.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="L" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда работает в <xref:System.Windows.Documents.Paragraph> уровень.  Если эта команда вызывается по части выборки содержимого в абзац (включая пустое выделение, если курсор находится в пределах абзаца), запрошенное действие применяется ко всему абзацу.  Если эта команда вызывается по выборке, которая охватывает несколько абзацев, эффект применяется ко всему содержимому каждого абзаца, который участвует в выделении.  
  
 Следующий рисунок показывает пример содержимого с выравниванием по левому краю.  
  
 ![Снимок экрана: Значение свойства TextAlign для Left](~/add/media/flowdoc-textalign-left.png "снимок экрана: Значение свойства TextAlign для Left")  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignRight : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.AlignRight" />, которая запрашивает выравнивание по правому краю выборки содержимого.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="R" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда работает в <xref:System.Windows.Documents.Paragraph> уровень.  Если эта команда вызывается по части выборки содержимого в абзац (включая пустое выделение, если курсор находится в пределах абзаца), запрошенное действие применяется ко всему абзацу.  Если эта команда вызывается по выборке, которая охватывает несколько абзацев, эффект применяется ко всему содержимому каждого абзаца, который участвует в выделении.  
  
 Следующий рисунок является примером содержимое по правому краю.  
  
 ![Снимок экрана: Значение Right свойства TextAlign](~/add/media/flowdoc-textalign-right.png "снимок экрана: Значение Right свойства TextAlign")  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Backspace As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Backspace { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Backspace : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Backspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.Backspace" />, которая запрашивает нажатие клавиши "backspace" в текущей позиции или в отношении текущей выборки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове в пустой выборке, эта команда удаляет символ или разделитель абзаца прямо перед курсором. При вызове для выделенной области пустым, эта команда удаляет выделение.  
  
 Эта команда сохраняет любое форматирование удаленной выборки, для содержимого, вставленного в одном месте после вызова этой команды.  Сравните с <xref:System.Windows.Documents.EditingCommands.Delete%2A> команду, которая не сохраняет предыдущих форматирование.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrectSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ CorrectSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CorrectSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />, которая запрашивает исправление любой орфографической ошибки в слове в текущей позиции.</summary>
        <value>Запрошенная команда.  Для данной команды отсутствует знак клавиши по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />, которая запрашивает уменьшение размера шрифта для текущей выборки на 1 пкт.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="OemOpenBrackets" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если эта команда вызывается пустое выделение, если курсор находится внутри слова, выборка автоматически расширяется для применения команды ко всему слову.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />, которая запрашивает уменьшение отступа для текущего абзаца на одну позицию табуляции.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="T" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  Эта команда не влияет на элемент текста Если <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> текстового элемента свойству `true`.  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Delete As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Delete { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Delete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.Delete" />, которая запрашивает удаление текущей выборки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда отменяет любое форматирование удаленной выборки.  Сравните с <xref:System.Windows.Documents.EditingCommands.Backspace%2A> команду, которая сохраняет любое форматирование из удаленной выборки, для содержимого, вставленного в одном месте после вызова этой команды.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Delete"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="Delete"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeleteNextWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeleteNextWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteNextWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />, которая запрашивает удаление следующего слова (относительно текущей позиции).</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится внутри слова, оставшаяся часть слова между текущей позицией и концом слова удаляется.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeletePreviousWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeletePreviousWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeletePreviousWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />, которая запрашивает удаление предыдущего слова (относительно текущей позиции).</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится внутри слова, оставшаяся часть слова между текущей позиции и началом слова удаляется.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterLineBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterLineBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterLineBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />, которая запрашивает вставку разрыва строки в текущей позиции или в отношении текущей выборки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Shift" /> + <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для редакторов, которые поддерживают поток содержимого, такие как <xref:System.Windows.Controls.RichTextBox>, этой команды <xref:System.Windows.Documents.LineBreak> элемента для вставки в текущей позиции.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox> и <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterParagraphBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterParagraphBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterParagraphBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />, которая запрашивает вставку разрыва абзаца в текущей позиции или в отношении текущей выборки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда является эквивалентом пользователю, нажав клавишу ВВОД.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox> и <xref:System.Windows.Controls.TextBox> (когда <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> свойство `true`).  
  
> [!IMPORTANT]
>  Эта команда не влияет на элемент текста Если <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> текстового элемента свойству `true`.  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IgnoreSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IgnoreSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />, которая запрашивает игнорирование любых орфографических ошибок в словах в текущей позиции или в текущей выборке.</summary>
        <value>Запрошенная команда.  Для данной команды отсутствует знак клавиши по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />, которая запрашивает увеличения размера шрифта для текущей выборки на 1 пкт.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="OemCloseBrackets" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если эта команда вызывается пустое выделение, если курсор находится внутри слова, выделение расширяется для применения команды ко всему слову.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />, которая запрашивает увеличение отступа для текущего абзаца на одну позицию табуляции.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="T" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  Эта команда не влияет на элемент текста Если <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> текстового элемента свойству `true`.  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />, которая запрашивает переход курсора вниз на одну строку.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox> и <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />, которая запрашивает переход курсора вниз на одну страницу.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox> и <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />, которая запрашивает переход курсора вниз на один абзац.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда устанавливает курсор в начало следующего абзаца.  
  
 Эта команда ведет себя как <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> при вызове <xref:System.Windows.Controls.TextBox>.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox> и <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />, которая запрашивает переход курсора влево на один символ.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />, которая запрашивает переход курсора влево на одно слово.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится внутри слова, эта команда перемещает курсор в начало этого слова.  В противном случае эта команда перемещает курсор в начало предыдущего слова.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />, которая запрашивает переход курсора вправо на один символ.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />, которая запрашивает переход курсора вправо на одно слово.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится внутри слова, эта команда перемещает курсор в конец этого слова.  В противном случае эта команда перемещает курсор в начало следующего слова.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />, которая запрашивает перемещение курсора в конец содержимого.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект *контейнера текста* является элементом, который образует конечную границу для содержимого под рукой.  <xref:System.Windows.Controls.TextBlock> и <xref:System.Windows.Documents.FlowDocument> являются примерами текстовых контейнеров.  Собирательно содержимое в текстовом контейнере называется *документа*.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />, которая запрашивает перемещение курсора в начало содержимого.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект *контейнера текста* является элементом, который образует конечную границу для содержимого под рукой.  <xref:System.Windows.Controls.TextBlock> и <xref:System.Windows.Documents.FlowDocument> являются примерами текстовых контейнеров.  Собирательно содержимое в текстовом контейнере называется *документа*.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />, которая запрашивает перемещение курсора в конец текущей строки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />, которая запрашивает перемещение курсора в начало текущей строки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />, которая запрашивает переход курсора вверх на одну строку.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox> и <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />, которая запрашивает переход курсора вверх на одну страницу.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox> и <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />, которая запрашивает переход курсора вверх на один абзац.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда устанавливает курсор в начало следующего абзаца.  
  
 Эта команда ведет себя как <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> при вызове <xref:System.Windows.Controls.TextBox>.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox> и <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />, которая запрашивает расширение текущей выборки на одну строку вниз.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Shift" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />, которая запрашивает расширение текущей выборки на одну страницу вниз.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Shift" /> + <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />, которая запрашивает расширение текущей выборки на один абзац вниз.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда расширяет выделение до начала следующего абзаца.  В противном случае команда расширяет выделение до конца текущего абзаца.  Развернутый элемент включает разделитель абзаца, отмечающий конец абзаца.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />, которая запрашивает расширение текущей выборки на один символ влево.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Shift" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />, которая запрашивает расширение текущей выборки на одно слово влево.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится внутри слова, эта команда расширяет выделение до начала данного слова.  В противном случае эта команда расширяет выделение до начала предыдущего слова.  
  
 Развернутый элемент не включает разделитель слова.  Сравните с <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>, который включает разделитель слова в развернутый элемент.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />, которая запрашивает расширение текущей выборки на один символ вправо.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Shift" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />, которая запрашивает расширение текущей выборки на одно слово вправо.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится внутри слова, данная команда расширяет выделение до конца этого слова.  В противном случае команда расширяет выделение до конца массива следующего слова.  
  
 Развернутый элемент включает разделитель слова.  Сравните с <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> которого не включает разделитель слова в развернутый элемент.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />, которая запрашивает расширение текущей выборки в конец содержимого.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект *контейнера текста* является элементом, который образует конечную границу для содержимого под рукой.  <xref:System.Windows.Controls.TextBlock> и <xref:System.Windows.Documents.FlowDocument> являются примерами текстовых контейнеров.  Собирательно содержимое в текстовом контейнере называется *документа*.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />, которая запрашивает расширение текущей выборки в начало содержимого.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект *контейнера текста* является элементом, который образует конечную границу для содержимого под рукой.  <xref:System.Windows.Controls.TextBlock> и <xref:System.Windows.Documents.FlowDocument> являются примерами текстовых контейнеров.  Собирательно содержимое в текстовом контейнере называется *документа*.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />, которая запрашивает расширение текущей выборки в конец текущей строки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Shift" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />, которая запрашивает расширение текущей выборки в начало текущей строки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Shift" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />, которая запрашивает расширение текущей выборки на одну строку вверх.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Shift" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />, которая запрашивает расширение текущей выборки на одну страницу вверх.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Shift" /> + <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />, которая запрашивает расширение текущей выборки на один абзац вверх.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится в начале абзаца, эта команда расширяет выделение до начала предыдущего абзаца.  В противном случае эта команда расширяет выделение до начала текущего абзаца.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabBackward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabBackward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabBackward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.TabBackward" />.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Shift" /> + <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поведение для этой команды зависит от текущего выделения. Если выделение является пустым, эта команда эквивалентна <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>. Если курсор находится в ячейке таблицы (представленный <xref:System.Windows.Documents.TableCell> элемент), эта команда перемещает курсор к предыдущей ячейке. В противном случае символ табуляции вставляется в текущей позиции.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox> и <xref:System.Windows.Controls.TextBox> (когда <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> свойство `true`).  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabForward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.TabForward" />.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поведение для этой команды зависит от текущего выделения. Если выделение является пустым, или если выделение является пустым, и текущее положение курсора находится в начале абзаца, эта команда эквивалентна <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>. Если курсор находится в ячейке таблицы (представленный <xref:System.Windows.Documents.TableCell> элемент), эта команда перемещает курсор к следующей ячейке. Если курсор находится в последней ячейке таблицы, эта команда запускает новую строку для добавления в таблицу, а курсор располагается в первой ячейке новой строки.  В противном случае символ табуляции вставляется в текущей позиции.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox> и <xref:System.Windows.Controls.TextBox> (когда <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> свойство `true`).  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBold As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBold { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBold : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />, которая запрашивает, чтобы форматирование <see cref="T:System.Windows.Documents.Bold" /> переключилось на текущую выборку.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="B" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.FontWeight> для текущий выделенный фрагмент находится в диапазоне от <xref:System.Windows.FontWeights.Thin%2A> для <xref:System.Windows.FontWeights.SemiBold%2A>, <xref:System.Windows.FontWeights.Bold%2A> применяется к текущему выделению.  В противном случае <xref:System.Windows.FontWeights.Normal%2A> применяется.  Сравнительный список <xref:System.Windows.FontWeight> значения, см. в разделе <xref:System.Windows.FontWeights>.  
  
 Если выделение является пустым и курсор находится внутри слова, выделение расширяется для включения слово целиком.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBullets As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBullets { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBullets : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" />, которая запрашивает переключение форматирования маркированного списка на текущую выборку.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="L" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда работает в <xref:System.Windows.Documents.Paragraph> уровень.  Если эта команда вызывается по части выборки содержимого в абзац (включая пустое выделение, если курсор находится в пределах абзаца), запрошенное действие применяется ко всему абзацу.  Если эта команда вызывается по выборке, которая охватывает несколько абзацев, эффект применяется ко всему содержимому каждого абзаца, который участвует в выделении.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleInsert As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleInsert { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleInsert : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" />, которая переключает режимы вставки и замены.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Insert" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleItalic As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleItalic { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleItalic : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />, которая запрашивает, чтобы форматирование <see cref="T:System.Windows.Documents.Italic" /> переключилось на текущую выборку.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="I" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.FontStyle> для текущего выделения — <xref:System.Windows.FontStyles.Normal%2A>, <xref:System.Windows.FontStyles.Italic%2A> применяется к текущему выделению.  В противном случае <xref:System.Windows.FontStyles.Normal%2A> применяется.  
  
 Если выделение является пустым и курсор находится внутри слова, выделение расширяется для включения слово целиком.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleNumbering As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleNumbering { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleNumbering : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />, которая запрашивает переключение форматирования упорядоченного списка (также называемый нумерованным списком) на текущую выборку.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="N" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда работает в <xref:System.Windows.Documents.Paragraph> уровень.  Если эта команда вызывается по части выборки содержимого в абзац (включая пустое выделение, если курсор находится в пределах абзаца), запрошенное действие применяется ко всему абзацу.  Если эта команда вызывается по выборке, которая охватывает несколько абзацев, эффект применяется ко всему содержимому каждого абзаца, который участвует в выделении.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSubscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSubscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSubscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />, которая запрашивает, чтобы форматирование нижнего индекса переключилось на текущую выборку.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="OemPlus" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSuperscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSuperscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSuperscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />, которая запрашивает, чтобы форматирование верхнего индекса переключилось на текущую выборку.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="OemPlus" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleUnderline As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleUnderline { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleUnderline : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />, которая запрашивает, чтобы форматирование <see cref="T:System.Windows.Documents.Underline" /> переключилось на текущую выборку.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для этой команды является <see langword="Ctrl" /> + <see langword="U" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если выделение является пустым и курсор находится внутри слова, выделение расширяется для включения слово целиком.  
  
 Не обязательно фактической реализации, которая отвечает на эту команду для каждого конкретного объекта; Во многих случаях реализация, которая отвечает на команду отвечает разработчик приложения.  
  
 Эта команда поддерживается <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов команды изменения на объекте, который поддерживает команды.  
  
 В этом примере <xref:System.Windows.Controls.RichTextBox> служит в качестве целевого объекта команды.  Обратите внимание, что <xref:System.Windows.Controls.RichTextBox> реализует <xref:System.Windows.IInputElement> интерфейс (наследуется от <xref:System.Windows.FrameworkElement>), и что он включает встроенную поддержку для многих команд редактирования.  
  
 Первый аргумент для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметром команды.  Большинство команд изменения игнорируют параметр команды; как правило, этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, к которому будут направляться команды.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейсов и должна включать обработчик для указанной команды.  Как правило команды учитывается при вызове объекта, которое не обрабатывает команды.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>