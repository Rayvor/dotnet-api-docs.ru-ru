<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e548e08b556eb3bea554b24d86bbc3a1cc4dbe43" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69208816" /></Metadata><TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class EditingCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class EditingCommands abstract sealed" />
  <TypeSignature Language="F#" Value="type EditingCommands = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет стандартный набор команд изменения.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице показаны команды редактирования и связанные с ними жесты клавиш по умолчанию (с именами ключей <xref:System.Windows.Input.Key> из <xref:System.Windows.Input.ModifierKeys> перечислений и).  
  
|Команда редактирования|Жест клавиши по умолчанию|  
|---------------------|-------------------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|нет жеста клавиши по умолчанию|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`+`Shift`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|нет жеста клавиши по умолчанию|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`+`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`+`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`+`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`+`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`+`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`+`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`+`Shift`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`+`Shift`+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`+`U`|  
  
 Команды перемещения курсора и расширение выбора команды разделяют общий набор жестов клавиш по умолчанию. общее различие заключается в добавлении <xref:System.Windows.Input.ModifierKeys.Shift> ключа для различения команд выбора из команд перемещения курсора.  Например, <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> команда имеет <xref:System.Windows.Input.ModifierKeys.Shift> <xref:System.Windows.Input.Key.Left>жест клавиши по умолчанию, а соответствующая <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> команда имеет клавишу + <xref:System.Windows.Input.Key.Left>по умолчанию.  
  
 В общем случае определения команд, предоставляемые <xref:System.Windows.Documents.EditingCommands> классом, не используют параметры команды `parameter` (параметр, ожидаемый <xref:System.Windows.Input.ICommand.Execute%2A> методом).  
  
 Дополнительные сведения о командах и командах см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignCenter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignCenter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignCenter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />, которая запрашивает, чтобы текущий абзац или выборка абзацев выравнивались по центру.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="E" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда работает на <xref:System.Windows.Documents.Paragraph> уровне.  Если эта команда вызывается для частичного выделения содержимого в абзаце (включая пустое выделение, в котором курсор находится внутри абзаца), запрошенный результат применяется ко всему абзацу.  Если эта команда вызывается для выделения, охватывающего несколько абзацев, то этот результат применяется ко всему содержимому каждого абзаца, участвующего в выборе.  
  
 На следующем рисунке показан пример содержимого с выравниванием по центру.  
  
 ![Снимок экрана Значение свойства TextAlign для снимка центра]:(~/add/media/flowdoc-textalign-center.png " Свойство TextAlign для значения Center")  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignJustify As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignJustify { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignJustify : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />, которая запрашивает выравнивание данного абзаца или выборки абзацев.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="J" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда работает на <xref:System.Windows.Documents.Paragraph> уровне.  Если эта команда вызывается для частичного выделения содержимого в абзаце (включая пустое выделение, в котором курсор находится внутри абзаца), запрошенный результат применяется ко всему абзацу.  Если эта команда вызывается для выделения, охватывающего несколько абзацев, то этот результат применяется ко всем абзацам в выделенном фрагменте.  
  
 Когда содержимое выравнивается по ширине, интервал по горизонтали в каждой строке содержимого корректируется таким образом, чтобы выровненные линии были одинаковыми или близкими к ширине.  Обычно содержимое выравнивается для создания гладких краев на сторонах содержимого.  
  
 Так как часто бывает короче остальных, последняя строка в абзаце может остаться невыровненной после вызова этой команды.  
  
 На следующем рисунке показано невыровненное (выровненное по левому краю) содержимое.  
  
 ![Снимок экрана Содержимое не выровнено](~/add/media/content-unjustified.png "на снимке экрана: Содержимое не выровнено")  
  
 На следующем рисунке показано то же содержимое после выравнивания.  
  
 ![Снимок экрана: текст, выровненный по ширине содержимого] (~/add/media/content-justified.png "Снимок экрана: текст, выровненный по ширине содержимого")  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignLeft : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />, которая запрашивает выравнивание по левому краю выборки содержимого.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="L" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда работает на <xref:System.Windows.Documents.Paragraph> уровне.  Если эта команда вызывается для частичного выделения содержимого в абзаце (включая пустое выделение, в котором курсор находится внутри абзаца), запрошенный результат применяется ко всему абзацу.  Если эта команда вызывается для выделения, охватывающего несколько абзацев, то этот результат применяется ко всему содержимому каждого абзаца, участвующего в выборе.  
  
 На следующем рисунке показан пример содержимого, выданного по левому краю.  
  
 ![Снимок экрана Значение свойства TextAlign для левого](~/add/media/flowdoc-textalign-left.png "снимка экрана: TextAlign значение свойства Left")  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignRight : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.AlignRight" />, которая запрашивает выравнивание по правому краю выборки содержимого.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="R" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда работает на <xref:System.Windows.Documents.Paragraph> уровне.  Если эта команда вызывается для частичного выделения содержимого в абзаце (включая пустое выделение, в котором курсор находится внутри абзаца), запрошенный результат применяется ко всему абзацу.  Если эта команда вызывается для выделения, охватывающего несколько абзацев, то этот результат применяется ко всему содержимому каждого абзаца, участвующего в выборе.  
  
 На следующем рисунке показан пример содержимого, выходящего по правому краю.  
  
 ![Снимок экрана Значение TextAlign правильного](~/add/media/flowdoc-textalign-right.png "снимка экрана: TextAlign значение справа")  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Backspace As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Backspace { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Backspace : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Backspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.Backspace" />, которая запрашивает нажатие клавиши "backspace" в текущей позиции или в отношении текущей выборки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове для пустого выделения эта команда удаляет разделитель символов или абзаца непосредственно перед курсором. При вызове для непустого выделения эта команда удаляет выбранный фрагмент.  
  
 Эта команда оставляет все форматирование из удаленного выделения для содержимого, которое сразу же вставляется в то же расположение после вызова этой команды.  Сравните с <xref:System.Windows.Documents.EditingCommands.Delete%2A> командой, которая не удерживает предыдущее форматирование.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrectSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ CorrectSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CorrectSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />, которая запрашивает исправление любой орфографической ошибки в слове в текущей позиции.</summary>
        <value>Запрошенная команда.  Для данной команды отсутствует знак клавиши по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />, которая запрашивает уменьшение размера шрифта для текущей выборки на 1 пкт.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="OemOpenBrackets" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если эта команда вызывается для пустого выделения, в котором курсор находится внутри слова, выбор автоматически расширяется, чтобы применить команду ко всему слову.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />, которая запрашивает уменьшение отступа для текущего абзаца на одну позицию табуляции.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Shift" /> + <see langword="T" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  Эта команда не влияет на текстовый элемент, если <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> свойство текстового элемента не имеет `true`значение.  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Delete As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Delete { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Delete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.Delete" />, которая запрашивает удаление текущей выборки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда отменяет все форматирование из удаленного выделения.  Сравните с <xref:System.Windows.Documents.EditingCommands.Backspace%2A> командой, которая оставляет все форматирование из удаленного выделения для содержимого, которое сразу же вставляется в то же место после вызова этой команды.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Delete"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="Delete"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeleteNextWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeleteNextWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteNextWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />, которая запрашивает удаление следующего слова (относительно текущей позиции).</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Delete" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится внутри слова, то оставшаяся часть слова между текущей позицией и концом слова удаляется.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeletePreviousWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeletePreviousWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeletePreviousWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />, которая запрашивает удаление предыдущего слова (относительно текущей позиции).</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Backspace" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится внутри слова, то оставшаяся часть слова между текущей позицией и началом слова удаляется.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterLineBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterLineBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterLineBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />, которая запрашивает вставку разрыва строки в текущей позиции или в отношении текущей выборки.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Shift" />команды является. + <see langword="Enter" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для редакторов, поддерживающих содержимое нефиксированного формата, например <xref:System.Windows.Controls.RichTextBox>, эта команда <xref:System.Windows.Documents.LineBreak> приводит к вставке элемента в текущую точку.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox> и. <xref:System.Windows.Controls.TextBox>  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterParagraphBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterParagraphBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterParagraphBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />, которая запрашивает вставку разрыва абзаца в текущей позиции или в отношении текущей выборки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда эквивалентна пользователю, нажимая клавишу ВВОД.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально <xref:System.Windows.Controls.RichTextBox> поддерживается и <xref:System.Windows.Controls.TextBox> (если <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> свойство имеет `true`значение).  
  
> [!IMPORTANT]
>  Эта команда не влияет на текстовый элемент, если <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> свойство текстового элемента не имеет `true`значение.  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IgnoreSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IgnoreSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />, которая запрашивает игнорирование любых орфографических ошибок в словах в текущей позиции или в текущей выборке.</summary>
        <value>Запрошенная команда.  Для данной команды отсутствует знак клавиши по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />, которая запрашивает увеличения размера шрифта для текущей выборки на 1 пкт.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="OemCloseBrackets" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если эта команда вызывается для пустого выделения, где курсор находится внутри слова, выбор расширяется для применения команды ко всему слову.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />, которая запрашивает увеличение отступа для текущего абзаца на одну позицию табуляции.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="T" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  Эта команда не влияет на текстовый элемент, если <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> свойство текстового элемента не имеет `true`значение.  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />, которая запрашивает переход курсора вниз на одну строку.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox> и. <xref:System.Windows.Controls.TextBox>  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />, которая запрашивает переход курсора вниз на одну страницу.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox> и. <xref:System.Windows.Controls.TextBox>  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />, которая запрашивает переход курсора вниз на один абзац.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Down" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда размещает курсор в начале следующего абзаца.  
  
 Эта команда ведет себя так же <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> , как при вызове <xref:System.Windows.Controls.TextBox>для.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox> и. <xref:System.Windows.Controls.TextBox>  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />, которая запрашивает переход курсора влево на один символ.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />, которая запрашивает переход курсора влево на одно слово.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Left" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится внутри слова, эта команда перемещает курсор в начало этого слова.  В противном случае эта команда перемещает курсор в начало предыдущего слова.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />, которая запрашивает переход курсора вправо на один символ.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />, которая запрашивает переход курсора вправо на одно слово.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Right" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится внутри слова, эта команда перемещает курсор в конец этого слова.  В противном случае эта команда перемещает курсор в начало следующего слова.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />, которая запрашивает перемещение курсора в конец содержимого.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="End" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Текстовый контейнер* — это элемент, который формирует конечную границу для содержимого.  <xref:System.Windows.Controls.TextBlock>и <xref:System.Windows.Documents.FlowDocument> являются примерами текстовых контейнеров.  Содержимое, которое совместно содержится в контейнере текста, называется документом. **  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />, которая запрашивает перемещение курсора в начало содержимого.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Home" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Текстовый контейнер* — это элемент, который формирует конечную границу для содержимого.  <xref:System.Windows.Controls.TextBlock>и <xref:System.Windows.Documents.FlowDocument> являются примерами текстовых контейнеров.  Содержимое, которое совместно содержится в контейнере текста, называется документом. **  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />, которая запрашивает перемещение курсора в конец текущей строки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />, которая запрашивает перемещение курсора в начало текущей строки.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />, которая запрашивает переход курсора вверх на одну строку.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox> и. <xref:System.Windows.Controls.TextBox>  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />, которая запрашивает переход курсора вверх на одну страницу.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox> и. <xref:System.Windows.Controls.TextBox>  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />, которая запрашивает переход курсора вверх на один абзац.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Up" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда размещает курсор в начале следующего абзаца.  
  
 Эта команда ведет себя так же <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> , как при вызове <xref:System.Windows.Controls.TextBox>для.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox> и. <xref:System.Windows.Controls.TextBox>  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />, которая запрашивает расширение текущей выборки на одну строку вниз.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Shift" />команды является. + <see langword="Down" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />, которая запрашивает расширение текущей выборки на одну страницу вниз.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Shift" />команды является. + <see langword="PageDown" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />, которая запрашивает расширение текущей выборки на один абзац вниз.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Shift" /> + <see langword="Down" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда расширяет выделенный фрагмент до начала следующего абзаца.  В противном случае эта команда расширяет выбор до конца текущего абзаца.  Расширенное выделение включает разрыв абзаца, обозначающий конец абзаца.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />, которая запрашивает расширение текущей выборки на один символ влево.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Shift" />команды является. + <see langword="Left" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />, которая запрашивает расширение текущей выборки на одно слово влево.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Shift" /> + <see langword="Left" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится внутри слова, эта команда расширяет выделение до начала этого слова.  В противном случае эта команда расширяет выбор до начала предыдущего слова.  
  
 Расширенное выделение не включает в себя разделитель слов.  Сравните с <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>, который включает разделитель слов в развернутом выделенном фрагменте.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />, которая запрашивает расширение текущей выборки на один символ вправо.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Shift" />команды является. + <see langword="Right" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />, которая запрашивает расширение текущей выборки на одно слово вправо.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Shift" /> + <see langword="Right" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится внутри слова, эта команда расширяет выделение до конца этого слова.  В противном случае эта команда расширяет выделение до конца следующего слова.  
  
 Расширенное выделение включает в себя разделитель слов.  Сравните с <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> тем, что не включает разделитель слов в развернутом фрагменте.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />, которая запрашивает расширение текущей выборки в конец содержимого.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Shift" /> + <see langword="End" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Текстовый контейнер* — это элемент, который формирует конечную границу для содержимого.  <xref:System.Windows.Controls.TextBlock>и <xref:System.Windows.Documents.FlowDocument> являются примерами текстовых контейнеров.  Содержимое, которое совместно содержится в контейнере текста, называется документом. **  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />, которая запрашивает расширение текущей выборки в начало содержимого.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Shift" /> + <see langword="Home" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Текстовый контейнер* — это элемент, который формирует конечную границу для содержимого.  <xref:System.Windows.Controls.TextBlock>и <xref:System.Windows.Documents.FlowDocument> являются примерами текстовых контейнеров.  Содержимое, которое совместно содержится в контейнере текста, называется документом. **  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />, которая запрашивает расширение текущей выборки в конец текущей строки.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Shift" />команды является. + <see langword="End" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />, которая запрашивает расширение текущей выборки в начало текущей строки.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Shift" />команды является. + <see langword="Home" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />, которая запрашивает расширение текущей выборки на одну строку вверх.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Shift" />команды является. + <see langword="Up" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />, которая запрашивает расширение текущей выборки на одну страницу вверх.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Shift" />команды является. + <see langword="PageUp" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />, которая запрашивает расширение текущей выборки на один абзац вверх.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Shift" /> + <see langword="Up" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если курсор находится в начале абзаца, эта команда расширяет выделенный фрагмент до начала предыдущего абзаца.  В противном случае эта команда расширяет выделенный фрагмент до начала текущего абзаца.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabBackward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabBackward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabBackward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.TabBackward" />.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Shift" />команды является. + <see langword="Tab" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поведение этой команды зависит от текущего выбора. Если выделение не пусто, эта команда эквивалентна <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>. Если курсор находится в ячейке таблицы (представленной <xref:System.Windows.Documents.TableCell> элементом), эта команда перемещает курсор в предыдущую ячейку. В противном случае в текущей позиции вставляется символ табуляции.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально <xref:System.Windows.Controls.RichTextBox> поддерживается и <xref:System.Windows.Controls.TextBox> (если <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> свойство имеет `true`значение).  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabForward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.TabForward" />.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поведение этой команды зависит от текущего выбора. Если выделение не пусто или если выделение пусто, а текущая курсор находится в начале абзаца, эта команда эквивалентна <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>. Если курсор находится в ячейке таблицы (представленной <xref:System.Windows.Documents.TableCell> элементом), эта команда перемещает курсор в следующую ячейку. Если курсор находится в последней ячейке таблицы, эта команда вызывает добавление новой строки в таблицу с курсором, расположенным в первой ячейке новой строки.  В противном случае в текущей позиции вставляется символ табуляции.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально <xref:System.Windows.Controls.RichTextBox> поддерживается и <xref:System.Windows.Controls.TextBox> (если <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> свойство имеет `true`значение).  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBold As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBold { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBold : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />, которая запрашивает, чтобы форматирование <see cref="T:System.Windows.Documents.Bold" /> переключилось на текущую выборку.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="B" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если объект <xref:System.Windows.FontWeight> для текущего выделения находится в диапазоне от <xref:System.Windows.FontWeights.Thin%2A> до <xref:System.Windows.FontWeights.SemiBold%2A>, <xref:System.Windows.FontWeights.Bold%2A> то применяется к текущему выделению.  <xref:System.Windows.FontWeights.Normal%2A> В противном случае применяется.  Сравнительный список <xref:System.Windows.FontWeight> значений см. в разделе <xref:System.Windows.FontWeights>.  
  
 Если выделение пусто и курсор находится внутри слова, выделение расширяется и включает слово целиком.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBullets As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBullets { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBullets : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" />, которая запрашивает переключение форматирования маркированного списка на текущую выборку.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Shift" /> + <see langword="L" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда работает на <xref:System.Windows.Documents.Paragraph> уровне.  Если эта команда вызывается для частичного выделения содержимого в абзаце (включая пустое выделение, в котором курсор находится внутри абзаца), запрошенный результат применяется ко всему абзацу.  Если эта команда вызывается для выделения, охватывающего несколько абзацев, то этот результат применяется ко всему содержимому каждого абзаца, участвующего в выборе.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleInsert As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleInsert { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleInsert : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" />, которая переключает режимы вставки и замены.</summary>
        <value>Запрошенная команда.  Знаком клавиши по умолчанию для данной команды является <see langword="Insert" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>и <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleItalic As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleItalic { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleItalic : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />, которая запрашивает, чтобы форматирование <see cref="T:System.Windows.Documents.Italic" /> переключилось на текущую выборку.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="I" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для текущего выделения задано <xref:System.Windows.FontStyles.Normal%2A>значение, <xref:System.Windows.FontStyles.Italic%2A> применяется к текущему выделению. <xref:System.Windows.FontStyle>  <xref:System.Windows.FontStyles.Normal%2A> В противном случае применяется.  
  
 Если выделение пусто и курсор находится внутри слова, выделение расширяется и включает слово целиком.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleNumbering As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleNumbering { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleNumbering : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />, которая запрашивает переключение форматирования упорядоченного списка (также называемый нумерованным списком) на текущую выборку.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Shift" /> + <see langword="N" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда работает на <xref:System.Windows.Documents.Paragraph> уровне.  Если эта команда вызывается для частичного выделения содержимого в абзаце (включая пустое выделение, в котором курсор находится внутри абзаца), запрошенный результат применяется ко всему абзацу.  Если эта команда вызывается для выделения, охватывающего несколько абзацев, то этот результат применяется ко всему содержимому каждого абзаца, участвующего в выборе.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSubscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSubscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSubscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />, которая запрашивает, чтобы форматирование нижнего индекса переключилось на текущую выборку.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="OemPlus" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSuperscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSuperscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSuperscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />, которая запрашивает, чтобы форматирование верхнего индекса переключилось на текущую выборку.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="Shift" /> + <see langword="OemPlus" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleUnderline As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleUnderline { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleUnderline : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет команду <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />, которая запрашивает, чтобы форматирование <see cref="T:System.Windows.Documents.Underline" /> переключилось на текущую выборку.</summary>
        <value>Запрошенная команда.  Жестом клавиши по умолчанию для этой <see langword="Ctrl" />команды является. + <see langword="U" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если выделение пусто и курсор находится внутри слова, выделение расширяется и включает слово целиком.  
  
 Фактическая реализация, которая реагирует на эту команду, не обязательно должна быть реализована для любого объекта. во многих случаях реализация, отвечающая на команду, отвечает за средство записи приложения.  
  
 Эта команда изначально поддерживается в <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## Examples  
 В следующем примере показано, как вызвать команду редактирования для объекта, который поддерживает команду.  
  
 В этом примере в <xref:System.Windows.Controls.RichTextBox> качестве целевого объекта команды выступает.  Обратите <xref:System.Windows.Controls.RichTextBox> внимание, <xref:System.Windows.IInputElement> что реализует интерфейс ( <xref:System.Windows.FrameworkElement>наследуется от) и включает встроенную поддержку многих команд редактирования.  
  
 Первым аргументом для <xref:System.Windows.Input.RoutedCommand.Execute%2A> метода является параметр команды.  Большинство команд редактирования игнорируют параметр команды. в общем случае этот параметр должен быть `null` для команд редактирования.  
  
 Второй аргумент задает объект, на который будет направляться команда.  Этот объект должен реализовывать <xref:System.Windows.IInputElement> интерфейс и включать обработчик для указанной команды.  Как правило, команда игнорируется при вызове для объекта, который не обрабатывает команду.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>
