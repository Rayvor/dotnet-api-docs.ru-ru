<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ab48ea222f69e09b0b493bad6b878974e0e32ebb" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70402590" /></Metadata><TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <TypeSignature Language="F#" Value="type TextPointer = class&#xA;    inherit ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Представляет положение в <see cref="T:System.Windows.Documents.FlowDocument" /> или <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer> Класс вводит следующую терминологию:  
  
-   По сути, элемент <xref:System.Windows.Documents.TextPointer> всегда указывает на *Расположение* в содержимом.  Такие позиции либо находятся между символами в содержимом, либо между тегами элементов содержимого нефиксированного формата, определяющими структуру содержимого.  
  
-   Current, так как <xref:System.Windows.Documents.TextPointer> всегда указывает на расположение, и так как многие операции, которые могут быть выполнены <xref:System.Windows.Documents.TextPointer> через, относятся к положению, на которое в настоящий момент указывает <xref:System.Windows.Documents.TextPointer>объект, имеет смысл просто ссылаться на расположение, указанное в <xref:System.Windows.Documents.TextPointer> качестве *текущей должности*.  
  
-   Позиция вставки — позиция *вставки* — это позиция, в которую можно добавить новое содержимое без нарушения семантических правил для связанного содержимого.  На практике позиция вставки находится в любом месте содержимого, где может быть размещен курсор.  Примером допустимой <xref:System.Windows.Documents.TextPointer> позиции, которая не является позицией вставки, является положение между двумя соседними <xref:System.Windows.Documents.Paragraph> тегами (то есть между закрывающим тегом предыдущего абзаца и открывающим тегом следующего абзаца).  
  
-   Символ. в целях <xref:System.Windows.Documents.TextPointer> операций, в которых используются символы, любой из следующих элементов считается *символом*:  
  
    -   Открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement> элемента.  
  
    -   Элемент, содержащийся <xref:System.Windows.Documents.InlineUIContainer> в или  <xref:System.Windows.Documents.BlockUIContainer> .  <xref:System.Windows.UIElement>  Обратите внимание, <xref:System.Windows.UIElement> что такое значение всегда учитывается как один символ; любое дополнительное содержимое или элементы, <xref:System.Windows.UIElement> содержащиеся в, не учитываются как символы.  
  
    -   Каждый 16-разрядный [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run> элемента.  
  
-   Контейнер текста — *текстовый контейнер* — это элемент, который формирует конечную границу для содержимого нефиксированного формата. расположение, указанное, <xref:System.Windows.Documents.TextPointer> всегда попадает в текстовый контейнер.  В настоящее время контейнер текста должен быть <xref:System.Windows.Documents.FlowDocument> либо <xref:System.Windows.Controls.TextBlock>или.  В общем случае операции между <xref:System.Windows.Documents.TextPointer> экземплярами в разных текстовых контейнерах не поддерживаются.  
  
-   Документ — содержимое в текстовом контейнере называется *документом*, как в <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> методе, а также <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> в свойствах и <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> .  
  
 Класс предназначен для упрощения обхода и обработки содержимого, [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] представленного элементами содержимого нефиксированного формата. в общем случае такие элементы являются производными от  <xref:System.Windows.Documents.TextElement> .  <xref:System.Windows.Documents.TextPointer>  Ниже перечислены некоторые операции, <xref:System.Windows.Documents.TextPointer> которые упрощают выполнение следующих операций.  
  
-   Выполнить порядковое сравнение текущей позицией со второй заданной позицией.  См. <xref:System.Windows.Documents.TextPointer.CompareTo%2A> метод.  
  
-   Определение типа содержимого, примыкающего к текущему положению в указанном направлении.  См. <xref:System.Windows.Documents.TextPointerContext> метод и перечисление. <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A>  
  
-   Возвращает область <xref:System.Windows.Documents.TextElement> , которая находится рядом с текущей позицией.  См <xref:System.Windows.Documents.Paragraph> . раздел <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> и метод.  
  
-   Возвращает текстовый контейнер, который ограничивает область текущего документа.  См. свойство <xref:System.Windows.Documents.TextPointer.Parent%2A>.  
  
-   Получение указанного числа символов перед текущей позицией или после нее.  См. <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> метод.  
  
-   Вставка строки символов в текущей позиции.  См. <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> метод.  
  
-   Поиск границ строк в содержимом.  См. <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> метод и свойство. <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A>  
  
-   Преобразование между <xref:System.Windows.Documents.TextPointer> позициями и смещениями символов в содержимое.  См. методы  <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> и. <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>  
  
-   Выполнение визуального тестирования нажатия путем перевода между <xref:System.Windows.Documents.TextPointer> позицией <xref:System.Windows.Point> и представлением относительных координат.  
  
-   Найдите расположенную рядом позицию вставки или проверьте, является ли текущая позиция позицией вставки.  См. методы <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> и Свойства. <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A>  
  
 Расположение и <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> обозначено объектом как <xref:System.Windows.Documents.TextPointer> неизменяемые.  Когда содержимое редактируется или изменяется, позиция, обозначенная объектом <xref:System.Windows.Documents.TextPointer> , не изменяется относительно окружающего текста; вместо этого смещение позиции от начала содержимого корректируется соответствующим образом для отражения новой относительной позиции в содержани.  Например, объект <xref:System.Windows.Documents.TextPointer> , указывающий позицию в начале данного абзаца, будет указывать на начало этого абзаца, даже когда содержимое вставляется или удаляется до или после абзаца.  
  
 <xref:System.Windows.Documents.TextPointer> Класс не предоставляет открытые конструкторы.  Экземпляр <xref:System.Windows.Documents.TextPointer> создается с помощью свойств или методов других объектов (включая другие <xref:System.Windows.Documents.TextPointer> объекты). В следующем списке приведено несколько примеров методов и свойств, которые создают и возвращают <xref:System.Windows.Documents.TextPointer>.  Этот список не является исчерпывающим:  
  
-   <xref:System.Windows.Documents.TextRange>Из: <xref:System.Windows.Documents.TextRange.Start%2A> и. <xref:System.Windows.Documents.TextRange.End%2A>  
  
-   <xref:System.Windows.Documents.TextElement>Из: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, , <xref:System.Windows.Documents.TextElement.ContentEnd%2A>  и <xref:System.Windows.Documents.TextElement.ElementEnd%2A> . <xref:System.Windows.Documents.TextElement.ElementStart%2A>  
  
-   Из (текстового контейнера): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>и  <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A> .  <xref:System.Windows.Controls.TextBlock>  
  
-   Из (текстового контейнера): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, и <xref:System.Windows.Documents.FlowDocument><xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   Из существующего <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, и <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> . <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>  
  
   
  
## Examples  
 В следующем примере показано, <xref:System.Windows.Documents.TextPointer> как использовать для поиска позиций непосредственно внутри первого <xref:System.Windows.Documents.Run> элемента в указанном текстовом контейнере.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 В следующем примере реализуется упрощенный алгоритм поиска <xref:System.Windows.Documents.TextPointer> с помощью средств.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.CompareTo position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position"><see cref="T:System.Windows.Documents.TextPointer" />, который указывает положение для сравнения с текущим положением.</param>
        <summary>Выполнение порядкового сравнения между положениями, указанными текущим <see cref="T:System.Windows.Documents.TextPointer" /> и вторым указанным <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>-1 если текущий <see cref="T:System.Windows.Documents.TextPointer" /> предшествует <paramref name="position" />; 0 если расположения те же; +1 если текущий <see cref="T:System.Windows.Documents.TextPointer" /> следует за <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение-1 указывает, что заданная в текущем <xref:System.Windows.Documents.TextPointer> положении координата предшествует положению, заданному параметром. `position`  Значение 0 указывает, что указанные позиции равны.  Положительное значение + 1 указывает на то, что текущая <xref:System.Windows.Documents.TextPointer> координата соответствует положению, `position`заданному в параметре.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого метода.  В этом примере <xref:System.Windows.Documents.TextPointer.CompareTo%2A> метод используется в сочетании <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> с методом для проверки того, является ли указанный <xref:System.Windows.Documents.TextElement> объект пустым.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="position" /> указывает положение за пределами текстового контейнера, связанного с текущим положением.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberSignature Language="F#" Value="member this.DeleteTextInRun : int -&gt; int" Usage="textPointer.DeleteTextInRun count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Число символов, подлежащих удалению, начиная с текущего положения. Укажите положительное значение, чтобы удалить символы, следующие за текущим положением; укажите отрицательное значение, чтобы удалить символы, предшествующие текущему положению.</param>
        <summary>Удаление указанного числа символов, начиная с положения, указанного текущим <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Число фактически удаленных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Укажите положительное значение, чтобы удалить символы, следующие за текущей позицией (как <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>в); укажите отрицательное значение, чтобы удалить символы, предшествующие текущему положению <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>(как в).  
  
 Число фактически удаленных символов может быть меньше числа, указанного параметром `count`.  Это происходит в тех случаях `count` , когда для удаления указано больше символов, чем существует.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод вызывается в положении, для которого текст не разрешен.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение <see cref="T:System.Windows.Documents.TextPointer" /> в конце содержимого в текстовом контейнере, связанном с текущим положением.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" /> в конце содержимого в текстовом контейнере, связанном с текущим положением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer> <xref:System.Windows.Controls.TextBlock> <xref:System.Windows.Documents.FlowDocument>Для возвращаемого элемента всегда является текстовым контейнером (или), а не  <xref:System.Windows.Documents.TextElement> .  <xref:System.Windows.Documents.TextPointer.Parent%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение <see cref="T:System.Windows.Documents.TextPointer" /> в начале содержимого в текстовом контейнере, связанном с текущим положением.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" /> в начале содержимого в текстовом контейнере, связанном с текущим положением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте позицию, возвращаемую этим свойством, в качестве базовой позиции для работы с относительными смещениями в другие позиции.  Методы <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> и <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>  предоставляют способ преобразования между позициями и смещениями позиции.  
  
 <xref:System.Windows.Documents.TextPointer> <xref:System.Windows.Controls.TextBlock> <xref:System.Windows.Documents.FlowDocument>Для возвращаемого элемента всегда является текстовым контейнером (или), а не  <xref:System.Windows.Documents.TextElement> .  <xref:System.Windows.Documents.TextPointer.Parent%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetAdjacentElement : System.Windows.Documents.LogicalDirection -&gt; System.Windows.DependencyObject" Usage="textPointer.GetAdjacentElement direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск примыкающих элементов.</param>
        <summary>Возвращение элемента, если таковой имеется, который граничит с текущим <see cref="T:System.Windows.Documents.TextPointer" /> в указанном логическом направлении.</summary>
        <returns>Примыкающий элемент в указанном <paramref name="direction" /> или <see langword="null" />, если не существует примыкающих элементов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемым элементом обычно <xref:System.Windows.Documents.TextElement>является.  Может быть возвращен, если объект <xref:System.Windows.Documents.TextPointer> <xref:System.Windows.Documents.BlockUIContainer> указывает на расположение <xref:System.Windows.Documents.InlineUIContainer> внутри элемента или элемента. <xref:System.Windows.UIElement>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterRect : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Rect" Usage="textPointer.GetCharacterRect direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, задающее логическое направление, в котором осуществляется поиск ограничивающего прямоугольника содержимого.</param>
        <summary>Возвращение ограничивающего прямоугольника (<see cref="T:System.Windows.Rect" />) для содержимого, которое граничит с текущим <see cref="T:System.Windows.Documents.TextPointer" /> в указанном логическом направлении.</summary>
        <returns>Ограничивающий прямоугольник для содержимого, которое граничит с текущим <see cref="T:System.Windows.Documents.TextPointer" /> в указанном направлении или <see cref="P:System.Windows.Rect.Empty" />, если текущая допустимая информация о структуре недоступна.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement>края не считаются содержимым в целях этого метода.  Если объект <xref:System.Windows.Documents.TextPointer> располагается <xref:System.Windows.Documents.TextElement> перед ребром, то возвращаемое значение является ограничивающим прямоугольником<xref:System.Windows.Documents.TextElement> для следующего элемента, не являющегося содержимым в указанном направлении.  Если в указанном направлении нет содержимого, возвращается нулевая ширина <xref:System.Windows.Rect> с высотой, соответствующей высоте любого предыдущего содержимого.  
  
 Операция, выполняемая этим методом, зависит от допустимого макета.  При необходимости этот метод пытается автоматически повторно создать допустимый макет, прежде чем продолжить операцию.  Повторное создание макета может быть относительно дорогостоящей операцией.  <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> Используйте свойство для проверки допустимости макета перед выполнением операций, которые могут повторно создать макет.  Дополнительные сведения см. в разделе [Макет](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск ближайшего положения вставки.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> к ближайшему положению вставки в заданном логическом направлении.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> к ближайшему положению вставки в заданном направлении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Позиция вставки — это позиция, в которую можно добавить новое содержимое без нарушения семантических правил для связанного содержимого.  На практике позиция вставки находится в любом месте содержимого, где может быть размещен курсор.  Примером допустимой <xref:System.Windows.Documents.TextPointer> позиции, которая не является позицией вставки, является положение между двумя соседними <xref:System.Windows.Documents.Paragraph> тегами (то есть между закрывающим тегом предыдущего абзаца и открывающим тегом следующего абзаца).  
  
 Если объект <xref:System.Windows.Documents.TextPointer> уже указывает на допустимую позицию вставки, но закрывающий тег для непустой последовательности форматирования непосредственно следует за этой позицией в данном направлении, то значение <xref:System.Windows.Documents.TextPointer> , возвращаемое этим методом, корректируется так, чтобы оно указывало на вставку. расположение сразу после закрытия последовательности форматирования. Например, рассмотрим последовательность `<Bold>a</Bold>b`разметки. Обратите внимание, что существуют две позиции вставки между `a` буквами и `b` -One, предшествующих `Bold` закрывающему тегу, и один непосредственно за `Bold` закрывающим тегом. Если <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> метод вызывается <xref:System.Windows.Documents.TextPointer> для к позиции непосредственно после буквы `a` и до закрывающего `Bold` тега, а WITH `direction` <xref:System.Windows.Documents.LogicalDirection.Forward>, то возвращаемый <xref:System.Windows.Documents.TextPointer> объект настраивается так, чтобы указывал на элемент располагать непосредственно перед буквой `b`после закрывающего `Bold` тега. Аналогичная корректировка выполняется для открытия тегов форматирования при работе в противоположном логическом направлении. Этот метод предназначен для предоставления средств устранения неоднозначности между позициями вставки в похожих случаях.  
  
 Этот метод также можно использовать для избирательного использования точек вставки при использовании последовательности структурных тегов. Например, если в позиции между закрывающим и открывающим тегами абзаца, параметр Direction можно использовать для выбора ближайшей точки вставки в начале следующего абзаца (указав <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) или в конце предыдущего абзаца ( путем указания <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>параметра).  
  
 Если указатель уже находится на позиции вставки и в указанном `direction`месте нет смежных тегов форматирования, возвращаемые <xref:System.Windows.Documents.TextPointer> точки будут указывать на ту же позицию, что и <xref:System.Windows.Documents.TextPointer>вызов.  
  
 Возможно, не существует допустимой позиции вставки относительно позиции, <xref:System.Windows.Documents.TextPointer>на которую указывает.  Это может произойти, если содержимое, на которое указывает ссылка, является структурно неполным, как в пустой таблице или списке.  В таких случаях этот метод просто возвращает <xref:System.Windows.Documents.TextPointer> в ту же точку, что и, <xref:System.Windows.Documents.TextPointer> из которой был вызван этот метод.  Этот метод всегда возвращает допустимый <xref:System.Windows.Documents.TextPointer>объект.  
  
   
  
## Examples  
 В этом примере показано, как использовать <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> метод для проверки того, является <xref:System.Windows.Documents.TextElement> ли указанный объект пустым для печатного содержимого.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в начало строки, задаваемое относительно текущего <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Число маркеров начала строки, которые надо пропустить при определении строки, для которой требуется вернуть начальное положение. Отрицательные значения указывают предшествующие строки, 0 задает текущую строку, а положительные значения задают следующие строки.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в начало строки, задаваемое относительно текущего <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" />, указывающий на начало указанной строки (при том, что для <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> задано значение <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), или <see langword="null" />, если указанная строка выходит за пределы диапазона или не может быть обнаружена иным способом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если точка указывает на неоднозначное расположение, например между двумя строками, в качестве относительной начальной линии выбирается строка в направлении, указанном параметром  <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> . <xref:System.Windows.Documents.TextPointer>  
  
 Операция, выполняемая этим методом, зависит от допустимого макета.  При необходимости этот метод пытается автоматически повторно создать допустимый макет, прежде чем продолжить операцию.  Повторное создание макета может быть относительно дорогостоящей операцией.  Используйте <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> для проверки допустимости макета перед выполнением операций, которые могут повторно создать макет.  Дополнительные сведения см. в разделе [Макет](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int *  -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition (count, actualCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">Число маркеров начала строки, которые надо пропустить при определении строки, для которой требуется вернуть начальное положение. Отрицательные значения указывают предшествующие строки, 0 задает текущую строку, а положительные значения задают следующие строки.</param>
        <param name="actualCount">При возврате данный метод включает фактическое число маркеров начала строки, которые были пропущены при определении строки, для которой возвращается начальное положение.  Данное значение может оказаться меньше <paramref name="count" />, если начало или конец содержимого обнаружен до того, как указанное число строк было пропущено. Этот параметр передается неинициализированным.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в начало строки, задаваемое относительно текущего <see cref="T:System.Windows.Documents.TextPointer" />, и создание отчета о числе пропущенных строк.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" />, указывающий на начало указанной строки (при том, что для <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> задано значение <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), или на начало строки, ближайшей к указанной строке, если указанная строка находится вне диапазона.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если точка указывает на неоднозначное расположение, например между двумя строками, то строка в направлении, указанном <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> свойством, выбирается как относительная Начальная строка. <xref:System.Windows.Documents.TextPointer>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextContextPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextContextPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск следующего символа.</param>
        <summary>Возвращение указателя к следующему символу в указанном логическом направлении.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> к следующему символу в требуемом направлении или <see langword="null" />, если текущий<see cref="T:System.Windows.Documents.TextPointer" /> граничит с началом или концом содержимого.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Любой из следующих элементов считается символом:  
  
-   Открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement> элемента.  
  
-   Элемент, содержащийся <xref:System.Windows.Documents.InlineUIContainer> в или  <xref:System.Windows.Documents.BlockUIContainer> .  <xref:System.Windows.UIElement>  Обратите внимание, <xref:System.Windows.UIElement> что такое значение всегда учитывается как один символ; любое дополнительное содержимое или элементы, <xref:System.Windows.UIElement> содержащиеся в, не учитываются как символы.  
  
-   16-разрядный [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run> элемента.  
  
 Если следующий символ относится к категории <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>или <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (как определено в <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> методе), то возвращаемое этим <xref:System.Windows.Documents.TextPointer> методом значение увеличивается на один символ из текущей позицией.  
  
 Если следующий <xref:System.Windows.Documents.TextPointerContext.Text>символ относится к категории, то возвращаемый этим методом элемент <xref:System.Windows.Documents.TextPointer> был расширен после текста на следующий нетекстовый символ (то есть <xref:System.Windows.Documents.TextPointerContext> в следующей позиции, где нет <xref:System.Windows.Documents.TextPointerContext.Text>).  Точные значения счетчика символов можно вычислить заранее, вызвав <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> метод.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого метода.  В примере используется <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> метод в сочетании <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> с методом для прохода и извлечения символов в указанном <xref:System.Windows.Documents.TextElement>.  
  
 Хотя пример можно использовать для извлечения [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] структуры содержимого заданного <xref:System.Windows.Documents.TextElement>объекта, он предназначен только для наглядных целей и не должен использоваться в рабочем коде.  См. <xref:System.Xml> пространство имен для обширного набора типов, предназначенных для работы с XML и обработки.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск следующего положения вставки.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> к следующему положению вставки в указанном логическом направлении.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" />, который определяет следующее положение вставки в запрошенном направлении или <see langword="null" />, если невозможно найти следующее положение вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Позиция вставки* — это позиция, в которую можно добавить новое содержимое без нарушения семантических правил для связанного содержимого.  На практике позиция вставки находится в любом месте содержимого, где может быть размещен курсор.  Примером допустимой <xref:System.Windows.Documents.TextPointer> позиции, которая не является позицией вставки, является положение между двумя соседними <xref:System.Windows.Documents.Paragraph> тегами (то есть между закрывающим тегом предыдущего абзаца и открывающим тегом следующего абзаца).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого метода. В примере используется <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> метод для прохода по границам элементов содержимого для подсчета <xref:System.Windows.Documents.Paragraph> количества элементов, существующих между двумя указанными <xref:System.Windows.Documents.TextPointer> экземплярами.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetOffsetToPosition : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.GetOffsetToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position"><see cref="T:System.Windows.Documents.TextPointer" />, который задает положение, до которо٠надо найти расстояние (в символах).</param>
        <summary>Возвращение числа символов между текущим <see cref="T:System.Windows.Documents.TextPointer" /> и вторым указанным <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Относительное число символов между текущим <see cref="T:System.Windows.Documents.TextPointer" /> и <paramref name="position" />.  Отрицательное значение показывает, что текущий <see cref="T:System.Windows.Documents.TextPointer" /> следует за положением, заданным <paramref name="position" />, 0 означает, что положения равны, а положительное значение показывает, что текущий <see cref="T:System.Windows.Documents.TextPointer" /> предшествует положению, указанному <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Любой из следующих элементов считается символом:  
  
-   Открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement> элемента.  
  
-   Элемент, содержащийся <xref:System.Windows.Documents.InlineUIContainer> в или  <xref:System.Windows.Documents.BlockUIContainer> .  <xref:System.Windows.UIElement>  Обратите внимание, <xref:System.Windows.UIElement> что такое значение всегда учитывается как один символ; любое дополнительное содержимое или элементы, <xref:System.Windows.UIElement> содержащиеся в, не учитываются как символы.  
  
-   16-разрядный [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run> элемента.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого метода. В примере используется <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> метод для поиска смещений для двух <xref:System.Windows.Documents.TextPointer> экземпляров, а затем эти сведения используются для сохранения и <xref:System.Windows.Controls.RichTextBox>восстановления выделенного фрагмента в.  В примере предполагается, что содержимое <xref:System.Windows.Controls.RichTextBox> объекта не изменилось между сохранением выделения и восстановлением выбора.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="position" /> указывает положение за пределами текстового контейнера, связанного с текущим положением.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPointerContext : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointerContext" Usage="textPointer.GetPointerContext direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором необходимо определить категорию примыкающего содержимого.</param>
        <summary>Возвращение индикатора категории для содержимого, примыкающего к текущему <see cref="T:System.Windows.Documents.TextPointer" /> в указанном логическом направлении.</summary>
        <returns>Одно из значений <see cref="T:System.Windows.Documents.TextPointerContext" />, которое определяет категорию примыкающего содержимого в указанном логическом направлении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере демонстрируется использование этого метода. В примере <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> метод используется для реализации алгоритма для вычисления баланса между открывающим и закрывающим тегами элемента между двумя заданными <xref:System.Windows.Documents.TextPointer> позициями.  Каждый открывающий тег элемента считается + 1, а каждый закрывающий тег элемента считается-1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в положение, указанное заданным смещением в символах от начала содержимого.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Смещение (в символах) на которое необходимо рассчитывать и возвращать положение.  Если смещение отрицательное, положение рассчитывается в логическом направлении, противоположном заданному свойством <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в положение, указанное заданным смещением в символах от начала текущего <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Указатель <see cref="T:System.Windows.Documents.TextPointer" /> на положение, определенное заданным смещением, или <see langword="null" />, если невозможно найти соответствующее положение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Любой из следующих элементов считается символом:  
  
-   Открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement> элемента.  
  
-   Элемент, содержащийся <xref:System.Windows.Documents.InlineUIContainer> в или  <xref:System.Windows.Documents.BlockUIContainer> .  <xref:System.Windows.UIElement>  Обратите внимание, <xref:System.Windows.UIElement> что такое значение всегда учитывается как один символ; любое дополнительное содержимое или элементы, <xref:System.Windows.UIElement> содержащиеся в, не учитываются как символы.  
  
-   16-разрядный [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run> элемента.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого метода. В примере используется <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> метод для реализации пары методов, один для вычисления смещения до указанной позиции относительно любого абзаца размещения, а другой — <xref:System.Windows.Documents.TextPointer> для возврата к указанному смещению в указанном абзаце.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset (offset, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Смещение (в символах) на которое необходимо рассчитывать и возвращать положение.  Если смешение отрицательное, возвращенный <see cref="T:System.Windows.Documents.TextPointer" /> предшествует текущему <see cref="T:System.Windows.Documents.TextPointer" />; в противном случае, он идет следом.</param>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление возвращенного <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в положение, указанное заданным смещением в символах от начала текущего <see cref="T:System.Windows.Documents.TextPointer" />, а также в указанном направлении.</summary>
        <returns>Указатель <see cref="T:System.Windows.Documents.TextPointer" /> на положение, определяемое заданным смещением, или <see langword="null" />, если смещение выходит за рамки содержимого.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Любой из следующих элементов считается символом:  
  
-   Открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement> элемента.  
  
-   Элемент, содержащийся <xref:System.Windows.Documents.InlineUIContainer> в или  <xref:System.Windows.Documents.BlockUIContainer> .  <xref:System.Windows.UIElement>  Обратите внимание, <xref:System.Windows.UIElement> что такое значение всегда учитывается как один символ; любое дополнительное содержимое или элементы, <xref:System.Windows.UIElement> содержащиеся в, не учитываются как символы.  
  
-   16-разрядный [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run> элемента.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращение текста, примыкающего к текущему <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection -&gt; string" Usage="textPointer.GetTextInRun direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск и возвращение любого примыкающего текста.</param>
        <summary>Возвращение строки, содержащей любой текст, примыкающий к текущему <see cref="T:System.Windows.Documents.TextPointer" /> в указанном логическом направлении.</summary>
        <returns>Строка, содержащая любой примыкающий текст в указанном логическом направлении, или <see cref="F:System.String.Empty" />, если не найдено примыкающего текста.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает только непрерывающие выполнения текста.  Если какой-либо тип символа, отличный от <xref:System.Windows.Documents.TextPointerContext.Text> , является смежным с <xref:System.Windows.Documents.TextPointer> текущим в указанном направлении, ничего не возвращается.  Аналогичным образом текст возвращается только до следующего символа, не являющегося текстовым.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого метода. В примере используется <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> метод для реализации простого текстового извлечения.  Метод возвращает объединение строк для всего текста между двумя указанными <xref:System.Windows.Documents.TextPointer> экземплярами.  
  
 Хотя пример можно использовать для извлечения любого текста между двумя <xref:System.Windows.Documents.TextPointer> экземплярами, он предназначен только для наглядных целей и не должен использоваться в рабочем коде.  Вместо этого следует использовать свойство <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection * char[] * int * int -&gt; int" Usage="textPointer.GetTextInRun (direction, textBuffer, startIndex, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск и копирование любого примыкающего текста.</param>
        <param name="textBuffer">Буфер, в который копируется текст.</param>
        <param name="startIndex">Индекс в <paramref name="textBuffer" />, с которого начинается запись копируемого текста.</param>
        <param name="count">Максимальное число символов для копирования.</param>
        <summary>Копирование в указанном направлении заданного максимального числа символов из примыкающего текста в массив символов, предоставленный вызывающим.</summary>
        <returns>Число фактически скопированных символов в <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает только непрерывающие выполнения текста.  Если какой-либо тип символа, отличный от <xref:System.Windows.Documents.TextPointerContext.Text> , является смежным с <xref:System.Windows.Documents.TextPointer> текущим в указанном направлении, ничего не возвращается.  Аналогичным образом текст возвращается только до следующего символа, не являющегося текстовым.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="startIndex" /> меньше 0 или больше <see cref="P:System.Array.Length" /> свойства <paramref name="textBuffer" />.  
  
-или- 
 <paramref name="count" /> меньше 0 или больше оставшегося пространства в <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> минус <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextRunLength : System.Windows.Documents.LogicalDirection -&gt; int" Usage="textPointer.GetTextRunLength direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется подсчет числа символов.</param>
        <summary>Возвращение числа знаков Юникода между текущим <see cref="T:System.Windows.Documents.TextPointer" /> и следующим нетекстовым символом в указанном логическом направлении.</summary>
        <returns>Число знаков Юникода между текущим <see cref="T:System.Windows.Documents.TextPointer" /> и следующим нетекстовым символом.  Данное число может быть равно 0, если примыкающего текста нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Любой из следующих элементов считается символом:  
  
-   Открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement> элемента.  
  
-   Элемент, содержащийся <xref:System.Windows.Documents.InlineUIContainer> в или  <xref:System.Windows.Documents.BlockUIContainer> .  <xref:System.Windows.UIElement>  Обратите внимание, <xref:System.Windows.UIElement> что такое значение всегда учитывается как один символ; любое дополнительное содержимое или элементы, <xref:System.Windows.UIElement> содержащиеся в, не учитываются как символы.  
  
-   16-разрядный [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run> элемента.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidLayout : bool" Usage="System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, указывающего, имеется ли для текстового контейнера, связанного с текущим положением, допустимый (современным) макет.</summary>
        <value><see langword="true" />, если макет является текущим и допустимым; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При необходимости операции, зависящие от допустимого макета (например <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> , метод, <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> метод и <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> свойство), пытаются автоматически повторно создать допустимый макет, прежде чем продолжить операцию.  Повторное создание макета может быть относительно дорогостоящей операцией.  Это свойство используется для проверки допустимости макета перед выполнением операций, которые могут повторно создать макет.  Дополнительные сведения см. в разделе [Макет](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertLineBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertLineBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вставка разрыва строки в текущем положении.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" />, располагающийся сразу за элементом <see cref="T:System.Windows.Documents.LineBreak" />, вставленным данным методом.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertParagraphBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertParagraphBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вставка разрыва абзаца в текущем положении.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> к началу (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) нового абзаца.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод вызывается, когда текущая координата находится внутри существующего <xref:System.Windows.Documents.Paragraph> элемента, существующий абзац и любое содержимое, которое он содержит, разбиваются на два абзаца в текущей позиции.  Если этот метод вызывается, когда текущая координата не находится внутри существующего абзаца, вставляется новый пустой абзац.  Если этот метод вызывается в позиции, непригодной для разделения или вставки абзаца (например, если текущая координата находится внутри <xref:System.Windows.Documents.Hyperlink> элемента), возникает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Данный метод вызывается для положения, которое невозможно разделить для размещения нового абзаца, как в области <see cref="T:System.Windows.Documents.Hyperlink" /> или <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberSignature Language="F#" Value="member this.InsertTextInRun : string -&gt; unit" Usage="textPointer.InsertTextInRun textData" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Текст для вставки.</param>
        <summary>Вставка указанного текста в текст <see cref="T:System.Windows.Documents.Run" /> в текущее положение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если область <xref:System.Windows.Documents.Run> `textData`не ограничена элементом, вставляется вместе с. <xref:System.Windows.Documents.Run> <xref:System.Windows.Documents.TextPointer>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущее положение находится за пределами элемента <see cref="T:System.Windows.Documents.Run" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="textData" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtInsertionPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, указывающего, является ли положение вставки текущим положением.</summary>
        <value><see langword="true" />, если текущее положение является положением вставки; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Позиция вставки — это позиция, в которую можно добавить новое содержимое без нарушения семантических правил для связанного содержимого.  На практике позиция вставки находится в любом месте содержимого, где может быть размещен курсор.  Примером допустимой <xref:System.Windows.Documents.TextPointer> позиции, которая не является позицией вставки, является положение между двумя соседними <xref:System.Windows.Documents.Paragraph> тегами (то есть между закрывающим тегом предыдущего абзаца и открывающим тегом следующего абзаца).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtLineStartPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, указывающего, находится ли текущее положение в начале строки.</summary>
        <value><see langword="true" />, если текущее положение находится в начале строки; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если точка указывает на неоднозначное расположение, например между двумя строками, то строка в направлении, указанном <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> свойством, выбирается как относительная Начальная строка. <xref:System.Windows.Documents.TextPointer>  
  
 Операция, выполняемая этим свойством, зависит от допустимого макета.  При необходимости этот метод пытается автоматически повторно создать допустимый макет, прежде чем продолжить операцию.  Повторное создание макета может быть относительно дорогостоящей операцией.  <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> Используйте свойство для проверки допустимости макета перед выполнением операций, которые могут повторно создать макет.  Дополнительные сведения см. в разделе [Макет](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberSignature Language="F#" Value="member this.IsInSameDocument : System.Windows.Documents.TextPointer -&gt; bool" Usage="textPointer.IsInSameDocument textPosition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition"><see cref="T:System.Windows.Documents.TextPointer" />, который указывает положение для сравнения с текущим положением.</param>
        <summary>Определение, находится ли указанное положение в том же текстовом контейнере, что и текущее положение.</summary>
        <returns><see langword="true" />, если <paramref name="textPosition" /> указывает положение, которое располагается в том же текстовом контейнере, что и текущее положение; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Большинство операций, затрагивающих <xref:System.Windows.Documents.TextPointer> несколько экземпляров, допустимы только в том случае, если искомые экземпляры указывают позиции, которые находятся в одной области текстового контейнера.  Например, <xref:System.Windows.Documents.TextPointer.CompareTo%2A> методы и <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> не могут использоваться с a <xref:System.Windows.Documents.TextPointer> в качестве места вне контейнера текста, связанного с текущей позицией.  Используйте этот метод, чтобы убедиться, что <xref:System.Windows.Documents.TextPointer> указанный объект совместим с текущей позицией для таких операций.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого метода.  В примере <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> метод используется для проверки того, находится ли <xref:System.Windows.Documents.TextPointer> заданный объект между двумя другими заданными <xref:System.Windows.Documents.TextPointer> экземплярами в ситуации, когда нет гарантии, что все три позиции принадлежат одному и тому же текстовому контейнеру.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="textPosition" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalDirection : System.Windows.Documents.LogicalDirection" Usage="System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение логического направления, связанного с текущим положением, которое используется для снятия неоднозначности в отношении содержимого, связанного с текущим положением.</summary>
        <value>Значение <see cref="T:System.Windows.Documents.LogicalDirection" />, которое связано с текущим положением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В качестве примера того, как используется это свойство, объект <xref:System.Windows.Documents.LogicalDirection> <xref:System.Windows.Documents.TextPointer> , возвращаемый методом проверки нажатия, обеспечивает попадание между двумя символами текста. Логическое направление указывает, какой из двух символов был на самом деле находился слева или справа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Paragraph : System.Windows.Documents.Paragraph" Usage="System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение абзаца, в области которого находится текущее положение, если таковой имеется.</summary>
        <value>Объект <see cref="T:System.Windows.Documents.Paragraph" /> , область которого является текущей позицией, или <see langword="null" /> значение, если такой абзац не существует.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение логического родительского элемента, задающего область для текущего положения.</summary>
        <value>Логический родительский элемент, задающий область для текущего положения.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textPointer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Данный тип или член поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для непосредственного использования из кода.</summary>
        <returns>Строка, представляющая объект.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
