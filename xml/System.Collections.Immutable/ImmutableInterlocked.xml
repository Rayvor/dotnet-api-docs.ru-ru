<Type Name="ImmutableInterlocked" FullName="System.Collections.Immutable.ImmutableInterlocked">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5f26ef1cb6f91c1657ad80d212ce1e374478ddea" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73375602" /></Metadata><TypeSignature Language="C#" Value="public static class ImmutableInterlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ImmutableInterlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Immutable.ImmutableInterlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class ImmutableInterlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class ImmutableInterlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type ImmutableInterlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Immutable</AssemblyName>
    <AssemblyVersion>1.1.37.0</AssemblyVersion>
    <AssemblyVersion>1.2.0.0</AssemblyVersion>
    <AssemblyVersion>1.2.1.0</AssemblyVersion>
    <AssemblyVersion>1.2.2.0</AssemblyVersion>
    <AssemblyVersion>1.2.3.0</AssemblyVersion>
    <AssemblyVersion>1.2.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Содержит механизмы обмена с взаимоблокировкой для неизменяемых коллекций.  
  
 **Пакет NuGet**: <see href="https://www.nuget.org/packages/System.Collections.Immutable/">System.Collections.Immutable</see> (<see href="https://docs.microsoft.com/dotnet/api/system.collections.immutable?#remarks">сведения о неизменяемых коллекциях и способах их установки</see>)</summary>
    <remarks>To be added.</remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="AddOrUpdate&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue AddOrUpdate&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, Func&lt;TKey,TValue&gt; addValueFactory, Func&lt;TKey,TValue,TValue&gt; updateValueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue AddOrUpdate&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, class System.Func`2&lt;!!TKey, !!TValue&gt; addValueFactory, class System.Func`3&lt;!!TKey, !!TValue, !!TValue&gt; updateValueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1},System.Func{``0,``1,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddOrUpdate(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, addValueFactory As Func(Of TKey, TValue), updateValueFactory As Func(Of TKey, TValue, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static TValue AddOrUpdate(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, Func&lt;TKey, TValue&gt; ^ addValueFactory, Func&lt;TKey, TValue, TValue&gt; ^ updateValueFactory);" />
      <MemberSignature Language="F#" Value="static member AddOrUpdate : ImmutableDictionary * 'Key * Func&lt;'Key, 'Value&gt; * Func&lt;'Key, 'Value, 'Value&gt; -&gt; 'Value" Usage="System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate (location, key, addValueFactory, updateValueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="addValueFactory" Type="System.Func&lt;TKey,TValue&gt;" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TValue&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип ключа, хранящегося в словаре.</typeparam>
        <typeparam name="TValue">Тип значения, хранящегося в словаре.</typeparam>
        <param name="location">Переменная или поле, которые нужно обновить атомарным образом, если указанного элемента нет в словаре.</param>
        <param name="key">Ключ для значения, которое нужно добавить или обновить.</param>
        <param name="addValueFactory">Функция, получающая ключ и возвращающая новое значение, которое нужно добавить в словарь, если такого значения в нем нет.</param>
        <param name="updateValueFactory">Функция, получающая ключ и предыдущее значение и возвращающая новое значение, которым нужно обновить словарь.</param>
        <summary>Возвращает значение из словаря после добавления или изменения существующей записи.</summary>
        <returns>Добавленное или обновленное значение.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue AddOrUpdate&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, TValue addValue, Func&lt;TKey,TValue,TValue&gt; updateValueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue AddOrUpdate&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, !!TValue addValue, class System.Func`3&lt;!!TKey, !!TValue, !!TValue&gt; updateValueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1,System.Func{``0,``1,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddOrUpdate(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, addValue As TValue, updateValueFactory As Func(Of TKey, TValue, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static TValue AddOrUpdate(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, TValue addValue, Func&lt;TKey, TValue, TValue&gt; ^ updateValueFactory);" />
      <MemberSignature Language="F#" Value="static member AddOrUpdate : ImmutableDictionary * 'Key * 'Value * Func&lt;'Key, 'Value, 'Value&gt; -&gt; 'Value" Usage="System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate (location, key, addValue, updateValueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="addValue" Type="TValue" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TValue&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип ключа, хранящегося в словаре.</typeparam>
        <typeparam name="TValue">Тип значения, хранящегося в словаре.</typeparam>
        <param name="location">Переменная или поле, которые нужно обновить атомарным образом, если указанного элемента нет в словаре.</param>
        <param name="key">Ключ для значения, которое нужно добавить или обновить.</param>
        <param name="addValue">Значение, которое нужно использовать, если предыдущего значения не существует.</param>
        <param name="updateValueFactory">Функция, получающая ключ и предыдущее значение и возвращающая новое значение, которым нужно обновить словарь.</param>
        <summary>Возвращает значение из словаря после добавления или изменения существующей записи.</summary>
        <returns>Добавленное или обновленное значение.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Enqueue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Enqueue&lt;T&gt; (ref System.Collections.Immutable.ImmutableQueue&lt;T&gt; location, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enqueue&lt;T&gt;(class System.Collections.Immutable.ImmutableQueue`1&lt;!!T&gt;&amp; location, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.Enqueue``1(System.Collections.Immutable.ImmutableQueue{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enqueue(Of T) (ByRef location As ImmutableQueue(Of T), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Enqueue(System::Collections::Immutable::ImmutableQueue&lt;T&gt; ^ % location, T value);" />
      <MemberSignature Language="F#" Value="static member Enqueue : ImmutableQueue * 'T -&gt; unit" Usage="System.Collections.Immutable.ImmutableInterlocked.Enqueue (location, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableQueue&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов коллекции.</typeparam>
        <param name="location">Переменная или поле, которые нужно обновить атомарным образом.</param>
        <param name="value">Значение, которое нужно добавить в очередь.</param>
        <summary>Атомарным образом добавляет элемент в конец очереди.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAdd&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue GetOrAdd&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, Func&lt;TKey,TValue&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue GetOrAdd&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, class System.Func`2&lt;!!TKey, !!TValue&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOrAdd(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, valueFactory As Func(Of TKey, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static TValue GetOrAdd(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, Func&lt;TKey, TValue&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member GetOrAdd : ImmutableDictionary * 'Key * Func&lt;'Key, 'Value&gt; -&gt; 'Value" Usage="System.Collections.Immutable.ImmutableInterlocked.GetOrAdd (location, key, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="valueFactory" Type="System.Func&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип ключей в коллекции.</typeparam>
        <typeparam name="TValue">Тип значений в коллекции.</typeparam>
        <param name="location">Переменная или поле, которые нужно обновить атомарным образом, если указанного элемента нет в словаре.</param>
        <param name="key">Ключ значения, которое нужно получить или добавить.</param>
        <param name="valueFactory">Функция, выполняемая для получения значения, которое нужно вставить в словарь, если ключ не найден. Этот делегат будет вызван не больше одного раза.</param>
        <summary>Возвращает из словаря значение для указанного ключа или добавляет в него новое значение, если такой ключ не найден.</summary>
        <returns>Значение по указанному ключу или <paramref name="valueFactory" />, если ключ не найден.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAdd&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue GetOrAdd&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue GetOrAdd&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, !!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOrAdd(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, value As TValue) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static TValue GetOrAdd(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="static member GetOrAdd : ImmutableDictionary * 'Key * 'Value -&gt; 'Value" Usage="System.Collections.Immutable.ImmutableInterlocked.GetOrAdd (location, key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип ключей в коллекции.</typeparam>
        <typeparam name="TValue">Тип значений в коллекции.</typeparam>
        <param name="location">Переменная или поле, которые нужно обновить атомарным образом, если указанного ключа нет в словаре.</param>
        <param name="key">Ключ для значения, которое нужно получить или добавить.</param>
        <param name="value">Значение, которое нужно добавить в словарь, если ключ не найден.</param>
        <summary>Возвращает из словаря значение для указанного ключа или добавляет в него новое значение, если такой ключ не найден.</summary>
        <returns>Значение по указанному ключу или <paramref name="valueFactory" />, если ключ не найден.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAdd&lt;TKey,TValue,TArg&gt;">
      <MemberSignature Language="C#" Value="public static TValue GetOrAdd&lt;TKey,TValue,TArg&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, Func&lt;TKey,TArg,TValue&gt; valueFactory, TArg factoryArgument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue GetOrAdd&lt;TKey, TValue, TArg&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, class System.Func`3&lt;!!TKey, !!TArg, !!TValue&gt; valueFactory, !!TArg factoryArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``3(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``2,``1},``2)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOrAdd(Of TKey, TValue, TArg) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, valueFactory As Func(Of TKey, TArg, TValue), factoryArgument As TArg) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue, typename TArg&gt;&#xA; static TValue GetOrAdd(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, Func&lt;TKey, TArg, TValue&gt; ^ valueFactory, TArg factoryArgument);" />
      <MemberSignature Language="F#" Value="static member GetOrAdd : ImmutableDictionary * 'Key * Func&lt;'Key, 'Arg, 'Value&gt; * 'Arg -&gt; 'Value" Usage="System.Collections.Immutable.ImmutableInterlocked.GetOrAdd (location, key, valueFactory, factoryArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
        <TypeParameter Name="TArg" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="valueFactory" Type="System.Func&lt;TKey,TArg,TValue&gt;" />
        <Parameter Name="factoryArgument" Type="TArg" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип ключей в коллекции.</typeparam>
        <typeparam name="TValue">Тип значений в коллекции.</typeparam>
        <typeparam name="TArg">Тип аргумента, переданного в фабрику значений.</typeparam>
        <param name="location">Переменная или поле, которые нужно обновить, если указанного элемента нет в словаре.</param>
        <param name="key">Ключ значения, которое нужно получить или добавить.</param>
        <param name="valueFactory">Функция, выполняемая для получения значения, которое нужно вставить в словарь, если ключ не найден.</param>
        <param name="factoryArgument">Аргумент, передаваемый фабрике значений.</param>
        <summary>Возвращает из словаря значение для указанного ключа или добавляет в него новое значение, если такой ключ не найден.</summary>
        <returns>Значение по указанному ключу или <paramref name="valueFactory" />, если ключ не найден.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InterlockedCompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;T&gt; InterlockedCompareExchange&lt;T&gt; (ref System.Collections.Immutable.ImmutableArray&lt;T&gt; location, System.Collections.Immutable.ImmutableArray&lt;T&gt; value, System.Collections.Immutable.ImmutableArray&lt;T&gt; comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt; InterlockedCompareExchange&lt;T&gt;(valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt;&amp; location, valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt; value, valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt; comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.InterlockedCompareExchange``1(System.Collections.Immutable.ImmutableArray{``0}@,System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function InterlockedCompareExchange(Of T) (ByRef location As ImmutableArray(Of T), value As ImmutableArray(Of T), comparand As ImmutableArray(Of T)) As ImmutableArray(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::Immutable::ImmutableArray&lt;T&gt; InterlockedCompareExchange(System::Collections::Immutable::ImmutableArray&lt;T&gt; % location, System::Collections::Immutable::ImmutableArray&lt;T&gt; value, System::Collections::Immutable::ImmutableArray&lt;T&gt; comparand);" />
      <MemberSignature Language="F#" Value="static member InterlockedCompareExchange : ImmutableArray * System.Collections.Immutable.ImmutableArray&lt;'T&gt; * System.Collections.Immutable.ImmutableArray&lt;'T&gt; -&gt; System.Collections.Immutable.ImmutableArray&lt;'T&gt;" Usage="System.Collections.Immutable.ImmutableInterlocked.InterlockedCompareExchange (location, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" />
        <Parameter Name="comparand" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов, которые хранятся в массиве.</typeparam>
        <param name="location">Целевой объект, который нужно сравнить с объектом <paramref name="comparand" /> и, возможно, заменить.</param>
        <param name="value">Значение, которым будет заменено целевое значение, если проверка покажет равенство.</param>
        <param name="comparand">Значение, которое сравнивается со значением в позиции <paramref name="location" />.</param>
        <summary>Проверяет два неизменяемых массива на равенство и, если они равны, заменяет один из них.</summary>
        <returns>Исходное значение в позиции <paramref name="location" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InterlockedExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;T&gt; InterlockedExchange&lt;T&gt; (ref System.Collections.Immutable.ImmutableArray&lt;T&gt; location, System.Collections.Immutable.ImmutableArray&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt; InterlockedExchange&lt;T&gt;(valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt;&amp; location, valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.InterlockedExchange``1(System.Collections.Immutable.ImmutableArray{``0}@,System.Collections.Immutable.ImmutableArray{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function InterlockedExchange(Of T) (ByRef location As ImmutableArray(Of T), value As ImmutableArray(Of T)) As ImmutableArray(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::Immutable::ImmutableArray&lt;T&gt; InterlockedExchange(System::Collections::Immutable::ImmutableArray&lt;T&gt; % location, System::Collections::Immutable::ImmutableArray&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member InterlockedExchange : ImmutableArray * System.Collections.Immutable.ImmutableArray&lt;'T&gt; -&gt; System.Collections.Immutable.ImmutableArray&lt;'T&gt;" Usage="System.Collections.Immutable.ImmutableInterlocked.InterlockedExchange (location, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов, которые хранятся в массиве.</typeparam>
        <param name="location">Массив, для которого нужно задать указанное значение.</param>
        <param name="value">Значение, которое задается для параметра <paramref name="location" />.</param>
        <summary>Задает для массива значение указанного массива и возвращает ссылку на исходный массив (вся операция выполняется атомарным образом).</summary>
        <returns>Исходное значение <paramref name="location" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InterlockedInitialize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool InterlockedInitialize&lt;T&gt; (ref System.Collections.Immutable.ImmutableArray&lt;T&gt; location, System.Collections.Immutable.ImmutableArray&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool InterlockedInitialize&lt;T&gt;(valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt;&amp; location, valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.InterlockedInitialize``1(System.Collections.Immutable.ImmutableArray{``0}@,System.Collections.Immutable.ImmutableArray{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function InterlockedInitialize(Of T) (ByRef location As ImmutableArray(Of T), value As ImmutableArray(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool InterlockedInitialize(System::Collections::Immutable::ImmutableArray&lt;T&gt; % location, System::Collections::Immutable::ImmutableArray&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member InterlockedInitialize : ImmutableArray * System.Collections.Immutable.ImmutableArray&lt;'T&gt; -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.InterlockedInitialize (location, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов, которые хранятся в массиве.</typeparam>
        <param name="location">Массив, для которого нужно задать указанное значение.</param>
        <param name="value">Значение, которое задается для параметра <paramref name="location" />, если он не инициализирован.</param>
        <summary>Задает для массива значение указанного массива, если он не инициализирован.</summary>
        <returns>Значение <see langword="true" />, если массиву было присвоено указанное значение; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Push&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Push&lt;T&gt; (ref System.Collections.Immutable.ImmutableStack&lt;T&gt; location, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Push&lt;T&gt;(class System.Collections.Immutable.ImmutableStack`1&lt;!!T&gt;&amp; location, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.Push``1(System.Collections.Immutable.ImmutableStack{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Push(Of T) (ByRef location As ImmutableStack(Of T), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Push(System::Collections::Immutable::ImmutableStack&lt;T&gt; ^ % location, T value);" />
      <MemberSignature Language="F#" Value="static member Push : ImmutableStack * 'T -&gt; unit" Usage="System.Collections.Immutable.ImmutableInterlocked.Push (location, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableStack&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов стека.</typeparam>
        <param name="location">Стек, в который вносятся изменения.</param>
        <param name="value">Значение, которое нужно поместить в стек.</param>
        <summary>Помещает в стек новый элемент.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryAdd&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static bool TryAdd&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryAdd&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, !!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.TryAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAdd(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static bool TryAdd(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="static member TryAdd : ImmutableDictionary * 'Key * 'Value -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.TryAdd (location, key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип ключей в коллекции.</typeparam>
        <typeparam name="TValue">Тип значений в коллекции.</typeparam>
        <param name="location">Словарь, который нужно обновить с использованием указанных ключа и значения.</param>
        <param name="key">Ключ, который нужно добавить, если он еще не определен в словаре.</param>
        <param name="value">Значение для сложения.</param>
        <summary>Добавляет в словарь указанные ключ и значение, если такого ключа нет в словаре.</summary>
        <returns>Значение <see langword="true" />, если ключа нет в словаре; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryDequeue&lt;T&gt; (ref System.Collections.Immutable.ImmutableQueue&lt;T&gt; location, out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryDequeue&lt;T&gt;(class System.Collections.Immutable.ImmutableQueue`1&lt;!!T&gt;&amp; location, [out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.TryDequeue``1(System.Collections.Immutable.ImmutableQueue{``0}@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryDequeue(Of T) (ByRef location As ImmutableQueue(Of T), ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryDequeue(System::Collections::Immutable::ImmutableQueue&lt;T&gt; ^ % location, [Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member TryDequeue : ImmutableQueue * 'T -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.TryDequeue (location, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableQueue&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов очереди.</typeparam>
        <param name="location">Переменная или поле, которые нужно обновить атомарным образом.</param>
        <param name="value">Устанавливает значение в голове очереди, если она не пуста.</param>
        <summary>Атомарным образом удаляет и возвращает указанный элемент в голове очереди, если она не пуста.</summary>
        <returns>Значение <see langword="true" />, если очередь не пуста и из ее головы удален элемент; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryPop&lt;T&gt; (ref System.Collections.Immutable.ImmutableStack&lt;T&gt; location, out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryPop&lt;T&gt;(class System.Collections.Immutable.ImmutableStack`1&lt;!!T&gt;&amp; location, [out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.TryPop``1(System.Collections.Immutable.ImmutableStack{``0}@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryPop(Of T) (ByRef location As ImmutableStack(Of T), ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryPop(System::Collections::Immutable::ImmutableStack&lt;T&gt; ^ % location, [Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member TryPop : ImmutableStack * 'T -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.TryPop (location, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableStack&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов стека.</typeparam>
        <param name="location">Стек, в который вносятся изменения.</param>
        <param name="value">Получает значение, удаленное из стека, если стек не пуст.</param>
        <summary>Удаляет верхний элемент стека, если в нем есть элементы для удаления.</summary>
        <returns>Значение <see langword="true" />, если элемент удален из стека; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryRemove&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static bool TryRemove&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryRemove&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, [out] !!TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.TryRemove``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryRemove(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static bool TryRemove(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="static member TryRemove : ImmutableDictionary * 'Key * 'Value -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.TryRemove (location, key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип ключей в коллекции.</typeparam>
        <typeparam name="TValue">Тип значений в коллекции.</typeparam>
        <param name="location">Обновляемый словарь.</param>
        <param name="key">Удаляемый ключ.</param>
        <param name="value">Получает значение удаленного элемента, если словарь не пуст.</param>
        <summary>Удаляет элемент с указанным ключом, если такой ключ существует.</summary>
        <returns>Значение <see langword="true" />, если ключ найден и удален; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUpdate&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static bool TryUpdate&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, TValue newValue, TValue comparisonValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryUpdate&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, !!TValue newValue, !!TValue comparisonValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.TryUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryUpdate(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, newValue As TValue, comparisonValue As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static bool TryUpdate(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, TValue newValue, TValue comparisonValue);" />
      <MemberSignature Language="F#" Value="static member TryUpdate : ImmutableDictionary * 'Key * 'Value * 'Value -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.TryUpdate (location, key, newValue, comparisonValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="newValue" Type="TValue" />
        <Parameter Name="comparisonValue" Type="TValue" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип ключей в коллекции.</typeparam>
        <typeparam name="TValue">Тип значений в коллекции.</typeparam>
        <param name="location">Обновляемый словарь.</param>
        <param name="key">Обновляемый ключ.</param>
        <param name="newValue">Устанавливаемое новое значение.</param>
        <param name="comparisonValue">Текущее значение для ключа <paramref name="key" />, чтобы операция была успешно выполнена.</param>
        <summary>Устанавливает для указанного ключа заданное значение, если для него еще не установлено определенное значение.</summary>
        <returns>Значение <see langword="true" />, если в словаре есть ключ <paramref name="key" /> и значение <paramref name="comparisonValue" /> и для него было задано новое значение <paramref name="newValue" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Update&lt;T&gt; (ref T location, Func&lt;T,T&gt; transformer) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Update&lt;class T&gt;(!!T&amp; location, class System.Func`2&lt;!!T, !!T&gt; transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.Update``1(``0@,System.Func{``0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Update(Of T As Class) (ByRef location As T, transformer As Func(Of T, T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static bool Update(T % location, Func&lt;T, T&gt; ^ transformer);" />
      <MemberSignature Language="F#" Value="static member Update : 'T * Func&lt;'T, 'T (requires 'T : null and 'T : null)&gt; -&gt; bool (requires 'T : null)" Usage="System.Collections.Immutable.ImmutableInterlocked.Update (location, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="T" RefType="ref" />
        <Parameter Name="transformer" Type="System.Func&lt;T,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип данных.</typeparam>
        <param name="location">Переменная или изменяемое поле, к которым могут обращаться сразу несколько потоков.</param>
        <param name="transformer">Функция, изменяющая значение. Эта функция не должна иметь никаких побочных эффектов, поскольку может выполняться сразу несколько раз при конфликтах с другими потоками.</param>
        <summary>Изменяет текущее значение на семантику транзакции оптимистической блокировки, используя указанную функцию трансформации.             Преобразование извлекается столько раз, сколько требуется для устранения конфликта оптимистической блокировки.</summary>
        <returns><see langword="true" />, если значение расположения изменилось после применения результата функции <paramref name="transformer" />; <see langword="false" />, если значение расположения осталось неизменным, поскольку последний вызов <paramref name="transformer" /> вернул существующее значение.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update&lt;T,TArg&gt;">
      <MemberSignature Language="C#" Value="public static bool Update&lt;T,TArg&gt; (ref T location, Func&lt;T,TArg,T&gt; transformer, TArg transformerArgument) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Update&lt;class T, TArg&gt;(!!T&amp; location, class System.Func`3&lt;!!T, !!TArg, !!T&gt; transformer, !!TArg transformerArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.Update``2(``0@,System.Func{``0,``1,``0},``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Update(Of T As Class, TArg As Class) (ByRef location As T, transformer As Func(Of T, TArg, T), transformerArgument As TArg) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TArg&gt;&#xA; where T : class static bool Update(T % location, Func&lt;T, TArg, T&gt; ^ transformer, TArg transformerArgument);" />
      <MemberSignature Language="F#" Value="static member Update : 'T * Func&lt;'T, 'Arg, 'T (requires 'T : null and 'T : null)&gt; * 'Arg -&gt; bool (requires 'T : null)" Usage="System.Collections.Immutable.ImmutableInterlocked.Update (location, transformer, transformerArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TArg" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="T" RefType="ref" />
        <Parameter Name="transformer" Type="System.Func&lt;T,TArg,T&gt;" />
        <Parameter Name="transformerArgument" Type="TArg" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип данных.</typeparam>
        <typeparam name="TArg">Тип аргумента, переданного в <paramref name="transformer" />.</typeparam>
        <param name="location">Переменная или изменяемое поле, к которым могут обращаться сразу несколько потоков.</param>
        <param name="transformer">Функция, изменяющая значение. Эта функция не должна иметь никаких побочных эффектов, поскольку может выполняться сразу несколько раз при конфликтах с другими потоками.</param>
        <param name="transformerArgument">Аргумент, передаваемый в <paramref name="transformer" />.</param>
        <summary>Изменяет текущее значение на семантику транзакции оптимистической блокировки, используя указанную функцию трансформации.             Преобразование извлекается столько раз, сколько требуется для устранения конфликта оптимистической блокировки.</summary>
        <returns><see langword="true" />, если значение расположения изменилось после применения результата функции <paramref name="transformer" />; <see langword="false" />, если значение расположения осталось неизменным, поскольку последний вызов <paramref name="transformer" /> вернул существующее значение.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
