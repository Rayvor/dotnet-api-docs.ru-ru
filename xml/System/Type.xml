<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c6780b83922cb2cab78948eb62ecfa1c898e0ad2" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73383826" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="95a33-101">Представляет объявления типов для классов, интерфейсов, массивов, значений, перечислений параметров, определений универсальных типов и открытых или закрытых сконструированных универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-101">Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-102">`Type` является корнем функции <xref:System.Reflection> и является основным способом доступа к метаданным.</span><span class="sxs-lookup"><span data-stu-id="95a33-102">`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata.</span></span> <span data-ttu-id="95a33-103">Члены <xref:System.Type> используются для получения сведений об объявлении типа, о членах типа (таких как конструкторы, методы, поля, свойства и события класса), а также о модуле и сборке, в которой развернут класс.</span><span class="sxs-lookup"><span data-stu-id="95a33-103">Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</span></span>  
  
 <span data-ttu-id="95a33-104">Разрешения не требуются, чтобы код использовал отражение для получения сведений о типах и их членах, независимо от их уровней доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-104">No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</span></span> <span data-ttu-id="95a33-105">Разрешения не требуются, чтобы код использовал отражение для доступа к открытым членам или другим членам, уровни доступа которых станут видимыми во время обычной компиляции.</span><span class="sxs-lookup"><span data-stu-id="95a33-105">No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</span></span> <span data-ttu-id="95a33-106">Однако, чтобы код использовал отражение для доступа к членам, которые обычно недоступны, например закрытые или внутренние методы, или защищенные поля типа, который не наследуется классом, код должен иметь <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="95a33-106">However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="95a33-107">См. раздел [вопросы безопасности при отражении](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-107">See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
 <span data-ttu-id="95a33-108">`Type` является абстрактным базовым классом, который допускает несколько реализаций.</span><span class="sxs-lookup"><span data-stu-id="95a33-108">`Type` is an abstract base class that allows multiple implementations.</span></span> <span data-ttu-id="95a33-109">Система всегда будет предоставлять производный класс `RuntimeType`.</span><span class="sxs-lookup"><span data-stu-id="95a33-109">The system will always provide the derived class `RuntimeType`.</span></span> <span data-ttu-id="95a33-110">В отражении все классы, начинающиеся со слова Runtime, создаются только один раз для каждого объекта в системе и поддерживают операции сравнения.</span><span class="sxs-lookup"><span data-stu-id="95a33-110">In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-111">В сценариях многопоточности не блокируйте <xref:System.Type> объекты, чтобы синхронизировать доступ к `static` данным.</span><span class="sxs-lookup"><span data-stu-id="95a33-111">In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data.</span></span> <span data-ttu-id="95a33-112">Другой код, для которого нет элемента управления, может также заблокировать тип класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-112">Other code, over which you have no control, might also lock your class type.</span></span> <span data-ttu-id="95a33-113">Это может привести к взаимоблокировке.</span><span class="sxs-lookup"><span data-stu-id="95a33-113">This might result in a deadlock.</span></span> <span data-ttu-id="95a33-114">Вместо этого следует синхронизировать доступ к статическим данным путем блокировки закрытого объекта `static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-114">Instead, synchronize access to static data by locking a private `static` object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-115">Производный класс может обращаться к защищенным членам базовых классов вызывающего кода.</span><span class="sxs-lookup"><span data-stu-id="95a33-115">A derived class can access protected members of the calling code's base classes.</span></span> <span data-ttu-id="95a33-116">Кроме того, доступ к членам сборки вызывающего кода разрешен.</span><span class="sxs-lookup"><span data-stu-id="95a33-116">Also, access is allowed to assembly members of the calling code's assembly.</span></span> <span data-ttu-id="95a33-117">Как правило, если доступ разрешен в коде с ранней привязкой, доступ к нему также разрешен в коде с поздним связыванием.</span><span class="sxs-lookup"><span data-stu-id="95a33-117">As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-118">Интерфейсы, расширяющие другие интерфейсы, не наследуют методы, определенные в расширенных интерфейсах.</span><span class="sxs-lookup"><span data-stu-id="95a33-118">Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</span></span>  
  
 <span data-ttu-id="95a33-119">Содержание</span><span class="sxs-lookup"><span data-stu-id="95a33-119">In this section:</span></span>  
  
 <span data-ttu-id="95a33-120">[Какие типы представляет объект типа?](#WhatTypes) </span><span class="sxs-lookup"><span data-stu-id="95a33-120">[What types does a Type object represent?](#WhatTypes) </span></span>  
 <span data-ttu-id="95a33-121">[Получение объекта типа](#Retrieve) </span><span class="sxs-lookup"><span data-stu-id="95a33-121">[Retrieving a Type object](#Retrieve) </span></span>  
 [<span data-ttu-id="95a33-122">Сравнение объектов типа на равенство</span><span class="sxs-lookup"><span data-stu-id="95a33-122">Comparing type objects for equality</span></span>](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a><span data-ttu-id="95a33-123">Какие типы представляет объект типа?</span><span class="sxs-lookup"><span data-stu-id="95a33-123">What types does a Type object represent?</span></span>  
 <span data-ttu-id="95a33-124">Этот класс является потокобезопасным; несколько потоков могут одновременно считывать из экземпляра этого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-124">This class is thread safe; multiple threads can concurrently read from an instance of this type.</span></span> <span data-ttu-id="95a33-125">Экземпляр класса <xref:System.Type> может представлять любой из следующих типов:</span><span class="sxs-lookup"><span data-stu-id="95a33-125">An instance of the <xref:System.Type> class can represent any of the following types:</span></span>  
  
-   <span data-ttu-id="95a33-126">Классы</span><span class="sxs-lookup"><span data-stu-id="95a33-126">Classes</span></span>  
  
-   <span data-ttu-id="95a33-127">Типы значений</span><span class="sxs-lookup"><span data-stu-id="95a33-127">Value types</span></span>  
  
-   <span data-ttu-id="95a33-128">Массивы</span><span class="sxs-lookup"><span data-stu-id="95a33-128">Arrays</span></span>  
  
-   <span data-ttu-id="95a33-129">интерфейсов,</span><span class="sxs-lookup"><span data-stu-id="95a33-129">Interfaces</span></span>  
  
-   <span data-ttu-id="95a33-130">Перечисления</span><span class="sxs-lookup"><span data-stu-id="95a33-130">Enumerations</span></span>  
  
-   <span data-ttu-id="95a33-131">Делегаты</span><span class="sxs-lookup"><span data-stu-id="95a33-131">Delegates</span></span>  
  
-   <span data-ttu-id="95a33-132">Сконструированные универсальные типы и определения универсальных типов</span><span class="sxs-lookup"><span data-stu-id="95a33-132">Constructed generic types and generic type definitions</span></span>  
  
-   <span data-ttu-id="95a33-133">Аргументы типа и параметры типов сконструированных универсальных типов, определений универсальных типов и определений универсальных методов</span><span class="sxs-lookup"><span data-stu-id="95a33-133">Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</span></span>  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a><span data-ttu-id="95a33-134">Получение объекта типа</span><span class="sxs-lookup"><span data-stu-id="95a33-134">Retrieving a Type object</span></span>  
 <span data-ttu-id="95a33-135">Объект <xref:System.Type>, связанный с определенным типом, можно получить следующими способами.</span><span class="sxs-lookup"><span data-stu-id="95a33-135">The <xref:System.Type> object associated with a particular type can be obtained in the following ways:</span></span>  
  
-   <span data-ttu-id="95a33-136">Метод <xref:System.Object.GetType%2A?displayProperty=nameWithType> экземпляра возвращает объект <xref:System.Type>, представляющий тип экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-136">The instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> method returns a <xref:System.Type> object that represents the type of an instance.</span></span> <span data-ttu-id="95a33-137">Поскольку все управляемые типы являются производными от <xref:System.Object>, метод <xref:System.Object.GetType%2A> может быть вызван для экземпляра любого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-137">Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.</span></span>  
  
     <span data-ttu-id="95a33-138">В следующем примере вызывается метод <xref:System.Object.GetType%2A?displayProperty=nameWithType> для определения типа среды выполнения каждого объекта в массиве объектов.</span><span class="sxs-lookup"><span data-stu-id="95a33-138">The following example calls the <xref:System.Object.GetType%2A?displayProperty=nameWithType> method to determine the runtime type of each object in an object array.</span></span>  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   <span data-ttu-id="95a33-139">Статические <xref:System.Type.GetType%2A?displayProperty=nameWithType> методы возвращают объект <xref:System.Type>, представляющий тип, указанный с помощью его полного имени.</span><span class="sxs-lookup"><span data-stu-id="95a33-139">The static <xref:System.Type.GetType%2A?displayProperty=nameWithType> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.</span></span>  
  
-   <span data-ttu-id="95a33-140">Методы <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>и <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> возвращают `Type` объекты, представляющие типы, определенные в модуле.</span><span class="sxs-lookup"><span data-stu-id="95a33-140">The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> methods return `Type` objects that represent the types defined in a module.</span></span> <span data-ttu-id="95a33-141">Первый метод можно использовать для получения массива объектов <xref:System.Type> для всех открытых и закрытых типов, определенных в модуле.</span><span class="sxs-lookup"><span data-stu-id="95a33-141">The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module.</span></span> <span data-ttu-id="95a33-142">(Экземпляр `Module` можно получить с помощью метода <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> или с помощью свойства <xref:System.Type.Module%2A?displayProperty=nameWithType>.)</span><span class="sxs-lookup"><span data-stu-id="95a33-142">(You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> method, or through the <xref:System.Type.Module%2A?displayProperty=nameWithType> property.)</span></span>  
  
-   <span data-ttu-id="95a33-143">Объект <xref:System.Reflection.Assembly?displayProperty=nameWithType> содержит ряд методов для получения классов, определенных в сборке, включая <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>и <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-143">The <xref:System.Reflection.Assembly?displayProperty=nameWithType> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="95a33-144">Метод <xref:System.Type.FindInterfaces%2A> возвращает отфильтрованный список типов интерфейсов, поддерживаемых типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-144">The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="95a33-145">Метод <xref:System.Type.GetElementType%2A> возвращает объект `Type`, представляющий элемент.</span><span class="sxs-lookup"><span data-stu-id="95a33-145">The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.</span></span>  
  
-   <span data-ttu-id="95a33-146">Методы <xref:System.Type.GetInterfaces%2A> и <xref:System.Type.GetInterface%2A> возвращают <xref:System.Type> объекты, представляющие типы интерфейсов, поддерживаемые типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-146">The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="95a33-147">Метод <xref:System.Type.GetTypeArray%2A> возвращает массив объектов <xref:System.Type>, представляющих типы, заданные произвольным набором объектов.</span><span class="sxs-lookup"><span data-stu-id="95a33-147">The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects.</span></span> <span data-ttu-id="95a33-148">Объекты указываются с помощью массива типа <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="95a33-148">The objects are specified with an array of type <xref:System.Object>.</span></span>  
  
-   <span data-ttu-id="95a33-149">Методы <xref:System.Type.GetTypeFromProgID%2A> и <xref:System.Type.GetTypeFromCLSID%2A> предоставляются для COM-взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="95a33-149">The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability.</span></span> <span data-ttu-id="95a33-150">Они возвращают объект <xref:System.Type>, представляющий тип, заданный `ProgID` или `CLSID`.</span><span class="sxs-lookup"><span data-stu-id="95a33-150">They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.</span></span>  
  
-   <span data-ttu-id="95a33-151">Метод <xref:System.Type.GetTypeFromHandle%2A> обеспечивает взаимодействие.</span><span class="sxs-lookup"><span data-stu-id="95a33-151">The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability.</span></span> <span data-ttu-id="95a33-152">Он возвращает объект `Type`, представляющий тип, указанный в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-152">It returns a `Type` object that represents the type specified by a class handle.</span></span>  
  
-   <span data-ttu-id="95a33-153">Оператор C# `typeof`, оператор C++ `typeid` и оператор Visual Basic `GetType` получают объект `Type` для типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-153">The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.</span></span>  
  
-   <span data-ttu-id="95a33-154">Метод <xref:System.Type.MakeGenericType%2A> возвращает объект <xref:System.Type>, представляющий сконструированный универсальный тип, который представляет собой открытый сконструированный тип, если его свойство <xref:System.Type.ContainsGenericParameters%2A> возвращает `true`, а закрытый сконструированный тип — в противном случае.</span><span class="sxs-lookup"><span data-stu-id="95a33-154">The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise.</span></span> <span data-ttu-id="95a33-155">Универсальный тип можно создать только в том случае, если он закрыт.</span><span class="sxs-lookup"><span data-stu-id="95a33-155">A generic type can be instantiated only if it is closed.</span></span>  
  
-   <span data-ttu-id="95a33-156">Методы <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>и <xref:System.Type.MakeByRefType%2A> возвращают <xref:System.Type> объектов, представляющих соответственно массив указанного типа, указатель на указанный тип и тип ссылочного параметра (`ref` C#в `ByRef` Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-156">The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).</span></span>  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a><span data-ttu-id="95a33-157">Сравнение объектов типа на равенство</span><span class="sxs-lookup"><span data-stu-id="95a33-157">Comparing type objects for equality</span></span>  
 <span data-ttu-id="95a33-158">Объект <xref:System.Type>, представляющий тип, является уникальным; то есть две ссылки на объект <xref:System.Type> ссылаются на один и тот же объект, только если они представляют один и тот же тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-158">A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type.</span></span> <span data-ttu-id="95a33-159">Это позволяет сравнивать <xref:System.Type> объекты, используя равенство ссылок.</span><span class="sxs-lookup"><span data-stu-id="95a33-159">This allows for comparison of <xref:System.Type> objects using reference equality.</span></span> <span data-ttu-id="95a33-160">В следующем примере сравниваются <xref:System.Type> объекты, представляющие число целочисленных значений, чтобы определить, относятся ли они к одному типу.</span><span class="sxs-lookup"><span data-stu-id="95a33-160">The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.</span></span>  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="95a33-161">В следующем примере показаны несколько репрезентативных функций <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-161">The following example shows a few representative features of <xref:System.Type>.</span></span> <span data-ttu-id="95a33-162">Оператор C# `typeof` (оператор`GetType` в Visual Basic) используется для получения объекта <xref:System.Type>, представляющего <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="95a33-162">The C# `typeof` operator (`GetType` operator in Visual Basic) is used to get a <xref:System.Type> object representing <xref:System.String>.</span></span> <span data-ttu-id="95a33-163">В этом <xref:System.Type>ном объекте метод <xref:System.Type.GetMethod%2A> используется для получения <xref:System.Reflection.MethodInfo>, представляющего перегрузку <xref:System.String.Substring%2A?displayProperty=nameWithType>, которая принимает начальное расположение и длину.</span><span class="sxs-lookup"><span data-stu-id="95a33-163">From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A?displayProperty=nameWithType> overload that takes a starting location and a length.</span></span>
  
 <span data-ttu-id="95a33-164">Для обнаружения сигнатуры перегрузки в примере кода создается временный массив, содержащий два <xref:System.Type> объектов, представляющих `int` (`Integer` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-164">To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-165">Чтобы быть точным, массив содержит две ссылки на экземпляр <xref:System.Type>, который представляет `int` в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="95a33-165">To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain.</span></span> <span data-ttu-id="95a33-166">Для любого типа существует только один экземпляр <xref:System.Type> для каждого домена приложения.</span><span class="sxs-lookup"><span data-stu-id="95a33-166">For any type, there is only one instance of <xref:System.Type> per application domain.</span></span>  
  
 <span data-ttu-id="95a33-167">В примере кода используется <xref:System.Reflection.MethodInfo> для вызова метода <xref:System.String.Substring%2A> в строке "Hello, World!" и отображается результат.</span><span class="sxs-lookup"><span data-stu-id="95a33-167">The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World!", and displays the result.</span></span>  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="95a33-168">Данный тип потокобезопасен.</span><span class="sxs-lookup"><span data-stu-id="95a33-168">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="95a33-169">При наследовании от <see langword="Type" />необходимо переопределить следующие члены:</span><span class="sxs-lookup"><span data-stu-id="95a33-169">When you inherit from <see langword="Type" />, you must override the following members:</span></span> 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md"><span data-ttu-id="95a33-170">Просмотр сведений о типах</span><span class="sxs-lookup"><span data-stu-id="95a33-170">Viewing Type Information</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-171">Инициализирует новый экземпляр класса <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-171">Initializes a new instance of the <see cref="T:System.Type" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-172">Этот конструктор вызывается производными классами во время создания объектов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-172">This constructor is invoked by derived classes during the construction of type objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-173">Возвращает объект <see cref="T:System.Reflection.Assembly" />, в котором объявлен тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-173">Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.</span></span> <span data-ttu-id="95a33-174">Для универсальных типов возвращает объект сборки <see cref="T:System.Reflection.Assembly" />, в которой определен универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-174">For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</span></span></summary>
        <value><span data-ttu-id="95a33-175">Экземпляр <see cref="T:System.Reflection.Assembly" />, описывающий сборку, которая содержит текущий тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-175">An <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.</span></span> <span data-ttu-id="95a33-176">Для универсальных типов экземпляр описывает сборку, содержащую определение универсального типа, а не сборку, которая создала и использует определенный сконструированный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-176">For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-177">Если текущий объект <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает сборку, содержащую определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-177">If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</span></span> <span data-ttu-id="95a33-178">Например, предположим, что создается сборка с именем Миженерикс. dll, которая содержит определение универсального типа `MyGenericStack<T>` (`MyGenericStack(Of T)` в Visual Basic, `generic<T> ref class MyGenericStack` C++в).</span><span class="sxs-lookup"><span data-stu-id="95a33-178">For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++).</span></span> <span data-ttu-id="95a33-179">При создании экземпляра `MyGenericStack<int>` (`MyGenericStack(Of Integer)` в Visual Basic) в другой сборке свойство <xref:System.Type.Assembly%2A> для сконструированного типа возвращает объект <xref:System.Reflection.Assembly>, представляющий Миженерикс. dll.</span><span class="sxs-lookup"><span data-stu-id="95a33-179">If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.</span></span>  
  
 <span data-ttu-id="95a33-180">Аналогично, если текущий объект <xref:System.Type> представляет неназначенный универсальный параметр `T`, это свойство возвращает сборку, содержащую универсальный тип, определяющий `T`.</span><span class="sxs-lookup"><span data-stu-id="95a33-180">Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
 <span data-ttu-id="95a33-181">Если свойство <xref:System.Type.Assembly%2A?displayProperty=nameWithType> недоступно в конкретной реализации .NET, например .NET Core или универсальная платформа Windows, используйте вместо этого свойство <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-181">If the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> property instead.</span></span>      
  
 <span data-ttu-id="95a33-182">Это свойство доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-182">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-183">В следующем примере выводится имя сборки, связанной с классом, и полное имя типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-183">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-184">Возвращает имя типа с указанием сборки, включающее имя сборки, из которой был загружен объект <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-184">Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</span></span></summary>
        <value><span data-ttu-id="95a33-185">Имя объекта <see cref="T:System.Type" /> с указанием сборки, включающее имя сборки, из которой был загружен объект <see cref="T:System.Type" />, или значение <see langword="null" />, если текущий экземпляр представляет параметр универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-185">The assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded, or <see langword="null" /> if the current instance represents a generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-186">Имя с указанием сборки типа состоит из имени типа, включая его пространство имен, за которым следует запятая, за которым следует отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-186">The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</span></span> <span data-ttu-id="95a33-187">Отображаемое имя сборки получается с помощью свойства <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-187">The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-188">В .NET Framework версии 2,0 архитектура процессора добавляется в удостоверение сборки и может быть указана в качестве части строк имен сборок.</span><span class="sxs-lookup"><span data-stu-id="95a33-188">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="95a33-189">Например, "ProcessorArchitecture = MSIL".</span><span class="sxs-lookup"><span data-stu-id="95a33-189">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="95a33-190">Однако он не включается в строку, возвращенную свойством <xref:System.Type.AssemblyQualifiedName%2A>, по причинам совместимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-190">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="95a33-191">См. раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-191">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="95a33-192">Все компиляторы, поддерживающие среду CLR, выдают простое имя вложенного класса, а отражение при запросе создает искаженное имя в соответствии со следующими соглашениями.</span><span class="sxs-lookup"><span data-stu-id="95a33-192">All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="95a33-193">Разделитель</span><span class="sxs-lookup"><span data-stu-id="95a33-193">Delimiter</span></span>|<span data-ttu-id="95a33-194">Значение</span><span class="sxs-lookup"><span data-stu-id="95a33-194">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="95a33-195">Обратная косая черта (\\)</span><span class="sxs-lookup"><span data-stu-id="95a33-195">Backslash (\\)</span></span>|<span data-ttu-id="95a33-196">Escape-символ.</span><span class="sxs-lookup"><span data-stu-id="95a33-196">Escape character.</span></span>|  
|<span data-ttu-id="95a33-197">Запятая (,)</span><span class="sxs-lookup"><span data-stu-id="95a33-197">Comma (,)</span></span>|<span data-ttu-id="95a33-198">Предшествует имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-198">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="95a33-199">Знак плюса (+)</span><span class="sxs-lookup"><span data-stu-id="95a33-199">Plus sign (+)</span></span>|<span data-ttu-id="95a33-200">Предшествует вложенному классу.</span><span class="sxs-lookup"><span data-stu-id="95a33-200">Precedes a nested class.</span></span>|  
|<span data-ttu-id="95a33-201">Точка (.)</span><span class="sxs-lookup"><span data-stu-id="95a33-201">Period (.)</span></span>|<span data-ttu-id="95a33-202">Обозначает идентификаторы пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-202">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="95a33-203">Квадратные скобки ([])</span><span class="sxs-lookup"><span data-stu-id="95a33-203">Brackets ([])</span></span>|<span data-ttu-id="95a33-204">После имени типа обозначает массив этого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-204">After a type name, denotes an array of that type.</span></span><br /><br /> <span data-ttu-id="95a33-205">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-205">-or-</span></span><br /><br /> <span data-ttu-id="95a33-206">Для универсального типа заключает список аргументов универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-206">For a generic type, encloses the generic type argument list.</span></span><br /><br /> <span data-ttu-id="95a33-207">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-207">-or-</span></span><br /><br /> <span data-ttu-id="95a33-208">В списке аргументов типа заключает в себя тип с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-208">Within a type argument list, encloses an assembly-qualified type.</span></span>|  
  
 <span data-ttu-id="95a33-209">Например, полное имя сборки для класса может выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-209">For example, the assembly-qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 <span data-ttu-id="95a33-210">Если пространство имен содержит знак «плюс», например Топнамеспаце. Re+ Namespace, то перед знаком «плюс» (+) будет стоять escape-символ (\\), чтобы предотвратить его интерпретацию как разделителя вложений.</span><span class="sxs-lookup"><span data-stu-id="95a33-210">If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="95a33-211">При отражении эта строка будет выдаваться следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-211">Reflection would emit this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 <span data-ttu-id="95a33-212">"+ +" Преобразуется в "\\+\\+", а "\\" преобразуется в "\\\\".</span><span class="sxs-lookup"><span data-stu-id="95a33-212">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="95a33-213">Это полное имя можно сохранить и позже использовать для загрузки <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-213">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="95a33-214">Чтобы найти и загрузить <xref:System.Type>, используйте <xref:System.Type.GetType%2A> либо с именем типа, либо с полным именем типа сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-214">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="95a33-215"><xref:System.Type.GetType%2A> с именем типа будет искать только <xref:System.Type> в сборке вызывающего объекта, а затем в системной сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-215"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="95a33-216"><xref:System.Type.GetType%2A> с полным именем типа сборки будет искать <xref:System.Type> в любой сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-216"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="95a33-217">Имена типов могут содержать конечные символы, которые обозначают дополнительные сведения о типе, например, является ли тип ссылочным типом, типом указателя или типом массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-217">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="95a33-218">Чтобы получить имя типа без этих замыкающих символов, используйте `t.GetElementType().ToString()`, где `t` — это тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-218">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="95a33-219">Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-219">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="95a33-220">В имени сборки учитываются пробелы перед разделителем ",", но пробелы после разделителя "," игнорируются.</span><span class="sxs-lookup"><span data-stu-id="95a33-220">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="95a33-221">Универсальные аргументы универсальных типов сами по себе имеют имя сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-221">Generic arguments of generic types are themselves qualified by assembly name.</span></span> <span data-ttu-id="95a33-222">Например, в имени типа с указанием сборки для `MyGenericClass<int>` (`MyGenericClass(Of Integer)` в Visual Basic) `int` расширяется на имя типа с указанием сборки для <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="95a33-222">For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="95a33-223">Если текущий объект <xref:System.Type> представляет универсальный параметр, это свойство возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-223">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-224">В следующем примере выводится имя сборки, связанной с классом, и полное имя типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-224">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 <span data-ttu-id="95a33-225">В следующем примере сравниваются строки, возвращаемые методом <xref:System.Type.ToString%2A> и свойствами `Name`, <xref:System.Type.FullName%2A>и <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-225">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="95a33-226">Указание полных имен типов</span><span class="sxs-lookup"><span data-stu-id="95a33-226">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-227">Возвращает атрибуты, связанные с объектом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-227">Gets the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="95a33-228">Объект <see cref="T:System.Reflection.TypeAttributes" />, представляющий набор атрибутов типа <see cref="T:System.Type" />, если <see cref="T:System.Type" /> не представляет параметр универсального типа. В противном случае это значение не определено.</span><span class="sxs-lookup"><span data-stu-id="95a33-228">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />, unless the <see cref="T:System.Type" /> represents a generic type parameter, in which case the value is unspecified.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-229">Некоторые члены перечисления <xref:System.Reflection.TypeAttributes> представляют собой маски, представляющие группу значений.</span><span class="sxs-lookup"><span data-stu-id="95a33-229">Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values.</span></span> <span data-ttu-id="95a33-230">Каждая группа содержит один член, базовое значение которого равно нулю.</span><span class="sxs-lookup"><span data-stu-id="95a33-230">Each group includes one member whose underlying value is zero.</span></span> <span data-ttu-id="95a33-231">Например, базовое значение элемента <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> в группе <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> равно нулю, как и элемент <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> в группе <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-231">For example, the underlying value of the <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> group is zero, as is the <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> group.</span></span> <span data-ttu-id="95a33-232">Поэтому перед тестированием этих значений необходимо использовать маску.</span><span class="sxs-lookup"><span data-stu-id="95a33-232">Because of this, you must use the mask before testing for those values.</span></span> <span data-ttu-id="95a33-233">Иллюстрация приведена в примере.</span><span class="sxs-lookup"><span data-stu-id="95a33-233">The example provides an illustration.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="95a33-234">Для большинства целей такие свойства, как <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>и <xref:System.Type.IsSpecialName%2A>, проще в использовании, чем атрибуты типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-234">For most purposes, properties like <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and <xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.</span></span>  
  
 <span data-ttu-id="95a33-235">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает атрибуты определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-235">If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition.</span></span> <span data-ttu-id="95a33-236">Например, атрибуты, возвращаемые для `MyGenericClass<int>` (`MyGenericClass(Of Integer)` в Visual Basic), являются атрибутами `MyGenericClass<T>` (`MyGenericClass(Of T)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-236">For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="95a33-237">Если текущий <xref:System.Type> представляет параметр универсального типа, то есть если свойство <xref:System.Type.IsGenericParameter%2A> возвращает `true` — значение <xref:System.Reflection.TypeAttributes>, возвращаемое этим свойством, не определено.</span><span class="sxs-lookup"><span data-stu-id="95a33-237">If the current <xref:System.Type> represents a generic type parameter - that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true` - the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-238">В следующем примере используется свойство <xref:System.Type.Attributes%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-238">The following example uses the <xref:System.Type.Attributes%2A> property.</span></span>  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-239">Возвращает тип, для которого текущий объект <see cref="T:System.Type" /> является непосредственным наследником.</span><span class="sxs-lookup"><span data-stu-id="95a33-239">Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</span></span></summary>
        <value><span data-ttu-id="95a33-240">Объект <see cref="T:System.Type" />, прямым наследником которого является текущий объект <see cref="T:System.Type" />, или <see langword="null" />, если текущий объект <see langword="Type" /> представляет класс <see cref="T:System.Object" /> или интерфейс.</span><span class="sxs-lookup"><span data-stu-id="95a33-240">The <see cref="T:System.Type" /> from which the current <see cref="T:System.Type" /> directly inherits, or <see langword="null" /> if the current <see langword="Type" /> represents the <see cref="T:System.Object" /> class or an interface.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-241">Базовый тип — это тип, от которого непосредственно наследуется текущий тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-241">The base type is the type from which the current type directly inherits.</span></span> <span data-ttu-id="95a33-242"><xref:System.Object> является единственным типом, который не имеет базового типа, поэтому `null` возвращается в качестве базового типа <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="95a33-242"><xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="95a33-243">Интерфейсы наследуют от нуля или более базовых интерфейсов; Поэтому это свойство возвращает `null`, если объект `Type` представляет интерфейс.</span><span class="sxs-lookup"><span data-stu-id="95a33-243">Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface.</span></span> <span data-ttu-id="95a33-244">Базовые интерфейсы можно определить с помощью <xref:System.Type.GetInterfaces%2A> или <xref:System.Type.FindInterfaces%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-244">The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.</span></span>  
  
 <span data-ttu-id="95a33-245">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, базовый тип отражает универсальные аргументы.</span><span class="sxs-lookup"><span data-stu-id="95a33-245">If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments.</span></span> <span data-ttu-id="95a33-246">В качестве примера рассмотрим следующие объявления:</span><span class="sxs-lookup"><span data-stu-id="95a33-246">For example, consider the following declarations:</span></span>  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="95a33-247">Для сконструированного типа `C<int>` (`C(Of Integer)` в Visual Basic) свойство <xref:System.Type.BaseType%2A> возвращает `B<int>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-247">For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.</span></span>  
  
 <span data-ttu-id="95a33-248">Если текущий <xref:System.Type> представляет параметр типа определения универсального типа, <xref:System.Type.BaseType%2A> возвращает ограничение класса, то есть класс, который должен наследовать параметр типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-248">If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit.</span></span> <span data-ttu-id="95a33-249">Если ограничение класса отсутствует, <xref:System.Type.BaseType%2A> возвращает <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-249">If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="95a33-250">Это свойство доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-250">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-251">В следующем примере демонстрируется использование свойства <xref:System.Type.BaseType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-251">The following example demonstrates using the <xref:System.Type.BaseType%2A> property.</span></span>  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 <span data-ttu-id="95a33-252">В следующем примере рекурсия используется для перечисления полной иерархии наследования для каждого класса, найденного в сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-252">The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</span></span> <span data-ttu-id="95a33-253">В примере определяется класс с именем `C`, производный от класса с именем `B`, который, в свою очередь, является производным от класса с именем `A`.</span><span class="sxs-lookup"><span data-stu-id="95a33-253">The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.</span></span>  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="95a33-254">Отражение и универсальные типы</span><span class="sxs-lookup"><span data-stu-id="95a33-254">Reflection and Generic Types</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-255">Возвращает значение, позволяющее определить, имеются ли у текущего объекта <see cref="T:System.Type" /> параметры типа, которые не были замещены указанными типами.</span><span class="sxs-lookup"><span data-stu-id="95a33-255">Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</span></span></summary>
        <value><span data-ttu-id="95a33-256">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> сам является параметром универсального типа или если для его параметров типа не предоставлены определенные типы; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-256"><see langword="true" /> if the <see cref="T:System.Type" /> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-257">Чтобы создать экземпляр типа, не должно быть определений универсального типа или открытых сконструированных типов в аргументах типа самого типа, во всех включающих универсальных типах или в любых элементах типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-257">In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</span></span> <span data-ttu-id="95a33-258">Другой способ сказать, что при рекурсивном исследовании тип не должен содержать параметров универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-258">Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</span></span>  
  
 <span data-ttu-id="95a33-259">Так как типы могут быть произвольными сложными, такое определение сложно.</span><span class="sxs-lookup"><span data-stu-id="95a33-259">Since types can be arbitrarily complex, making this determination is difficult.</span></span> <span data-ttu-id="95a33-260">Для удобства и снижения вероятности возникновения ошибки свойство <xref:System.Type.ContainsGenericParameters%2A> предоставляет стандартный способ различения закрытых сконструированных типов, которые могут быть созданы, и открытых сконструированных типов, которые не могут.</span><span class="sxs-lookup"><span data-stu-id="95a33-260">For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</span></span> <span data-ttu-id="95a33-261">Если свойство <xref:System.Type.ContainsGenericParameters%2A> возвращает `true`, создание экземпляра типа невозможно.</span><span class="sxs-lookup"><span data-stu-id="95a33-261">If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.</span></span>  
  
 <span data-ttu-id="95a33-262">Свойство <xref:System.Type.ContainsGenericParameters%2A> выполняет рекурсивный поиск параметров типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-262">The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="95a33-263">Например, он возвращает `true` для массива, элементы которого имеют тип `A<T>` (`A(Of T)` в Visual Basic), несмотря на то, что массив не является универсальным.</span><span class="sxs-lookup"><span data-stu-id="95a33-263">For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic.</span></span> <span data-ttu-id="95a33-264">Сравните это с поведением свойства <xref:System.Type.IsGenericType%2A>, которое возвращает `false` для массивов.</span><span class="sxs-lookup"><span data-stu-id="95a33-264">Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.</span></span>  
  
 <span data-ttu-id="95a33-265">Набор примеров классов и таблица, в которой показаны значения свойства <xref:System.Type.ContainsGenericParameters%2A>, см. в разделе <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-265">For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-266">В следующем примере определяется универсальный класс с двумя параметрами типа, а затем определяется второй универсальный класс, производный от первого класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-266">The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="95a33-267">Базовый класс производного класса имеет два аргумента типа: первый — <xref:System.Int32>, а второй — параметр типа производного типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-267">The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="95a33-268">В примере отображаются сведения об этих универсальных классах, включая позиции, сообщаемые свойством <xref:System.Type.GenericParameterPosition%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-268">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="95a33-269">Отражение и универсальные типы</span><span class="sxs-lookup"><span data-stu-id="95a33-269">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="95a33-270">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-270">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-271">Возвращает метод <see cref="T:System.Reflection.MethodBase" />, который представляет объявляемый метод, если текущий <see cref="T:System.Type" /> представляет параметр типа универсального метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-271">Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</span></span></summary>
        <value><span data-ttu-id="95a33-272">Если текущий объект <see cref="T:System.Type" /> представляет параметр типа универсального метода, класс <see cref="T:System.Reflection.MethodBase" />, представляющий объявляемый метод; в противном случае — значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-272">If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodBase" /> that represents declaring method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-273">Объявляющий метод является определением универсального метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-273">The declaring method is a generic method definition.</span></span> <span data-ttu-id="95a33-274">То есть если <xref:System.Type.DeclaringMethod%2A> не возвращает `null`, `DeclaringMethod.IsGenericMethodDefinition` возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-274">That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.</span></span>  
  
 <span data-ttu-id="95a33-275">Свойства <xref:System.Type.DeclaringType%2A> и <xref:System.Type.DeclaringMethod%2A> определяют определение универсального типа или определение универсального метода, в котором был изначально определен параметр универсального типа:</span><span class="sxs-lookup"><span data-stu-id="95a33-275">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="95a33-276">Если свойство <xref:System.Type.DeclaringMethod%2A> возвращает <xref:System.Reflection.MethodInfo>, то <xref:System.Reflection.MethodInfo> представляет определение универсального метода, а текущий объект <xref:System.Type> представляет параметр типа этого определения универсального метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-276">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="95a33-277">Если свойство <xref:System.Type.DeclaringMethod%2A> возвращает `null`, то свойство <xref:System.Type.DeclaringType%2A> всегда возвращает объект <xref:System.Type>, представляющий определение универсального типа, а текущий объект <xref:System.Type> представляет параметр типа этого определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-277">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="95a33-278">Получение свойства <xref:System.Type.DeclaringMethod%2A> для типа, свойство <xref:System.Type.IsGenericParameter%2A> которого `false` создает исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="95a33-278">Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="95a33-279"><xref:System.Reflection.MethodBase>, возвращаемое свойством <xref:System.Type.DeclaringMethod%2A>, является либо <xref:System.Reflection.MethodInfo> в случае универсального метода, либо <xref:System.Reflection.ConstructorInfo> в случае с универсальным конструктором.</span><span class="sxs-lookup"><span data-stu-id="95a33-279">The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-280">В .NET Framework версии 2,0 Универсальные конструкторы не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="95a33-280">In the .NET Framework version 2.0, generic constructors are not supported.</span></span>  
  
 <span data-ttu-id="95a33-281">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-281">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-282">В следующем примере кода определяется класс, имеющий универсальный метод, который присваивает методу аргумент типа и вызывает созданный универсальный метод.</span><span class="sxs-lookup"><span data-stu-id="95a33-282">The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</span></span> <span data-ttu-id="95a33-283">Он также отображает сведения об определении универсального метода и сконструированном методе.</span><span class="sxs-lookup"><span data-stu-id="95a33-283">It also displays information about the generic method definition and the constructed method.</span></span> <span data-ttu-id="95a33-284">При отображении сведений о параметрах типа определения универсального метода в методе `DisplayGenericMethodInfo` в примере кода показано значение свойства <xref:System.Type.DeclaringMethod%2A> для параметра универсального типа метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-284">When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="95a33-285">Отражение и универсальные типы</span><span class="sxs-lookup"><span data-stu-id="95a33-285">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="95a33-286">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-286">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public abstract Type DeclaringType { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DeclaringType As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ DeclaringType { Type ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-287">Возвращает тип, объявивший текущий вложенный тип или параметр универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-287">Gets the type that declares the current nested type or generic type parameter.</span></span></summary>
        <value><span data-ttu-id="95a33-288">Объект <see cref="T:System.Type" />, представляющий включающий тип, если текущий тип является вложенным, или определение универсального типа, если текущий тип является параметром универсального типа, или тип, объявивший этот универсальный метод, если текущий тип является параметром типа универсального метода; в противном случае — значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-288">A <see cref="T:System.Type" /> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-289">Если текущий объект <xref:System.Type> представляет параметр типа универсального типа, это свойство возвращает определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-289">If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.</span></span>  
  
 <span data-ttu-id="95a33-290">Если текущий объект <xref:System.Type> представляет параметр типа универсального метода, это свойство возвращает тип, содержащий определение универсального метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-290">If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</span></span> <span data-ttu-id="95a33-291">Если тип является универсальным, возвращается определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-291">If the type is generic, the generic type definition is returned.</span></span> <span data-ttu-id="95a33-292">Таким образом, следующий код возвращает определение универсального типа <xref:System.Collections.Generic.List%601> универсального класса, который содержит универсальный метод <xref:System.Collections.Generic.List%601.ConvertAll%2A>:</span><span class="sxs-lookup"><span data-stu-id="95a33-292">That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:</span></span>  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="95a33-293">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, свойства <xref:System.Type.DeclaringType%2A> и <xref:System.Type.DeclaringMethod%2A> указывают определение универсального типа или определение универсального метода, в котором изначально был задан параметр универсального типа. определяется</span><span class="sxs-lookup"><span data-stu-id="95a33-293">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="95a33-294">Если свойство <xref:System.Type.DeclaringMethod%2A> возвращает <xref:System.Reflection.MethodInfo>, то <xref:System.Reflection.MethodInfo> представляет определение универсального метода, а текущий объект <xref:System.Type> представляет параметр типа этого определения универсального метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-294">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="95a33-295">Если свойство <xref:System.Type.DeclaringMethod%2A> возвращает `null`, то свойство <xref:System.Type.DeclaringType%2A> всегда возвращает объект <xref:System.Type>, представляющий определение универсального типа, а текущий объект <xref:System.Type> представляет параметр типа этого определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-295">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="95a33-296">Получение свойства <xref:System.Type.DeclaringType%2A> для типа, свойство <xref:System.Type.IsGenericParameter%2A> которого `false` создает исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="95a33-296">Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-297">В этом примере отображается объявляющий тип метода в производном классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-297">This example displays the declaring type of a method in a derived class.</span></span>  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-298">Возвращает ссылку на связыватель по умолчанию, который реализует внутренние правила выбора соответствующих членов, вызываемых методом <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-298">Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span></summary>
        <value><span data-ttu-id="95a33-299">Ссылка на связыватель, используемый в системе по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-299">A reference to the default binder used by the system.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-300">Связыватель по умолчанию, поставляемый со средой CLR, применим только в самых специализированных обстоятельствах.</span><span class="sxs-lookup"><span data-stu-id="95a33-300">The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</span></span> <span data-ttu-id="95a33-301">Если вам нужен связыватель, который соответствует правилам, отличающимся от указанных связывателей по умолчанию, определите тип, производный от класса <xref:System.Reflection.Binder> и передайте экземпляр этого типа, используя параметр `binder` одной из <xref:System.Type.InvokeMember%2A> перегрузок.</span><span class="sxs-lookup"><span data-stu-id="95a33-301">If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.</span></span>  
  
 <span data-ttu-id="95a33-302">Отражение моделирует правила специальных возможностей системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-302">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="95a33-303">Например, если вызывающий объект находится в той же сборке, вызывающему объекту не требуются специальные разрешения для внутренних членов.</span><span class="sxs-lookup"><span data-stu-id="95a33-303">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="95a33-304">В противном случае вызывающему объекту требуется <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="95a33-304">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="95a33-305">Это согласуется с поиском защищенных, закрытых и других элементов.</span><span class="sxs-lookup"><span data-stu-id="95a33-305">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="95a33-306">Основным принципом является то, что <xref:System.Reflection.Binder.ChangeType%2A> должны выполнять только расширяющие преобразования, которые никогда не теряют данные.</span><span class="sxs-lookup"><span data-stu-id="95a33-306">The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data.</span></span> <span data-ttu-id="95a33-307">Примером расширяющего преобразования является преобразование значения 32-битового целого числа со знаком в значение, которое является 64-битным целым числом со знаком.</span><span class="sxs-lookup"><span data-stu-id="95a33-307">An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="95a33-308">Это отличается от сужения преобразования, которое может привести к потере данных.</span><span class="sxs-lookup"><span data-stu-id="95a33-308">This is distinguished from a narrowing conversion, which may lose data.</span></span> <span data-ttu-id="95a33-309">Примером суженного преобразования является преобразование 64-разрядного целого числа со знаком в 32-разрядное целое число со знаком.</span><span class="sxs-lookup"><span data-stu-id="95a33-309">An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="95a33-310">В следующей таблице перечислены преобразования, поддерживаемые связывателем по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-310">The following table lists the conversions supported by the default binder.</span></span>  
  
|<span data-ttu-id="95a33-311">Тип источника</span><span class="sxs-lookup"><span data-stu-id="95a33-311">Source Type</span></span>|<span data-ttu-id="95a33-312">Тип целевого объекта</span><span class="sxs-lookup"><span data-stu-id="95a33-312">Target Type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="95a33-313">Любой тип</span><span class="sxs-lookup"><span data-stu-id="95a33-313">Any type</span></span>|<span data-ttu-id="95a33-314">Его базовый тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-314">Its base type.</span></span>|  
|<span data-ttu-id="95a33-315">Любой тип</span><span class="sxs-lookup"><span data-stu-id="95a33-315">Any type</span></span>|<span data-ttu-id="95a33-316">Интерфейс, который он реализует.</span><span class="sxs-lookup"><span data-stu-id="95a33-316">The interface it implements.</span></span>|  
|<span data-ttu-id="95a33-317">Char</span><span class="sxs-lookup"><span data-stu-id="95a33-317">Char</span></span>|<span data-ttu-id="95a33-318">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="95a33-318">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="95a33-319">Byte</span><span class="sxs-lookup"><span data-stu-id="95a33-319">Byte</span></span>|<span data-ttu-id="95a33-320">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="95a33-320">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="95a33-321">SByte</span><span class="sxs-lookup"><span data-stu-id="95a33-321">SByte</span></span>|<span data-ttu-id="95a33-322">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="95a33-322">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="95a33-323">UInt16</span><span class="sxs-lookup"><span data-stu-id="95a33-323">UInt16</span></span>|<span data-ttu-id="95a33-324">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="95a33-324">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="95a33-325">Int16</span><span class="sxs-lookup"><span data-stu-id="95a33-325">Int16</span></span>|<span data-ttu-id="95a33-326">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="95a33-326">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="95a33-327">UInt32</span><span class="sxs-lookup"><span data-stu-id="95a33-327">UInt32</span></span>|<span data-ttu-id="95a33-328">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="95a33-328">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="95a33-329">Int32</span><span class="sxs-lookup"><span data-stu-id="95a33-329">Int32</span></span>|<span data-ttu-id="95a33-330">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="95a33-330">Int64, Single, Double</span></span>|  
|<span data-ttu-id="95a33-331">UInt64</span><span class="sxs-lookup"><span data-stu-id="95a33-331">UInt64</span></span>|<span data-ttu-id="95a33-332">Single, Double</span><span class="sxs-lookup"><span data-stu-id="95a33-332">Single, Double</span></span>|  
|<span data-ttu-id="95a33-333">Int64</span><span class="sxs-lookup"><span data-stu-id="95a33-333">Int64</span></span>|<span data-ttu-id="95a33-334">Single, Double</span><span class="sxs-lookup"><span data-stu-id="95a33-334">Single, Double</span></span>|  
|<span data-ttu-id="95a33-335">Single</span><span class="sxs-lookup"><span data-stu-id="95a33-335">Single</span></span>|<span data-ttu-id="95a33-336">Double</span><span class="sxs-lookup"><span data-stu-id="95a33-336">Double</span></span>|  
|<span data-ttu-id="95a33-337">Не является ссылкой</span><span class="sxs-lookup"><span data-stu-id="95a33-337">Non-reference</span></span>|<span data-ttu-id="95a33-338">По ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-338">By-reference.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="95a33-339">В следующем примере возвращается связыватель по умолчанию из свойства `DefaultBinder` и вызывается член MyClass путем передачи значения `DefaultBinder` в качестве параметра в <xref:System.Type.InvokeMember%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-339">The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.</span></span>  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-340">Разделяет имена в пространстве имен класса <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-340">Separates names in the namespace of the <see cref="T:System.Type" />.</span></span> <span data-ttu-id="95a33-341">Это поле доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-341">This field is read-only.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-342">Представляет пустой массив типа <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-342">Represents an empty array of type <see cref="T:System.Type" />.</span></span> <span data-ttu-id="95a33-343">Это поле доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-343">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="95a33-344">В следующем примере кода показано `EmptyTypes` поле, используемое в одном из методов `GetConstructor` для получения конструктора, не принимающего параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-344">The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.</span></span>  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-345">Определяет, совпадает ли базовый системный тип текущего объекта <see cref="T:System.Type" /> с базовым системным типом указанного объекта <see cref="T:System.Object" /> или <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-345">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95a33-346">Объект, базовый системный тип которого сравнивается с базовым системным типом текущего типа <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-346">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span> <span data-ttu-id="95a33-347">Для успешного сравнения необходимо, чтобы параметр <paramref name="o" /> можно было привести к объекту типа <see cref="T:System.Type" /> или преобразовать в объект такого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-347">For the comparison to succeed, <paramref name="o" /> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="95a33-348">Определяет, совпадает ли базовый системный тип текущего объекта <see cref="T:System.Type" /> с базовым системным типом указанного объекта <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-348">Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-349">Значение <see langword="true" />, если базовый системный тип параметра <paramref name="o" /> совпадает с базовым системным типом текущего объекта <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-349"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="95a33-350">Этот метод также возвращает <see langword="false" /> в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="95a33-350">This method also returns <see langword="false" /> if: .</span></span>  
  <span data-ttu-id="95a33-351">
-   <paramref name="o" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-351">
-   <paramref name="o" /> is <see langword="null" />.</span></span>  
  <span data-ttu-id="95a33-352">
-   <paramref name="o" /> невозможно привести к объекту или преобразовать в объект <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-352">
-   <paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-353">Этот метод переопределяет метод <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-353">This method overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95a33-354">Он приводит `o` к объекту типа <xref:System.Type> и вызывает метод <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-354">It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-355">В следующем примере <xref:System.Type.Equals%28System.Object%29> используется для сравнения различных экземпляров объектов <xref:System.Type> с различными экземплярами <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="95a33-355">The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.</span></span>  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 <span data-ttu-id="95a33-356">В примере следует обратить внимание на две вещи:</span><span class="sxs-lookup"><span data-stu-id="95a33-356">Two things are particularly worth noting about the example:</span></span>  
  
-   <span data-ttu-id="95a33-357">Сравнение объекта <xref:System.Type>, представляющего целое число с <xref:System.Reflection.TypeInfo>ным объектом, представляющим целочисленное значение, возвращаемое `true`, так как <xref:System.Reflection.TypeInfo> является производной от <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-357">The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.</span></span>  
  
-   <span data-ttu-id="95a33-358">Сравнение объекта <xref:System.Type>, представляющего объект <xref:System.Collections.Generic.IList%601> (открытый универсальный тип) с `List(Of String)`ным объектом (закрытым универсальным типом), возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-358">The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (Type o);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Type o) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (o As Type) As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(Type ^ o);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95a33-359">Объект, базовый системный тип которого сравнивается с базовым системным типом текущего типа <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-359">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="95a33-360">Позволяет определить, совпадает ли базовый системный тип текущего объекта <see cref="T:System.Type" /> с базовым системным типом указанного объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-360">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-361">Значение <see langword="true" />, если базовый системный тип параметра <paramref name="o" /> совпадает с базовым системным типом текущего объекта <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-361"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="95a33-362">В следующем примере для сравнения двух типов используется `Equals`.</span><span class="sxs-lookup"><span data-stu-id="95a33-362">The following example uses `Equals` to compare two types.</span></span>  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-363">Предоставляет фильтр членов, используемый для атрибутов.</span><span class="sxs-lookup"><span data-stu-id="95a33-363">Represents the member filter used on attributes.</span></span> <span data-ttu-id="95a33-364">Это поле доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-364">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-365">Это поле содержит ссылку на делегат, используемый методом <xref:System.Type.FindMembers%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-365">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="95a33-366">Метод, инкапсулированный этим делегатом, принимает два параметра: Первый — это объект <xref:System.Reflection.MemberInfo>, а второй — `Object`.</span><span class="sxs-lookup"><span data-stu-id="95a33-366">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="95a33-367">Метод определяет, соответствует ли объект `MemberInfo` критериям, заданным `Object`.</span><span class="sxs-lookup"><span data-stu-id="95a33-367">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="95a33-368">`Object` может быть назначено значение любого из полей в классах <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>или <xref:System.Reflection.MethodImplAttributes>.</span><span class="sxs-lookup"><span data-stu-id="95a33-368">The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.</span></span>  
  
 <span data-ttu-id="95a33-369">Например, `Object` можно присвоить значение поля из `FieldAttributes` например public.</span><span class="sxs-lookup"><span data-stu-id="95a33-369">For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public.</span></span> <span data-ttu-id="95a33-370">В этом случае, когда вызывается делегат `FilterAttribute`, он возвращает `true` только в том случае, если метод, представленный объектом `MemberInfo`, снабжен открытым атрибутом Field в метаданных.</span><span class="sxs-lookup"><span data-stu-id="95a33-370">In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-371">В следующем примере возвращается делегат `FilterAttribute`, передается в качестве параметра методу <xref:System.Type.FindMembers%2A> и отображаются указанные элементы и их атрибуты.</span><span class="sxs-lookup"><span data-stu-id="95a33-371">The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.</span></span>  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-372">Представляет фильтр членов с учетом регистра, применяемый к именам.</span><span class="sxs-lookup"><span data-stu-id="95a33-372">Represents the case-sensitive member filter used on names.</span></span> <span data-ttu-id="95a33-373">Это поле доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-373">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-374">Это поле содержит ссылку на делегат, используемый методом <xref:System.Type.FindMembers%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-374">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="95a33-375">Метод, инкапсулированный этим делегатом, принимает два параметра: Первый — это объект <xref:System.Reflection.MemberInfo>, а второй — `Object`.</span><span class="sxs-lookup"><span data-stu-id="95a33-375">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="95a33-376">Метод определяет, соответствует ли объект `MemberInfo` критериям, заданным `Object`.</span><span class="sxs-lookup"><span data-stu-id="95a33-376">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="95a33-377">`Object`у присваивается строковое значение, которое может включать замыкающий подстановочный знак "\*".</span><span class="sxs-lookup"><span data-stu-id="95a33-377">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="95a33-378">Поддерживаются только сопоставления с подстановочными знаками конца строки.</span><span class="sxs-lookup"><span data-stu-id="95a33-378">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="95a33-379">Например, `Object` может быть присвоено значение «Byte \*».</span><span class="sxs-lookup"><span data-stu-id="95a33-379">For example, the `Object` may be assigned the value "Byte\*".</span></span> <span data-ttu-id="95a33-380">В этом случае, когда вызывается делегат `FilterName`, он возвращает `true` только в том случае, если метод, представленный объектом `MemberInfo`, имеет имя, которое начинается с Byte.</span><span class="sxs-lookup"><span data-stu-id="95a33-380">In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with "Byte".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-381">В следующем примере кода получаются методы, связанные с определяемым пользователем типом `Application`.</span><span class="sxs-lookup"><span data-stu-id="95a33-381">The following code example gets the methods associated with the user-defined `Application` type.</span></span>  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-382">Представляет фильтр членов без учета регистра, применяемый к именам.</span><span class="sxs-lookup"><span data-stu-id="95a33-382">Represents the case-insensitive member filter used on names.</span></span> <span data-ttu-id="95a33-383">Это поле доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-383">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-384">Это поле содержит ссылку на делегат, используемый методом <xref:System.Type.FindMembers%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-384">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="95a33-385">Метод, инкапсулированный этим делегатом, принимает два параметра: Первый — это объект <xref:System.Reflection.MemberInfo>, а второй — `Object`.</span><span class="sxs-lookup"><span data-stu-id="95a33-385">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="95a33-386">Метод определяет, соответствует ли объект `MemberInfo` критериям, заданным `Object`.</span><span class="sxs-lookup"><span data-stu-id="95a33-386">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="95a33-387">`Object`у присваивается строковое значение, которое может включать замыкающий подстановочный знак "\*".</span><span class="sxs-lookup"><span data-stu-id="95a33-387">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="95a33-388">Поддерживаются только сопоставления с подстановочными знаками конца строки.</span><span class="sxs-lookup"><span data-stu-id="95a33-388">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="95a33-389">Например, `Object` может быть присвоено значение «ByTe \*».</span><span class="sxs-lookup"><span data-stu-id="95a33-389">For example, the `Object` may be assigned the value "ByTe\*".</span></span> <span data-ttu-id="95a33-390">В этом случае, когда вызывается делегат `FilterName`, он возвращает значение true только в том случае, если у метода, представленного объектом `MemberInfo`, есть имя, которое начинается с "Byte" без учета регистра.</span><span class="sxs-lookup"><span data-stu-id="95a33-390">In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with "byte", ignoring case.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-391">В следующем примере возвращается делегат `MemberFilter`, передается в качестве параметра методу <xref:System.Type.FindMembers%2A> и выводятся методы и их атрибуты класса `String`, которые начинаются с буквы "c", не учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-391">The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter "c", disregarding the case.</span></span>  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="95a33-392">Делегат, сравнивающий интерфейсы с параметром <paramref name="filterCriteria" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-392">The delegate that compares the interfaces against <paramref name="filterCriteria" />.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="95a33-393">Критерий поиска, определяющий, должен ли тот или иной интерфейс включаться в возвращаемый массив.</span><span class="sxs-lookup"><span data-stu-id="95a33-393">The search criteria that determines whether an interface should be included in the returned array.</span></span></param>
        <summary><span data-ttu-id="95a33-394">Возвращает массив объектов <see cref="T:System.Type" />, представляющий отфильтрованный список интерфейсов, реализованных или наследуемых текущим объектом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-394">Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-395">Массив объектов <see cref="T:System.Type" />, представляющий отфильтрованный список интерфейсов, которые реализует или наследует текущий объект <see cref="T:System.Type" />, или пустой массив, если после применения фильтра для текущего объекта <see cref="T:System.Type" /> отсутствуют соответствующие реализованные или унаследованные интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="95a33-395">An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-396">Этот метод может быть переопределен производным классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-396">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="95a33-397">Также можно использовать делегаты <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> и <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType>, предоставляемые классом <xref:System.Reflection.Module?displayProperty=nameWithType>, вместо делегата <xref:System.Reflection.TypeFilter?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-397">The <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegates supplied by the <xref:System.Reflection.Module?displayProperty=nameWithType> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.</span></span>  
  
 <span data-ttu-id="95a33-398">Все интерфейсы, реализуемые этим классом, рассматриваются во время поиска, независимо от того, объявлены ли они базовым классом или самим классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-398">All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</span></span>  
  
 <span data-ttu-id="95a33-399">Этот метод выполняет поиск в иерархии базового класса, возвращая каждый из соответствующих интерфейсов, а также всех соответствующих интерфейсов, которые реализуются каждым из этих интерфейсов (то есть возвращается транзитивное замыкание соответствующих интерфейсов).</span><span class="sxs-lookup"><span data-stu-id="95a33-399">This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</span></span> <span data-ttu-id="95a33-400">Повторные интерфейсы не возвращаются.</span><span class="sxs-lookup"><span data-stu-id="95a33-400">No duplicate interfaces are returned.</span></span>  
  
 <span data-ttu-id="95a33-401">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, <xref:System.Type.FindInterfaces%2A> выполняет поиск всех интерфейсов, объявленных в ограничениях на параметр типа, и все интерфейсы, унаследованные через интерфейсы, объявленные в Учитывая.</span><span class="sxs-lookup"><span data-stu-id="95a33-401">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</span></span> <span data-ttu-id="95a33-402">Если текущий <xref:System.Type> представляет аргумент типа универсального типа, <xref:System.Type.FindInterfaces%2A> выполняет поиск всех интерфейсов, реализованных типом, независимо от того, совпадают ли они с ограничениями.</span><span class="sxs-lookup"><span data-stu-id="95a33-402">If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-403"><xref:System.Type.FindInterfaces%2A> могут возвращать универсальные интерфейсы даже для типов, которые не являются универсальными.</span><span class="sxs-lookup"><span data-stu-id="95a33-403"><xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic.</span></span> <span data-ttu-id="95a33-404">Например, неуниверсальный тип может реализовывать `IEnumerable<int>` (`IEnumerable(Of Integer)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-404">For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-405">В следующем примере выполняется поиск указанного интерфейса, реализованного или унаследованного указанным типом, а затем отображаются имена интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="95a33-405">The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</span></span>  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-406">Свойство <paramref name="filter" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-406"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="95a33-407">Статический инициализатор вызывается и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-407">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="memberType"><span data-ttu-id="95a33-408">Побитовое сочетание значений перечисления, обозначающее тип искомого члена.</span><span class="sxs-lookup"><span data-stu-id="95a33-408">A bitwise combination of the enumeration values that indicates the type of member to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-409">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-409">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-410">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-410">-or-</span></span> 
 <span data-ttu-id="95a33-411"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-411"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="filter"><span data-ttu-id="95a33-412">Делегат, выполняющий сравнение и возвращающий <see langword="true" />, если проверяемый член соответствует условиям, заданным в параметре <paramref name="filterCriteria" />, и <see langword="false" /> в противном случае.</span><span class="sxs-lookup"><span data-stu-id="95a33-412">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <paramref name="filterCriteria" /> and <see langword="false" /> otherwise.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="95a33-413">Условие поиска, определяющее, будет ли член включен в возвращаемый массив объектов <see langword="MemberInfo" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-413">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.</span></span>  
  
<span data-ttu-id="95a33-414">Поля классов <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> и <see langword="MethodImplAttributes" /> могут использоваться вместе с делегатом <see langword="FilterAttribute" />, предоставляемым этим классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-414">The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</span></span></param>
        <summary><span data-ttu-id="95a33-415">Возвращает отфильтрованный массив объектов <see cref="T:System.Reflection.MemberInfo" />, тип которого совпадает с указанным типом члена.</span><span class="sxs-lookup"><span data-stu-id="95a33-415">Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span></summary>
        <returns><span data-ttu-id="95a33-416">Отфильтрованный массив объектов <see cref="T:System.Reflection.MemberInfo" />, имеющих тип указанного члена.</span><span class="sxs-lookup"><span data-stu-id="95a33-416">A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span>  
  
<span data-ttu-id="95a33-417">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-417">-or-</span></span> 
<span data-ttu-id="95a33-418">Пустой массив, если у текущего <see cref="T:System.Type" /> нет членов типа <paramref name="memberType" />, удовлетворяющих условиям фильтра.</span><span class="sxs-lookup"><span data-stu-id="95a33-418">An empty array if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="95a33-419">Этот метод может быть переопределен производным классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-419">This method can be overridden by a derived class.</span></span>  
  
<span data-ttu-id="95a33-420">Элементы включают свойства, методы, поля, события и т. д.</span><span class="sxs-lookup"><span data-stu-id="95a33-420">Members include properties, methods, fields, events, and so on.</span></span>  

<span data-ttu-id="95a33-421">Чтобы метод `FindMembers` успешно получал сведения об элементе, аргумент `bindingAttr` должен включать по крайней мере один из <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, а также хотя бы один из <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-421">For the `FindMembers` method to successfully retrieve member information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 

 <span data-ttu-id="95a33-422">Для определения элементов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-422">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-423">Укажите `BindingFlags.Instance`, чтобы включить в поиск члены экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-423">Specify `BindingFlags.Instance` to include instance members in the search.</span></span>  
  
-   <span data-ttu-id="95a33-424">Укажите `BindingFlags.Static`, чтобы включить в поиск статические элементы.</span><span class="sxs-lookup"><span data-stu-id="95a33-424">Specify `BindingFlags.Static` to include static members in the search.</span></span>  
  
-   <span data-ttu-id="95a33-425">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые члены.</span><span class="sxs-lookup"><span data-stu-id="95a33-425">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="95a33-426">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск неоткрытые члены (т. е. частные, внутренние и защищенные члены).</span><span class="sxs-lookup"><span data-stu-id="95a33-426">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
 <span data-ttu-id="95a33-427">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-427">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-428">`BindingFlags.DeclaredOnly` искать только члены, объявленные в <xref:System.Type>, а не члены, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-428">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-429">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-429">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
<span data-ttu-id="95a33-430">Чтобы получить инициализатор класса (статический конструктор) с помощью этого метода, необходимо указать <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-430">To get the class initializer (static constructor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="95a33-431">Инициализатор класса также можно получить с помощью свойства <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-431">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
<span data-ttu-id="95a33-432">Если текущий <xref:System.Type> представляет параметр типа универсального типа или универсального метода, <xref:System.Type.FindMembers%2A> обрабатывает все члены, объявленные ограничением класса, и ограничения интерфейса параметра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-432">If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.</span></span>  

<span data-ttu-id="95a33-433">Аргумент `filter` может быть пользовательским делегатом типа <xref:System.Reflection.MemberFilter>или одним из следующих предопределенных делегатов:</span><span class="sxs-lookup"><span data-stu-id="95a33-433">The `filter` argument can be a custom delegate of type <xref:System.Reflection.MemberFilter>, or it can be one of the following  predefined delegates:</span></span>

- <span data-ttu-id="95a33-434"><xref:System.Type.FilterAttribute?displayProperty=nameWithType>, который использует<xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>или <xref:System.Reflection.MethodImplAttributes> битовую маску в качестве значения `filterCriteria`.</span><span class="sxs-lookup"><span data-stu-id="95a33-434"><xref:System.Type.FilterAttribute?displayProperty=nameWithType>, which uses a<xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes> bitmask as the `filterCriteria` value.</span></span>

- <span data-ttu-id="95a33-435"><xref:System.Type.FilterName?displayProperty=nameWithType>, выполняющее сравнение с учетом регистра имени каждого члена со строкой, передаваемой в `filterCriteria`.</span><span class="sxs-lookup"><span data-stu-id="95a33-435"><xref:System.Type.FilterName?displayProperty=nameWithType>, which performs a case-sensitive comparison of each member name with the string passed to `filterCriteria`.</span></span>

- <span data-ttu-id="95a33-436"><xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>, который выполняет сравнение каждого имени элемента со строкой, передаваемой в `filterCriteria`, без учета регистра.</span><span class="sxs-lookup"><span data-stu-id="95a33-436"><xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>, which performs a case-insensitive comparison of each member name with the string passed to `filterCriteria`.</span></span>

## Examples  
 <span data-ttu-id="95a33-437">В следующем примере выполняется поиск всех элементов в классе, соответствующих указанным условиям поиска, а затем отображаются сопоставленные члены.</span><span class="sxs-lookup"><span data-stu-id="95a33-437">The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</span></span>  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-438">Свойство <paramref name="filter" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-438"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-439">Возвращает полное имя типа, включая пространство имен, но не сборку.</span><span class="sxs-lookup"><span data-stu-id="95a33-439">Gets the fully qualified name of the type, including its namespace but not its assembly.</span></span></summary>
        <value><span data-ttu-id="95a33-440">Полное имя типа, включая пространство имен, но не сборку; или значение <see langword="null" />, если текущий экземпляр представляет параметр универсального типа, тип массива, тип указателя, тип <see langword="byref" /> на основе параметра типа либо универсальный тип, который, хотя и не является определением универсального типа, содержит неразрешенные параметры типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-440">The fully qualified name of the type, including its namespace but not its assembly; or <see langword="null" /> if the current instance represents a generic type parameter, an array type, pointer type, or <see langword="byref" /> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-441">Например, полное имя типа <xref:System.String> `System.String`.</span><span class="sxs-lookup"><span data-stu-id="95a33-441">For example, the fully qualified name of the <xref:System.String> type is `System.String`.</span></span> <span data-ttu-id="95a33-442">Сравните это с полным именем сборки, возвращенным свойством <xref:System.Type.AssemblyQualifiedName%2A>, которое состоит из полного имени и полного имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-442">Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.</span></span>  
  
 <span data-ttu-id="95a33-443">Если текущий тип представляет закрытый универсальный тип, аргументы типа в строке, возвращаемой свойством <xref:System.Type.FullName%2A>, задаются полным именем сборки, даже если строковое представление самого универсального типа не уточняется полной сборкой. безымян.</span><span class="sxs-lookup"><span data-stu-id="95a33-443">If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</span></span> <span data-ttu-id="95a33-444">В следующем примере показана разница в свойстве FullName для типа, который представляет определение универсального типа, а другой — закрытый универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-444">The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</span></span>  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 <span data-ttu-id="95a33-445">Это свойство возвращает `null`, если:</span><span class="sxs-lookup"><span data-stu-id="95a33-445">This property returns `null` if:</span></span>  
  
-   <span data-ttu-id="95a33-446">Текущий объект <xref:System.Type> представляет параметр типа универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-446">The current <xref:System.Type> object represents a type parameter of a generic type.</span></span>  
  
     <span data-ttu-id="95a33-447">В следующем примере извлекается тип параметра типа <xref:System.Nullable%601> и предпринимается попытка отобразить его свойство <xref:System.Type.FullName%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-447">The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.</span></span>  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   <span data-ttu-id="95a33-448">Текущий объект <xref:System.Type> представляет тип массива, тип указателя или тип `byref`, основанный на параметре универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-448">The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.</span></span>  
  
     <span data-ttu-id="95a33-449">В следующем примере определяется универсальный тип `Generictype1<T>`с тремя методами: `Display(T[])`, которому передается массив типа T; `HandleT(T)`, которому передается T-объект; и `ChangeValue(ref T)`, который передается по ссылке в T-объект.</span><span class="sxs-lookup"><span data-stu-id="95a33-449">The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference.</span></span> <span data-ttu-id="95a33-450">Поскольку C# и Visual Basic не позволяют определить T в качестве указателя в методе `HandleT`, необходимо вызвать метод <xref:System.Type.MakePointerType%2A> для объекта <xref:System.Type>, представляющего тип параметра метода, чтобы создать указатель на универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-450">Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type.</span></span> <span data-ttu-id="95a33-451">Выходные данные в примере показывают, что во всех трех случаях свойство <xref:System.Type.FullName%2A> `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-451">The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   <span data-ttu-id="95a33-452">Текущий тип содержит параметры универсального типа, которые не были заменены конкретными типами (то есть свойство <xref:System.Type.ContainsGenericParameters%2A> возвращает `true`), но тип не является определением универсального типа (т. е. свойство <xref:System.Type.IsGenericTypeDefinition%2A> возвращает `false`</span><span class="sxs-lookup"><span data-stu-id="95a33-452">The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`</span></span>  
  
     <span data-ttu-id="95a33-453">В следующем примере `Derived<T>` наследует от `Base<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-453">In the following example, `Derived<T>` inherits from `Base<T>`.</span></span> <span data-ttu-id="95a33-454">Свойство <xref:System.Type.BaseType%2A> получает объект <xref:System.Type>, представляющий базовый тип `Derived<T>`, а его свойство <xref:System.Type.FullName%2A> возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-454">The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     <span data-ttu-id="95a33-455">Чтобы получить <xref:System.Type.FullName%2A>, не `null`, можно использовать метод <xref:System.Type.GetGenericTypeDefinition%2A>, чтобы получить определение универсального типа, как показано в примере.</span><span class="sxs-lookup"><span data-stu-id="95a33-455">To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.</span></span>  
  
 <span data-ttu-id="95a33-456">Это свойство доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-456">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-457">В следующем примере отображается полное имя указанного типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-457">The following example displays the full name of the specified type.</span></span>  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 <span data-ttu-id="95a33-458">В следующем примере сравниваются строки, возвращаемые методом <xref:System.Type.ToString%2A> и свойствами `Name`, <xref:System.Type.FullName%2A>и <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-458">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="95a33-459">Указание полных имен типов</span><span class="sxs-lookup"><span data-stu-id="95a33-459">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-460">Возвращает сочетание флагов <see cref="T:System.Reflection.GenericParameterAttributes" />, описывающих ковариацию и особые ограничения текущего параметра универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-460">Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="95a33-461">Побитовое сочетание значений <see cref="T:System.Reflection.GenericParameterAttributes" />, которое описывает ковариацию и особые ограничения текущего параметра универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-461">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-462">Значение этого свойства содержит флаги, описывающие, является ли текущий параметр универсального типа ковариантным, а также флагами, описывающими специальные ограничения.</span><span class="sxs-lookup"><span data-stu-id="95a33-462">The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</span></span> <span data-ttu-id="95a33-463">Используйте значение <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType>, чтобы выбрать флаги ковариации и использовать значение <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> для выбора флагов ограничений.</span><span class="sxs-lookup"><span data-stu-id="95a33-463">Use the <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> value to select the constraint flags.</span></span>  
  
 <span data-ttu-id="95a33-464">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-464">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-465">В следующем примере кода определяется универсальный тип `Test` с двумя параметрами типа, имеющими разные ограничения.</span><span class="sxs-lookup"><span data-stu-id="95a33-465">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="95a33-466">При выполнении программы ограничения проверяются с помощью свойства <xref:System.Type.GenericParameterAttributes%2A> и метода <xref:System.Type.GetGenericParameterConstraints%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-466">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="95a33-467">Текущий объект <see cref="T:System.Type" /> не является параметром универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-467">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="95a33-468">То есть свойство <see cref="P:System.Type.IsGenericParameter" /> возвращает значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-468">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-469">Вызванный метод не поддерживается в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-469">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="95a33-470">Отражение и универсальные типы</span><span class="sxs-lookup"><span data-stu-id="95a33-470">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="95a33-471">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-471">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public abstract int GenericParameterPosition { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GenericParameterPosition As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int GenericParameterPosition { int get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-472">Возвращает позицию параметра типа в списке параметров универсального типа или метода, который объявил параметр, если объект <see cref="T:System.Type" /> представляет параметр универсального типа или метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-472">Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</span></span></summary>
        <value><span data-ttu-id="95a33-473">Позиция параметра типа в списке параметров типа универсального типа или метода, которые задали этот параметр.</span><span class="sxs-lookup"><span data-stu-id="95a33-473">The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</span></span> <span data-ttu-id="95a33-474">Нумерация позиций начинается с 0.</span><span class="sxs-lookup"><span data-stu-id="95a33-474">Position numbers begin at 0.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-475">Свойство <xref:System.Type.GenericParameterPosition%2A> Возвращает позицию параметра типа в списке параметров определения универсального типа или определения универсального метода, в котором был изначально определен параметр типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-475">The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</span></span> <span data-ttu-id="95a33-476">Свойства <xref:System.Type.DeclaringType%2A> и <xref:System.Type.DeclaringMethod%2A> обозначают универсальный тип или определение метода:</span><span class="sxs-lookup"><span data-stu-id="95a33-476">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:</span></span>  
  
-   <span data-ttu-id="95a33-477">Если свойство <xref:System.Type.DeclaringMethod%2A> возвращает <xref:System.Reflection.MethodInfo>, то <xref:System.Reflection.MethodInfo> представляет определение универсального метода, а текущий объект <xref:System.Type> представляет параметр типа этого определения универсального метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-477">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="95a33-478">Если свойство <xref:System.Type.DeclaringMethod%2A> возвращает `null`, то свойство <xref:System.Type.DeclaringType%2A> всегда возвращает объект <xref:System.Type>, представляющий определение универсального типа, а текущий объект <xref:System.Type> представляет параметр типа этого определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-478">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
 <span data-ttu-id="95a33-479">Чтобы предоставить правильный контекст для значения свойства <xref:System.Type.GenericParameterPosition%2A>, необходимо указать универсальный тип или метод, которому принадлежит параметр типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-479">To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to.</span></span> <span data-ttu-id="95a33-480">Например, рассмотрим возвращаемое значение универсального метода `GetSomething` в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="95a33-480">For example, consider the return value of the generic method `GetSomething` in the following code:</span></span>  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 <span data-ttu-id="95a33-481">Тип, возвращаемый `GetSomething`, зависит от аргументов типа, предоставленных `A` класса, и для `GetSomething` самого себя.</span><span class="sxs-lookup"><span data-stu-id="95a33-481">The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself.</span></span> <span data-ttu-id="95a33-482">Можно получить <xref:System.Reflection.MethodInfo> для `GetSomething`, а также получить тип возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="95a33-482">You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type.</span></span> <span data-ttu-id="95a33-483">При изучении параметров типа возвращаемого значения <xref:System.Type.GenericParameterPosition%2A> возвращает 0 для обоих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-483">When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both.</span></span> <span data-ttu-id="95a33-484">Расположение `V` равно 0, поскольку `V` является первым параметром типа в списке параметров типа для класса `A`.</span><span class="sxs-lookup"><span data-stu-id="95a33-484">The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`.</span></span> <span data-ttu-id="95a33-485">Расположение `X` равно 0, поскольку `X` является первым параметром типа в списке параметров типа для `GetSomething`.</span><span class="sxs-lookup"><span data-stu-id="95a33-485">The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-486">Вызов свойства <xref:System.Type.GenericParameterPosition%2A> вызывает исключение, если текущий <xref:System.Type> не представляет параметр типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-486">Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter.</span></span> <span data-ttu-id="95a33-487">При изучении аргументов типа открытого сконструированного типа используйте свойство <xref:System.Type.IsGenericParameter%2A>, чтобы определить, какие параметры являются параметрами типа, а какие — типами.</span><span class="sxs-lookup"><span data-stu-id="95a33-487">When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types.</span></span> <span data-ttu-id="95a33-488">Свойство <xref:System.Type.IsGenericParameter%2A> возвращает `true` для параметра типа. Затем можно использовать метод <xref:System.Type.GenericParameterPosition%2A>, чтобы получить его расположение и использовать свойства <xref:System.Type.DeclaringMethod%2A> и <xref:System.Type.DeclaringType%2A> для определения универсального метода или определения типа, определяющего его.</span><span class="sxs-lookup"><span data-stu-id="95a33-488">The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-489">В следующем примере определяется универсальный класс с двумя параметрами типа и определяется второй универсальный класс, производный от первого класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-489">The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="95a33-490">Базовый класс производного класса имеет два аргумента типа: первый — <xref:System.Int32>, а второй — параметр типа производного типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-490">The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="95a33-491">В примере отображаются сведения об этих универсальных классах, включая позиции, сообщаемые свойством <xref:System.Type.GenericParameterPosition%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-491">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="95a33-492">Текущий тип не представляет параметр типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-492">The current type does not represent a type parameter.</span></span> <span data-ttu-id="95a33-493">То есть <see cref="P:System.Type.IsGenericParameter" /> возвращает <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-493">That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="95a33-494">Отражение и универсальные типы</span><span class="sxs-lookup"><span data-stu-id="95a33-494">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="95a33-495">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-495">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public abstract Type[] GenericTypeArguments { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GenericTypeArguments As Type()" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-496">Получает массив аргументов универсального типа для этого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-496">Gets an array of the generic type arguments for this type.</span></span></summary>
        <value><span data-ttu-id="95a33-497">Массив аргументов универсального типа для этого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-497">An array of the generic type arguments for this type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-498">Это свойство получает только аргументы универсального типа. то есть типы, указанные для параметров универсального типа текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-498">This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</span></span> <span data-ttu-id="95a33-499">Если текущий тип является определением универсального типа, это свойство возвращает пустой массив.</span><span class="sxs-lookup"><span data-stu-id="95a33-499">If the current type is a generic type definition, this property returns an empty array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-500">Если универсальный тип используется в универсальном методе или в другом универсальном типе, некоторые из его аргументов универсального типа могут быть параметрами универсального типа включающего метода или типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-500">If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</span></span>  
  
 <span data-ttu-id="95a33-501">Чтобы получить параметры универсального типа для типа, представляющего определение универсального типа, используйте свойство <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-501">To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="95a33-502">Чтобы получить объект <xref:System.Reflection.TypeInfo> для текущего объекта <xref:System.Type>, используйте метод расширения <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-502">To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> extension method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public abstract int GetArrayRank ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetArrayRank () As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetArrayRank();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-503">Возвращает размерность массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-503">Gets the number of dimensions in an array.</span></span></summary>
        <returns><span data-ttu-id="95a33-504">Целое число, указывающее на количество измерений текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-504">An integer that contains the number of dimensions in the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="95a33-505">В следующем примере показано количество измерений в массиве.</span><span class="sxs-lookup"><span data-stu-id="95a33-505">The following example displays the number of dimensions in an array.</span></span>  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-506">Функциональность этого метода не поддерживается в базовом классе и должна быть реализована в производном классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-506">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-507">Текущий тип не является массивом.</span><span class="sxs-lookup"><span data-stu-id="95a33-507">The current type is not an array.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-508">При переопределении в производном классе реализует свойство <see cref="P:System.Type.Attributes" /> и возвращает побитовое сочетание значений перечисления, указывающих атрибуты, связанные с <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-508">When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitwise combination of enumeration values that indicate the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-509">Объект <see cref="T:System.Reflection.TypeAttributes" />, представляющий набор атрибутов объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-509">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-510">Возвращает определенный конструктор текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-510">Gets a specific constructor of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="types"><span data-ttu-id="95a33-511">Массив объектов <see cref="T:System.Type" />, предоставляющих число, порядок и тип параметров нужного конструктора.</span><span class="sxs-lookup"><span data-stu-id="95a33-511">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</span></span>  
  
<span data-ttu-id="95a33-512">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-512">-or-</span></span> 
<span data-ttu-id="95a33-513">Пустой массив объектов <see cref="T:System.Type" /> для получения конструктора, не имеющего параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-513">An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters.</span></span> <span data-ttu-id="95a33-514">Подобный пустой массив предоставляется полем <see langword="static" /> с описателем <see cref="F:System.Type.EmptyTypes" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-514">Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <summary><span data-ttu-id="95a33-515">Выполняет поиск открытого конструктора экземпляра, параметры которого соответствуют типам, содержащимся в указанном массиве.</span><span class="sxs-lookup"><span data-stu-id="95a33-515">Searches for a public instance constructor whose parameters match the types in the specified array.</span></span></summary>
        <returns><span data-ttu-id="95a33-516">Объект, представляющий открытый конструктор экземпляра, параметры которого соответствуют типам, указанным в массиве типов параметров, если такой конструктор найден; в противном случае — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-516">An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-517">Эта перегрузка метода выполняет поиск конструкторов открытых экземпляров и не может использоваться для получения инициализатора класса (статический конструктор).</span><span class="sxs-lookup"><span data-stu-id="95a33-517">This method overload looks for public instance constructors and cannot be used to obtain a class initializer (static constructor).</span></span> <span data-ttu-id="95a33-518">Чтобы получить инициализатор класса, используйте перегрузку, которая принимает <xref:System.Reflection.BindingFlags>, и укажите &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-518">To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="95a33-519">Инициализатор класса также можно получить с помощью свойства <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-519">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="95a33-520">Если запрашиваемый конструктор не является открытым, этот метод возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-520">If the requested constructor is non-public, this method returns `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-521">Нельзя опустить параметры при поиске конструкторов и методов.</span><span class="sxs-lookup"><span data-stu-id="95a33-521">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="95a33-522">При вызове можно опустить только параметры.</span><span class="sxs-lookup"><span data-stu-id="95a33-522">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="95a33-523">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-523">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="95a33-524">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод всегда возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-524">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-525">В следующем примере получается тип `MyClass`, получается <xref:System.Reflection.ConstructorInfo> объект и отображается сигнатура конструктора.</span><span class="sxs-lookup"><span data-stu-id="95a33-525">The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-526">Свойство <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-526"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-527">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-527">-or-</span></span> 
<span data-ttu-id="95a33-528">Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-528">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-529">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-529"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="95a33-530">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-530">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-531">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-531">-or-</span></span> 
 <span data-ttu-id="95a33-532"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-532"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="95a33-533">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-533">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="95a33-534">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-534">-or-</span></span> 
<span data-ttu-id="95a33-535">Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-535">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-536">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров, извлекаемых конструктором.</span><span class="sxs-lookup"><span data-stu-id="95a33-536">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="95a33-537">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-537">-or-</span></span> 
<span data-ttu-id="95a33-538">Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить конструктор, который не имеет параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-538">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span>  
  
<span data-ttu-id="95a33-539">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-539">-or-</span></span> 
 <span data-ttu-id="95a33-540"><see cref="F:System.Type.EmptyTypes" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-540"><see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <param name="modifiers"><span data-ttu-id="95a33-541">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве типов параметра.</span><span class="sxs-lookup"><span data-stu-id="95a33-541">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array.</span></span> <span data-ttu-id="95a33-542">Связыватель по умолчанию не обрабатывает этот параметр.</span><span class="sxs-lookup"><span data-stu-id="95a33-542">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="95a33-543">Выполняет поиск конструктора, параметры которого соответствуют указанным типам аргументов и модификаторам, используя заданные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-543">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-544">Если поиск выполнен удачно, возвращается объект <see cref="T:System.Reflection.ConstructorInfo" />, представляющий конструктор, который соответствует указанным требованиям; в противном случае возвращается значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-544">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-545">Если точное соответствие не существует, `binder` будет пытаться привести типы параметров, заданные в массиве `types`, чтобы выбрать совпадение.</span><span class="sxs-lookup"><span data-stu-id="95a33-545">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="95a33-546">Если `binder` не удается выбрать соответствие, возвращается `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-546">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="95a33-547">Для определения конструкторов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-547">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-548">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-548">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-549">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые конструкторы.</span><span class="sxs-lookup"><span data-stu-id="95a33-549">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="95a33-550">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск неоткрытые конструкторы (то есть частные, внутренние и защищенные конструкторы).</span><span class="sxs-lookup"><span data-stu-id="95a33-550">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="95a33-551">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-551">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-552">Чтобы получить инициализатор класса (статический конструктор) с помощью этой перегрузки метода, необходимо указать &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-552">To get the class initializer (static constructor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="95a33-553">Инициализатор класса также можно получить с помощью свойства <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-553">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-554">Нельзя опустить параметры при поиске конструкторов и методов.</span><span class="sxs-lookup"><span data-stu-id="95a33-554">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="95a33-555">При вызове можно опустить только параметры.</span><span class="sxs-lookup"><span data-stu-id="95a33-555">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="95a33-556">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-556">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="95a33-557">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод всегда возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-557">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-558">Следующая программа получает тип `MyClass1` класса, возвращает объект <xref:System.Reflection.ConstructorInfo>, соответствующий указанным флагам привязки, и отображает сигнатуру конструктора.</span><span class="sxs-lookup"><span data-stu-id="95a33-558">The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.</span></span>  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-559"><paramref name="types" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-559"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-560">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-560">-or-</span></span> 
<span data-ttu-id="95a33-561">Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-561">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-562">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-562"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-563">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-563">-or-</span></span> 
 <span data-ttu-id="95a33-564">Массив <paramref name="modifiers" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-564"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-565">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-565">-or-</span></span> 
 <span data-ttu-id="95a33-566"><paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</span><span class="sxs-lookup"><span data-stu-id="95a33-566"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="95a33-567">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-567">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-568">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-568">-or-</span></span> 
 <span data-ttu-id="95a33-569"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-569"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="95a33-570">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-570">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="95a33-571">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-571">-or-</span></span> 
<span data-ttu-id="95a33-572">Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-572">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="95a33-573">Объект, определяющий набор применяемых правил, касающихся порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и очистки стека.</span><span class="sxs-lookup"><span data-stu-id="95a33-573">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-574">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров, извлекаемых конструктором.</span><span class="sxs-lookup"><span data-stu-id="95a33-574">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="95a33-575">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-575">-or-</span></span> 
<span data-ttu-id="95a33-576">Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить конструктор, который не имеет параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-576">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="95a33-577">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-577">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="95a33-578">Связыватель по умолчанию не обрабатывает этот параметр.</span><span class="sxs-lookup"><span data-stu-id="95a33-578">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="95a33-579">Выполняет поиск конструктора с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений по привязке и соглашений о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-579">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="95a33-580">Если поиск выполнен удачно, возвращается объект, представляющий конструктор, который соответствует указанным требованиям; в противном случае возвращается значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-580">An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-581">Хотя связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> (параметр `modifiers`), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательского связывателя, который обрабатывает `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="95a33-581">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="95a33-582">`ParameterModifier` используется только при вызове через COM-взаимодействие, и обрабатываются только параметры, передаваемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-582">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="95a33-583">Если точное соответствие не существует, `binder` будет пытаться привести типы параметров, заданные в массиве `types`, чтобы выбрать совпадение.</span><span class="sxs-lookup"><span data-stu-id="95a33-583">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="95a33-584">Если `binder` не удается выбрать соответствие, возвращается `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-584">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="95a33-585">Для определения конструкторов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-585">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-586">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-586">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-587">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые конструкторы.</span><span class="sxs-lookup"><span data-stu-id="95a33-587">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="95a33-588">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск неоткрытые конструкторы (то есть частные, внутренние и защищенные конструкторы).</span><span class="sxs-lookup"><span data-stu-id="95a33-588">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="95a33-589">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-589">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-590">Чтобы получить инициализатор класса (статический конструктор) с помощью этого метода, необходимо указать <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-590">To get the class initializer (static constructor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="95a33-591">Инициализатор класса также можно получить с помощью свойства <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-591">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="95a33-592">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-592">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-593">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-593">Member Type</span></span>|<span data-ttu-id="95a33-594">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-594">Static</span></span>|<span data-ttu-id="95a33-595">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-595">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-596">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-596">Constructor</span></span>|<span data-ttu-id="95a33-597">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-597">No</span></span>|<span data-ttu-id="95a33-598">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-598">No</span></span>|  
|<span data-ttu-id="95a33-599">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-599">Field</span></span>|<span data-ttu-id="95a33-600">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-600">No</span></span>|<span data-ttu-id="95a33-601">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-601">Yes.</span></span> <span data-ttu-id="95a33-602">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-602">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-603">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-603">Event</span></span>|<span data-ttu-id="95a33-604">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-604">Not applicable</span></span>|<span data-ttu-id="95a33-605">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-605">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-606">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-606">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-607">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-607">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-608">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-608">Method</span></span>|<span data-ttu-id="95a33-609">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-609">No</span></span>|<span data-ttu-id="95a33-610">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-610">Yes.</span></span> <span data-ttu-id="95a33-611">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-611">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-612">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-612">Nested Type</span></span>|<span data-ttu-id="95a33-613">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-613">No</span></span>|<span data-ttu-id="95a33-614">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-614">No</span></span>|  
|<span data-ttu-id="95a33-615">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-615">Property</span></span>|<span data-ttu-id="95a33-616">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-616">Not applicable</span></span>|<span data-ttu-id="95a33-617">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-617">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-618">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-618">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-619">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-619">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-620">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-620">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-621">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-621">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-622">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-622">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-623">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-623">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-624">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-624">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-625">Нельзя опустить параметры при поиске конструкторов и методов.</span><span class="sxs-lookup"><span data-stu-id="95a33-625">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="95a33-626">При вызове можно опустить только параметры.</span><span class="sxs-lookup"><span data-stu-id="95a33-626">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="95a33-627">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-627">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="95a33-628">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод всегда возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-628">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-629">Следующий пример получает тип `MyClass1`, возвращает объект <xref:System.Reflection.ConstructorInfo>, соответствующий указанным флагам привязки, и отображает сигнатуру конструктора.</span><span class="sxs-lookup"><span data-stu-id="95a33-629">The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-630">Свойство <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-630"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-631">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-631">-or-</span></span> 
<span data-ttu-id="95a33-632">Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-632">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-633">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-633"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-634">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-634">-or-</span></span> 
 <span data-ttu-id="95a33-635">Массив <paramref name="modifiers" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-635"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-636">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-636">-or-</span></span> 
 <span data-ttu-id="95a33-637"><paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</span><span class="sxs-lookup"><span data-stu-id="95a33-637"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="95a33-638">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-638">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-639">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-639">-or-</span></span> 
<span data-ttu-id="95a33-640"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-640"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="95a33-641">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-641">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="95a33-642">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-642">-or-</span></span> 
<span data-ttu-id="95a33-643">Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-643">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="95a33-644">Объект, определяющий набор применяемых правил, касающихся порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и очистки стека.</span><span class="sxs-lookup"><span data-stu-id="95a33-644">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-645">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров, извлекаемых конструктором.</span><span class="sxs-lookup"><span data-stu-id="95a33-645">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="95a33-646">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-646">-or-</span></span> 
<span data-ttu-id="95a33-647">Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить конструктор, который не имеет параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-647">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="95a33-648">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-648">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="95a33-649">Связыватель по умолчанию не обрабатывает этот параметр.</span><span class="sxs-lookup"><span data-stu-id="95a33-649">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="95a33-650">При переопределении в производном классе ищет конструктор, параметры которого соответствуют указанным типам аргументов и модификаторам, используя для этого заданные ограничения привязки и соглашение о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-650">When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="95a33-651">Если поиск выполнен удачно, возвращается объект <see cref="T:System.Reflection.ConstructorInfo" />, представляющий конструктор, который соответствует указанным требованиям; в противном случае возвращается значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-651">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-652">Хотя связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> (параметр `modifiers`), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательского связывателя, который обрабатывает `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="95a33-652">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="95a33-653">`ParameterModifier` используется только при вызове через COM-взаимодействие, и обрабатываются только параметры, передаваемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-653">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="95a33-654">Если точное соответствие не существует, `binder` будет пытаться привести типы параметров, заданные в массиве `types`, чтобы выбрать совпадение.</span><span class="sxs-lookup"><span data-stu-id="95a33-654">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="95a33-655">Если `binder` не удается выбрать соответствие, возвращается `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-655">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="95a33-656">Для определения конструкторов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-656">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-657">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-657">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-658">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые конструкторы.</span><span class="sxs-lookup"><span data-stu-id="95a33-658">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="95a33-659">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск неоткрытые конструкторы (то есть частные, внутренние и защищенные конструкторы).</span><span class="sxs-lookup"><span data-stu-id="95a33-659">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="95a33-660">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-660">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-661">Этот метод реализует <xref:System.Type.GetConstructor%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-661">This method implements <xref:System.Type.GetConstructor%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-662"><paramref name="types" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-662"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-663">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-663">-or-</span></span> 
<span data-ttu-id="95a33-664">Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-664">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-665">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-665"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-666">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-666">-or-</span></span> 
 <span data-ttu-id="95a33-667">Массив <paramref name="modifiers" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-667"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-668">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-668">-or-</span></span> 
 <span data-ttu-id="95a33-669"><paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</span><span class="sxs-lookup"><span data-stu-id="95a33-669"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-670">Текущий тип — <see cref="T:System.Reflection.Emit.TypeBuilder" /> или <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-670">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-671">Получает конструкторы текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-671">Gets the constructors of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-672">Возвращает все открытые конструкторы, определенные для текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-672">Returns all the public constructors defined for the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-673">Массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющий все открытые конструкторы экземпляров, определенные для текущего типа <see cref="T:System.Type" />, за исключением инициализатора типа (статический конструктор).</span><span class="sxs-lookup"><span data-stu-id="95a33-673">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor).</span></span> <span data-ttu-id="95a33-674">Если для текущего объекта <see cref="T:System.Type" /> открытые конструкторы экземпляров не определены или если текущий объект <see cref="T:System.Type" /> представляет параметр типа в определении универсального типа или метода, возвращается пустой массив типа <see cref="T:System.Reflection.ConstructorInfo" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-674">If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-675">Метод <xref:System.Type.GetConstructors%2A> не возвращает конструкторы в определенном порядке, например в порядке объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-675">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="95a33-676">Код не должен зависеть от порядка, в котором возвращаются конструкторы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-676">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-677">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-677">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-678">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-678">Member Type</span></span>|<span data-ttu-id="95a33-679">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-679">Static</span></span>|<span data-ttu-id="95a33-680">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-680">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-681">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-681">Constructor</span></span>|<span data-ttu-id="95a33-682">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-682">No</span></span>|<span data-ttu-id="95a33-683">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-683">No</span></span>|  
|<span data-ttu-id="95a33-684">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-684">Field</span></span>|<span data-ttu-id="95a33-685">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-685">No</span></span>|<span data-ttu-id="95a33-686">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-686">Yes.</span></span> <span data-ttu-id="95a33-687">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-687">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-688">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-688">Event</span></span>|<span data-ttu-id="95a33-689">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-689">Not applicable</span></span>|<span data-ttu-id="95a33-690">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-690">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-691">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-691">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-692">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-692">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-693">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-693">Method</span></span>|<span data-ttu-id="95a33-694">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-694">No</span></span>|<span data-ttu-id="95a33-695">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-695">Yes.</span></span> <span data-ttu-id="95a33-696">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-696">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-697">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-697">Nested Type</span></span>|<span data-ttu-id="95a33-698">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-698">No</span></span>|<span data-ttu-id="95a33-699">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-699">No</span></span>|  
|<span data-ttu-id="95a33-700">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-700">Property</span></span>|<span data-ttu-id="95a33-701">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-701">Not applicable</span></span>|<span data-ttu-id="95a33-702">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-702">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-703">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-703">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-704">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-704">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-705">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-705">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-706">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-706">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-707">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-707">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-708">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-708">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-709">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-709">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-710">Эта перегрузка метода вызывает перегрузку метода <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> с <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-710">This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="95a33-711">Инициализаторы классов не будут найдены (статический конструктор).</span><span class="sxs-lookup"><span data-stu-id="95a33-711">It will not find class initializers (static constructor).</span></span> <span data-ttu-id="95a33-712">Чтобы найти инициализаторы классов, используйте перегрузку, которая принимает <xref:System.Reflection.BindingFlags>, и &#124; укажите <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-712">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="95a33-713">Инициализатор класса также можно получить с помощью свойства <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-713">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="95a33-714">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.ConstructorInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-714">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="95a33-715">Например, если класс `C<T>` имеет конструктор `C(T t1)` (`Sub New(ByVal t1 As T)` в Visual Basic), вызов <xref:System.Type.GetConstructors%2A> в `C<int>` возвращает <xref:System.Reflection.ConstructorInfo>, который представляет `C(int t1)` в C# (`Sub New(ByVal t1 As Integer)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-715">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="95a33-716">Если текущий <xref:System.Type> представляет параметр универсального типа, метод <xref:System.Type.GetConstructors%2A> возвращает пустой массив.</span><span class="sxs-lookup"><span data-stu-id="95a33-716">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-717">В этом примере показаны выходные данные перегрузки <xref:System.Type.GetConstructors%2A> из класса, который имеет два конструктора экземпляров и один статический конструктор.</span><span class="sxs-lookup"><span data-stu-id="95a33-717">This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="95a33-718">Выходные данные этого кода:</span><span class="sxs-lookup"><span data-stu-id="95a33-718">The output of this code is:</span></span>  
  
 <span data-ttu-id="95a33-719">2</span><span class="sxs-lookup"><span data-stu-id="95a33-719">2</span></span>  
  
 <span data-ttu-id="95a33-720">False</span><span class="sxs-lookup"><span data-stu-id="95a33-720">False</span></span>  
  
 <span data-ttu-id="95a33-721">False</span><span class="sxs-lookup"><span data-stu-id="95a33-721">False</span></span>  
  
 <span data-ttu-id="95a33-722">Поскольку перегрузка <xref:System.Type.GetConstructors> использует только <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, статический конструктор не подсчитывается выражением `for` и не вычисляется `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="95a33-722">Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="95a33-723">Чтобы найти статические конструкторы, используйте перегрузку <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> и передайте сочетание (логическое `OR`) <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, как показано в следующем примере кода:</span><span class="sxs-lookup"><span data-stu-id="95a33-723">To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="95a33-724">Выходные данные будут выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-724">Now the output is:</span></span>  
  
 <span data-ttu-id="95a33-725">3</span><span class="sxs-lookup"><span data-stu-id="95a33-725">3</span></span>  
  
 <span data-ttu-id="95a33-726">False</span><span class="sxs-lookup"><span data-stu-id="95a33-726">False</span></span>  
  
 <span data-ttu-id="95a33-727">Да</span><span class="sxs-lookup"><span data-stu-id="95a33-727">True</span></span>  
  
 <span data-ttu-id="95a33-728">False</span><span class="sxs-lookup"><span data-stu-id="95a33-728">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="95a33-729">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-729">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-730">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-730">-or-</span></span> 
<span data-ttu-id="95a33-731"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-731"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="95a33-732">При переопределении в производном классе ищет конструкторы, определенные для текущего объекта <see cref="T:System.Type" />, с использованием указанного объекта <see langword="BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-732">When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-733">Массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющий все конструкторы, определенные для текущего объекта <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки, в том числе и инициализатор типа, если он определен.</span><span class="sxs-lookup"><span data-stu-id="95a33-733">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined.</span></span> <span data-ttu-id="95a33-734">Возвращает пустой массив типа <see cref="T:System.Reflection.ConstructorInfo" />, если для текущего типа <see cref="T:System.Type" /> не определены конструкторы, если ни один из определенных конструкторов не соответствует ограничениям привязки или если текущий тип <see cref="T:System.Type" /> представляет параметр типа в определении универсального типа или метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-734">Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="95a33-735">`bindingAttr` можно использовать, чтобы указать, следует ли возвращать только открытые конструкторы или открытые и не являющиеся открытыми конструкторы.</span><span class="sxs-lookup"><span data-stu-id="95a33-735">`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.</span></span>  
  
<span data-ttu-id="95a33-736">Для определения конструкторов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-736">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
- <span data-ttu-id="95a33-737">Укажите `BindingFlags.Static` вместе с `BindingFlags.NonPublic`, чтобы получить инициализатор класса (статический конструктор).</span><span class="sxs-lookup"><span data-stu-id="95a33-737">Specify `BindingFlags.Static` along with `BindingFlags.NonPublic` to retrieve the class initializer (static constructor).</span></span> <span data-ttu-id="95a33-738">Инициализатор класса также можно получить с помощью свойства <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-738">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>

- <span data-ttu-id="95a33-739">Укажите `BindingFlags.Instance`, а также один или оба `BindingFlags.Public` и `BindingFlags.NonPublic`, чтобы получить конструкторы экземпляров.</span><span class="sxs-lookup"><span data-stu-id="95a33-739">Specify `BindingFlags.Instance` along with one or both of `BindingFlags.Public` and `BindingFlags.NonPublic` to retrieve instance constructors.</span></span>   
  
<span data-ttu-id="95a33-740">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-740">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  

<span data-ttu-id="95a33-741">Метод <xref:System.Type.GetConstructors%2A> не возвращает конструкторы в определенном порядке, например в порядке объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-741">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="95a33-742">Код не должен зависеть от порядка, в котором возвращаются конструкторы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-742">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  

<span data-ttu-id="95a33-743">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.ConstructorInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-743">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="95a33-744">Например, если класс `C<T>` имеет конструктор `C(T t1)` (`Sub New(ByVal t1 As T)` в Visual Basic), вызов <xref:System.Type.GetConstructors%2A> в `C<int>` возвращает <xref:System.Reflection.ConstructorInfo>, который представляет `C(int t1)` в C# (`Sub New(ByVal t1 As Integer)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-744">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
<span data-ttu-id="95a33-745">Если текущий <xref:System.Type> представляет параметр универсального типа, метод <xref:System.Type.GetConstructors%2A> возвращает пустой массив.</span><span class="sxs-lookup"><span data-stu-id="95a33-745">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
## Examples  

<span data-ttu-id="95a33-746">В этом примере показаны выходные данные перегрузки <xref:System.Type.GetConstructors> из класса, который имеет два конструктора экземпляров и один статический конструктор.</span><span class="sxs-lookup"><span data-stu-id="95a33-746">This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="95a33-747">Выходные данные этого кода:</span><span class="sxs-lookup"><span data-stu-id="95a33-747">The output of this code is:</span></span>  
  
 <span data-ttu-id="95a33-748">2</span><span class="sxs-lookup"><span data-stu-id="95a33-748">2</span></span>  
  
 <span data-ttu-id="95a33-749">False</span><span class="sxs-lookup"><span data-stu-id="95a33-749">False</span></span>  
  
 <span data-ttu-id="95a33-750">False</span><span class="sxs-lookup"><span data-stu-id="95a33-750">False</span></span>  
  
 <span data-ttu-id="95a33-751">Поскольку перегрузка <xref:System.Type.GetConstructors%2A> использует только <xref:System.Reflection.BindingFlags.Public> и <xref:System.Reflection.BindingFlags.Instance>, статический конструктор не подсчитывается выражением `for` и не вычисляется `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="95a33-751">Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="95a33-752">Чтобы найти статические конструкторы, используйте перегрузку <xref:System.Type.GetConstructors%2A> и передайте ей сочетание (логическое или) <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, как показано в следующем примере кода:</span><span class="sxs-lookup"><span data-stu-id="95a33-752">To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="95a33-753">Выходные данные будут выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-753">Now the output is:</span></span>  
  
 <span data-ttu-id="95a33-754">3</span><span class="sxs-lookup"><span data-stu-id="95a33-754">3</span></span>  
  
 <span data-ttu-id="95a33-755">False</span><span class="sxs-lookup"><span data-stu-id="95a33-755">False</span></span>  
  
 <span data-ttu-id="95a33-756">Да</span><span class="sxs-lookup"><span data-stu-id="95a33-756">True</span></span>  
  
 <span data-ttu-id="95a33-757">False</span><span class="sxs-lookup"><span data-stu-id="95a33-757">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-758">Выполняет поиск членов, определенных для текущего объекта <see cref="T:System.Type" />, для которого задан атрибут <see cref="T:System.Reflection.DefaultMemberAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-758">Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</span></span></summary>
        <returns><span data-ttu-id="95a33-759">Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий все члены по умолчанию текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-759">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="95a33-760">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-760">-or-</span></span> 
<span data-ttu-id="95a33-761">Пустой массив типа <see cref="T:System.Reflection.MemberInfo" />, если у текущего типа <see cref="T:System.Type" /> нет членов по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-761">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-762">Метод <xref:System.Type.GetDefaultMembers%2A> не возвращает элементы в определенном порядке, например алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-762">The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-763">Код не должен зависеть от порядка, в котором возвращаются элементы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-763">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-764">Этот метод может быть переопределен производным классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-764">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="95a33-765">Элементы включают свойства, методы, поля, события и т. д.</span><span class="sxs-lookup"><span data-stu-id="95a33-765">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="95a33-766">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-766">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-767">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-767">Member Type</span></span>|<span data-ttu-id="95a33-768">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-768">Static</span></span>|<span data-ttu-id="95a33-769">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-769">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-770">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-770">Constructor</span></span>|<span data-ttu-id="95a33-771">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-771">No</span></span>|<span data-ttu-id="95a33-772">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-772">No</span></span>|  
|<span data-ttu-id="95a33-773">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-773">Field</span></span>|<span data-ttu-id="95a33-774">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-774">No</span></span>|<span data-ttu-id="95a33-775">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-775">Yes.</span></span> <span data-ttu-id="95a33-776">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-776">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-777">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-777">Event</span></span>|<span data-ttu-id="95a33-778">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-778">Not applicable</span></span>|<span data-ttu-id="95a33-779">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-779">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-780">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-780">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-781">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-781">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-782">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-782">Method</span></span>|<span data-ttu-id="95a33-783">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-783">No</span></span>|<span data-ttu-id="95a33-784">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-784">Yes.</span></span> <span data-ttu-id="95a33-785">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-785">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-786">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-786">Nested Type</span></span>|<span data-ttu-id="95a33-787">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-787">No</span></span>|<span data-ttu-id="95a33-788">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-788">No</span></span>|  
|<span data-ttu-id="95a33-789">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-789">Property</span></span>|<span data-ttu-id="95a33-790">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-790">Not applicable</span></span>|<span data-ttu-id="95a33-791">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-791">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-792">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-792">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-793">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-793">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-794">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-794">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-795">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-795">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-796">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-796">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-797">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-797">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-798">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-798">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-799">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.MemberInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-799">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="95a33-800">Например, если класс `C<T>` имеет свойство `P`, которое возвращает `T`, вызов <xref:System.Type.GetDefaultMembers%2A> в `C<int>` возвращает `int P` в C# (`Property P As Integer` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-800">For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).</span></span>  
  
 <span data-ttu-id="95a33-801">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <xref:System.Object>, если ограничение класса отсутствует.</span><span class="sxs-lookup"><span data-stu-id="95a33-801">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-802">Следующий пример получает сведения об элементе по умолчанию `MyClass` и отображает элементы по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-802">The following example obtains the default member information of `MyClass` and displays the default members.</span></span>  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-803">При переопределении в производном классе возвращает тип <see cref="T:System.Type" /> объекта, на который ссылается данный массив, указатель или ссылка или который инкапсулирован в этих объектах.</span><span class="sxs-lookup"><span data-stu-id="95a33-803">When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</span></span></summary>
        <returns><span data-ttu-id="95a33-804">Тип объекта <see cref="T:System.Type" />, на который ссылается данный массив, указатель или ссылка или который инкапсулирован в этих объектах, или значение <see langword="null" />, если текущий объект <see cref="T:System.Type" /> не является массивом или указателем, не передается по ссылке либо представляет универсальный тип или параметр типа в определении универсального типа или метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-804">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-805">Этот метод возвращает `null` для класса <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="95a33-805">This method returns `null` for the <xref:System.Array> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-806">В следующем примере демонстрируется использование метода `GetElementType`.</span><span class="sxs-lookup"><span data-stu-id="95a33-806">The following example demonstrates using the `GetElementType` method.</span></span>  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="95a33-807">Значение, имя которой требуется извлечь.</span><span class="sxs-lookup"><span data-stu-id="95a33-807">The value whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="95a33-808">Возвращает имя константы с заданным значением для текущего типа перечисления.</span><span class="sxs-lookup"><span data-stu-id="95a33-808">Returns the name of the constant that has the specified value, for the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="95a33-809">Имя члена текущего типа перечисления, имеющего указанное значение, или <see langword="null" />, если такая константа не найдена.</span><span class="sxs-lookup"><span data-stu-id="95a33-809">The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-810">Текущий тип не является перечислением.</span><span class="sxs-lookup"><span data-stu-id="95a33-810">The current type is not an enumeration.</span></span>  
  
<span data-ttu-id="95a33-811">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-811">-or-</span></span> 
 <span data-ttu-id="95a33-812"><paramref name="value" /> не является ни текущим типом, ни имеющим базовый тип, совпадающий с текущим типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-812"><paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-813"><paramref name="value" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-813"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-814">Возвращает имена членов текущего типа перечисления.</span><span class="sxs-lookup"><span data-stu-id="95a33-814">Returns the names of the members of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="95a33-815">Массив, который содержит имена членов перечисления.</span><span class="sxs-lookup"><span data-stu-id="95a33-815">An array that contains the names of the members of the enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-816">Элементы массива возвращаемых значений сортируются по двоичным значениям (то есть значениям без знака) перечисляемых констант.</span><span class="sxs-lookup"><span data-stu-id="95a33-816">The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</span></span> <span data-ttu-id="95a33-817">Если массив содержит перечислимые константы с одинаковым значением, порядок их соответствующих имен не определен.</span><span class="sxs-lookup"><span data-stu-id="95a33-817">If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-818">Текущий тип не является перечислением.</span><span class="sxs-lookup"><span data-stu-id="95a33-818">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-819">Возвращает базовый тип текущего типа перечисления.</span><span class="sxs-lookup"><span data-stu-id="95a33-819">Returns the underlying type of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="95a33-820">Базовый тип текущего перечисления.</span><span class="sxs-lookup"><span data-stu-id="95a33-820">The underlying type of the current enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-821">По умолчанию базовым типом перечисления в C# и Visual Basic является <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="95a33-821">By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>.</span></span> <span data-ttu-id="95a33-822">Можно указать другие целочисленные типы.</span><span class="sxs-lookup"><span data-stu-id="95a33-822">Other integer types can be specified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-823">Текущий тип не является перечислением.</span><span class="sxs-lookup"><span data-stu-id="95a33-823">The current type is not an enumeration.</span></span>  
  
 <span data-ttu-id="95a33-824">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-824">-or-</span></span>  
  
 <span data-ttu-id="95a33-825">Тип перечисления не является допустимым, так как содержит более одного поля экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-825">The enumeration type is not valid, because it contains more than one instance field.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-826">Возвращает массив значений констант в текущем типе перечисления.</span><span class="sxs-lookup"><span data-stu-id="95a33-826">Returns an array of the values of the constants in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="95a33-827">Массив, содержащий значения.</span><span class="sxs-lookup"><span data-stu-id="95a33-827">An array that contains the values.</span></span> <span data-ttu-id="95a33-828">Элементы массива сортируются по двоичным значениям (то есть значениям без знака) констант перечисления.</span><span class="sxs-lookup"><span data-stu-id="95a33-828">The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-829">Текущий тип не является перечислением.</span><span class="sxs-lookup"><span data-stu-id="95a33-829">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-830">Получает определенное событие, которое объявлено или унаследовано в текущем объекте <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-830">Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.EventInfo GetEvent(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-831">Строка, содержащая имя события, которое объявлено или унаследовано текущим типом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-831">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="95a33-832">Возвращает объект <see cref="T:System.Reflection.EventInfo" />, представляющий указанное открытое событие.</span><span class="sxs-lookup"><span data-stu-id="95a33-832">Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</span></span></summary>
        <returns><span data-ttu-id="95a33-833">Объект, представляющий указанное открытое событие, которое объявлено или унаследовано в текущем объекте <see cref="T:System.Type" />, если такое событие найдено; в противном случае — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-833">The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-834">Событие считается открытым для отражения, если у него есть по крайней мере один из открытых методов или метода доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-834">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="95a33-835">В противном случае событие считается закрытым и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения с помощью `Or`), чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-835">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="95a33-836">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-836">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="95a33-837">Поиск включает открытые статические и открытые события экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-837">The search includes public static and public instance events.</span></span>  
  
 <span data-ttu-id="95a33-838">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-838">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-839">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-839">Member Type</span></span>|<span data-ttu-id="95a33-840">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-840">Static</span></span>|<span data-ttu-id="95a33-841">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-841">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-842">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-842">Constructor</span></span>|<span data-ttu-id="95a33-843">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-843">No</span></span>|<span data-ttu-id="95a33-844">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-844">No</span></span>|  
|<span data-ttu-id="95a33-845">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-845">Field</span></span>|<span data-ttu-id="95a33-846">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-846">No</span></span>|<span data-ttu-id="95a33-847">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-847">Yes.</span></span> <span data-ttu-id="95a33-848">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-848">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-849">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-849">Event</span></span>|<span data-ttu-id="95a33-850">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-850">Not applicable</span></span>|<span data-ttu-id="95a33-851">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-851">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-852">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-852">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-853">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-853">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-854">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-854">Method</span></span>|<span data-ttu-id="95a33-855">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-855">No</span></span>|<span data-ttu-id="95a33-856">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-856">Yes.</span></span> <span data-ttu-id="95a33-857">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-857">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-858">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-858">Nested Type</span></span>|<span data-ttu-id="95a33-859">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-859">No</span></span>|<span data-ttu-id="95a33-860">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-860">No</span></span>|  
|<span data-ttu-id="95a33-861">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-861">Property</span></span>|<span data-ttu-id="95a33-862">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-862">Not applicable</span></span>|<span data-ttu-id="95a33-863">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-863">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-864">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-864">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-865">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-865">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-866">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-866">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-867">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-867">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-868">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-868">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-869">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-869">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-870">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-870">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-871">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.EventInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-871">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-872">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск событий ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-872">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-873">В следующем примере создается объект <xref:System.Reflection.EventInfo> и получается событие для класса Button для указанного события.</span><span class="sxs-lookup"><span data-stu-id="95a33-873">The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.</span></span>  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-874"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-874"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-875">Строка, содержащая имя события, которое объявлено или унаследовано текущим типом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-875">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-876">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-876">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-877">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-877">-or-</span></span> 
 <span data-ttu-id="95a33-878"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-878"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="95a33-879">При переопределении в производном классе возвращает объект <see cref="T:System.Reflection.EventInfo" />, представляющий указанное событие, используя для этого указанные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-879">When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-880">Объект, представляющий указанное событие, которое объявлено или унаследовано текущим типом <see cref="T:System.Type" />, если такое событие найдено; <see langword="null" /> в противном случае.</span><span class="sxs-lookup"><span data-stu-id="95a33-880">The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-881">Для определения событий, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-881">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-882">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-882">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-883">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые события.</span><span class="sxs-lookup"><span data-stu-id="95a33-883">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="95a33-884">Укажите `BindingFlags.NonPublic`, чтобы включить в Поиск события, не являющиеся общими (т. е. частные, внутренние и защищенные события).</span><span class="sxs-lookup"><span data-stu-id="95a33-884">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-885">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-885">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="95a33-886">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-886">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-887">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-887">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-888">`BindingFlags.DeclaredOnly` искать только события, объявленные в <xref:System.Type>, а не события, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-888">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-889">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-889">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-890">Событие считается открытым для отражения, если у него есть по крайней мере один из открытых методов или метода доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-890">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="95a33-891">В противном случае событие считается закрытым и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения с помощью `Or`), чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-891">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="95a33-892">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.EventInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-892">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-893">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск событий ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-893">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-894">В следующем примере кода метод <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> используется для поиска открытого или не открытого события с именем "Click", которое не `static` (`Shared` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-894">The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named "Click" that is not `static` (`Shared` in Visual Basic).</span></span>  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-895">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-895"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-896">Получает события, которые объявлены или унаследованы текущим объектом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-896">Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-897">Возвращает все открытые события, которые объявлены или унаследованы текущим объектом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-897">Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-898">Массив объектов <see cref="T:System.Reflection.EventInfo" />, представляющий все открытые события, которые объявлены или унаследованы текущим объектом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-898">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="95a33-899">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-899">-or-</span></span> 
<span data-ttu-id="95a33-900">Пустой массив типа <see cref="T:System.Reflection.EventInfo" />, если в текущем объекте <see cref="T:System.Type" /> нет открытых событий.</span><span class="sxs-lookup"><span data-stu-id="95a33-900">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-901">Событие считается открытым для отражения, если у него есть по крайней мере один из открытых методов или метода доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-901">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="95a33-902">В противном случае событие считается закрытым и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения с помощью `Or`), чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-902">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="95a33-903">Метод <xref:System.Type.GetEvents%2A> не возвращает события в определенном порядке, таком как алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-903">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-904">Код не должен зависеть от порядка, в котором возвращаются события, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-904">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-905">Этот метод может быть переопределен производным классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-905">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="95a33-906">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-906">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-907">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-907">Member Type</span></span>|<span data-ttu-id="95a33-908">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-908">Static</span></span>|<span data-ttu-id="95a33-909">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-909">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-910">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-910">Constructor</span></span>|<span data-ttu-id="95a33-911">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-911">No</span></span>|<span data-ttu-id="95a33-912">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-912">No</span></span>|  
|<span data-ttu-id="95a33-913">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-913">Field</span></span>|<span data-ttu-id="95a33-914">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-914">No</span></span>|<span data-ttu-id="95a33-915">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-915">Yes.</span></span> <span data-ttu-id="95a33-916">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-916">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-917">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-917">Event</span></span>|<span data-ttu-id="95a33-918">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-918">Not applicable</span></span>|<span data-ttu-id="95a33-919">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-919">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-920">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-920">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-921">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-921">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-922">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-922">Method</span></span>|<span data-ttu-id="95a33-923">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-923">No</span></span>|<span data-ttu-id="95a33-924">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-924">Yes.</span></span> <span data-ttu-id="95a33-925">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-925">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-926">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-926">Nested Type</span></span>|<span data-ttu-id="95a33-927">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-927">No</span></span>|<span data-ttu-id="95a33-928">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-928">No</span></span>|  
|<span data-ttu-id="95a33-929">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-929">Property</span></span>|<span data-ttu-id="95a33-930">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-930">Not applicable</span></span>|<span data-ttu-id="95a33-931">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-931">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-932">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-932">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-933">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-933">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-934">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-934">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-935">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-935">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-936">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-936">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-937">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-937">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-938">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-938">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-939">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.EventInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-939">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-940">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск событий ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-940">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-941">Следующий пример получает массив объектов <xref:System.Reflection.EventInfo>, получает все события для класса `Button` и отображает имена событий.</span><span class="sxs-lookup"><span data-stu-id="95a33-941">The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="95a33-942">Чтобы скомпилировать пример Visual Basic, используйте следующую командную строку:</span><span class="sxs-lookup"><span data-stu-id="95a33-942">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="95a33-943">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-943">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="95a33-944">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-944">-or-</span></span>

 <span data-ttu-id="95a33-945"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-945"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="95a33-946">При переопределении в производном классе ищет события, которые объявлены или унаследованы текущим объектом <see cref="T:System.Type" />, используя указанные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-946">When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-947">Массив объектов <see cref="T:System.Reflection.EventInfo" />, представляющий все события, которые объявлены или унаследованы данным объектом <see cref="T:System.Type" /> и удовлетворяют указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-947">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="95a33-948">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-948">-or-</span></span> 
<span data-ttu-id="95a33-949">Пустой массив типа <see cref="T:System.Reflection.EventInfo" />, если у текущего типа <see cref="T:System.Type" /> нет событий или ни одно событие не удовлетворяет ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-949">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-950">Метод <xref:System.Type.GetEvents%2A> не возвращает события в определенном порядке, таком как алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-950">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-951">Код не должен зависеть от порядка, в котором возвращаются события, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-951">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-952">Для определения событий, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-952">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-953">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-953">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-954">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые события.</span><span class="sxs-lookup"><span data-stu-id="95a33-954">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="95a33-955">Укажите `BindingFlags.NonPublic`, чтобы включить в Поиск события, не являющиеся общими (т. е. частные, внутренние и защищенные события).</span><span class="sxs-lookup"><span data-stu-id="95a33-955">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span> <span data-ttu-id="95a33-956">Возвращаются только защищенные и внутренние события базовых классов. Закрытые события в базовых классах не возвращаются.</span><span class="sxs-lookup"><span data-stu-id="95a33-956">Only protected and internal events on base classes are returned; private events on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="95a33-957">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-957">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="95a33-958">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-958">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-959">`BindingFlags.DeclaredOnly` искать только события, объявленные в <xref:System.Type>, а не события, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-959">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-960">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-960">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-961">Событие считается открытым для отражения, если у него есть по крайней мере один из открытых методов или метода доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-961">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="95a33-962">В противном случае событие считается закрытым и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения с помощью `Or`), чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-962">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="95a33-963">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.EventInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-963">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-964">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск событий ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-964">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-965">В следующем примере получается массив объектов <xref:System.Reflection.EventInfo>, соответствующих указанным флагам привязки, получаются все события для класса `Button` и отображаются имена событий.</span><span class="sxs-lookup"><span data-stu-id="95a33-965">The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="95a33-966">Чтобы скомпилировать пример Visual Basic, используйте следующую командную строку:</span><span class="sxs-lookup"><span data-stu-id="95a33-966">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-967">Получает указанное поле текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-967">Gets a specific field of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-968">Строка, содержащая имя искомого поля данных.</span><span class="sxs-lookup"><span data-stu-id="95a33-968">The string containing the name of the data field to get.</span></span></param>
        <summary><span data-ttu-id="95a33-969">Выполняет поиск открытого поля с заданным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-969">Searches for the public field with the specified name.</span></span></summary>
        <returns><span data-ttu-id="95a33-970">Объект, представляющий открытое поле с указанным именем, если такое свойство есть, или <see langword="null" />, если такого свойства нет.</span><span class="sxs-lookup"><span data-stu-id="95a33-970">An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-971">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-971">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="95a33-972">Поиск включает открытые статические и открытые поля экземпляров.</span><span class="sxs-lookup"><span data-stu-id="95a33-972">The search includes public static and public instance fields.</span></span>  
  
 <span data-ttu-id="95a33-973">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.FieldInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-973">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-974">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск в полях ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-974">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-975">В следующем примере показано получение объекта `Type` для указанного класса, получение объекта <xref:System.Reflection.FieldInfo> для поля и отображение значения поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-975">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-976">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-976"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-977">Этот объект <see cref="T:System.Type" /> является <see cref="T:System.Reflection.Emit.TypeBuilder" />, метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> которого еще не был вызван.</span><span class="sxs-lookup"><span data-stu-id="95a33-977">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-978">Строка, содержащая имя искомого поля данных.</span><span class="sxs-lookup"><span data-stu-id="95a33-978">The string containing the name of the data field to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-979">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-979">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-980">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-980">-or-</span></span> 
 <span data-ttu-id="95a33-981"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-981"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="95a33-982">Выполняет поиск указанного поля, используя заданные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-982">Searches for the specified field, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-983">Объект, предоставляющий поле, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-983">An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-984">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-984">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-985">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-985">Member Type</span></span>|<span data-ttu-id="95a33-986">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-986">Static</span></span>|<span data-ttu-id="95a33-987">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-987">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-988">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-988">Constructor</span></span>|<span data-ttu-id="95a33-989">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-989">No</span></span>|<span data-ttu-id="95a33-990">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-990">No</span></span>|  
|<span data-ttu-id="95a33-991">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-991">Field</span></span>|<span data-ttu-id="95a33-992">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-992">No</span></span>|<span data-ttu-id="95a33-993">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-993">Yes.</span></span> <span data-ttu-id="95a33-994">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-994">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-995">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-995">Event</span></span>|<span data-ttu-id="95a33-996">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-996">Not applicable</span></span>|<span data-ttu-id="95a33-997">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-997">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-998">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-998">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-999">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-999">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-1000">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-1000">Method</span></span>|<span data-ttu-id="95a33-1001">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1001">No</span></span>|<span data-ttu-id="95a33-1002">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1002">Yes.</span></span> <span data-ttu-id="95a33-1003">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1003">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1004">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-1004">Nested Type</span></span>|<span data-ttu-id="95a33-1005">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1005">No</span></span>|<span data-ttu-id="95a33-1006">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1006">No</span></span>|  
|<span data-ttu-id="95a33-1007">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1007">Property</span></span>|<span data-ttu-id="95a33-1008">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1008">Not applicable</span></span>|<span data-ttu-id="95a33-1009">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1009">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1010">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1010">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1011">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1011">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-1012">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-1012">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-1013">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-1013">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-1014">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1014">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1015">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1015">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-1016">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1016">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-1017">Для определения полей, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1017">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-1018">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1018">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-1019">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-1019">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1020">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск не являющиеся открытыми поля (т. е. закрытые, внутренние и защищенные поля).</span><span class="sxs-lookup"><span data-stu-id="95a33-1020">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1021">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1021">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="95a33-1022">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1022">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-1023">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1023">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-1024">`BindingFlags.DeclaredOnly` искать только поля, объявленные в <xref:System.Type>, а не поля, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1024">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-1025">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1025">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-1026">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.FieldInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1026">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1027">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск в полях ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1027">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1028">В следующем примере показано получение объекта `Type` для указанного класса, получение объекта <xref:System.Reflection.FieldInfo> для поля, соответствующего указанным флагам привязки, и отображение значения поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-1028">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1029">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1029"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-1030">Получает поля текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1030">Gets the fields of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-1031">Возвращает все открытые поля текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1031">Returns all the public fields of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-1032">Массив объектов <see cref="T:System.Reflection.FieldInfo" />, представляющий все открытые поля, определенные для текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1032">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="95a33-1033">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1033">-or-</span></span> 
<span data-ttu-id="95a33-1034">Пустой массив типа <see cref="T:System.Reflection.FieldInfo" />, если для текущего типа <see cref="T:System.Type" /> открытые поля не определены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1034">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1035">Метод <xref:System.Type.GetFields%2A> не возвращает поля в определенном порядке, таком как алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1035">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1036">Код не должен зависеть от порядка, в котором возвращаются поля, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1036">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-1037">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1037">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-1038">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-1038">Member Type</span></span>|<span data-ttu-id="95a33-1039">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-1039">Static</span></span>|<span data-ttu-id="95a33-1040">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-1040">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-1041">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-1041">Constructor</span></span>|<span data-ttu-id="95a33-1042">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1042">No</span></span>|<span data-ttu-id="95a33-1043">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1043">No</span></span>|  
|<span data-ttu-id="95a33-1044">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-1044">Field</span></span>|<span data-ttu-id="95a33-1045">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1045">No</span></span>|<span data-ttu-id="95a33-1046">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1046">Yes.</span></span> <span data-ttu-id="95a33-1047">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1047">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1048">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-1048">Event</span></span>|<span data-ttu-id="95a33-1049">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1049">Not applicable</span></span>|<span data-ttu-id="95a33-1050">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1050">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1051">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1051">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1052">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1052">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-1053">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-1053">Method</span></span>|<span data-ttu-id="95a33-1054">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1054">No</span></span>|<span data-ttu-id="95a33-1055">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1055">Yes.</span></span> <span data-ttu-id="95a33-1056">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1056">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1057">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-1057">Nested Type</span></span>|<span data-ttu-id="95a33-1058">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1058">No</span></span>|<span data-ttu-id="95a33-1059">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1059">No</span></span>|  
|<span data-ttu-id="95a33-1060">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1060">Property</span></span>|<span data-ttu-id="95a33-1061">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1061">Not applicable</span></span>|<span data-ttu-id="95a33-1062">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1062">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1063">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1063">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1064">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1064">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-1065">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-1065">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-1066">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-1066">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-1067">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1067">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1068">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1068">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-1069">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1069">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-1070">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.FieldInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1070">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1071">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск открытых полей ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1071">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1072">В следующем примере показано использование метода `GetFields()`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1072">The following example shows a use of the `GetFields()` method.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="95a33-1073">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1073">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="95a33-1074">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1074">-or-</span></span>

 <span data-ttu-id="95a33-1075"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-1075"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="95a33-1076">При переопределении в производном классе ищет поля, определенные для текущего объекта <see cref="T:System.Type" />, используя указанные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1076">When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-1077">Массив объектов <see cref="T:System.Reflection.FieldInfo" />, представляющий все поля, определенные для текущего типа <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1077">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="95a33-1078">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1078">-or-</span></span> 
<span data-ttu-id="95a33-1079">Пустой массив типа <see cref="T:System.Reflection.FieldInfo" />, если для текущего объекта <see cref="T:System.Type" /> не определены поля или ни одно из определенных полей не удовлетворяет ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1079">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="95a33-1080">Чтобы перегрузить `GetFields(BindingFlags)` для успешного получения сведений о свойствах, аргумент `bindingAttr` должен включать по крайней мере один из <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, а также хотя бы один из <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1080">For the `GetFields(BindingFlags)` overload to successfully retrieve property information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="95a33-1081">Для определения полей, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1081">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
- <span data-ttu-id="95a33-1082">Укажите `BindingFlags.Instance`, чтобы включить методы экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1082">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="95a33-1083">Укажите `BindingFlags.Static`, чтобы включить статические методы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1083">Specify `BindingFlags.Static` to include static methods.</span></span> 
    
- <span data-ttu-id="95a33-1084">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-1084">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
- <span data-ttu-id="95a33-1085">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск не являющиеся открытыми поля (т. е. закрытые, внутренние и защищенные поля).</span><span class="sxs-lookup"><span data-stu-id="95a33-1085">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span> <span data-ttu-id="95a33-1086">Возвращаются только защищенные и внутренние поля базовых классов; закрытые поля базовых классов не возвращаются.</span><span class="sxs-lookup"><span data-stu-id="95a33-1086">Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</span></span>  
  
- <span data-ttu-id="95a33-1087">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1087">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="95a33-1088">Укажите только `BindingFlags.Default`, чтобы вернуть пустой массив <xref:System.Reflection.PropertyInfo>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1088">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.PropertyInfo> array.</span></span>

<span data-ttu-id="95a33-1089">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1089">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="95a33-1090">`BindingFlags.DeclaredOnly` искать только поля, объявленные в <xref:System.Type>, а не поля, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1090">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
<span data-ttu-id="95a33-1091">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1091">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
<span data-ttu-id="95a33-1092">Метод <xref:System.Type.GetFields%2A> не возвращает поля в определенном порядке, таком как алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1092">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1093">Код не должен зависеть от порядка, в котором возвращаются поля, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1093">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  

 <span data-ttu-id="95a33-1094">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.FieldInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1094">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1095">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск открытых полей ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1095">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
## Examples  
 <span data-ttu-id="95a33-1096">В следующем примере показано использование метода `GetFields(BindingFlags)`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1096">The following example shows a use of the `GetFields(BindingFlags)` method.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-1097">Возвращает массив объектов <see cref="T:System.Type" />, которые представляют аргументы закрытого универсального типа или параметры определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1097">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</span></span></summary>
        <returns><span data-ttu-id="95a33-1098">Массив объектов <see cref="T:System.Type" />, которые представляют аргументы универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1098">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type.</span></span> <span data-ttu-id="95a33-1099">Возвращает пустой массив, если текущий тип не является универсальным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1099">Returns an empty array if the current type is not a generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1100">Элементы массива возвращаются в том порядке, в котором они отображаются в списке аргументов типа для универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1100">The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</span></span>  
  
-   <span data-ttu-id="95a33-1101">Если текущий тип является закрытым сконструированным типом (то есть свойство <xref:System.Type.ContainsGenericParameters%2A> возвращает `false`), то массив, возвращаемый методом <xref:System.Type.GetGenericArguments%2A>, содержит типы, которые были назначены параметрам универсального типа определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1101">If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.</span></span>  
  
-   <span data-ttu-id="95a33-1102">Если текущий тип является определением универсального типа, массив содержит параметры типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1102">If the current type is a generic type definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="95a33-1103">Если текущий тип является открытым сконструированным типом (то есть свойство <xref:System.Type.ContainsGenericParameters%2A> возвращает `true`), в котором определенные типы не были назначены всем параметрам типа и параметрам типа, включающим универсальные типы или методы, массив содержит оба типа и параметры типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1103">If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</span></span> <span data-ttu-id="95a33-1104">Используйте свойство <xref:System.Type.IsGenericParameter%2A>, чтобы отличить их друг от друга.</span><span class="sxs-lookup"><span data-stu-id="95a33-1104">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="95a33-1105">Демонстрацию этого сценария см. в примере кода для свойства <xref:System.Type.ContainsGenericParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1105">For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="95a33-1106">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1106">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1107">В следующем примере кода используется метод <xref:System.Type.GetGenericArguments%2A> для вывода аргументов сконструированного типа и параметров типа его определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1107">The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</span></span>  
  
 <span data-ttu-id="95a33-1108">Этот пример кода является частью большого примера, приведенного для свойства <xref:System.Type.IsGenericTypeDefinition%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1108">This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property.</span></span> <span data-ttu-id="95a33-1109">Пример выходных данных см. в примере выше.</span><span class="sxs-lookup"><span data-stu-id="95a33-1109">See the larger example for sample output.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-1110">Вызванный метод не поддерживается в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1110">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="95a33-1111">Реализацию должны обеспечивать производные классы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1111">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="95a33-1112">Отражение и универсальные типы</span><span class="sxs-lookup"><span data-stu-id="95a33-1112">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="95a33-1113">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-1113">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-1114">Возвращает массив объектов <see cref="T:System.Type" />, которые представляют ограничения, накладываемые на параметр текущего универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1114">Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></summary>
        <returns><span data-ttu-id="95a33-1115">Массив объектов <see cref="T:System.Type" />, которые представляют ограничения, накладываемые на параметр текущего универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1115">An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1116">Каждое ограничение параметра универсального типа выражается как объект <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1116">Each constraint on a generic type parameter is expressed as a <xref:System.Type> object.</span></span> <span data-ttu-id="95a33-1117">Используйте свойство <xref:System.Type.IsClass%2A>, чтобы определить, является ли ограничение ограничением базового класса; Если свойство возвращает `false`, ограничение является ограничением интерфейса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1117">Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint.</span></span> <span data-ttu-id="95a33-1118">Если параметр типа не имеет ограничений класса и не имеет ограничений интерфейса, возвращается пустой массив.</span><span class="sxs-lookup"><span data-stu-id="95a33-1118">If a type parameter has no class constraint and no interface constraints, an empty array is returned.</span></span>  
  
 <span data-ttu-id="95a33-1119">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1119">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1120">В следующем примере кода определяется универсальный тип `Test` с двумя параметрами типа, имеющими разные ограничения.</span><span class="sxs-lookup"><span data-stu-id="95a33-1120">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="95a33-1121">При выполнении программы ограничения проверяются с помощью свойства <xref:System.Type.GenericParameterAttributes%2A> и метода <xref:System.Type.GetGenericParameterConstraints%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1121">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="95a33-1122">Текущий объект <see cref="T:System.Type" /> не является параметром универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1122">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="95a33-1123">То есть свойство <see cref="P:System.Type.IsGenericParameter" /> возвращает значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1123">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="95a33-1124">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-1124">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public abstract Type GetGenericTypeDefinition ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetGenericTypeDefinition () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetGenericTypeDefinition();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-1125">Возвращает объект <see cref="T:System.Type" />, представляющий определение универсального типа, на основе которого можно сконструировать текущий универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-1125">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</span></span></summary>
        <returns><span data-ttu-id="95a33-1126">Объект <see cref="T:System.Type" />, представляющий универсальный тип, на основе которого можно сконструировать текущий тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-1126">A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1127">Определение универсального типа — это шаблон, из которого могут быть созданы другие типы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1127">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="95a33-1128">Например, из определения универсального типа `G<T>` (выраженного в C# синтаксисе; `G(Of T)` в Visual Basic или `generic <typename T> ref class G` C++в) можно создать и создать экземпляр типа `G<int>` (`G(Of Integer)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-1128">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic).</span></span> <span data-ttu-id="95a33-1129">При наличии объекта <xref:System.Type>, представляющего этот сконструированный тип, метод <xref:System.Type.GetGenericTypeDefinition%2A> Возвращает определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1129">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.</span></span>  
  
 <span data-ttu-id="95a33-1130">Если два сконструированных типа создаются из одного определения универсального типа с использованием одних и тех же аргументов типа, то метод <xref:System.Type.GetGenericTypeDefinition%2A> возвращает один и тот же объект <xref:System.Type> для обоих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1130">If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.</span></span>  
  
 <span data-ttu-id="95a33-1131">При вызове метода <xref:System.Type.GetGenericTypeDefinition%2A> для объекта <xref:System.Type>, который уже представляет определение универсального типа, он возвращает текущий <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1131">If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="95a33-1132">Массив универсальных типов не является универсальным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1132">An array of generic types is not itself generic.</span></span> <span data-ttu-id="95a33-1133">В `A<int>[] v;` C# кода или Visual Basic коде `Dim v() As A(Of Integer)`тип переменной `v` не является универсальным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1133">In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic.</span></span> <span data-ttu-id="95a33-1134">Используйте <xref:System.Type.IsGenericType%2A>, чтобы определить, является ли тип универсальным, перед вызовом <xref:System.Type.GetGenericTypeDefinition%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1134">Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.</span></span>  
  
 <span data-ttu-id="95a33-1135">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1135">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1136">В следующем примере кода создается экземпляр сконструированного типа с помощью обычного создания экземпляра, а затем используются методы <xref:System.Type.GetType%2A> и <xref:System.Type.GetGenericTypeDefinition%2A> для получения сконструированного типа и определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1136">The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition.</span></span> <span data-ttu-id="95a33-1137">В этом примере используется универсальный тип <xref:System.Collections.Generic.Dictionary%602>. сконструированный тип представляет <xref:System.Collections.Generic.Dictionary%602> `Test` объектов со строковыми ключами.</span><span class="sxs-lookup"><span data-stu-id="95a33-1137">This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="95a33-1138">Текущий тип не является универсальным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1138">The current type is not a generic type.</span></span>  <span data-ttu-id="95a33-1139">То есть <see cref="P:System.Type.IsGenericType" /> возвращает <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1139">That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-1140">Вызванный метод не поддерживается в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1140">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="95a33-1141">Реализацию должны обеспечивать производные классы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1141">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="95a33-1142">Отражение и универсальные типы</span><span class="sxs-lookup"><span data-stu-id="95a33-1142">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="95a33-1143">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-1143">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-1144">Возвращает хэш-код данного экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1144">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="95a33-1145">Хэш-код данного экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1145">The hash code for this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1146">Этот метод переопределяет метод <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1146">This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1147">В следующем примере выводится хэш-код класса `System.Windows.Forms.Button`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1147">The following example displays the hash code of the `System.Windows.Forms.Button` class.</span></span>  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-1148">Возвращает определенный интерфейс, реализуемый или наследуемый текущим объектом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1148">Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetInterface(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetInterface(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1149">Строка, содержащая имя искомого интерфейса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1149">The string containing the name of the interface to get.</span></span> <span data-ttu-id="95a33-1150">Для универсальных интерфейсов это искаженное имя.</span><span class="sxs-lookup"><span data-stu-id="95a33-1150">For generic interfaces, this is the mangled name.</span></span></param>
        <summary><span data-ttu-id="95a33-1151">Выполняет поиск интерфейса с заданным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-1151">Searches for the interface with the specified name.</span></span></summary>
        <returns><span data-ttu-id="95a33-1152">Объект, представляющий интерфейс с заданным именем, который реализуется или наследуется текущим объектом <see cref="T:System.Type" />, если такой интерфейс существует; в противном случае — значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1152">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1153">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-1153">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="95a33-1154">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Type> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1154">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1155">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет ограничения интерфейса и все интерфейсы, унаследованные от ограничений класса или интерфейса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1155">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1156">Для универсальных интерфейсов параметр `name` — это искаженное имя, заканчивающееся на знак ударения (\`) и число параметров типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1156">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="95a33-1157">Это справедливо и для определений универсальных интерфейсов, и для сконструированных универсальных интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1157">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="95a33-1158">Например, чтобы найти `IExample<T>` (`IExample(Of T)` в Visual Basic) или `IExample<string>` (`IExample(Of String)` в Visual Basic), выполните поиск ``"IExample`1"``.</span><span class="sxs-lookup"><span data-stu-id="95a33-1158">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``"IExample`1"``.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1159">В следующем примере кода используется метод <xref:System.Type.GetInterface%28System.String%29> для поиска <xref:System.Collections.Hashtable> класса для <xref:System.Runtime.Serialization.IDeserializationCallback> интерфейса и перечислены методы интерфейса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1159">The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.</span></span>  
  
 <span data-ttu-id="95a33-1160">В примере кода также демонстрируется перегрузка метода <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> и метод <xref:System.Type.GetInterfaceMap%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1160">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1161"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1161"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-1162">Текущий <see cref="T:System.Type" /> представляет тип, реализующий тот же универсальный интерфейс с другими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1162">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1163">Строка, содержащая имя искомого интерфейса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1163">The string containing the name of the interface to get.</span></span> <span data-ttu-id="95a33-1164">Для универсальных интерфейсов это искаженное имя.</span><span class="sxs-lookup"><span data-stu-id="95a33-1164">For generic interfaces, this is the mangled name.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="95a33-1165">Значение <see langword="true" />, чтобы игнорировать регистр той части параметра <paramref name="name" />, в которой задается простое имя интерфейса (регистр части, соответствующей пространству имен, должен быть надлежащим образом соблюден).</span><span class="sxs-lookup"><span data-stu-id="95a33-1165"><see langword="true" /> to ignore the case of that part of <paramref name="name" /> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</span></span>  
  
<span data-ttu-id="95a33-1166">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1166">-or-</span></span> 
 <span data-ttu-id="95a33-1167">Значение <see langword="false" />, для поиска с учетом регистра всех частей параметра <paramref name="name" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1167"><see langword="false" /> to perform a case-sensitive search for all parts of <paramref name="name" />.</span></span></param>
        <summary><span data-ttu-id="95a33-1168">При переопределении в производном классе ищет интерфейс с заданным именем, позволяющий определить, нужно ли выполнять поиск без учета регистра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1168">When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</span></span></summary>
        <returns><span data-ttu-id="95a33-1169">Объект, представляющий интерфейс с заданным именем, который реализуется или наследуется текущим объектом <see cref="T:System.Type" />, если такой интерфейс существует; в противном случае — значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1169">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1170">Параметр `ignoreCase` применяется только к простому имени интерфейса, а не к пространству имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-1170">The `ignoreCase` parameter applies only to the simple interface name, not to the namespace.</span></span> <span data-ttu-id="95a33-1171">Часть `name`, указывающая пространство имен, должна иметь правильный регистр, иначе интерфейс не будет найден.</span><span class="sxs-lookup"><span data-stu-id="95a33-1171">The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found.</span></span> <span data-ttu-id="95a33-1172">Например, строка "System. IComparable" находит интерфейс <xref:System.IComparable>, но строка "System. IComparable" не имеет.</span><span class="sxs-lookup"><span data-stu-id="95a33-1172">For example, the string "System.icomparable" finds the <xref:System.IComparable> interface, but the string "system.icomparable" does not.</span></span>  
  
 <span data-ttu-id="95a33-1173">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Type> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1173">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1174">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет ограничения интерфейса и все интерфейсы, унаследованные от ограничений класса или интерфейса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1174">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1175">Для универсальных интерфейсов параметр `name` — это искаженное имя, заканчивающееся на знак ударения (\`) и число параметров типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1175">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="95a33-1176">Это справедливо и для определений универсальных интерфейсов, и для сконструированных универсальных интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1176">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="95a33-1177">Например, чтобы найти `IExample<T>` (`IExample(Of T)` в Visual Basic) или `IExample<string>` (`IExample(Of String)` в Visual Basic), выполните поиск по `"IExample`1 "".</span><span class="sxs-lookup"><span data-stu-id="95a33-1177">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `"IExample`1"\`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1178">В следующем примере кода используется метод <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> для выполнения поиска <xref:System.Collections.Hashtable> класса для <xref:System.Collections.IEnumerable> интерфейса без учета регистра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1178">The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="95a33-1179">В примере кода также демонстрируется перегрузка метода <xref:System.Type.GetInterface%28System.String%29> и метод <xref:System.Type.GetInterfaceMap%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1179">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1180">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1180"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-1181">Текущий <see cref="T:System.Type" /> представляет тип, реализующий тот же универсальный интерфейс с другими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1181">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="95a33-1182">Тип интерфейса, для которого требуется извлечь сопоставление.</span><span class="sxs-lookup"><span data-stu-id="95a33-1182">The interface type to retrieve a mapping for.</span></span></param>
        <summary><span data-ttu-id="95a33-1183">Возвращает сопоставление для интерфейса заданного типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1183">Returns an interface mapping for the specified interface type.</span></span></summary>
        <returns><span data-ttu-id="95a33-1184">Объект, представляющий сопоставление интерфейса для <paramref name="interfaceType" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1184">An object that represents the interface mapping for <paramref name="interfaceType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1185">Карта интерфейса определяет, как интерфейс сопоставляется с фактическими элементами класса, реализующего этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="95a33-1185">The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</span></span>  
  
 <span data-ttu-id="95a33-1186">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, параметры типа заменяются соответствующими аргументами типа в элементах <xref:System.Reflection.InterfaceMapping>, возвращаемых этим методом.</span><span class="sxs-lookup"><span data-stu-id="95a33-1186">If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1187">В следующем примере вызывается метод <xref:System.Type.GetInterfaceMap%2A>, чтобы определить, как интерфейс <xref:System.IFormatProvider> сопоставляется с <xref:System.Globalization.CultureInfo> методами, и как интерфейс <xref:System.IAppDomainSetup> сопоставляется с <xref:System.AppDomainSetup> свойствами.</span><span class="sxs-lookup"><span data-stu-id="95a33-1187">The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties.</span></span> <span data-ttu-id="95a33-1188">Обратите внимание, что, поскольку интерфейс <xref:System.IAppDomainSetup> определяет набор свойств, возвращаемый <xref:System.Reflection.InterfaceMapping> объект содержит отдельные объекты <xref:System.Reflection.MethodInfo> для методов доступа get и Set свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-1188">Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.</span></span>  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-1189">Тип <paramref name="interfaceType" /> не реализован с помощью текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1189"><paramref name="interfaceType" /> is not implemented by the current type.</span></span>  
  
<span data-ttu-id="95a33-1190">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1190">-or-</span></span> 
<span data-ttu-id="95a33-1191">Аргумент <paramref name="interfaceType" /> не ссылается на интерфейс.</span><span class="sxs-lookup"><span data-stu-id="95a33-1191">The <paramref name="interfaceType" /> argument does not refer to an interface.</span></span>  
  
<span data-ttu-id="95a33-1192">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1192">-or-</span></span>

<span data-ttu-id="95a33-1193">Текущий экземпляр или аргумент <paramref name="interfaceType" /> является открытым универсальным типом (то есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />).</span><span class="sxs-lookup"><span data-stu-id="95a33-1193">The current instance or <paramref name="interfaceType" /> argument is an open generic type; that is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span>

<span data-ttu-id="95a33-1194">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1194">-or-</span></span>


 <span data-ttu-id="95a33-1195"><paramref name="interfaceType" /> является универсальным интерфейсом, а текущий тип является типом массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-1195"><paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1196">Свойство <paramref name="interfaceType" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1196"><paramref name="interfaceType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="95a33-1197">Текущий тип <see cref="T:System.Type" /> представляет параметр универсального типа, то есть <see cref="P:System.Type.IsGenericParameter" /> имеет значение <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1197">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-1198">Вызванный метод не поддерживается в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1198">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="95a33-1199">Реализацию должны обеспечивать производные классы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1199">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-1200">При переопределении в производном классе возвращает все интерфейсы, реализуемые или наследуемые текущим объектом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1200">When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-1201">Массив объектов <see cref="T:System.Type" /> , представляющий все интерфейсы, реализуемые или наследуемые текущим типом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1201">An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="95a33-1202">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1202">-or-</span></span> 
<span data-ttu-id="95a33-1203">Пустой массив типа <see cref="T:System.Type" /> в случае отсутствия интерфейсов, реализуемых или наследуемых текущим типом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1203">An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1204">Метод <xref:System.Type.GetInterfaces%2A> не возвращает интерфейсы в определенном порядке, таком как алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1204">The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1205">Код не должен зависеть от порядка, в котором возвращаются интерфейсы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1205">Your code must not depend on the order in which interfaces are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-1206">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Type> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1206">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1207">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет ограничения интерфейса и все интерфейсы, унаследованные от ограничений класса или интерфейса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1207">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1208">В следующем примере показано получение типа указанного класса и отображение всех интерфейсов, которые реализует или наследует тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-1208">The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</span></span> <span data-ttu-id="95a33-1209">Чтобы скомпилировать пример Visual Basic, используйте следующие команды компилятора:</span><span class="sxs-lookup"><span data-stu-id="95a33-1209">To compile the Visual Basic example, use the following compiler commands:</span></span>  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="95a33-1210">Статический инициализатор вызывается и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-1210">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-1211">Возвращает указанные члены текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1211">Gets the specified members of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1212">Строка, содержащая имя искомых открытых членов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1212">The string containing the name of the public members to get.</span></span></param>
        <summary><span data-ttu-id="95a33-1213">Выполняет поиск открытого члена с заданным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-1213">Searches for the public members with the specified name.</span></span></summary>
        <returns><span data-ttu-id="95a33-1214">Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий открытые члены с заданным именем, если такие члены есть, и пустой массив, если таких членов нет.</span><span class="sxs-lookup"><span data-stu-id="95a33-1214">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1215">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-1215">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="95a33-1216">Поиск включает открытые статические и открытые члены экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1216">The search includes public static and public instance members.</span></span>  
  
 <span data-ttu-id="95a33-1217">Элементы включают свойства, методы, поля, события и т. д.</span><span class="sxs-lookup"><span data-stu-id="95a33-1217">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="95a33-1218">Метод <xref:System.Type.GetMember%2A> не возвращает элементы в определенном порядке, например алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1218">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1219">Код не должен зависеть от порядка, в котором возвращаются элементы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1219">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-1220">Эта перегрузка метода не находит инициализаторы классов (статический конструктор).</span><span class="sxs-lookup"><span data-stu-id="95a33-1220">This method overload will not find class initializers (static constructor).</span></span> <span data-ttu-id="95a33-1221">Чтобы найти инициализаторы классов, используйте перегрузку, которая принимает <xref:System.Reflection.BindingFlags>, и &#124; укажите <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-1221">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="95a33-1222">Инициализатор класса также можно получить с помощью свойства <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1222">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="95a33-1223">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1223">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-1224">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-1224">Member Type</span></span>|<span data-ttu-id="95a33-1225">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-1225">Static</span></span>|<span data-ttu-id="95a33-1226">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-1226">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-1227">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-1227">Constructor</span></span>|<span data-ttu-id="95a33-1228">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1228">No</span></span>|<span data-ttu-id="95a33-1229">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1229">No</span></span>|  
|<span data-ttu-id="95a33-1230">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-1230">Field</span></span>|<span data-ttu-id="95a33-1231">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1231">No</span></span>|<span data-ttu-id="95a33-1232">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1232">Yes.</span></span> <span data-ttu-id="95a33-1233">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1233">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1234">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-1234">Event</span></span>|<span data-ttu-id="95a33-1235">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1235">Not applicable</span></span>|<span data-ttu-id="95a33-1236">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1236">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1237">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1237">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1238">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1238">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-1239">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-1239">Method</span></span>|<span data-ttu-id="95a33-1240">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1240">No</span></span>|<span data-ttu-id="95a33-1241">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1241">Yes.</span></span> <span data-ttu-id="95a33-1242">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1242">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1243">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-1243">Nested Type</span></span>|<span data-ttu-id="95a33-1244">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1244">No</span></span>|<span data-ttu-id="95a33-1245">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1245">No</span></span>|  
|<span data-ttu-id="95a33-1246">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1246">Property</span></span>|<span data-ttu-id="95a33-1247">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1247">Not applicable</span></span>|<span data-ttu-id="95a33-1248">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1248">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1249">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1249">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1250">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1250">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-1251">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-1251">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-1252">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-1252">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-1253">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1253">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1254">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1254">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-1255">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1255">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-1256">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1256">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1257">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <xref:System.Object>, если ограничение класса отсутствует.</span><span class="sxs-lookup"><span data-stu-id="95a33-1257">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1258">Для универсальных методов не включайте аргументы типа в `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1258">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="95a33-1259">Например, C# код `GetMember("MyMethod<int>")` выполняет поиск элемента с текстовым именем "`MyMethod<int>`", а не для метода с именем `MyMethod` с одним универсальным аргументом типа `int`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1259">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1260">В следующем примере отображаются все члены класса `String`, начинающиеся с буквы C.</span><span class="sxs-lookup"><span data-stu-id="95a33-1260">The following example displays all the members of the `String` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1261">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1261"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1262">Строка, содержащая имя для поиска элементов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1262">The string containing the name of the members to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-1263">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1263">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-1264">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1264">-or-</span></span> 
 <span data-ttu-id="95a33-1265"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-1265"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="95a33-1266">Выполняет поиск указанных членов, используя заданные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1266">Searches for the specified members, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-1267">Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий открытые члены с заданным именем, если такие члены есть, и пустой массив, если таких членов нет.</span><span class="sxs-lookup"><span data-stu-id="95a33-1267">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1268">Этот метод может быть переопределен производным классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-1268">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="95a33-1269">Элементы включают свойства, методы, поля, события и т. д.</span><span class="sxs-lookup"><span data-stu-id="95a33-1269">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="95a33-1270">Метод <xref:System.Type.GetMember%2A> не возвращает элементы в определенном порядке, например алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1270">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1271">Код не должен зависеть от порядка, в котором возвращаются элементы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1271">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-1272">Для определения элементов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1272">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-1273">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1273">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-1274">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые члены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1274">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1275">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск неоткрытые члены (т. е. частные, внутренние и защищенные члены).</span><span class="sxs-lookup"><span data-stu-id="95a33-1275">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1276">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1276">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="95a33-1277">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1277">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-1278">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1278">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-1279">`BindingFlags.DeclaredOnly` искать только члены, объявленные в <xref:System.Type>, а не члены, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1279">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-1280">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1280">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-1281">Чтобы получить инициализатор класса (статический конструктор) с помощью перегрузки этого метода, необходимо указать "статический конструктор" для `name`и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic) для `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1281">To get the class initializer (static constructor) using this method overload, you must specify "static constructor" for `name`, and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="95a33-1282">Инициализатор класса также можно получить с помощью свойства <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1282">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="95a33-1283">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1283">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1284">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <xref:System.Object>, если ограничение класса отсутствует.</span><span class="sxs-lookup"><span data-stu-id="95a33-1284">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1285">Для универсальных методов не включайте аргументы типа в `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1285">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="95a33-1286">Например, C# код `GetMember("MyMethod<int>")` выполняет поиск элемента с текстовым именем "`MyMethod<int>`", а не для метода с именем `MyMethod` с одним универсальным аргументом типа `int`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1286">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1287">В следующем примере отображаются все открытые статические члены класса `myString`, начинающиеся с буквы C.</span><span class="sxs-lookup"><span data-stu-id="95a33-1287">The following example displays all the public static members of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1288">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1288"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1289">Строка, содержащая имя для поиска элементов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1289">The string containing the name of the members to get.</span></span></param>
        <param name="type"><span data-ttu-id="95a33-1290">Значение, которое нужно найти.</span><span class="sxs-lookup"><span data-stu-id="95a33-1290">The value to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-1291">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1291">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-1292">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1292">-or-</span></span> 
 <span data-ttu-id="95a33-1293"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-1293"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="95a33-1294">Ищет указанные члены заданного типа, используя установленные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1294">Searches for the specified members of the specified member type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-1295">Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий открытые члены с заданным именем, если такие члены есть, и пустой массив, если таких членов нет.</span><span class="sxs-lookup"><span data-stu-id="95a33-1295">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1296">Элементы включают свойства, методы, поля, события и т. д.</span><span class="sxs-lookup"><span data-stu-id="95a33-1296">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="95a33-1297">Метод <xref:System.Type.GetMember%2A> не возвращает элементы в определенном порядке, например алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1297">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1298">Код не должен зависеть от порядка, в котором возвращаются элементы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1298">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-1299">Для определения элементов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1299">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-1300">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1300">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-1301">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые члены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1301">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1302">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск неоткрытые члены (т. е. частные, внутренние и защищенные члены).</span><span class="sxs-lookup"><span data-stu-id="95a33-1302">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1303">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1303">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="95a33-1304">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1304">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-1305">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1305">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-1306">`BindingFlags.DeclaredOnly` искать только члены, объявленные в <xref:System.Type>, а не члены, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1306">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-1307">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1307">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-1308">Чтобы получить инициализатор класса (статический конструктор) с помощью этой перегрузки метода, необходимо указать "статический конструктор" для `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> для `type`и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic) для `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1308">To get the class initializer (static constructor) using this method overload, you must specify "static constructor" for `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`, and  <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="95a33-1309">Инициализатор класса также можно получить с помощью свойства <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1309">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="95a33-1310">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1310">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1311">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <xref:System.Object>, если ограничение класса отсутствует.</span><span class="sxs-lookup"><span data-stu-id="95a33-1311">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1312">Для универсальных методов не включайте аргументы типа в `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1312">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="95a33-1313">Например, C# код `GetMember("MyMethod<int>")` выполняет поиск элемента с текстовым именем "`MyMethod<int>`", а не для метода с именем `MyMethod` с одним универсальным аргументом типа `int`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1313">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1314">В следующем примере отображаются все методы класса `myString`, начинающиеся с буквы C.</span><span class="sxs-lookup"><span data-stu-id="95a33-1314">The following example displays all the methods of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1315">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1315"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-1316">Реализацию должен обеспечивать производный класс.</span><span class="sxs-lookup"><span data-stu-id="95a33-1316">A derived class must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-1317">Получает члены (свойства, методы, поля, события и т. д.) текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1317">Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMembers() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-1318">Возвращает все открытые члены текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1318">Returns all the public members of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-1319">Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий все открытые члены текущего типа <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1319">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="95a33-1320">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1320">-or-</span></span> 
<span data-ttu-id="95a33-1321">Пустой массив типа <see cref="T:System.Reflection.MemberInfo" />, если у текущего типа <see cref="T:System.Type" /> нет открытых членов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1321">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="95a33-1322">К элементам относятся свойства, методы, конструкторы, поля, события и вложенные типы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1322">Members include properties, methods, constructors, fields, events, and nested types.</span></span>
  
 <span data-ttu-id="95a33-1323">Метод <xref:System.Type.GetMembers%2A> не возвращает элементы в определенном порядке, например алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1323">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1324">Код не должен зависеть от порядка, в котором возвращаются элементы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1324">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-1325">Эта перегрузка метода вызывает перегрузку метода <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> с <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="95a33-1325">This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="95a33-1326">Инициализаторы классов не будут найдены (статические конструкторы).</span><span class="sxs-lookup"><span data-stu-id="95a33-1326">It will not find class initializers (static constructors).</span></span> <span data-ttu-id="95a33-1327">Чтобы найти инициализаторы классов, вызовите перегрузку <xref:System.Type.GetMembers(System.Reflection.BindingFlags)> и укажите &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-1327">To find class initializers, call the <xref:System.Type.GetMembers(System.Reflection.BindingFlags)> overload, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="95a33-1328">Инициализатор класса также можно получить с помощью свойства <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1328">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="95a33-1329">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1329">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-1330">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-1330">Member Type</span></span>|<span data-ttu-id="95a33-1331">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-1331">Static</span></span>|<span data-ttu-id="95a33-1332">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-1332">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-1333">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-1333">Constructor</span></span>|<span data-ttu-id="95a33-1334">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1334">No</span></span>|<span data-ttu-id="95a33-1335">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1335">No</span></span>|  
|<span data-ttu-id="95a33-1336">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-1336">Field</span></span>|<span data-ttu-id="95a33-1337">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1337">No</span></span>|<span data-ttu-id="95a33-1338">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1338">Yes.</span></span> <span data-ttu-id="95a33-1339">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1339">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1340">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-1340">Event</span></span>|<span data-ttu-id="95a33-1341">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1341">Not applicable</span></span>|<span data-ttu-id="95a33-1342">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1342">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1343">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1343">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1344">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1344">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-1345">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-1345">Method</span></span>|<span data-ttu-id="95a33-1346">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1346">No</span></span>|<span data-ttu-id="95a33-1347">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1347">Yes.</span></span> <span data-ttu-id="95a33-1348">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1348">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1349">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-1349">Nested Type</span></span>|<span data-ttu-id="95a33-1350">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1350">No</span></span>|<span data-ttu-id="95a33-1351">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1351">No</span></span>|  
|<span data-ttu-id="95a33-1352">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1352">Property</span></span>|<span data-ttu-id="95a33-1353">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1353">Not applicable</span></span>|<span data-ttu-id="95a33-1354">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1354">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1355">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1355">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1356">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1356">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-1357">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-1357">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-1358">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-1358">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-1359">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1359">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1360">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1360">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-1361">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1361">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-1362">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.MemberInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1362">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1363">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <xref:System.Object>, если ограничение класса отсутствует.</span><span class="sxs-lookup"><span data-stu-id="95a33-1363">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span> 
  
## Examples  
 <span data-ttu-id="95a33-1364">В следующем примере кода показано, как использовать перегрузку метода <xref:System.Type.GetMembers> для получения сведений обо всех открытых членах указанного класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1364">The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="95a33-1365">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1365">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-1366">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1366">-or-</span></span> 
 <span data-ttu-id="95a33-1367"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-1367"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="95a33-1368">При переопределении в производном классе ищет члены, определенные для текущего объекта <see cref="T:System.Type" />, используя указанные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1368">When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-1369">Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий все члены, определенные для текущего типа <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1369">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="95a33-1370">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1370">-or-</span></span> 
<span data-ttu-id="95a33-1371">Пустой массив, если для текущего объекта <see cref="T:System.Type" /> не определены члены или ни один из определенных членов не удовлетворяет ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1371">An empty array if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="95a33-1372">К элементам относятся свойства, методы, конструкторы, поля, события и вложенные типы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1372">Members include properties, methods, constructors, fields, events, and nested types.</span></span>

<span data-ttu-id="95a33-1373">Чтобы перегрузить `GetMethods(BindingFlags)` для успешного получения сведений о методе, аргумент `bindingAttr` должен включать по крайней мере один из <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, а также хотя бы один из <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1373">For the `GetMethods(BindingFlags)` overload to successfully retrieve method information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95a33-1374">Единственное исключение — вызов метода с <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, который возвращает сведения об элементе о вложенных типах.</span><span class="sxs-lookup"><span data-stu-id="95a33-1374">The sole exception is a method call with <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, which returns member information about nested types.</span></span>

<span data-ttu-id="95a33-1375">Для определения элементов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1375">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span> 

- <span data-ttu-id="95a33-1376">Укажите `BindingFlags.Instance`, чтобы включить методы экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1376">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="95a33-1377">Укажите `BindingFlags.Static`, чтобы включить статические методы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1377">Specify `BindingFlags.Static` to include static methods.</span></span> 
  
- <span data-ttu-id="95a33-1378">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые методы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1378">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
- <span data-ttu-id="95a33-1379">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск неоткрытые методы (т. е. частные, внутренние и защищенные методы).</span><span class="sxs-lookup"><span data-stu-id="95a33-1379">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="95a33-1380">Возвращаются только защищенные и внутренние методы базовых классов. закрытые методы в базовых классах не возвращаются.</span><span class="sxs-lookup"><span data-stu-id="95a33-1380">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
- <span data-ttu-id="95a33-1381">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1381">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="95a33-1382">Укажите только `BindingFlags.Default`, чтобы вернуть пустой массив <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1382">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.MethodInfo> array.</span></span>

<span data-ttu-id="95a33-1383">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1383">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="95a33-1384">`BindingFlags.DeclaredOnly` искать только члены, объявленные в <xref:System.Type>, а не члены, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1384">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
<span data-ttu-id="95a33-1385">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1385">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  

<span data-ttu-id="95a33-1386">Метод <xref:System.Type.GetMembers%2A> не возвращает элементы в определенном порядке, например алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1386">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1387">Код не должен зависеть от порядка, в котором возвращаются элементы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1387">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  

 <span data-ttu-id="95a33-1388">Чтобы получить инициализатор класса (статический конструктор) с помощью этой перегрузки метода, необходимо указать &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-1388">To get the class initializer (static constructor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="95a33-1389">Инициализатор класса также можно получить с помощью свойства <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1389">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="95a33-1390">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.MemberInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1390">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1391">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <xref:System.Object>, если ограничение класса отсутствует.</span><span class="sxs-lookup"><span data-stu-id="95a33-1391">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  

## Examples  
 <span data-ttu-id="95a33-1392">В следующем примере кода показано, как использовать перегрузку метода <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> для получения сведений обо всех открытых членах экземпляра указанного класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1392">The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-1393">Получает заданный метод текущего класса <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1393">Gets a specific method of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1394">Строка, содержащая имя искомого открытого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1394">The string containing the name of the public method to get.</span></span></param>
        <summary><span data-ttu-id="95a33-1395">Выполняет поиск открытого метода с заданным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-1395">Searches for the public method with the specified name.</span></span></summary>
        <returns><span data-ttu-id="95a33-1396">Объект, представляющий открытый метод с заданным именем, если такой метод есть, и <see langword="null" />, если такого метода нет.</span><span class="sxs-lookup"><span data-stu-id="95a33-1396">An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1397">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-1397">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="95a33-1398">Поиск включает открытые статические и открытые методы экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1398">The search includes public static and public instance methods.</span></span>  
  
 <span data-ttu-id="95a33-1399">Если метод перегружен и имеет более одного открытого метода, метод <xref:System.Type.GetMethod%28System.String%29> выдает исключение <xref:System.Reflection.AmbiguousMatchException>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1399">If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="95a33-1400">В следующем примере создается исключение, поскольку существует более одной открытой перегрузки метода <xref:System.Int32.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1400">In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="95a33-1401">С другой стороны, поскольку метод `Person.ToString` переопределяет <xref:System.Object.ToString%2A?displayProperty=nameWithType> и, следовательно, не перегружен, метод <xref:System.Type.GetMethod%28System.String%29> может получить объект <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1401">On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=nameWithType> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 <span data-ttu-id="95a33-1402">Для получения конкретного метода можно выполнить одно из следующих действий.</span><span class="sxs-lookup"><span data-stu-id="95a33-1402">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="95a33-1403">Вызовите метод <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> и укажите `bindingAttr` аргумент, который однозначно идентифицирует метод.</span><span class="sxs-lookup"><span data-stu-id="95a33-1403">Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method.</span></span> <span data-ttu-id="95a33-1404">Например, если возникает исключение, так как тип имеет статическую и перегрузку экземпляра, можно указать `bindingAttr` аргумент <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1404">For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="95a33-1405">Вызовите перегрузку метода <xref:System.Type.GetMethod%2A>, который включает параметр `types`, который определяет типы параметров метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1405">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="95a33-1406">Вызовите метод <xref:System.Type.GetMethods>, чтобы получить массив, содержащий все открытые методы, принадлежащие типу.</span><span class="sxs-lookup"><span data-stu-id="95a33-1406">Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type.</span></span> <span data-ttu-id="95a33-1407">Затем можно выполнить итерацию для поиска повторяющихся методов с именем `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1407">You can then iterate it to identify the duplicate methods named `name`.</span></span>  
  
 <span data-ttu-id="95a33-1408">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1408">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1409">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object>, если отсутствует ограничение класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1409">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1410">Для универсальных методов не включайте аргументы типа в `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1410">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="95a33-1411">Например, C# код `GetMember("MyMethod<int>")` выполняет поиск элемента с текстовым именем "`MyMethod<int>`", а не для метода с именем `MyMethod` с одним универсальным аргументом типа `int`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1411">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1412">В следующем примере возвращается метод с именем `MethodA`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1412">The following example gets a method named `MethodA`.</span></span>  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-1413">Найдено несколько методов с указанным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-1413">More than one method is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1414"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1414"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1415">Строка, содержащая имя искомого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1415">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-1416">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1416">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-1417">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1417">-or-</span></span> 
 <span data-ttu-id="95a33-1418"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1418"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="95a33-1419">Выполняет поиск указанного метода, используя заданные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1419">Searches for the specified method, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-1420">Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1420">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1421">Для определения методов, которые следует включить в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1421">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-1422">Чтобы получить возвращаемое значение, необходимо указать либо <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, либо <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1422">You must specify either <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-1423">Укажите <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, чтобы включить в поиск открытые методы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1423">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1424">Укажите <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, чтобы включить в поиск неоткрытые методы (т. е. частные, внутренние и защищенные методы).</span><span class="sxs-lookup"><span data-stu-id="95a33-1424">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1425">Укажите <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType>, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1425">Specify <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="95a33-1426">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1426">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-1427"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType>, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1427"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-1428"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> искать только методы, объявленные в <xref:System.Type>, а не методы, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1428"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-1429">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1429">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-1430">Если метод перегружен и несколько перегрузок соответствуют ограничениям, заданным аргументом `bindingAttr`, метод создает исключение <xref:System.Reflection.AmbiguousMatchException>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1430">If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="95a33-1431">В следующем примере создается исключение, поскольку:</span><span class="sxs-lookup"><span data-stu-id="95a33-1431">In the following example, an exception is thrown because:</span></span>  
  
-   <span data-ttu-id="95a33-1432">Тип `TestClass` имеет два открытых перегруженных экземпляра метода `DisplayValue`, `DisplayValue(String)` и `DisplayValue(String, Object[])`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1432">The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.</span></span>  
  
-   <span data-ttu-id="95a33-1433">Тип `TestClass` имеет два открытых перегруженных экземпляра метода `Equals`, один из которых наследуется от <xref:System.Object>: `Equals(TestClass)` и `Equals(Object)`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1433">The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 <span data-ttu-id="95a33-1434">Для получения конкретного метода можно выполнить одно из следующих действий.</span><span class="sxs-lookup"><span data-stu-id="95a33-1434">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="95a33-1435">Измените ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1435">Change the binding constraints.</span></span> <span data-ttu-id="95a33-1436">В предыдущем примере попытка получить открытый экземпляр `Equals` метод, объявленный типом и не наследуемый, успешно получает `Equals(TestClass)`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1436">In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.</span></span>  
  
-   <span data-ttu-id="95a33-1437">Вызовите перегрузку метода <xref:System.Type.GetMethod%2A>, который включает параметр `types`, который определяет типы параметров метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1437">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="95a33-1438">Вызовите метод <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29>, чтобы получить массив, содержащий все методы, принадлежащие типу, имеющему указанные атрибуты привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1438">Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</span></span> <span data-ttu-id="95a33-1439">Затем можно выполнить итерацию для поиска повторяющихся методов с именем `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1439">You can then iterate it to identify the duplicate methods named `name`.</span></span> <span data-ttu-id="95a33-1440">Этот подход показан в обработчике предыдущего примера для исключения <xref:System.Reflection.AmbiguousMatchException>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1440">This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.</span></span>  
  
 <span data-ttu-id="95a33-1441">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1441">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1442">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object>, если отсутствует ограничение класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1442">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1443">Для универсальных методов не включайте аргументы типа в `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1443">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="95a33-1444">Например, C# код `GetMember("MyMethod<int>")` выполняет поиск элемента с текстовым именем "`MyMethod<int>`", а не для метода с именем `MyMethod` с одним универсальным аргументом типа `int`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1444">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1445">В следующем примере возвращается метод, соответствующий указанным флагам привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1445">The following example gets the method that matches the specified binding flags.</span></span>  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-1446">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1446">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1447">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1447"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1448">Строка, содержащая имя искомого открытого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1448">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-1449">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1449">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="95a33-1450">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1450">-or-</span></span> 
<span data-ttu-id="95a33-1451">Пустой массив объектов <see cref="T:System.Type" /> (в соответствии со значением поля <see cref="F:System.Type.EmptyTypes" />) для получения метода, не принимающего параметры.</span><span class="sxs-lookup"><span data-stu-id="95a33-1451">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <summary><span data-ttu-id="95a33-1452">Ищет указанный открытый метод, параметры которого соответствуют заданным типам аргументов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1452">Searches for the specified public method whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="95a33-1453">Объект, представляющий открытый метод, параметры которого соответствуют указанным типам аргументов, если они существуют, и <see langword="null" />, если их нет.</span><span class="sxs-lookup"><span data-stu-id="95a33-1453">An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1454">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-1454">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="95a33-1455">Поиск включает открытые статические и открытые методы экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1455">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1456">Нельзя опустить параметры при поиске конструкторов и методов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1456">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="95a33-1457">При вызове можно опустить только параметры.</span><span class="sxs-lookup"><span data-stu-id="95a33-1457">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="95a33-1458">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1458">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1459">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object>, если отсутствует ограничение класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1459">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1460">Параметр `name` не может содержать аргументы типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1460">The `name` parameter cannot include type arguments.</span></span> <span data-ttu-id="95a33-1461">Например, C# код `GetMethod("MyGenericMethod<int>")` выполняет поиск метода с текстовым именем "`MyGenericMethod<int>`", а не для метода с именем `MyGenericMethod` с одним универсальным аргументом типа `int`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1461">For example, the C# code `GetMethod("MyGenericMethod<int>")` searches for a method with the text name "`MyGenericMethod<int>`", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="95a33-1462">Вместо этого используйте `GetMethod("MyGenericMethod")` с соответствующим параметром в массиве `types`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1462">Instead, use `GetMethod("MyGenericMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1463">В следующем примере выполняется поиск конкретных перегрузок `MethodA`с указанием различных типов аргументов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1463">The following example finds specific overloads of `MethodA`, specifying a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1464">В [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] примере требуется параметр компилятора `/unsafe`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1464">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <span data-ttu-id="95a33-1465">В следующем примере извлекаются <xref:System.Reflection.MethodInfo> объекты, представляющие методы `Add` неуниверсального типа (класс <xref:System.Collections.ArrayList>), Открытый универсальный тип (класс <xref:System.Collections.Generic.List%601>) и закрытый универсальный тип (тип `List(Of String)`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1465">The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 <span data-ttu-id="95a33-1466">В примере определяется метод `GetAddMethod`, который извлекает соответствующий объект <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1466">The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object.</span></span> <span data-ttu-id="95a33-1467">Чтобы предоставить аргумент `types` для открытого универсального типа, он вызывает метод <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1467">To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="95a33-1468">Чтобы предоставить аргумент `types` для закрытого универсального типа, он получает значение свойства <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1468">To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-1469">Найдено несколько методов с указанным именем и заданными параметрами.</span><span class="sxs-lookup"><span data-stu-id="95a33-1469">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1470"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1470"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-1471">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1471">-or-</span></span> 
 <span data-ttu-id="95a33-1472">Свойство <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1472"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-1473">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1473">-or-</span></span> 
<span data-ttu-id="95a33-1474">Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1474">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-1475">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1475"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1476">Строка, содержащая имя искомого открытого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1476">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-1477">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1477">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="95a33-1478">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1478">-or-</span></span> 
<span data-ttu-id="95a33-1479">Пустой массив объектов <see cref="T:System.Type" /> (в соответствии со значением поля <see cref="F:System.Type.EmptyTypes" />) для получения метода, не принимающего параметры.</span><span class="sxs-lookup"><span data-stu-id="95a33-1479">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="95a33-1480">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1480">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="95a33-1481">Используется только при вызове посредством COM-взаимодействия. При этом обрабатываются только параметры, переданные по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-1481">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="95a33-1482">Связыватель по умолчанию не обрабатывает этот параметр.</span><span class="sxs-lookup"><span data-stu-id="95a33-1482">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="95a33-1483">Выполняет поиск указанного открытого метода, параметры которого соответствуют указанным типам аргументов и модификаторам.</span><span class="sxs-lookup"><span data-stu-id="95a33-1483">Searches for the specified public method whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="95a33-1484">Если поиск выполнен успешно, возвращается объект, представляющий открытый метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1484">An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1485">Хотя связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> (параметр `modifiers`), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательского связывателя, который обрабатывает `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1485">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="95a33-1486">`ParameterModifier` используется только при вызове через COM-взаимодействие, и обрабатываются только параметры, передаваемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-1486">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="95a33-1487">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-1487">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="95a33-1488">Поиск включает открытые статические и открытые методы экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1488">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1489">Нельзя опустить параметры при поиске конструкторов и методов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1489">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="95a33-1490">При вызове можно опустить только параметры.</span><span class="sxs-lookup"><span data-stu-id="95a33-1490">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="95a33-1491">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1491">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1492">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object>, если отсутствует ограничение класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1492">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1493">Для универсальных методов не включайте аргументы типа в `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1493">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="95a33-1494">Например, C# код `GetMethod("MyMethod<int>")` выполняет поиск элемента с текстовым именем "`MyMethod<int>`", а не для метода с именем `MyMethod` с одним универсальным аргументом типа `int`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1494">For example, the C# code `GetMethod("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="95a33-1495">Вместо этого используйте `GetMethod("MyMethod")` с соответствующим параметром в массиве `types`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1495">Instead, use `GetMethod("MyMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-1496">Найдено несколько методов с указанным именем и заданными параметрами.</span><span class="sxs-lookup"><span data-stu-id="95a33-1496">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1497">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1497"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-1498">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1498">-or-</span></span> 
 <span data-ttu-id="95a33-1499">Свойство <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1499"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-1500">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1500">-or-</span></span> 
<span data-ttu-id="95a33-1501">Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1501">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-1502">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1502"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-1503">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1503">-or-</span></span> 
 <span data-ttu-id="95a33-1504">Массив <paramref name="modifiers" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1504"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1505">Строка, содержащая имя искомого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1505">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-1506">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1506">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-1507">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1507">-or-</span></span> 
 <span data-ttu-id="95a33-1508"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1508"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="95a33-1509">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-1509">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="95a33-1510">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1510">-or-</span></span> 
<span data-ttu-id="95a33-1511">Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1511">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-1512">Массив объектов <see cref="T:System.Type" /> , предоставляющий число, порядок и тип параметров искомого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1512">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="95a33-1513">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1513">-or-</span></span> 
<span data-ttu-id="95a33-1514">Пустой массив объектов <see cref="T:System.Type" /> (в соответствии со значением поля <see cref="F:System.Type.EmptyTypes" />) для получения метода, не принимающего параметры.</span><span class="sxs-lookup"><span data-stu-id="95a33-1514">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="95a33-1515">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1515">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="95a33-1516">Используется только при вызове посредством COM-взаимодействия. При этом обрабатываются только параметры, переданные по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-1516">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="95a33-1517">Связыватель по умолчанию не обрабатывает этот параметр.</span><span class="sxs-lookup"><span data-stu-id="95a33-1517">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="95a33-1518">Ищет заданный метод, параметры которого соответствуют указанным типам аргументов и модификаторам, используя установленные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1518">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-1519">Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1519">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1520">Хотя связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> (параметр `modifiers`), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательского связывателя, который обрабатывает `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1520">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="95a33-1521">`ParameterModifier` используется только при вызове через COM-взаимодействие, и обрабатываются только параметры, передаваемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-1521">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="95a33-1522">Для определения методов, которые следует включить в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1522">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-1523">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1523">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-1524">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые методы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1524">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1525">Укажите `BindingFlags.NonPublic`, чтобы в поиск включались неоткрытые методы (т. е. частные, внутренние и защищенные методы).</span><span class="sxs-lookup"><span data-stu-id="95a33-1525">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1526">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1526">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="95a33-1527">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1527">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-1528">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1528">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-1529">`BindingFlags.DeclaredOnly` искать только методы, объявленные в <xref:System.Type>, а не методы, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1529">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-1530">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1530">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1531">Нельзя опустить параметры при поиске конструкторов и методов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1531">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="95a33-1532">При вызове можно опустить только параметры.</span><span class="sxs-lookup"><span data-stu-id="95a33-1532">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="95a33-1533">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1533">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1534">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object>, если отсутствует ограничение класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1534">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1535">Для универсальных методов не включайте аргументы типа в `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1535">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="95a33-1536">Например, C# код `GetMember("MyMethod<int>")` выполняет поиск элемента с текстовым именем "`MyMethod<int>`", а не для метода с именем `MyMethod` с одним универсальным аргументом типа `int`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1536">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1537">В следующем примере обнаруживаются определенные перегрузки `MethodA`, задающие ограничения привязки и различные типы аргументов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1537">The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1538">В [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] примере требуется параметр компилятора `/unsafe`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1538">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-1539">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1539">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1540">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1540"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-1541">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1541">-or-</span></span> 
 <span data-ttu-id="95a33-1542"><paramref name="types" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1542"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-1543">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1543">-or-</span></span> 
<span data-ttu-id="95a33-1544">Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1544">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-1545">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1545"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-1546">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1546">-or-</span></span> 
 <span data-ttu-id="95a33-1547">Массив <paramref name="modifiers" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1547"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1548">Строка, содержащая имя искомого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1548">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-1549">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1549">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-1550">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1550">-or-</span></span> 
 <span data-ttu-id="95a33-1551"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1551"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="95a33-1552">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-1552">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="95a33-1553">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1553">-or-</span></span> 
<span data-ttu-id="95a33-1554">Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1554">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="95a33-1555">Объект, определяющий набор применяемых правил, касающихся порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и способа очистки стека.</span><span class="sxs-lookup"><span data-stu-id="95a33-1555">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-1556">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1556">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="95a33-1557">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1557">-or-</span></span> 
<span data-ttu-id="95a33-1558">Пустой массив объектов <see cref="T:System.Type" /> (в соответствии со значением поля <see cref="F:System.Type.EmptyTypes" />) для получения метода, не принимающего параметры.</span><span class="sxs-lookup"><span data-stu-id="95a33-1558">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="95a33-1559">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1559">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="95a33-1560">Используется только при вызове посредством COM-взаимодействия. При этом обрабатываются только параметры, переданные по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-1560">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="95a33-1561">Связыватель по умолчанию не обрабатывает этот параметр.</span><span class="sxs-lookup"><span data-stu-id="95a33-1561">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="95a33-1562">Ищет метод с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений привязки и соглашений о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-1562">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="95a33-1563">Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1563">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1564">Хотя связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> (параметр `modifiers`), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательского связывателя, который обрабатывает `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1564">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="95a33-1565">`ParameterModifier` используется только при вызове через COM-взаимодействие, и обрабатываются только параметры, передаваемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-1565">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="95a33-1566">В следующей таблице показаны элементы базового класса, возвращаемые методами `GetXXX` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1566">The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-1567">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-1567">Member Type</span></span>|<span data-ttu-id="95a33-1568">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-1568">Static</span></span>|<span data-ttu-id="95a33-1569">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-1569">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-1570">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-1570">Constructor</span></span>|<span data-ttu-id="95a33-1571">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1571">No</span></span>|<span data-ttu-id="95a33-1572">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1572">No</span></span>|  
|<span data-ttu-id="95a33-1573">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-1573">Field</span></span>|<span data-ttu-id="95a33-1574">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1574">No</span></span>|<span data-ttu-id="95a33-1575">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1575">Yes.</span></span> <span data-ttu-id="95a33-1576">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1576">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1577">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-1577">Event</span></span>|<span data-ttu-id="95a33-1578">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1578">Not applicable</span></span>|<span data-ttu-id="95a33-1579">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1579">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1580">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1580">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1581">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1581">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-1582">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-1582">Method</span></span>|<span data-ttu-id="95a33-1583">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1583">No</span></span>|<span data-ttu-id="95a33-1584">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1584">Yes.</span></span> <span data-ttu-id="95a33-1585">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1585">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1586">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-1586">Nested Type</span></span>|<span data-ttu-id="95a33-1587">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1587">No</span></span>|<span data-ttu-id="95a33-1588">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1588">No</span></span>|  
|<span data-ttu-id="95a33-1589">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1589">Property</span></span>|<span data-ttu-id="95a33-1590">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1590">Not applicable</span></span>|<span data-ttu-id="95a33-1591">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1591">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1592">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1592">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1593">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1593">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-1594">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-1594">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-1595">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-1595">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-1596">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1596">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1597">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1597">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-1598">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1598">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-1599">Для определения методов, которые следует включить в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1599">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-1600">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1600">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-1601">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые методы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1601">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1602">Укажите `BindingFlags.NonPublic`, чтобы в поиск включались неоткрытые методы (т. е. частные, внутренние и защищенные методы).</span><span class="sxs-lookup"><span data-stu-id="95a33-1602">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1603">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1603">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="95a33-1604">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1604">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-1605">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1605">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-1606">`BindingFlags.DeclaredOnly` искать только методы, объявленные в <xref:System.Type>, а не методы, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1606">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-1607">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1607">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1608">Нельзя опустить параметры при поиске конструкторов и методов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1608">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="95a33-1609">При вызове можно опустить только параметры.</span><span class="sxs-lookup"><span data-stu-id="95a33-1609">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="95a33-1610">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1610">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1611">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object>, если отсутствует ограничение класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1611">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1612">Для универсальных методов не включайте аргументы типа в `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1612">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="95a33-1613">Например, C# код `GetMember("MyMethod<int>")` выполняет поиск элемента с текстовым именем "`MyMethod<int>`", а не для метода с именем `MyMethod` с одним универсальным аргументом типа `int`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1613">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1614">В следующем примере обнаруживаются определенные перегрузки `MethodA`, указываются ограничения привязки, соглашения о вызовах и различные типы аргументов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1614">The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1615">В [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] примере требуется параметр компилятора `/unsafe`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1615">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-1616">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1616">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1617"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1617"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-1618">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1618">-or-</span></span> 
 <span data-ttu-id="95a33-1619">Свойство <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1619"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-1620">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1620">-or-</span></span> 
<span data-ttu-id="95a33-1621">Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1621">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-1622">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1622"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-1623">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1623">-or-</span></span> 
 <span data-ttu-id="95a33-1624">Массив <paramref name="modifiers" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1624"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1625">Строка, содержащая имя искомого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1625">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-1626">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1626">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-1627">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1627">-or-</span></span> 
 <span data-ttu-id="95a33-1628"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1628"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="95a33-1629">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-1629">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="95a33-1630">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1630">-or-</span></span> 
<span data-ttu-id="95a33-1631">Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1631">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="95a33-1632">Объект, который задает набор правил, используемых в зависимости от порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и процесса очистки стека.</span><span class="sxs-lookup"><span data-stu-id="95a33-1632">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-1633">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-1633">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="95a33-1634">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1634">-or-</span></span> 
<span data-ttu-id="95a33-1635">Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить метод, который не имеет параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-1635">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span></span>  
  
<span data-ttu-id="95a33-1636">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1636">-or-</span></span> 
 <span data-ttu-id="95a33-1637"><see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1637"><see langword="null" />.</span></span> <span data-ttu-id="95a33-1638">Если значение параметра <paramref name="types" /> равно <see langword="null" />, аргументы метода не проверяются на соответствие условиям.</span><span class="sxs-lookup"><span data-stu-id="95a33-1638">If <paramref name="types" /> is <see langword="null" />, arguments are not matched.</span></span></param>
        <param name="modifiers"><span data-ttu-id="95a33-1639">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1639">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="95a33-1640">Связыватель по умолчанию не обрабатывает этот параметр.</span><span class="sxs-lookup"><span data-stu-id="95a33-1640">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="95a33-1641">При переопределении в производном классе ищет указанный метод, параметры которого соответствуют указанным типам аргументов и модификаторам, используя для этого заданные ограничения привязки и соглашение о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-1641">When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="95a33-1642">Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1642">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1643">Хотя связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> (параметр `modifiers`), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательского связывателя, который обрабатывает `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1643">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="95a33-1644">`ParameterModifier` используется только при вызове через COM-взаимодействие, и обрабатываются только параметры, передаваемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-1644">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="95a33-1645">Если значение параметра `types` равно `null`, аргументы метода не проверяются на соответствие условиям.</span><span class="sxs-lookup"><span data-stu-id="95a33-1645">If `types` is `null`, arguments are not matched.</span></span>  
  
 <span data-ttu-id="95a33-1646">Для определения методов, которые следует включить в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1646">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-1647">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1647">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-1648">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые методы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1648">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1649">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск неоткрытые методы (т. е. частные, внутренние и защищенные методы).</span><span class="sxs-lookup"><span data-stu-id="95a33-1649">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1650">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1650">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="95a33-1651">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1651">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-1652">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1652">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-1653">`BindingFlags.DeclaredOnly` искать только методы, объявленные в <xref:System.Type>, а не методы, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1653">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-1654">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1654">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-1655">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1655">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1656">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1656"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-1657">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1657"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-1658">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1658">-or-</span></span> 
 <span data-ttu-id="95a33-1659">Массив <paramref name="modifiers" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1659"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-1660">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1660">-or-</span></span> 
 <span data-ttu-id="95a33-1661"><paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</span><span class="sxs-lookup"><span data-stu-id="95a33-1661"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-1662">Текущий тип — <see cref="T:System.Reflection.Emit.TypeBuilder" /> или <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1662">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-1663">Возвращает методы текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1663">Gets the methods of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-1664">Возвращает все открытые методы текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1664">Returns all the public methods of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-1665">Массив объектов <see cref="T:System.Reflection.MethodInfo" />, представляющий все открытые методы, определенные для текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1665">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="95a33-1666">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1666">-or-</span></span> 
<span data-ttu-id="95a33-1667">Пустой массив типа <see cref="T:System.Reflection.MethodInfo" />, если для текущего типа <see cref="T:System.Type" /> открытые методы не определены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1667">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="95a33-1668">Метод <xref:System.Type.GetMethods%2A> не возвращает методы в определенном порядке, таком как алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1668">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1669">Код не должен зависеть от порядка, в котором возвращаются методы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1669">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-1670">Конструкторы не включаются в массив методов, возвращаемых этим вызовом.</span><span class="sxs-lookup"><span data-stu-id="95a33-1670">Constructors are not included in the array of methods returned by this call.</span></span> <span data-ttu-id="95a33-1671">Выполните отдельный вызов `GetConstructors()`, чтобы получить методы конструктора.</span><span class="sxs-lookup"><span data-stu-id="95a33-1671">Make a separate call to `GetConstructors()` to get the constructor methods.</span></span>  
  
 <span data-ttu-id="95a33-1672">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1672">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-1673">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-1673">Member Type</span></span>|<span data-ttu-id="95a33-1674">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-1674">Static</span></span>|<span data-ttu-id="95a33-1675">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-1675">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-1676">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-1676">Constructor</span></span>|<span data-ttu-id="95a33-1677">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1677">No</span></span>|<span data-ttu-id="95a33-1678">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1678">No</span></span>|  
|<span data-ttu-id="95a33-1679">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-1679">Field</span></span>|<span data-ttu-id="95a33-1680">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1680">No</span></span>|<span data-ttu-id="95a33-1681">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1681">Yes.</span></span> <span data-ttu-id="95a33-1682">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1682">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1683">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-1683">Event</span></span>|<span data-ttu-id="95a33-1684">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1684">Not applicable</span></span>|<span data-ttu-id="95a33-1685">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1685">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1686">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1686">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1687">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1687">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-1688">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-1688">Method</span></span>|<span data-ttu-id="95a33-1689">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1689">No</span></span>|<span data-ttu-id="95a33-1690">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1690">Yes.</span></span> <span data-ttu-id="95a33-1691">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1691">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1692">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-1692">Nested Type</span></span>|<span data-ttu-id="95a33-1693">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1693">No</span></span>|<span data-ttu-id="95a33-1694">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1694">No</span></span>|  
|<span data-ttu-id="95a33-1695">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1695">Property</span></span>|<span data-ttu-id="95a33-1696">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1696">Not applicable</span></span>|<span data-ttu-id="95a33-1697">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1697">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1698">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1698">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1699">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1699">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-1700">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-1700">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-1701">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-1701">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-1702">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1702">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1703">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1703">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-1704">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1704">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1705">Нельзя опустить параметры при поиске конструкторов и методов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1705">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="95a33-1706">При вызове можно опустить только параметры.</span><span class="sxs-lookup"><span data-stu-id="95a33-1706">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="95a33-1707">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.MethodInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1707">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1708">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object>, если отсутствует ограничение класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1708">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="95a33-1709">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1709">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="95a33-1710">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1710">-or-</span></span>

 <span data-ttu-id="95a33-1711"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-1711"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="95a33-1712">При переопределении в производном классе ищет методы, определенные для текущего объекта <see cref="T:System.Type" />, используя указанные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1712">When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-1713">Массив объектов <see cref="T:System.Reflection.MethodInfo" />, представляющий все методы, определенные для текущего типа <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1713">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="95a33-1714">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1714">-or-</span></span> 
<span data-ttu-id="95a33-1715">Пустой массив типа <see cref="T:System.Reflection.MethodInfo" />, если для текущего объекта <see cref="T:System.Type" /> не определены методы или ни один из определенных методов не удовлетворяет ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1715">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="95a33-1716">Чтобы перегрузить `GetMethods(BindingFlags)` для успешного получения сведений о методе, аргумент `bindingAttr` должен включать по крайней мере один из <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, а также хотя бы один из <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1716">For the `GetMethods(BindingFlags)` overload to successfully retrieve method information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 
  
 <span data-ttu-id="95a33-1717">Для определения методов, которые следует включить в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1717">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
- <span data-ttu-id="95a33-1718">Укажите `BindingFlags.Instance`, чтобы включить методы экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1718">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="95a33-1719">Укажите `BindingFlags.Static`, чтобы включить статические методы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1719">Specify `BindingFlags.Static` to include static methods.</span></span> 
  
- <span data-ttu-id="95a33-1720">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые методы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1720">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
- <span data-ttu-id="95a33-1721">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск неоткрытые методы (т. е. частные, внутренние и защищенные методы).</span><span class="sxs-lookup"><span data-stu-id="95a33-1721">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="95a33-1722">Возвращаются только защищенные и внутренние методы базовых классов. закрытые методы в базовых классах не возвращаются.</span><span class="sxs-lookup"><span data-stu-id="95a33-1722">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
- <span data-ttu-id="95a33-1723">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1723">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="95a33-1724">Укажите только `BindingFlags.Default`, чтобы вернуть пустой массив <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1724">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.MethodInfo> array.</span></span>
  
 <span data-ttu-id="95a33-1725">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1725">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="95a33-1726">`BindingFlags.DeclaredOnly` искать только методы, объявленные в <xref:System.Type>, а не методы, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1726">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-1727">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1727">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  

<span data-ttu-id="95a33-1728">Метод <xref:System.Type.GetMethods%2A> не возвращает методы в определенном порядке, таком как алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1728">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1729">Код не должен зависеть от порядка, в котором возвращаются методы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1729">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  

<span data-ttu-id="95a33-1730">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.MethodInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1730">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
<span data-ttu-id="95a33-1731">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object>, если отсутствует ограничение класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1731">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span> 
  
## Examples  
 <span data-ttu-id="95a33-1732">В следующем примере создается класс с двумя открытыми методами и одним защищенным методом, создается объект `Type`, соответствующий `MyTypeClass`, получает все открытые и не являющиеся открытыми методы и отображает их имена.</span><span class="sxs-lookup"><span data-stu-id="95a33-1732">The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.</span></span>  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-1733">Возвращает определенный тип, вложенный в текущий объект <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1733">Gets a specific type nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetNestedType(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetNestedType(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1734">Строка, содержащая имя искомого вложенного типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1734">The string containing the name of the nested type to get.</span></span></param>
        <summary><span data-ttu-id="95a33-1735">Выполняет поиск открытого вложенного типа с заданным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-1735">Searches for the public nested type with the specified name.</span></span></summary>
        <returns><span data-ttu-id="95a33-1736">Объект, представляющий открытый вложенный тип с указанным именем, если тип есть, и <see langword="null" />, если такого типа нет.</span><span class="sxs-lookup"><span data-stu-id="95a33-1736">An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1737">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-1737">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="95a33-1738">Используйте простое имя вложенного класса для `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1738">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="95a33-1739">Не указывайте имя внешнего класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1739">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="95a33-1740">Для универсального вложенного класса используйте искаженное имя, то есть добавьте знак ударения и число универсальных аргументов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1740">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic arguments.</span></span> <span data-ttu-id="95a33-1741">Например, используйте строку "Inner\`1", чтобы получить универсальный вложенный класс `Inner<T>` (`Inner(Of T)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-1741">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="95a33-1742">Не включайте синтаксис для параметров типа, зависящий от языка.</span><span class="sxs-lookup"><span data-stu-id="95a33-1742">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="95a33-1743">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1743">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-1744">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-1744">Member Type</span></span>|<span data-ttu-id="95a33-1745">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-1745">Static</span></span>|<span data-ttu-id="95a33-1746">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-1746">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-1747">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-1747">Constructor</span></span>|<span data-ttu-id="95a33-1748">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1748">No</span></span>|<span data-ttu-id="95a33-1749">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1749">No</span></span>|  
|<span data-ttu-id="95a33-1750">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-1750">Field</span></span>|<span data-ttu-id="95a33-1751">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1751">No</span></span>|<span data-ttu-id="95a33-1752">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1752">Yes.</span></span> <span data-ttu-id="95a33-1753">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1753">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1754">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-1754">Event</span></span>|<span data-ttu-id="95a33-1755">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1755">Not applicable</span></span>|<span data-ttu-id="95a33-1756">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1756">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1757">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1757">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1758">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1758">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-1759">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-1759">Method</span></span>|<span data-ttu-id="95a33-1760">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1760">No</span></span>|<span data-ttu-id="95a33-1761">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1761">Yes.</span></span> <span data-ttu-id="95a33-1762">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1762">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1763">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-1763">Nested Type</span></span>|<span data-ttu-id="95a33-1764">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1764">No</span></span>|<span data-ttu-id="95a33-1765">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1765">No</span></span>|  
|<span data-ttu-id="95a33-1766">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1766">Property</span></span>|<span data-ttu-id="95a33-1767">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1767">Not applicable</span></span>|<span data-ttu-id="95a33-1768">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1768">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1769">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1769">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1770">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1770">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-1771">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-1771">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-1772">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-1772">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-1773">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1773">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1774">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1774">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-1775">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1775">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-1776">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск вложенных типов ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1776">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="95a33-1777">Если вложенный тип является универсальным, этот метод возвращает определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1777">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="95a33-1778">Это справедливо, даже если включающий универсальный тип является закрытым сконструированным типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-1778">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1779">Если текущий <xref:System.Type> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если у них нет универсальных параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-1779">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="95a33-1780">Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированных с помощью [Ilasm. exe (ассемблера IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-1780">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="95a33-1781">Сведения о вложенных универсальных типах и конструировании вложенных универсальных типов из их определений универсальных типов см. в разделе <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1781">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1782"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1782"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1783">Строка, содержащая имя искомого вложенного типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1783">The string containing the name of the nested type to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-1784">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1784">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-1785">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1785">-or-</span></span> 
 <span data-ttu-id="95a33-1786"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1786"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="95a33-1787">При переопределении в производном классе ищет указанный вложенный тип, используя заданные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1787">When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-1788">Если поиск выполнен успешно, возвращается объект, предоставляющий вложенный тип, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1788">An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1789">Используйте простое имя вложенного класса для `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1789">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="95a33-1790">Не указывайте имя внешнего класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1790">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="95a33-1791">Для универсального вложенного класса используйте искаженное имя, то есть добавьте знак ударения и число универсальных параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-1791">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic parameters.</span></span> <span data-ttu-id="95a33-1792">Например, используйте строку "Inner\`1", чтобы получить универсальный вложенный класс `Inner<T>` (`Inner(Of T)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-1792">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="95a33-1793">Не включайте синтаксис для параметров типа, зависящий от языка.</span><span class="sxs-lookup"><span data-stu-id="95a33-1793">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="95a33-1794">Для определения вложенных типов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1794">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-1795">Чтобы получить возвращаемое значение, необходимо указать либо <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, либо <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1795">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-1796">Укажите <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, чтобы включить в поиск открытые вложенные типы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1796">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1797">Укажите <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, чтобы включить в поиск не являющиеся открытыми вложенные типы (т. е. частные, внутренние и защищенные вложенные типы).</span><span class="sxs-lookup"><span data-stu-id="95a33-1797">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="95a33-1798">Этот метод возвращает только вложенные типы текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1798">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="95a33-1799">Он не выполняет поиск базовых классов текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1799">It does not search the base classes of the current type.</span></span> <span data-ttu-id="95a33-1800">Чтобы найти типы, вложенные в базовые классы, необходимо пройти по иерархии наследования, вызвав <xref:System.Type.GetNestedType%2A> на каждом уровне.</span><span class="sxs-lookup"><span data-stu-id="95a33-1800">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.</span></span>  
  
 <span data-ttu-id="95a33-1801"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> игнорируются.</span><span class="sxs-lookup"><span data-stu-id="95a33-1801"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="95a33-1802">Вызов этого метода только с флагом <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> или только с флагом <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> возвратит указанные вложенные типы и не требует других флагов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1802">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="95a33-1803">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1803">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-1804">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск вложенных типов ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1804">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="95a33-1805">Если вложенный тип является универсальным, этот метод возвращает определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1805">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="95a33-1806">Это справедливо, даже если включающий универсальный тип является закрытым сконструированным типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-1806">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1807">Если текущий <xref:System.Type> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если у них нет универсальных параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-1807">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="95a33-1808">Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированных с помощью [Ilasm. exe (ассемблера IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-1808">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="95a33-1809">Сведения о вложенных универсальных типах и конструировании вложенных универсальных типов из их определений универсальных типов см. в разделе <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1809">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1810"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1810"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-1811">Возвращает типы, вложенные в текущий объект <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1811">Gets the types nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type[] GetNestedTypes() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;Type ^&gt; ^ GetNestedTypes();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-1812">Возвращает открытые типы, вложенные в текущий объект <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1812">Returns the public types nested in the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-1813">Массив объектов <see cref="T:System.Type" />, представляющий открытые типы, вложенные в текущий объект <see cref="T:System.Type" /> (нерекурсивный поиск), или пустой массив типа <see cref="T:System.Type" />, если в текущий объект <see cref="T:System.Type" /> не вложен ни один открытый тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-1813">An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1814">Метод <xref:System.Type.GetNestedTypes%2A> не возвращает типы в определенном порядке, например алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1814">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1815">Код не должен зависеть от порядка, в котором возвращаются типы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1815">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-1816">Возвращаются только открытые типы, непосредственно вложенные в текущий тип. Поиск не является рекурсивным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1816">Only the public types immediately nested in the current type are returned; the search is not recursive.</span></span>  
  
 <span data-ttu-id="95a33-1817">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1817">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-1818">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-1818">Member Type</span></span>|<span data-ttu-id="95a33-1819">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-1819">Static</span></span>|<span data-ttu-id="95a33-1820">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-1820">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-1821">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-1821">Constructor</span></span>|<span data-ttu-id="95a33-1822">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1822">No</span></span>|<span data-ttu-id="95a33-1823">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1823">No</span></span>|  
|<span data-ttu-id="95a33-1824">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-1824">Field</span></span>|<span data-ttu-id="95a33-1825">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1825">No</span></span>|<span data-ttu-id="95a33-1826">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1826">Yes.</span></span> <span data-ttu-id="95a33-1827">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1827">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1828">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-1828">Event</span></span>|<span data-ttu-id="95a33-1829">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1829">Not applicable</span></span>|<span data-ttu-id="95a33-1830">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1830">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1831">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1831">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1832">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1832">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-1833">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-1833">Method</span></span>|<span data-ttu-id="95a33-1834">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1834">No</span></span>|<span data-ttu-id="95a33-1835">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1835">Yes.</span></span> <span data-ttu-id="95a33-1836">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1836">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1837">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-1837">Nested Type</span></span>|<span data-ttu-id="95a33-1838">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1838">No</span></span>|<span data-ttu-id="95a33-1839">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1839">No</span></span>|  
|<span data-ttu-id="95a33-1840">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1840">Property</span></span>|<span data-ttu-id="95a33-1841">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1841">Not applicable</span></span>|<span data-ttu-id="95a33-1842">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1842">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1843">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1843">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1844">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1844">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-1845">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-1845">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-1846">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-1846">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-1847">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1847">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1848">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1848">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-1849">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1849">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-1850">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск вложенных типов ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1850">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="95a33-1851">Если вложенный тип является универсальным, этот метод возвращает определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1851">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="95a33-1852">Это справедливо, даже если включающий универсальный тип является закрытым сконструированным типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-1852">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1853">Если текущий <xref:System.Type> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если у них нет универсальных параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-1853">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="95a33-1854">Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированных с помощью [Ilasm. exe (ассемблера IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-1854">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="95a33-1855">Сведения о вложенных универсальных типах и конструировании вложенных универсальных типов из их определений универсальных типов см. в разделе <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1855">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1856">В следующем примере определяется вложенный класс и `struct` в `MyClass`, а затем объекты вложенных типов получаются с использованием типа `MyClass`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1856">The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.</span></span>  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="95a33-1857">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1857">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-1858">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1858">-or-</span></span> 
 <span data-ttu-id="95a33-1859"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1859"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="95a33-1860">При переопределении в производном классе ищет типы, вложенные в текущий объект <see cref="T:System.Type" />, используя заданные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1860">When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-1861">Массив объектов <see cref="T:System.Type" />, представляющий все типы, вложенные в текущий объект <see cref="T:System.Type" />, удовлетворяющий заданным ограничениям привязки (нерекурсивный поиск), или пустой массив типа <see cref="T:System.Type" />, если вложенные типы, удовлетворяющие ограничениям привязки, не найдены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1861">An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1862">Поиск вложенных типов не является рекурсивным.</span><span class="sxs-lookup"><span data-stu-id="95a33-1862">The search for nested types is not recursive.</span></span>  
  
 <span data-ttu-id="95a33-1863">Метод <xref:System.Type.GetNestedTypes%2A> не возвращает типы в определенном порядке, например алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1863">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1864">Код не должен зависеть от порядка, в котором возвращаются типы, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1864">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-1865">Для определения вложенных типов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1865">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-1866">Чтобы получить возвращаемое значение, необходимо указать либо <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, либо <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1866">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-1867">Укажите <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, чтобы включить в поиск открытые вложенные типы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1867">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1868">Укажите <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, чтобы включить в поиск не являющиеся открытыми вложенные типы (т. е. частные, внутренние и защищенные вложенные типы).</span><span class="sxs-lookup"><span data-stu-id="95a33-1868">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="95a33-1869">Этот метод возвращает только вложенные типы текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1869">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="95a33-1870">Он не выполняет поиск базовых классов текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1870">It does not search the base classes of the current type.</span></span> <span data-ttu-id="95a33-1871">Чтобы найти типы, вложенные в базовые классы, необходимо пройти по иерархии наследования, вызвав <xref:System.Type.GetNestedTypes%2A> на каждом уровне.</span><span class="sxs-lookup"><span data-stu-id="95a33-1871">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.</span></span>  
  
 <span data-ttu-id="95a33-1872"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> игнорируются.</span><span class="sxs-lookup"><span data-stu-id="95a33-1872"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="95a33-1873">Вызов этого метода только с флагом <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> или только с флагом <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> возвратит указанные вложенные типы и не требует других флагов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1873">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="95a33-1874">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1874">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-1875">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск вложенных типов ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1875">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="95a33-1876">Если вложенный тип является универсальным, этот метод возвращает определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1876">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="95a33-1877">Это справедливо, даже если включающий универсальный тип является закрытым сконструированным типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-1877">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-1878">Если текущий <xref:System.Type> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если у них нет универсальных параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-1878">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="95a33-1879">Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированных с помощью [Ilasm. exe (ассемблера IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-1879">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="95a33-1880">Сведения о вложенных универсальных типах и конструировании вложенных универсальных типов из их определений универсальных типов см. в разделе <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1880">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1881">В следующем примере создаются два вложенных открытых класса и два вложенных защищенных класса и отображаются сведения о классах, соответствующих указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1881">The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-1882">Получает свойства текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1882">Gets the properties of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-1883">Возвращает все открытые свойства текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1883">Returns all the public properties of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-1884">Массив объектов <see cref="T:System.Reflection.PropertyInfo" />, представляющий все открытые свойства текущего типа <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1884">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="95a33-1885">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1885">-or-</span></span> 
<span data-ttu-id="95a33-1886">Пустой массив типа <see cref="T:System.Reflection.PropertyInfo" />, если у текущего типа <see cref="T:System.Type" /> нет открытых свойств.</span><span class="sxs-lookup"><span data-stu-id="95a33-1886">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1887">Вызов этой перегрузки эквивалентен вызову перегрузки <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> с аргументом `bindingAttr`, C# равным `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` в и `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="95a33-1887">Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span></span> <span data-ttu-id="95a33-1888">Он возвращает все открытые и статические свойства, которые определены типом, представленным текущим объектом <xref:System.Type>, а также те, которые унаследованы от его базовых типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1888">It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.</span></span>  
  
 <span data-ttu-id="95a33-1889">Свойство считается открытым для отражения, если у него есть по крайней мере один открытый метод доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1889">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="95a33-1890">В противном случае свойство считается закрытым и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения с помощью `Or`), чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-1890">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="95a33-1891">Метод <xref:System.Type.GetProperties%2A> не возвращает свойства в определенном порядке, таком как алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1891">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1892">Код не должен зависеть от порядка, в котором возвращаются свойства, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1892">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="95a33-1893">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1893">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-1894">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-1894">Member Type</span></span>|<span data-ttu-id="95a33-1895">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-1895">Static</span></span>|<span data-ttu-id="95a33-1896">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-1896">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-1897">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-1897">Constructor</span></span>|<span data-ttu-id="95a33-1898">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1898">No</span></span>|<span data-ttu-id="95a33-1899">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1899">No</span></span>|  
|<span data-ttu-id="95a33-1900">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-1900">Field</span></span>|<span data-ttu-id="95a33-1901">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1901">No</span></span>|<span data-ttu-id="95a33-1902">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1902">Yes.</span></span> <span data-ttu-id="95a33-1903">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1903">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1904">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-1904">Event</span></span>|<span data-ttu-id="95a33-1905">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1905">Not applicable</span></span>|<span data-ttu-id="95a33-1906">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1906">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1907">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1907">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1908">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1908">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-1909">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-1909">Method</span></span>|<span data-ttu-id="95a33-1910">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1910">No</span></span>|<span data-ttu-id="95a33-1911">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-1911">Yes.</span></span> <span data-ttu-id="95a33-1912">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1912">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-1913">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-1913">Nested Type</span></span>|<span data-ttu-id="95a33-1914">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1914">No</span></span>|<span data-ttu-id="95a33-1915">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-1915">No</span></span>|  
|<span data-ttu-id="95a33-1916">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1916">Property</span></span>|<span data-ttu-id="95a33-1917">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-1917">Not applicable</span></span>|<span data-ttu-id="95a33-1918">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1918">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-1919">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1919">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1920">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-1920">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-1921">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-1921">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-1922">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-1922">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-1923">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-1923">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-1924">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-1924">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-1925">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-1925">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-1926">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.PropertyInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1926">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1927">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск в свойствах ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1927">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1928">В следующем примере иллюстрируется использование метода `GetProperties`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1928">The following example demonstrates the use of the `GetProperties` method.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="95a33-1929">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1929">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="95a33-1930">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1930">-or-</span></span>

 <span data-ttu-id="95a33-1931"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-1931"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="95a33-1932">При переопределении в производном классе ищет свойства текущего объекта <see cref="T:System.Type" />, используя указанные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1932">When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-1933">Массив объектов, представляющий все свойства текущего <see cref="T:System.Type" />, которые удовлетворяют указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1933">An array of objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="95a33-1934">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1934">-or-</span></span> 
<span data-ttu-id="95a33-1935">Пустой массив типа <see cref="T:System.Reflection.PropertyInfo" />, если у текущего типа <see cref="T:System.Type" /> нет свойств или ни одно свойство не удовлетворяет ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1935">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="95a33-1936">Чтобы перегрузить `GetProperties(BindingFlags)` для успешного получения сведений о свойствах, аргумент `bindingAttr` должен включать по крайней мере один из <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, а также хотя бы один из <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1936">For the `GetProperties(BindingFlags)` overload to successfully retrieve property information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="95a33-1937">Для определения свойств, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1937">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
- <span data-ttu-id="95a33-1938">Укажите `BindingFlags.Instance`, чтобы включить методы экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1938">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="95a33-1939">Укажите `BindingFlags.Static`, чтобы включить статические методы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1939">Specify `BindingFlags.Static` to include static methods.</span></span> 
  
- <span data-ttu-id="95a33-1940">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-1940">Specify `BindingFlags.Public` to include public properties in the search.</span></span> <span data-ttu-id="95a33-1941">Свойство считается открытым для отражения, если у него есть по крайней мере один открытый метод доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1941">A property is considered public to reflection if it has at least one accessor that is public.</span></span> 
  
- <span data-ttu-id="95a33-1942">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск не являющиеся общими свойства (т. е. частные, внутренние и защищенные).</span><span class="sxs-lookup"><span data-stu-id="95a33-1942">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span> <span data-ttu-id="95a33-1943">Возвращаются только защищенные и внутренние свойства базовых классов; закрытые свойства базовых классов не возвращаются.</span><span class="sxs-lookup"><span data-stu-id="95a33-1943">Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</span></span>  
  
- <span data-ttu-id="95a33-1944">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1944">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="95a33-1945">Укажите только `BindingFlags.Default`, чтобы вернуть пустой массив <xref:System.Reflection.PropertyInfo>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1945">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.PropertyInfo> array.</span></span>

 <span data-ttu-id="95a33-1946">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1946">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="95a33-1947">`BindingFlags.DeclaredOnly` искать только свойства, объявленные в <xref:System.Type>, а не свойства, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-1947">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-1948">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1948">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
<span data-ttu-id="95a33-1949">Метод <xref:System.Type.GetProperties%2A> не возвращает свойства в определенном порядке, таком как алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="95a33-1949">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="95a33-1950">Код не должен зависеть от порядка, в котором возвращаются свойства, так как этот порядок меняется.</span><span class="sxs-lookup"><span data-stu-id="95a33-1950">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  

 <span data-ttu-id="95a33-1951">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает объекты <xref:System.Reflection.PropertyInfo> с параметрами типа, замененными соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1951">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1952">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск в свойствах ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1952">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1953">В следующем примере определяется класс с именем `PropertyClass`, включающий шесть свойств: два — Public, один — частный, один — защищенный, один — внутренний (`Friend` в Visual Basic), а второй — защищенный внутренний (`Protected Friend` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-1953">The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic).</span></span> <span data-ttu-id="95a33-1954">Затем он отображает некоторые основные сведения о свойстве (имя и тип свойства, будь то чтение и запись, а также видимость его `get` и `set`) для свойств, соответствующих указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1954">It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-1955">Получает указанное свойство текущего класса <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1955">Gets a specific property of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1956">Строка, содержащая искомое имя открытого свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-1956">The string containing the name of the public property to get.</span></span></param>
        <summary><span data-ttu-id="95a33-1957">Выполняет поиск открытого свойства с заданным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-1957">Searches for the public property with the specified name.</span></span></summary>
        <returns><span data-ttu-id="95a33-1958">Объект, представляющий открытое свойство с заданным именем, если такое свойство есть, и <see langword="null" />, если такого свойства нет.</span><span class="sxs-lookup"><span data-stu-id="95a33-1958">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1959">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-1959">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="95a33-1960">Поиск включает открытые статические и открытые свойства экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-1960">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="95a33-1961">Свойство считается открытым для отражения, если у него есть по крайней мере один открытый метод доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1961">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="95a33-1962">В противном случае свойство считается закрытым и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения с помощью `Or`), чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-1962">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="95a33-1963">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1963">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-1964">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск в свойствах ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-1964">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="95a33-1965">Ниже перечислены ситуации, в которых <xref:System.Reflection.AmbiguousMatchException> происходит следующее.</span><span class="sxs-lookup"><span data-stu-id="95a33-1965">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="95a33-1966">Тип содержит два индексированных свойства с одинаковыми именами, но разными числами параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-1966">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="95a33-1967">Чтобы устранить неоднозначность, используйте перегрузку метода <xref:System.Type.GetProperty%2A>, который указывает типы параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-1967">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="95a33-1968">Производный тип объявляет свойство, которое скрывает унаследованное свойство с тем же именем, с помощью модификатора `new` (`Shadows` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-1968">A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="95a33-1969">Чтобы устранить неоднозначность, используйте перегрузку метода <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> и добавьте флаг <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>, чтобы ограничить поиск неунаследованными членами.</span><span class="sxs-lookup"><span data-stu-id="95a33-1969">To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="95a33-1970">Индексаторы и свойства по умолчанию</span><span class="sxs-lookup"><span data-stu-id="95a33-1970">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="95a33-1971">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] имеют упрощенный синтаксис для доступа к индексированным свойствам и позволяют одному индексированному свойству быть значение по умолчанию для его типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1971">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="95a33-1972">Например, если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="95a33-1972">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="95a33-1973">Можно перегрузить свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-1973">You can overload the property.</span></span>  
  
 <span data-ttu-id="95a33-1974">В C#эта функция называется индексатором, и на нее нельзя ссылаться по имени.</span><span class="sxs-lookup"><span data-stu-id="95a33-1974">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="95a33-1975">По умолчанию C# индексатор отображается в метаданных как индексированное свойство с именем Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-1975">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="95a33-1976">Однако разработчик библиотеки классов может использовать атрибут <xref:System.Runtime.CompilerServices.IndexerNameAttribute> для изменения имени индексатора в метаданных.</span><span class="sxs-lookup"><span data-stu-id="95a33-1976">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="95a33-1977">Например, класс <xref:System.String> имеет индексатор с именем <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1977">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="95a33-1978">Индексированные свойства, созданные с помощью языков C# , отличных от, также могут иметь имена, отличные от Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-1978">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="95a33-1979">Чтобы определить, имеет ли тип свойство по умолчанию, используйте метод <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> для проверки атрибута <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1979">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="95a33-1980">Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, свойство <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> возвращает имя свойства по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-1980">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-1981">В следующем примере извлекается объект `Type` определяемого пользователем класса, извлекается свойство этого класса и отображается имя свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-1981">The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.</span></span>  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 <span data-ttu-id="95a33-1982">На внутреннем уровне это свойство упоминается в метаданных по имени "Item".</span><span class="sxs-lookup"><span data-stu-id="95a33-1982">Internally, this property is referred to in the metadata by the name "Item."</span></span> <span data-ttu-id="95a33-1983">Любая попытка получить `PropertyInfo` с помощью отражения должна указать это внутреннее имя, чтобы правильно вернуть свойство `PropertyInfo`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1983">Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-1984">Найдено несколько свойств с указанным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-1984">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-1985"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1985"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-1986">Строка, содержащий имя искомого свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-1986">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-1987">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-1987">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-1988">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-1988">-or-</span></span> 
<span data-ttu-id="95a33-1989"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1989"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="95a33-1990">Ищет указанное свойство, используя заданные ограничения привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-1990">Searches for the specified property, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-1991">Объект, предоставляющий свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-1991">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-1992">Свойство считается открытым для отражения, если у него есть по крайней мере один открытый метод доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-1992">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="95a33-1993">В противном случае свойство считается закрытым и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения с помощью `Or`), чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-1993">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="95a33-1994">Для определения свойств, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1994">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-1995">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-1995">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-1996">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-1996">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1997">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск не являющиеся общими свойства (т. е. частные, внутренние и защищенные).</span><span class="sxs-lookup"><span data-stu-id="95a33-1997">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-1998">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-1998">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="95a33-1999">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-1999">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-2000">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2000">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-2001">`BindingFlags.DeclaredOnly` искать только свойства, объявленные в <xref:System.Type>, а не свойства, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-2001">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-2002">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2002">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-2003">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2003">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-2004">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск в свойствах ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-2004">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="95a33-2005">Ниже перечислены ситуации, в которых <xref:System.Reflection.AmbiguousMatchException> происходит следующее.</span><span class="sxs-lookup"><span data-stu-id="95a33-2005">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="95a33-2006">Тип содержит два индексированных свойства с одинаковыми именами, но разными числами параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-2006">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="95a33-2007">Чтобы устранить неоднозначность, используйте перегрузку метода <xref:System.Type.GetProperty%2A>, который указывает типы параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-2007">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="95a33-2008">Производный тип объявляет свойство, которое скрывает унаследованное свойство с тем же именем, используя модификатор `new` (`Shadows` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-2008">A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="95a33-2009">Чтобы устранить неоднозначность, включите <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>, чтобы ограничить поиск неунаследованными членами.</span><span class="sxs-lookup"><span data-stu-id="95a33-2009">To resolve the ambiguity, include <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="95a33-2010">Индексаторы и свойства по умолчанию</span><span class="sxs-lookup"><span data-stu-id="95a33-2010">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="95a33-2011">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] имеют упрощенный синтаксис для доступа к индексированным свойствам и позволяют одному индексированному свойству быть значение по умолчанию для его типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2011">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="95a33-2012">Например, если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="95a33-2012">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="95a33-2013">Можно перегрузить свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2013">You can overload the property.</span></span>  
  
 <span data-ttu-id="95a33-2014">В C#эта функция называется индексатором, и на нее нельзя ссылаться по имени.</span><span class="sxs-lookup"><span data-stu-id="95a33-2014">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="95a33-2015">По умолчанию C# индексатор отображается в метаданных как индексированное свойство с именем Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-2015">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="95a33-2016">Однако разработчик библиотеки классов может использовать атрибут <xref:System.Runtime.CompilerServices.IndexerNameAttribute> для изменения имени индексатора в метаданных.</span><span class="sxs-lookup"><span data-stu-id="95a33-2016">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="95a33-2017">Например, класс <xref:System.String> имеет индексатор с именем <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2017">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="95a33-2018">Индексированные свойства, созданные с помощью языков C# , отличных от, также могут иметь имена, отличные от Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-2018">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="95a33-2019">Чтобы определить, имеет ли тип свойство по умолчанию, используйте метод <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> для проверки атрибута <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2019">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="95a33-2020">Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, свойство <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> возвращает имя свойства по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-2020">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-2021">В следующем примере извлекается тип определяемого пользователем класса, извлекается свойство этого класса и отображается имя свойства в соответствии с заданными ограничениями привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2021">The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-2022">Найдено несколько свойств с указанным именем и соответствующих указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2022">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2023">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2023"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-2024">Строка, содержащая искомое имя открытого свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2024">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="95a33-2025">Возвращаемый тип свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2025">The return type of the property.</span></span></param>
        <summary><span data-ttu-id="95a33-2026">Выполняет поиск открытого свойства с заданным именем и типом возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2026">Searches for the public property with the specified name and return type.</span></span></summary>
        <returns><span data-ttu-id="95a33-2027">Объект, представляющий открытое свойство с заданным именем, если такое свойство есть, и <see langword="null" />, если такого свойства нет.</span><span class="sxs-lookup"><span data-stu-id="95a33-2027">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-2028">Свойство считается открытым для отражения, если у него есть по крайней мере один открытый метод доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2028">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="95a33-2029">В противном случае свойство считается закрытым и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения с помощью `Or`), чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-2029">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="95a33-2030">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-2030">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="95a33-2031">Поиск включает открытые статические и открытые свойства экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-2031">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="95a33-2032">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2032">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-2033">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск в свойствах ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-2033">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="95a33-2034">Индексаторы и свойства по умолчанию</span><span class="sxs-lookup"><span data-stu-id="95a33-2034">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="95a33-2035">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] имеют упрощенный синтаксис для доступа к индексированным свойствам и позволяют одному индексированному свойству быть значение по умолчанию для его типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2035">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="95a33-2036">Например, если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="95a33-2036">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="95a33-2037">Можно перегрузить свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2037">You can overload the property.</span></span>  
  
 <span data-ttu-id="95a33-2038">В C#эта функция называется индексатором, и на нее нельзя ссылаться по имени.</span><span class="sxs-lookup"><span data-stu-id="95a33-2038">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="95a33-2039">По умолчанию C# индексатор отображается в метаданных как индексированное свойство с именем Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-2039">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="95a33-2040">Однако разработчик библиотеки классов может использовать атрибут <xref:System.Runtime.CompilerServices.IndexerNameAttribute> для изменения имени индексатора в метаданных.</span><span class="sxs-lookup"><span data-stu-id="95a33-2040">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="95a33-2041">Например, класс <xref:System.String> имеет индексатор с именем <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2041">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="95a33-2042">Индексированные свойства, созданные с помощью языков C# , отличных от, также могут иметь имена, отличные от Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-2042">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="95a33-2043">Чтобы определить, имеет ли тип свойство по умолчанию, используйте метод <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> для проверки атрибута <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2043">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="95a33-2044">Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, свойство <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> возвращает имя свойства по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-2044">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-2045">В следующем примере определяется класс с одним свойством и извлекается имя и тип свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2045">The following example defines a class with one property and retrieves the name and type of the property.</span></span>  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-2046">Найдено несколько свойств с указанным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-2046">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2047"><paramref name="name" /> имеет значение <see langword="null" />, или <paramref name="returnType" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2047"><paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-2048">Строка, содержащая искомое имя открытого свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2048">The string containing the name of the public property to get.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-2049">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого индексированного свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2049">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="95a33-2050">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2050">-or-</span></span> 
<span data-ttu-id="95a33-2051">Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2051">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="95a33-2052">Ищет указанное открытое свойство, параметры которого соответствуют указанным типам аргументов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2052">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="95a33-2053">Объект, представляющий открытое свойство, параметры которого соответствуют указанным типам аргументов, если таковые найдены; в противном случае — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2053">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-2054">Свойство считается открытым для отражения, если у него есть по крайней мере один открытый метод доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2054">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="95a33-2055">В противном случае свойство считается закрытым и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения с помощью `Or`), чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-2055">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="95a33-2056">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-2056">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="95a33-2057">Поиск включает открытые статические и открытые свойства экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-2057">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="95a33-2058">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2058">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-2059">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск в свойствах ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-2059">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="95a33-2060">Индексаторы и свойства по умолчанию</span><span class="sxs-lookup"><span data-stu-id="95a33-2060">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="95a33-2061">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] имеют упрощенный синтаксис для доступа к индексированным свойствам и позволяют одному индексированному свойству быть значение по умолчанию для его типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2061">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="95a33-2062">Например, если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="95a33-2062">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="95a33-2063">Можно перегрузить свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2063">You can overload the property.</span></span>  
  
 <span data-ttu-id="95a33-2064">В C#эта функция называется индексатором, и на нее нельзя ссылаться по имени.</span><span class="sxs-lookup"><span data-stu-id="95a33-2064">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="95a33-2065">По умолчанию C# индексатор отображается в метаданных как индексированное свойство с именем Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-2065">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="95a33-2066">Однако разработчик библиотеки классов может использовать атрибут <xref:System.Runtime.CompilerServices.IndexerNameAttribute> для изменения имени индексатора в метаданных.</span><span class="sxs-lookup"><span data-stu-id="95a33-2066">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="95a33-2067">Например, класс <xref:System.String> имеет индексатор с именем <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2067">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="95a33-2068">Индексированные свойства, созданные с помощью языков C# , отличных от, также могут иметь имена, отличные от Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-2068">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="95a33-2069">Чтобы определить, имеет ли тип свойство по умолчанию, используйте метод <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> для проверки атрибута <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2069">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="95a33-2070">Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, свойство <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> возвращает имя свойства по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-2070">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-2071">В следующем примере извлекается объект `Type` определяемого пользователем класса, извлекается свойство этого класса и отображается имя и тип свойства в соответствии с аргументами, передаваемыми в `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2071">The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.</span></span>  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-2072">Найдено несколько свойств с указанным именем и соответствующих указанным типам аргументов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2072">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2073"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2073"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-2074">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2074">-or-</span></span> 
 <span data-ttu-id="95a33-2075">Свойство <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2075"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-2076">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-2076"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="95a33-2077">Элемент <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2077">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-2078">Строка, содержащая искомое имя открытого свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2078">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="95a33-2079">Возвращаемый тип свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2079">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-2080">Массив объектов <see cref="T:System.Type" /> , предоставляющий число, порядок и тип параметров искомого индексированного свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2080">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="95a33-2081">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2081">-or-</span></span> 
<span data-ttu-id="95a33-2082">Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2082">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="95a33-2083">Ищет указанное открытое свойство, параметры которого соответствуют указанным типам аргументов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2083">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="95a33-2084">Объект, представляющий открытое свойство, параметры которого соответствуют указанным типам аргументов, если таковые найдены; в противном случае — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2084">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-2085">Свойство считается открытым для отражения, если у него есть по крайней мере один открытый метод доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2085">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="95a33-2086">В противном случае свойство считается закрытым и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения с помощью `Or`), чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-2086">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="95a33-2087">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-2087">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="95a33-2088">Поиск включает открытые статические и открытые свойства экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-2088">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="95a33-2089">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2089">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-2090">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск в свойствах ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-2090">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="95a33-2091">Индексаторы и свойства по умолчанию</span><span class="sxs-lookup"><span data-stu-id="95a33-2091">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="95a33-2092">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] имеют упрощенный синтаксис для доступа к индексированным свойствам и позволяют одному индексированному свойству быть значение по умолчанию для его типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2092">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="95a33-2093">Например, если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="95a33-2093">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="95a33-2094">Можно перегрузить свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2094">You can overload the property.</span></span>  
  
 <span data-ttu-id="95a33-2095">В C#эта функция называется индексатором, и на нее нельзя ссылаться по имени.</span><span class="sxs-lookup"><span data-stu-id="95a33-2095">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="95a33-2096">По умолчанию C# индексатор отображается в метаданных как индексированное свойство с именем Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-2096">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="95a33-2097">Однако разработчик библиотеки классов может использовать атрибут <xref:System.Runtime.CompilerServices.IndexerNameAttribute> для изменения имени индексатора в метаданных.</span><span class="sxs-lookup"><span data-stu-id="95a33-2097">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="95a33-2098">Например, класс <xref:System.String> имеет индексатор с именем <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2098">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="95a33-2099">Индексированные свойства, созданные с помощью языков C# , отличных от, также могут иметь имена, отличные от Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-2099">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="95a33-2100">Чтобы определить, имеет ли тип свойство по умолчанию, используйте метод <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> для проверки атрибута <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2100">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="95a33-2101">Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, свойство <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> возвращает имя свойства по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-2101">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-2102">Найдено несколько свойств с указанным именем и соответствующих указанным типам аргументов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2102">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2103"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2103"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-2104">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2104">-or-</span></span> 
 <span data-ttu-id="95a33-2105">Свойство <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2105"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-2106">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-2106"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="95a33-2107">Элемент <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2107">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-2108">Строка, содержащая искомое имя открытого свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2108">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="95a33-2109">Возвращаемый тип свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2109">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-2110">Массив объектов <see cref="T:System.Type" /> , предоставляющий число, порядок и тип параметров искомого индексированного свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2110">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="95a33-2111">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2111">-or-</span></span> 
<span data-ttu-id="95a33-2112">Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2112">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="95a33-2113">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2113">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="95a33-2114">Связыватель по умолчанию не обрабатывает этот параметр.</span><span class="sxs-lookup"><span data-stu-id="95a33-2114">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="95a33-2115">Ищет заданное открытое свойство, параметры которого соответствуют указанным типам аргументов и модификаторам.</span><span class="sxs-lookup"><span data-stu-id="95a33-2115">Searches for the specified public property whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="95a33-2116">Объект, представляющий открытое свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2116">An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-2117">Свойство считается открытым для отражения, если у него есть по крайней мере один открытый метод доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2117">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="95a33-2118">В противном случае свойство считается закрытым и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения с помощью `Or`), чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-2118">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="95a33-2119">Хотя связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> (параметр `modifiers`), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательского связывателя, который обрабатывает `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2119">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="95a33-2120">`ParameterModifier` используется только при вызове через COM-взаимодействие, и обрабатываются только параметры, передаваемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2120">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="95a33-2121">При поиске `name` учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-2121">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="95a33-2122">Поиск включает открытые статические и открытые свойства экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-2122">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="95a33-2123">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2123">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-2124">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск в свойствах ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-2124">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="95a33-2125">Индексаторы и свойства по умолчанию</span><span class="sxs-lookup"><span data-stu-id="95a33-2125">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="95a33-2126">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] имеют упрощенный синтаксис для доступа к индексированным свойствам и позволяют одному индексированному свойству быть значение по умолчанию для его типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2126">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="95a33-2127">Например, если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="95a33-2127">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="95a33-2128">Можно перегрузить свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2128">You can overload the property.</span></span>  
  
 <span data-ttu-id="95a33-2129">В C#эта функция называется индексатором, и на нее нельзя ссылаться по имени.</span><span class="sxs-lookup"><span data-stu-id="95a33-2129">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="95a33-2130">По умолчанию C# индексатор отображается в метаданных как индексированное свойство с именем Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-2130">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="95a33-2131">Однако разработчик библиотеки классов может использовать атрибут <xref:System.Runtime.CompilerServices.IndexerNameAttribute> для изменения имени индексатора в метаданных.</span><span class="sxs-lookup"><span data-stu-id="95a33-2131">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="95a33-2132">Например, класс <xref:System.String> имеет индексатор с именем <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2132">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="95a33-2133">Индексированные свойства, созданные с помощью языков C# , отличных от, также могут иметь имена, отличные от Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-2133">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="95a33-2134">Чтобы определить, имеет ли тип свойство по умолчанию, используйте метод <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> для проверки атрибута <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2134">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="95a33-2135">Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, свойство <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> возвращает имя свойства по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-2135">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-2136">В следующем примере получается объект `Type`, соответствующий `MyPropertyClass`, а индексированное свойство этого класса извлекается с помощью аргументов, передаваемых методу `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2136">The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.</span></span>  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-2137">Найдено несколько свойств с указанным именем и соответствующих указанным типам аргументов и модификаторам.</span><span class="sxs-lookup"><span data-stu-id="95a33-2137">More than one property is found with the specified name and matching the specified argument types and modifiers.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2138">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2138"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-2139">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2139">-or-</span></span> 
 <span data-ttu-id="95a33-2140">Свойство <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2140"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-2141">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-2141"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-2142">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2142">-or-</span></span> 
 <span data-ttu-id="95a33-2143">Массив <paramref name="modifiers" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-2143"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-2144">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2144">-or-</span></span> 
 <span data-ttu-id="95a33-2145"><paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</span><span class="sxs-lookup"><span data-stu-id="95a33-2145"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="95a33-2146">Элемент <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2146">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-2147">Строка, содержащий имя искомого свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2147">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-2148">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-2148">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-2149">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2149">-or-</span></span> 
 <span data-ttu-id="95a33-2150"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2150"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="95a33-2151">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2151">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="95a33-2152">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2152">-or-</span></span> 
<span data-ttu-id="95a33-2153">Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2153">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="95a33-2154">Возвращаемый тип свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2154">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-2155">Массив объектов <see cref="T:System.Type" /> , предоставляющий число, порядок и тип параметров искомого индексированного свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2155">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="95a33-2156">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2156">-or-</span></span> 
<span data-ttu-id="95a33-2157">Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2157">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="95a33-2158">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2158">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="95a33-2159">Связыватель по умолчанию не обрабатывает этот параметр.</span><span class="sxs-lookup"><span data-stu-id="95a33-2159">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="95a33-2160">Ищет свойство с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2160">Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-2161">Объект, предоставляющий свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2161">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-2162">Свойство считается открытым для отражения, если у него есть по крайней мере один открытый метод доступа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2162">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="95a33-2163">В противном случае свойство считается закрытым и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения с помощью `Or`), чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-2163">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="95a33-2164">Хотя связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> (параметр `modifiers`), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательского связывателя, который обрабатывает `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2164">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="95a33-2165">`ParameterModifier` используется только при вызове через COM-взаимодействие, и обрабатываются только параметры, передаваемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2165">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="95a33-2166">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-2166">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-2167">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-2167">Member Type</span></span>|<span data-ttu-id="95a33-2168">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-2168">Static</span></span>|<span data-ttu-id="95a33-2169">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-2169">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-2170">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-2170">Constructor</span></span>|<span data-ttu-id="95a33-2171">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2171">No</span></span>|<span data-ttu-id="95a33-2172">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2172">No</span></span>|  
|<span data-ttu-id="95a33-2173">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-2173">Field</span></span>|<span data-ttu-id="95a33-2174">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2174">No</span></span>|<span data-ttu-id="95a33-2175">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-2175">Yes.</span></span> <span data-ttu-id="95a33-2176">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2176">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-2177">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-2177">Event</span></span>|<span data-ttu-id="95a33-2178">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-2178">Not applicable</span></span>|<span data-ttu-id="95a33-2179">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2179">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-2180">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2180">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-2181">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-2181">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-2182">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-2182">Method</span></span>|<span data-ttu-id="95a33-2183">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2183">No</span></span>|<span data-ttu-id="95a33-2184">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-2184">Yes.</span></span> <span data-ttu-id="95a33-2185">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2185">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-2186">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-2186">Nested Type</span></span>|<span data-ttu-id="95a33-2187">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2187">No</span></span>|<span data-ttu-id="95a33-2188">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2188">No</span></span>|  
|<span data-ttu-id="95a33-2189">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2189">Property</span></span>|<span data-ttu-id="95a33-2190">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-2190">Not applicable</span></span>|<span data-ttu-id="95a33-2191">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2191">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-2192">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2192">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-2193">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-2193">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-2194">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-2194">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-2195">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-2195">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-2196">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2196">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-2197">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-2197">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-2198">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2198">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-2199">Для определения свойств, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2199">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-2200">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2200">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-2201">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2201">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="95a33-2202">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск не являющиеся общими свойства (т. е. частные, внутренние и защищенные).</span><span class="sxs-lookup"><span data-stu-id="95a33-2202">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-2203">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-2203">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="95a33-2204">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2204">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-2205">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2205">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-2206">`BindingFlags.DeclaredOnly` искать только свойства, объявленные в <xref:System.Type>, а не свойства, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-2206">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-2207">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2207">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-2208">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменяя соответствующими аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2208">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="95a33-2209">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск в свойствах ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-2209">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="95a33-2210">Индексаторы и свойства по умолчанию</span><span class="sxs-lookup"><span data-stu-id="95a33-2210">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="95a33-2211">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] имеют упрощенный синтаксис для доступа к индексированным свойствам и позволяют одному индексированному свойству быть значение по умолчанию для его типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2211">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="95a33-2212">Например, если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="95a33-2212">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="95a33-2213">Можно перегрузить свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2213">You can overload the property.</span></span>  
  
 <span data-ttu-id="95a33-2214">В C#эта функция называется индексатором, и на нее нельзя ссылаться по имени.</span><span class="sxs-lookup"><span data-stu-id="95a33-2214">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="95a33-2215">По умолчанию C# индексатор отображается в метаданных как индексированное свойство с именем Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-2215">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="95a33-2216">Однако разработчик библиотеки классов может использовать атрибут <xref:System.Runtime.CompilerServices.IndexerNameAttribute> для изменения имени индексатора в метаданных.</span><span class="sxs-lookup"><span data-stu-id="95a33-2216">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="95a33-2217">Например, класс <xref:System.String> имеет индексатор с именем <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2217">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="95a33-2218">Индексированные свойства, созданные с помощью языков C# , отличных от, также могут иметь имена, отличные от Item.</span><span class="sxs-lookup"><span data-stu-id="95a33-2218">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="95a33-2219">Чтобы определить, имеет ли тип свойство по умолчанию, используйте метод <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> для проверки атрибута <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2219">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="95a33-2220">Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, свойство <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> возвращает имя свойства по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-2220">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-2221">Найдено несколько свойств с указанным именем и соответствующих указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2221">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2222"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2222"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-2223">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2223">-or-</span></span> 
 <span data-ttu-id="95a33-2224">Свойство <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2224"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-2225">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-2225"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-2226">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2226">-or-</span></span> 
 <span data-ttu-id="95a33-2227">Массив <paramref name="modifiers" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-2227"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-2228">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2228">-or-</span></span> 
 <span data-ttu-id="95a33-2229"><paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</span><span class="sxs-lookup"><span data-stu-id="95a33-2229"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="95a33-2230">Элемент <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2230">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-2231">Строка, содержащий имя искомого свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2231">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="95a33-2232">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-2232">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="95a33-2233">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2233">-or-</span></span> 
 <span data-ttu-id="95a33-2234"><see cref="F:System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2234"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="95a33-2235">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженного члена, приведение типов аргументов и вызов члена с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2235">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="95a33-2236">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2236">-or-</span></span> 
<span data-ttu-id="95a33-2237">Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2237">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="95a33-2238">Возвращаемый тип свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2238">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="95a33-2239">Массив объектов <see cref="T:System.Type" /> , предоставляющий число, порядок и тип параметров искомого индексированного свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2239">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="95a33-2240">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2240">-or-</span></span> 
<span data-ttu-id="95a33-2241">Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2241">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="95a33-2242">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2242">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="95a33-2243">Связыватель по умолчанию не обрабатывает этот параметр.</span><span class="sxs-lookup"><span data-stu-id="95a33-2243">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="95a33-2244">При переопределении в производном классе выполняет поиск заданного свойства, параметры которого соответствуют типам и модификаторам заданных аргументов, с использованием заданных ограничений привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2244">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="95a33-2245">Объект, предоставляющий свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2245">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-2246">Хотя связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> (параметр `modifiers`), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательского связывателя, который обрабатывает `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2246">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="95a33-2247">`ParameterModifier` используется только при вызове через COM-взаимодействие, и обрабатываются только параметры, передаваемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2247">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="95a33-2248">Для определения свойств, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2248">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-2249">Чтобы получить возвращаемое значение, необходимо указать либо `BindingFlags.Instance`, либо `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2249">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="95a33-2250">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые свойства.</span><span class="sxs-lookup"><span data-stu-id="95a33-2250">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="95a33-2251">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск не являющиеся общими свойства (т. е. частные, внутренние и защищенные).</span><span class="sxs-lookup"><span data-stu-id="95a33-2251">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-2252">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить `public` и `protected` статические элементы в иерархии. `private` статические члены в унаследованных классах не включены.</span><span class="sxs-lookup"><span data-stu-id="95a33-2252">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="95a33-2253">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2253">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-2254">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2254">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-2255">`BindingFlags.DeclaredOnly` искать только свойства, объявленные в <xref:System.Type>, а не свойства, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-2255">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-2256">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2256">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-2257">Найдено несколько свойств с указанным именем и соответствующих указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2257">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2258">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2258"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-2259">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2259">-or-</span></span> 
 <span data-ttu-id="95a33-2260">Свойство <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2260"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-2261">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2261">-or-</span></span> 
<span data-ttu-id="95a33-2262">Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2262">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-2263">Массив <paramref name="types" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-2263"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-2264">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2264">-or-</span></span> 
 <span data-ttu-id="95a33-2265">Массив <paramref name="modifiers" /> является многомерным.</span><span class="sxs-lookup"><span data-stu-id="95a33-2265"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="95a33-2266">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2266">-or-</span></span> 
 <span data-ttu-id="95a33-2267"><paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</span><span class="sxs-lookup"><span data-stu-id="95a33-2267"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-2268">Текущий тип — <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> или <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2268">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-2269">Возвращает объект <see cref="T:System.Type" />, предоставляющий указанный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-2269">Gets a <see cref="T:System.Type" /> object that represents the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-2270">Возвращает текущий <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2270">Gets the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-2271">Текущий контекст <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2271">The current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="95a33-2272">Инициализатор класса вызывается и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-2272">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="95a33-2273">Указание полных имен типов</span><span class="sxs-lookup"><span data-stu-id="95a33-2273">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="95a33-2274">Имя искомого типа с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2274">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="95a33-2275">См. раздел <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2275">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="95a33-2276">Если тип находится в выполняемой в данный момент сборке или библиотеке Mscorlib.dll, достаточно предоставить имя типа с указанием пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-2276">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <summary><span data-ttu-id="95a33-2277">Возвращает объект <see cref="T:System.Type" /> с указанным именем, учитывая при поиске регистр.</span><span class="sxs-lookup"><span data-stu-id="95a33-2277">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="95a33-2278">Тип с указанным именем, если он существует; в противном случае — значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2278">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-2279">Можно использовать метод <xref:System.Type.GetType%2A> для получения объекта <xref:System.Type> для типа в другой сборке, если известно его полное имя, которое можно получить из <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2279">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="95a33-2280"><xref:System.Type.GetType%2A> вызывает загрузку сборки, указанной в `typeName`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2280"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="95a33-2281">Сборку также можно загрузить с помощью метода <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, а затем использовать метод <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> для получения объектов <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2281">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="95a33-2282">Если тип находится в сборке, известной для программы во время компиляции, более эффективно использовать `typeof` в C# или оператор `GetType` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="95a33-2282">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="95a33-2283">Если не удается найти `typeName`, вызов метода <xref:System.Type.GetType%28System.String%29> возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2283">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`.</span></span> <span data-ttu-id="95a33-2284">Исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="95a33-2284">It does not throw an exception.</span></span> <span data-ttu-id="95a33-2285">Чтобы управлять тем, возникает ли исключение, вызовите перегрузку метода <xref:System.Type.GetType%2A>, имеющего параметр `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2285">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="95a33-2286"><xref:System.Type.GetType%2A> работает только с сборками, загруженными с диска.</span><span class="sxs-lookup"><span data-stu-id="95a33-2286"><xref:System.Type.GetType%2A> only works on assemblies loaded from disk.</span></span> <span data-ttu-id="95a33-2287">При вызове <xref:System.Type.GetType%2A> для поиска типа, определенного в динамической сборке, определенной с помощью служб <xref:System.Reflection.Emit>, может возникнуть несоответствие поведения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2287">If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="95a33-2288">Поведение зависит от того, является ли динамическая сборка постоянной, то есть, созданной с использованием `RunAndSave` или `Save` режимов доступа перечисления <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2288">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="95a33-2289">Если динамическая сборка является постоянной и записывается на диск до вызова `GetType`, загрузчик находит сохраненную сборку на диске, загружает эту сборку и получает тип из этой сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2289">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="95a33-2290">Если сборка не была сохранена на диск при вызове `GetType`, метод возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2290">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="95a33-2291">`GetType` не распознает временные динамические сборки; Таким образом, вызов `GetType` для получения типа во временной динамической сборке возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2291">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="95a33-2292">Чтобы использовать `GetType` в динамическом модуле, подпишитесь на событие <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> и вызовите `GetType` перед сохранением.</span><span class="sxs-lookup"><span data-stu-id="95a33-2292">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="95a33-2293">В противном случае в памяти будут выводится две копии сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2293">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="95a33-2294">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-2294">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-2295">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-2295">Member Type</span></span>|<span data-ttu-id="95a33-2296">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-2296">Static</span></span>|<span data-ttu-id="95a33-2297">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-2297">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-2298">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-2298">Constructor</span></span>|<span data-ttu-id="95a33-2299">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2299">No</span></span>|<span data-ttu-id="95a33-2300">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2300">No</span></span>|  
|<span data-ttu-id="95a33-2301">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-2301">Field</span></span>|<span data-ttu-id="95a33-2302">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2302">No</span></span>|<span data-ttu-id="95a33-2303">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-2303">Yes.</span></span> <span data-ttu-id="95a33-2304">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2304">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-2305">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-2305">Event</span></span>|<span data-ttu-id="95a33-2306">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-2306">Not applicable</span></span>|<span data-ttu-id="95a33-2307">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2307">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-2308">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2308">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-2309">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-2309">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-2310">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-2310">Method</span></span>|<span data-ttu-id="95a33-2311">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2311">No</span></span>|<span data-ttu-id="95a33-2312">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-2312">Yes.</span></span> <span data-ttu-id="95a33-2313">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2313">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-2314">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-2314">Nested Type</span></span>|<span data-ttu-id="95a33-2315">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2315">No</span></span>|<span data-ttu-id="95a33-2316">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2316">No</span></span>|  
|<span data-ttu-id="95a33-2317">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2317">Property</span></span>|<span data-ttu-id="95a33-2318">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-2318">Not applicable</span></span>|<span data-ttu-id="95a33-2319">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2319">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-2320">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2320">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-2321">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-2321">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-2322">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-2322">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-2323">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-2323">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-2324">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2324">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-2325">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-2325">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-2326">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2326">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-2327">Поиск в массивах или типах COM не выполняется, если они еще не загружены в таблицу доступных классов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2327">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="95a33-2328">`typeName` может быть именем типа, дополненным его пространством имен или именем сборки, которое включает спецификацию имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2328">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="95a33-2329">См. раздел <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2329">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="95a33-2330">Если `typeName` включает пространство имен, но не имя сборки, этот метод выполняет поиск только в сборке вызывающего объекта и mscorlib. dll в указанном порядке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2330">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="95a33-2331">Если typeName имеет полное имя с частичным или полным именем сборки, этот метод выполняет поиск в указанной сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2331">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="95a33-2332">Если сборка имеет строгое имя, требуется полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2332">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="95a33-2333">Свойство <xref:System.Type.AssemblyQualifiedName%2A> возвращает полное имя типа, включая вложенные типы, имя сборки и аргументы универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2333">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</span></span> <span data-ttu-id="95a33-2334">Все компиляторы, поддерживающие среду CLR, будут выдавать простое имя вложенного класса, а отражение при запросе создает искаженное имя в соответствии со следующими соглашениями.</span><span class="sxs-lookup"><span data-stu-id="95a33-2334">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-2335">В .NET Framework версии 2,0 архитектура процессора добавляется в удостоверение сборки и может быть указана в качестве части строк имен сборок.</span><span class="sxs-lookup"><span data-stu-id="95a33-2335">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="95a33-2336">Например, "ProcessorArchitecture = MSIL".</span><span class="sxs-lookup"><span data-stu-id="95a33-2336">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="95a33-2337">Однако он не включается в строку, возвращенную свойством <xref:System.Type.AssemblyQualifiedName%2A>, по причинам совместимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-2337">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="95a33-2338">Можно также загрузить типы, создав объект <xref:System.Reflection.AssemblyName> и передав его в соответствующую перегрузку метода <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2338">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="95a33-2339">Затем можно использовать метод <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> для загрузки типов из сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2339">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="95a33-2340">См. также раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2340">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="95a33-2341">Разделитель</span><span class="sxs-lookup"><span data-stu-id="95a33-2341">Delimiter</span></span>|<span data-ttu-id="95a33-2342">Значение</span><span class="sxs-lookup"><span data-stu-id="95a33-2342">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="95a33-2343">Обратная косая черта (\\)</span><span class="sxs-lookup"><span data-stu-id="95a33-2343">Backslash (\\)</span></span>|<span data-ttu-id="95a33-2344">Escape-символ.</span><span class="sxs-lookup"><span data-stu-id="95a33-2344">Escape character.</span></span>|  
|<span data-ttu-id="95a33-2345">Обратная кавычка (')</span><span class="sxs-lookup"><span data-stu-id="95a33-2345">Backtick (\`)</span></span>|<span data-ttu-id="95a33-2346">Предшествует одной или нескольким цифрам, представляющим количество параметров типа, расположенных в конце имени универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2346">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="95a33-2347">Квадратные скобки ([])</span><span class="sxs-lookup"><span data-stu-id="95a33-2347">Brackets ([])</span></span>|<span data-ttu-id="95a33-2348">Заключите список аргументов универсального типа для сконструированного универсального типа. в списке аргументов типа заключите тип, квалифицированный сборкой.</span><span class="sxs-lookup"><span data-stu-id="95a33-2348">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="95a33-2349">Запятая (,)</span><span class="sxs-lookup"><span data-stu-id="95a33-2349">Comma (,)</span></span>|<span data-ttu-id="95a33-2350">Предшествует имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2350">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="95a33-2351">Точка (.)</span><span class="sxs-lookup"><span data-stu-id="95a33-2351">Period (.)</span></span>|<span data-ttu-id="95a33-2352">Обозначает идентификаторы пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-2352">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="95a33-2353">Знак плюса (+)</span><span class="sxs-lookup"><span data-stu-id="95a33-2353">Plus sign (+)</span></span>|<span data-ttu-id="95a33-2354">Предшествует вложенному классу.</span><span class="sxs-lookup"><span data-stu-id="95a33-2354">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="95a33-2355">Например, полное имя класса может выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-2355">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="95a33-2356">Если пространство имен было Топнамеспаце. Re+ Namespace, строка должна предшествовать знаку плюс (+) с escape-символом (\\), чтобы предотвратить его интерпретацию как разделитель вложения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2356">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="95a33-2357">Отражение выдает эту строку следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-2357">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="95a33-2358">"+ +" Преобразуется в "\\+\\+", а "\\" преобразуется в "\\\\".</span><span class="sxs-lookup"><span data-stu-id="95a33-2358">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="95a33-2359">Это полное имя можно сохранить и позже использовать для загрузки <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2359">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="95a33-2360">Чтобы найти и загрузить <xref:System.Type>, используйте <xref:System.Type.GetType%2A> либо с именем типа, либо с полным именем типа сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2360">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="95a33-2361"><xref:System.Type.GetType%2A> с именем типа будет искать только <xref:System.Type> в сборке вызывающего объекта, а затем в системной сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2361"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="95a33-2362"><xref:System.Type.GetType%2A> с полным именем типа сборки будет искать <xref:System.Type> в любой сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2362"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="95a33-2363">Имена типов могут содержать конечные символы, которые обозначают дополнительные сведения о типе, например, является ли тип ссылочным типом, типом указателя или типом массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-2363">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="95a33-2364">Чтобы получить имя типа без этих замыкающих символов, используйте `t.GetElementType().ToString()`, где `t` — это тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-2364">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="95a33-2365">Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2365">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="95a33-2366">В имени сборки учитываются пробелы перед разделителем ",", но пробелы после разделителя "," игнорируются.</span><span class="sxs-lookup"><span data-stu-id="95a33-2366">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="95a33-2367">Имя универсального типа заканчивается обратным импульсом (\`), за которым следуют цифры, представляющие число аргументов универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2367">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="95a33-2368">Такое искажение имени позволяет компиляторам поддерживать универсальные типы с тем же именем, но с разными числами параметров типа, происходящих в одной области.</span><span class="sxs-lookup"><span data-stu-id="95a33-2368">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="95a33-2369">Например, отражение возвращает искаженные имена `Tuple`1` and `кортеж`2` из универсальных методов `Tuple(Of T)` и `Tuple(Of T0, T1)` в Visual Basic или `Tuple<T>` и`\<T0, T1>` кортежа в Visual C#.</span><span class="sxs-lookup"><span data-stu-id="95a33-2369">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="95a33-2370">Для универсальных типов список аргументов типа заключается в квадратные скобки, а аргументы типа разделяются запятыми.</span><span class="sxs-lookup"><span data-stu-id="95a33-2370">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="95a33-2371">Например, универсальный <xref:System.Collections.Generic.Dictionary%602> имеет два параметра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2371">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="95a33-2372"><xref:System.Collections.Generic.Dictionary%602> `MyType` с ключами типа <xref:System.String> могут быть представлены следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-2372">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="95a33-2373">Чтобы указать тип с указанием сборки в списке аргументов типа, заключите тип сборки в квадратные скобки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2373">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="95a33-2374">В противном случае запятые, разделяющие части имени с указанием сборки, будут интерпретироваться как разделители дополнительных аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2374">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="95a33-2375">Например, <xref:System.Collections.Generic.Dictionary%602> `MyType` Фроммяссембли. dll с ключами типа <xref:System.String>можно указать следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-2375">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="95a33-2376">Тип с указанием сборки может быть заключен в квадратные скобки только в том случае, если он присутствует в списке параметров типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2376">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="95a33-2377">Правила поиска сборок для полных и неквалифицированных типов в списках параметров типов совпадают с правилами для полных и неполных неуниверсальных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2377">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="95a33-2378">Типы, допускающие значение null, являются особым случаем универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2378">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="95a33-2379">Например, <xref:System.Int32> Nullable представляется строкой "System. Nullable" 1 [System. Int32] ".</span><span class="sxs-lookup"><span data-stu-id="95a33-2379">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-2380">В C#, C++и Visual Basic можно также получить типы, допускающие значение null, с помощью операторов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2380">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="95a33-2381">Например, тип <xref:System.Boolean>, допускающего значение null, возвращается `typeof(Nullable<bool>)` C#в, с помощью C++`Nullable<Boolean>::typeid` в и `GetType(Nullable(Of Boolean))` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="95a33-2381">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="95a33-2382">В следующей таблице показан синтаксис, используемый с `GetType` для различных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2382">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="95a33-2383">Для получения</span><span class="sxs-lookup"><span data-stu-id="95a33-2383">To Get</span></span>|<span data-ttu-id="95a33-2384">Использовать</span><span class="sxs-lookup"><span data-stu-id="95a33-2384">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="95a33-2385"><xref:System.Int32> Nullable</span><span class="sxs-lookup"><span data-stu-id="95a33-2385">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="95a33-2386">Неуправляемый указатель на `MyType`</span><span class="sxs-lookup"><span data-stu-id="95a33-2386">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="95a33-2387">Неуправляемый указатель на указатель на `MyType`</span><span class="sxs-lookup"><span data-stu-id="95a33-2387">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="95a33-2388">Управляемый указатель или ссылка на `MyType`</span><span class="sxs-lookup"><span data-stu-id="95a33-2388">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="95a33-2389">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2389">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="95a33-2390">Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.</span><span class="sxs-lookup"><span data-stu-id="95a33-2390">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="95a33-2391">Родительский класс и вложенный класс</span><span class="sxs-lookup"><span data-stu-id="95a33-2391">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="95a33-2392">Одномерный массив с нижней границей 0</span><span class="sxs-lookup"><span data-stu-id="95a33-2392">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyType[]")`|  
|<span data-ttu-id="95a33-2393">Одномерный массив с неизвестной нижней границей</span><span class="sxs-lookup"><span data-stu-id="95a33-2393">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyType[*]")`|  
|<span data-ttu-id="95a33-2394">N-мерный массив</span><span class="sxs-lookup"><span data-stu-id="95a33-2394">An n-dimensional array</span></span>|<span data-ttu-id="95a33-2395">Запятая (,) внутри квадратных скобок, всего n – 1 раз.</span><span class="sxs-lookup"><span data-stu-id="95a33-2395">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="95a33-2396">Например, `System.Object[,,]` представляет трехмерный массив `Object`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2396">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="95a33-2397">Массив одномерных массивов</span><span class="sxs-lookup"><span data-stu-id="95a33-2397">An array of one-dimensional arrays</span></span>|`Type.GetType("MyType[][]")`|  
|<span data-ttu-id="95a33-2398">Прямоугольный двухмерный массив с неизвестными нижними границами</span><span class="sxs-lookup"><span data-stu-id="95a33-2398">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyType[,]")`|  
|<span data-ttu-id="95a33-2399">Универсальный тип с одним аргументом типа</span><span class="sxs-lookup"><span data-stu-id="95a33-2399">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="95a33-2400">Универсальный тип с двумя аргументами типа</span><span class="sxs-lookup"><span data-stu-id="95a33-2400">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="95a33-2401">Универсальный тип с двумя аргументами типа с указанием сборки</span><span class="sxs-lookup"><span data-stu-id="95a33-2401">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="95a33-2402">Квалифицированный в сборке универсальный тип с аргументом типа сборки</span><span class="sxs-lookup"><span data-stu-id="95a33-2402">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="95a33-2403">Универсальный тип, аргумент типа которого является универсальным типом с двумя аргументами типа</span><span class="sxs-lookup"><span data-stu-id="95a33-2403">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 <span data-ttu-id="95a33-2404">В следующем примере извлекается тип `System.Int32` и используется этот объект типа для вывода свойства <xref:System.Type.FullName%2A> `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2404">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2405">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2405"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="95a33-2406">Инициализатор класса вызывается и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-2406">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-2407"><paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2407"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="95a33-2408">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2408">-or-</span></span> 
 <span data-ttu-id="95a33-2409"><paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2409"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="95a33-2410">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2410">-or-</span></span> 
 <span data-ttu-id="95a33-2411"><paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2411"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="95a33-2412"><paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2412"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="95a33-2413">Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2413">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="95a33-2414">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</span><span class="sxs-lookup"><span data-stu-id="95a33-2414">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="95a33-2415">Сборка или одна из ее зависимостей является недопустимой.</span><span class="sxs-lookup"><span data-stu-id="95a33-2415">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="95a33-2416">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2416">-or-</span></span>  
  
 <span data-ttu-id="95a33-2417">В текущий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка была скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="95a33-2417">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="95a33-2418">Указание полных имен типов</span><span class="sxs-lookup"><span data-stu-id="95a33-2418">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="95a33-2419">Имя искомого типа с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2419">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="95a33-2420">См. раздел <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2420">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="95a33-2421">Если тип находится в выполняемой в данный момент сборке или библиотеке Mscorlib.dll, достаточно предоставить имя типа с указанием пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-2421">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="95a33-2422">Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2422"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="95a33-2423">Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них.</span><span class="sxs-lookup"><span data-stu-id="95a33-2423">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="95a33-2424">См. раздел "Исключения".</span><span class="sxs-lookup"><span data-stu-id="95a33-2424">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="95a33-2425">Возвращает объект <see cref="T:System.Type" /> с заданным именем, выполняя поиск с учетом регистра и указывая, будет ли создаваться исключение в случае невозможности найти тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-2425">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="95a33-2426">Тип с указанным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-2426">The type with the specified name.</span></span> <span data-ttu-id="95a33-2427">Если тип не найден, параметр <paramref name="throwOnError" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2427">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="95a33-2428">В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2428">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="95a33-2429">См. раздел "Исключения".</span><span class="sxs-lookup"><span data-stu-id="95a33-2429">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-2430">Можно использовать метод <xref:System.Type.GetType%2A> для получения объекта <xref:System.Type> для типа в другой сборке, если известно его полное имя, которое можно получить из <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2430">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="95a33-2431"><xref:System.Type.GetType%2A> вызывает загрузку сборки, указанной в `typeName`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2431"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="95a33-2432">Сборку также можно загрузить с помощью метода <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, а затем использовать метод <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> для получения объектов <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2432">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="95a33-2433">Если тип находится в сборке, известной для программы во время компиляции, более эффективно использовать `typeof` в C# или оператор `GetType` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="95a33-2433">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
 <span data-ttu-id="95a33-2434">`GetType` работает только с сборками, загруженными с диска.</span><span class="sxs-lookup"><span data-stu-id="95a33-2434">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="95a33-2435">При вызове `GetType` для поиска типа, определенного в динамической сборке, определенной с помощью служб <xref:System.Reflection.Emit>, может возникнуть несоответствие поведения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2435">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="95a33-2436">Поведение зависит от того, является ли динамическая сборка постоянной, то есть, созданной с использованием `RunAndSave` или `Save` режимов доступа перечисления <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2436">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="95a33-2437">Если динамическая сборка является постоянной и записывается на диск до вызова `GetType`, загрузчик находит сохраненную сборку на диске, загружает эту сборку и получает тип из этой сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2437">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="95a33-2438">Если сборка не была сохранена на диск при вызове `GetType`, метод возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2438">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="95a33-2439">`GetType` не распознает временные динамические сборки; Таким образом, вызов `GetType` для получения типа во временной динамической сборке возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2439">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="95a33-2440">Чтобы использовать `GetType` в динамическом модуле, подпишитесь на событие <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> и вызовите `GetType` перед сохранением.</span><span class="sxs-lookup"><span data-stu-id="95a33-2440">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="95a33-2441">В противном случае в памяти будут выводится две копии сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2441">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="95a33-2442">Параметр `throwOnError` указывает, что происходит, если тип не найден, а также подавляет некоторые другие условия исключения, как описано в разделе исключения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2442">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="95a33-2443">Некоторые исключения создаются независимо от значения `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2443">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="95a33-2444">Например, если тип найден, но не может быть загружен, создается <xref:System.TypeLoadException>, даже если `throwOnError` `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2444">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="95a33-2445">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-2445">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-2446">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-2446">Member Type</span></span>|<span data-ttu-id="95a33-2447">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-2447">Static</span></span>|<span data-ttu-id="95a33-2448">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-2448">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-2449">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-2449">Constructor</span></span>|<span data-ttu-id="95a33-2450">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2450">No</span></span>|<span data-ttu-id="95a33-2451">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2451">No</span></span>|  
|<span data-ttu-id="95a33-2452">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-2452">Field</span></span>|<span data-ttu-id="95a33-2453">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2453">No</span></span>|<span data-ttu-id="95a33-2454">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-2454">Yes.</span></span> <span data-ttu-id="95a33-2455">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2455">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-2456">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-2456">Event</span></span>|<span data-ttu-id="95a33-2457">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-2457">Not applicable</span></span>|<span data-ttu-id="95a33-2458">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2458">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-2459">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2459">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-2460">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-2460">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-2461">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-2461">Method</span></span>|<span data-ttu-id="95a33-2462">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2462">No</span></span>|<span data-ttu-id="95a33-2463">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-2463">Yes.</span></span> <span data-ttu-id="95a33-2464">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2464">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-2465">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-2465">Nested Type</span></span>|<span data-ttu-id="95a33-2466">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2466">No</span></span>|<span data-ttu-id="95a33-2467">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2467">No</span></span>|  
|<span data-ttu-id="95a33-2468">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2468">Property</span></span>|<span data-ttu-id="95a33-2469">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-2469">Not applicable</span></span>|<span data-ttu-id="95a33-2470">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2470">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-2471">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2471">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-2472">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-2472">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-2473">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-2473">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-2474">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-2474">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-2475">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2475">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-2476">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-2476">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-2477">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2477">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-2478">Поиск в массивах или типах COM не выполняется, если они еще не загружены в таблицу доступных классов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2478">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="95a33-2479">`typeName` может быть именем типа, дополненным его пространством имен или именем сборки, которое включает спецификацию имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2479">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="95a33-2480">См. раздел <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2480">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="95a33-2481">Если `typeName` включает пространство имен, но не имя сборки, этот метод выполняет поиск только в сборке вызывающего объекта и mscorlib. dll в указанном порядке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2481">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="95a33-2482">Если typeName имеет полное имя с частичным или полным именем сборки, этот метод выполняет поиск в указанной сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2482">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="95a33-2483">Если сборка имеет строгое имя, требуется полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2483">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="95a33-2484">Свойство <xref:System.Type.AssemblyQualifiedName%2A> возвращает полное имя типа, включая вложенные типы, имя сборки и универсальные аргументы.</span><span class="sxs-lookup"><span data-stu-id="95a33-2484">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</span></span> <span data-ttu-id="95a33-2485">Все компиляторы, поддерживающие среду CLR, будут выдавать простое имя вложенного класса, а отражение при запросе создает искаженное имя в соответствии со следующими соглашениями.</span><span class="sxs-lookup"><span data-stu-id="95a33-2485">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-2486">В .NET Framework версии 2,0 архитектура процессора добавляется в удостоверение сборки и может быть указана в качестве части строк имен сборок.</span><span class="sxs-lookup"><span data-stu-id="95a33-2486">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="95a33-2487">Например, "ProcessorArchitecture = MSIL".</span><span class="sxs-lookup"><span data-stu-id="95a33-2487">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="95a33-2488">Однако он не включается в строку, возвращенную свойством <xref:System.Type.AssemblyQualifiedName%2A>, по причинам совместимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-2488">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="95a33-2489">Можно также загрузить типы, создав объект <xref:System.Reflection.AssemblyName> и передав его в соответствующую перегрузку метода <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2489">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="95a33-2490">Затем можно использовать метод <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> для загрузки типов из сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2490">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="95a33-2491">См. также раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2491">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="95a33-2492">Разделитель</span><span class="sxs-lookup"><span data-stu-id="95a33-2492">Delimiter</span></span>|<span data-ttu-id="95a33-2493">Значение</span><span class="sxs-lookup"><span data-stu-id="95a33-2493">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="95a33-2494">Обратная косая черта (\\)</span><span class="sxs-lookup"><span data-stu-id="95a33-2494">Backslash (\\)</span></span>|<span data-ttu-id="95a33-2495">Escape-символ.</span><span class="sxs-lookup"><span data-stu-id="95a33-2495">Escape character.</span></span>|  
|<span data-ttu-id="95a33-2496">Обратная кавычка (')</span><span class="sxs-lookup"><span data-stu-id="95a33-2496">Backtick (\`)</span></span>|<span data-ttu-id="95a33-2497">Предшествует одной или нескольким цифрам, представляющим количество параметров типа, расположенных в конце имени универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2497">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="95a33-2498">Квадратные скобки ([])</span><span class="sxs-lookup"><span data-stu-id="95a33-2498">Brackets ([])</span></span>|<span data-ttu-id="95a33-2499">Заключите список аргументов универсального типа для сконструированного универсального типа. в списке аргументов типа заключите тип, квалифицированный сборкой.</span><span class="sxs-lookup"><span data-stu-id="95a33-2499">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="95a33-2500">Запятая (,)</span><span class="sxs-lookup"><span data-stu-id="95a33-2500">Comma (,)</span></span>|<span data-ttu-id="95a33-2501">Предшествует имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2501">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="95a33-2502">Точка (.)</span><span class="sxs-lookup"><span data-stu-id="95a33-2502">Period (.)</span></span>|<span data-ttu-id="95a33-2503">Обозначает идентификаторы пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-2503">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="95a33-2504">Знак плюса (+)</span><span class="sxs-lookup"><span data-stu-id="95a33-2504">Plus sign (+)</span></span>|<span data-ttu-id="95a33-2505">Предшествует вложенному классу.</span><span class="sxs-lookup"><span data-stu-id="95a33-2505">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="95a33-2506">Например, полное имя класса может выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-2506">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="95a33-2507">Если пространство имен было Топнамеспаце. Re+ Namespace, строка должна предшествовать знаку плюс (+) с escape-символом (\\), чтобы предотвратить его интерпретацию как разделитель вложения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2507">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="95a33-2508">Отражение выдает эту строку следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-2508">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="95a33-2509">"+ +" Преобразуется в "\\+\\+", а "\\" преобразуется в "\\\\".</span><span class="sxs-lookup"><span data-stu-id="95a33-2509">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="95a33-2510">Это полное имя можно сохранить и позже использовать для загрузки <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2510">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="95a33-2511">Чтобы найти и загрузить <xref:System.Type>, используйте <xref:System.Type.GetType%2A> либо с именем типа, либо с полным именем типа сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2511">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="95a33-2512"><xref:System.Type.GetType%2A> с именем типа будет искать только <xref:System.Type> в сборке вызывающего объекта, а затем в системной сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2512"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="95a33-2513"><xref:System.Type.GetType%2A> с полным именем типа сборки будет искать <xref:System.Type> в любой сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2513"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="95a33-2514">Имена типов могут содержать конечные символы, которые обозначают дополнительные сведения о типе, например, является ли тип ссылочным типом, типом указателя или типом массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-2514">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="95a33-2515">Чтобы получить имя типа без этих замыкающих символов, используйте `t.GetElementType().ToString()`, где `t` — это тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-2515">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="95a33-2516">Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2516">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="95a33-2517">В имени сборки учитываются пробелы перед разделителем ",", но пробелы после разделителя "," игнорируются.</span><span class="sxs-lookup"><span data-stu-id="95a33-2517">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="95a33-2518">Имя универсального типа заканчивается обратным импульсом (\`), за которым следуют цифры, представляющие число аргументов универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2518">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="95a33-2519">Такое искажение имени позволяет компиляторам поддерживать универсальные типы с тем же именем, но с разными числами параметров типа, происходящих в одной области.</span><span class="sxs-lookup"><span data-stu-id="95a33-2519">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="95a33-2520">Например, отражение возвращает искаженные имена `Tuple`1` and `кортеж`2` из универсальных методов `Tuple(Of T)` и `Tuple(Of T0, T1)` в Visual Basic или `Tuple<T>` и`\<T0, T1>` кортежа в Visual C#.</span><span class="sxs-lookup"><span data-stu-id="95a33-2520">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="95a33-2521">Для универсальных типов список аргументов типа заключается в квадратные скобки, а аргументы типа разделяются запятыми.</span><span class="sxs-lookup"><span data-stu-id="95a33-2521">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="95a33-2522">Например, универсальный <xref:System.Collections.Generic.Dictionary%602> имеет два параметра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2522">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="95a33-2523"><xref:System.Collections.Generic.Dictionary%602> `MyType` с ключами типа <xref:System.String> могут быть представлены следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-2523">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="95a33-2524">Чтобы указать тип с указанием сборки в списке аргументов типа, заключите тип сборки в квадратные скобки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2524">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="95a33-2525">В противном случае запятые, разделяющие части имени с указанием сборки, будут интерпретироваться как разделители дополнительных аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2525">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="95a33-2526">Например, <xref:System.Collections.Generic.Dictionary%602> `MyType` из MyAssembly. dll с ключами типа <xref:System.String>можно указать следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-2526">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="95a33-2527">Тип с указанием сборки может быть заключен в квадратные скобки только в том случае, если он присутствует в списке параметров типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2527">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="95a33-2528">Правила поиска сборок для полных и неквалифицированных типов в списках параметров типов совпадают с правилами для полных и неполных неуниверсальных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2528">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="95a33-2529">Типы, допускающие значение null, являются особым случаем универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2529">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="95a33-2530">Например, <xref:System.Int32> Nullable представляется строкой "System. Nullable" 1 [System. Int32] ".</span><span class="sxs-lookup"><span data-stu-id="95a33-2530">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-2531">В C#, C++и Visual Basic можно также получить типы, допускающие значение null, с помощью операторов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2531">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="95a33-2532">Например, тип <xref:System.Boolean>, допускающего значение null, возвращается `typeof(Nullable<bool>)` C#в, с помощью C++`Nullable<Boolean>::typeid` в и `GetType(Nullable(Of Boolean))` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="95a33-2532">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="95a33-2533">В следующей таблице показан синтаксис, используемый с `GetType` для различных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2533">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="95a33-2534">Для получения</span><span class="sxs-lookup"><span data-stu-id="95a33-2534">To Get</span></span>|<span data-ttu-id="95a33-2535">Использовать</span><span class="sxs-lookup"><span data-stu-id="95a33-2535">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="95a33-2536"><xref:System.Int32> Nullable</span><span class="sxs-lookup"><span data-stu-id="95a33-2536">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="95a33-2537">Неуправляемый указатель на `MyType`</span><span class="sxs-lookup"><span data-stu-id="95a33-2537">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="95a33-2538">Неуправляемый указатель на указатель на `MyType`</span><span class="sxs-lookup"><span data-stu-id="95a33-2538">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="95a33-2539">Управляемый указатель или ссылка на `MyType`</span><span class="sxs-lookup"><span data-stu-id="95a33-2539">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="95a33-2540">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2540">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="95a33-2541">Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.</span><span class="sxs-lookup"><span data-stu-id="95a33-2541">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="95a33-2542">Родительский класс и вложенный класс</span><span class="sxs-lookup"><span data-stu-id="95a33-2542">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="95a33-2543">Одномерный массив с нижней границей 0</span><span class="sxs-lookup"><span data-stu-id="95a33-2543">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="95a33-2544">Одномерный массив с неизвестной нижней границей</span><span class="sxs-lookup"><span data-stu-id="95a33-2544">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="95a33-2545">N-мерный массив</span><span class="sxs-lookup"><span data-stu-id="95a33-2545">An n-dimensional array</span></span>|<span data-ttu-id="95a33-2546">Запятая (,) внутри квадратных скобок, всего n – 1 раз.</span><span class="sxs-lookup"><span data-stu-id="95a33-2546">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="95a33-2547">Например, `System.Object[,,]` представляет трехмерный массив `Object`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2547">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="95a33-2548">Массив двумерных массивов</span><span class="sxs-lookup"><span data-stu-id="95a33-2548">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="95a33-2549">Прямоугольный двухмерный массив с неизвестными нижними границами</span><span class="sxs-lookup"><span data-stu-id="95a33-2549">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="95a33-2550">Универсальный тип с одним аргументом типа</span><span class="sxs-lookup"><span data-stu-id="95a33-2550">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="95a33-2551">Универсальный тип с двумя аргументами типа</span><span class="sxs-lookup"><span data-stu-id="95a33-2551">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="95a33-2552">Универсальный тип с двумя аргументами типа с указанием сборки</span><span class="sxs-lookup"><span data-stu-id="95a33-2552">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="95a33-2553">Квалифицированный в сборке универсальный тип с аргументом типа сборки</span><span class="sxs-lookup"><span data-stu-id="95a33-2553">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="95a33-2554">Универсальный тип, аргумент типа которого является универсальным типом с двумя аргументами типа</span><span class="sxs-lookup"><span data-stu-id="95a33-2554">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 <span data-ttu-id="95a33-2555">В следующем примере извлекается тип `System.Int32` и используется этот объект типа для вывода свойства <xref:System.Type.FullName%2A> `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2555">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span> <span data-ttu-id="95a33-2556">Если объект типа ссылается на несуществующую сборку, в этом примере создается исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-2556">If a type object refers to an assembly that does not exist, this example throws an exception.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2557">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2557"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="95a33-2558">Инициализатор класса вызывается и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-2558">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="95a33-2559"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и тип не найден.</span><span class="sxs-lookup"><span data-stu-id="95a33-2559"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="95a33-2560">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2560">-or-</span></span> 
 <span data-ttu-id="95a33-2561"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции.</span><span class="sxs-lookup"><span data-stu-id="95a33-2561"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="95a33-2562">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2562">-or-</span></span> 
 <span data-ttu-id="95a33-2563"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.</span><span class="sxs-lookup"><span data-stu-id="95a33-2563"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="95a33-2564">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2564">-or-</span></span> 
 <span data-ttu-id="95a33-2565"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.</span><span class="sxs-lookup"><span data-stu-id="95a33-2565"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="95a33-2566">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2566">-or-</span></span> 
 <span data-ttu-id="95a33-2567"><paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2567"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-2568"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис.</span><span class="sxs-lookup"><span data-stu-id="95a33-2568"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="95a33-2569">Например, "MyType[,\*,]".</span><span class="sxs-lookup"><span data-stu-id="95a33-2569">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="95a33-2570">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2570">-or-</span></span> 
 <span data-ttu-id="95a33-2571"><paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2571"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="95a33-2572">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2572">-or-</span></span> 
 <span data-ttu-id="95a33-2573"><paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2573"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="95a33-2574">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2574">-or-</span></span> 
 <span data-ttu-id="95a33-2575"><paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2575"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="95a33-2576"><paramref name="throwOnError" /> имеет значение <see langword="true" /> , и не удалось найти сборку либо одну из ее зависимостей.</span><span class="sxs-lookup"><span data-stu-id="95a33-2576"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="95a33-2577">Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2577">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="95a33-2578">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</span><span class="sxs-lookup"><span data-stu-id="95a33-2578">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="95a33-2579">Сборка или одна из ее зависимостей является недопустимой.</span><span class="sxs-lookup"><span data-stu-id="95a33-2579">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="95a33-2580">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2580">-or-</span></span>  
  
 <span data-ttu-id="95a33-2581">В текущий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка была скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="95a33-2581">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="95a33-2582">Указание полных имен типов</span><span class="sxs-lookup"><span data-stu-id="95a33-2582">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="95a33-2583">Имя искомого типа с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2583">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="95a33-2584">См. раздел <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2584">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="95a33-2585">Если тип находится в выполняемой в данный момент сборке или библиотеке Mscorlib.dll, достаточно предоставить имя типа с указанием пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-2585">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="95a33-2586">Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2586"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="95a33-2587">Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них.</span><span class="sxs-lookup"><span data-stu-id="95a33-2587">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="95a33-2588">См. раздел "Исключения".</span><span class="sxs-lookup"><span data-stu-id="95a33-2588">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="95a33-2589">Значение <see langword="true" />, чтобы не учитывать регистр при поиске <paramref name="typeName" />, значение <see langword="false" />, чтобы учитывать регистр при поиске <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2589"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="95a33-2590">Возвращает объект <see cref="T:System.Type" /> с указанным именем, позволяющий определить, будет ли создаваться исключение в случае невозможности найти тип и будет ли учитываться регистр при поиске.</span><span class="sxs-lookup"><span data-stu-id="95a33-2590">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="95a33-2591">Тип с указанным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-2591">The type with the specified name.</span></span> <span data-ttu-id="95a33-2592">Если тип не найден, параметр <paramref name="throwOnError" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2592">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="95a33-2593">В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2593">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="95a33-2594">См. раздел "Исключения".</span><span class="sxs-lookup"><span data-stu-id="95a33-2594">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-2595">Можно использовать метод <xref:System.Type.GetType%2A> для получения объекта <xref:System.Type> для типа в другой сборке, если известно его полное имя, которое можно получить из <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2595">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="95a33-2596"><xref:System.Type.GetType%2A> вызывает загрузку сборки, указанной в `typeName`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2596"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="95a33-2597">Сборку также можно загрузить с помощью метода <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, а затем использовать метод <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> для получения объектов <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2597">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="95a33-2598">Если тип находится в сборке, известной для программы во время компиляции, более эффективно использовать `typeof` в C# или оператор `GetType` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="95a33-2598">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
 <span data-ttu-id="95a33-2599">`GetType` работает только с сборками, загруженными с диска.</span><span class="sxs-lookup"><span data-stu-id="95a33-2599">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="95a33-2600">При вызове `GetType` для поиска типа, определенного в динамической сборке, определенной с помощью служб <xref:System.Reflection.Emit>, может возникнуть несоответствие поведения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2600">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="95a33-2601">Поведение зависит от того, является ли динамическая сборка постоянной, то есть, созданной с использованием `RunAndSave` или `Save` режимов доступа перечисления <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2601">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="95a33-2602">Если динамическая сборка является постоянной и записывается на диск до вызова `GetType`, загрузчик находит сохраненную сборку на диске, загружает эту сборку и получает тип из этой сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2602">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="95a33-2603">Если сборка не была сохранена на диск при вызове `GetType`, метод возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2603">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="95a33-2604">`GetType` не распознает временные динамические сборки; Таким образом, вызов `GetType` для получения типа во временной динамической сборке возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2604">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="95a33-2605">Чтобы использовать `GetType` в динамическом модуле, подпишитесь на событие <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> и вызовите `GetType` перед сохранением.</span><span class="sxs-lookup"><span data-stu-id="95a33-2605">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="95a33-2606">В противном случае в памяти будут выводится две копии сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2606">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="95a33-2607">Параметр `throwOnError` указывает, что происходит, если тип не найден, а также подавляет некоторые другие условия исключения, как описано в разделе исключения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2607">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="95a33-2608">Некоторые исключения создаются независимо от значения `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2608">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="95a33-2609">Например, если тип найден, но не может быть загружен, создается <xref:System.TypeLoadException>, даже если `throwOnError` `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2609">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="95a33-2610">В следующей таблице показаны элементы базового класса, возвращаемые методами `Get` при отражении в типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-2610">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="95a33-2611">Тип члена</span><span class="sxs-lookup"><span data-stu-id="95a33-2611">Member Type</span></span>|<span data-ttu-id="95a33-2612">Статические</span><span class="sxs-lookup"><span data-stu-id="95a33-2612">Static</span></span>|<span data-ttu-id="95a33-2613">Не статический</span><span class="sxs-lookup"><span data-stu-id="95a33-2613">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="95a33-2614">Конструктор</span><span class="sxs-lookup"><span data-stu-id="95a33-2614">Constructor</span></span>|<span data-ttu-id="95a33-2615">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2615">No</span></span>|<span data-ttu-id="95a33-2616">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2616">No</span></span>|  
|<span data-ttu-id="95a33-2617">Поле</span><span class="sxs-lookup"><span data-stu-id="95a33-2617">Field</span></span>|<span data-ttu-id="95a33-2618">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2618">No</span></span>|<span data-ttu-id="95a33-2619">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-2619">Yes.</span></span> <span data-ttu-id="95a33-2620">Поле всегда скрывается по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2620">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-2621">событие</span><span class="sxs-lookup"><span data-stu-id="95a33-2621">Event</span></span>|<span data-ttu-id="95a33-2622">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-2622">Not applicable</span></span>|<span data-ttu-id="95a33-2623">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2623">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-2624">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2624">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-2625">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-2625">See note 2 below.</span></span>|  
|<span data-ttu-id="95a33-2626">Метод</span><span class="sxs-lookup"><span data-stu-id="95a33-2626">Method</span></span>|<span data-ttu-id="95a33-2627">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2627">No</span></span>|<span data-ttu-id="95a33-2628">Да.</span><span class="sxs-lookup"><span data-stu-id="95a33-2628">Yes.</span></span> <span data-ttu-id="95a33-2629">Метод (как виртуальный, так и невиртуальный) может быть скрыт по имени или скрытию по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2629">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="95a33-2630">Вложенный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-2630">Nested Type</span></span>|<span data-ttu-id="95a33-2631">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2631">No</span></span>|<span data-ttu-id="95a33-2632">Нет</span><span class="sxs-lookup"><span data-stu-id="95a33-2632">No</span></span>|  
|<span data-ttu-id="95a33-2633">Свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2633">Property</span></span>|<span data-ttu-id="95a33-2634">Неприменимо</span><span class="sxs-lookup"><span data-stu-id="95a33-2634">Not applicable</span></span>|<span data-ttu-id="95a33-2635">Правило системы общих типов — это то же наследование, что и методы, реализующие свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-2635">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="95a33-2636">Отражение рассматривает свойства как скрытые по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2636">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-2637">См. Примечание 2 ниже.</span><span class="sxs-lookup"><span data-stu-id="95a33-2637">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="95a33-2638">При скрытии по имени и сигнатуре учитываются все части сигнатуры, включая пользовательские модификаторы, возвращаемые типы, типы параметров, Sentinel и неуправляемые соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="95a33-2638">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="95a33-2639">Это двоичное сравнение.</span><span class="sxs-lookup"><span data-stu-id="95a33-2639">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="95a33-2640">Для отражения свойства и события скрываются по имени и сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-2640">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="95a33-2641">Если у вас есть свойство с методом доступа get и Set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу задания в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-2641">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="95a33-2642">Настраиваемые атрибуты не являются частью системы общих типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2642">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="95a33-2643">Поиск в массивах или типах COM не выполняется, если они еще не загружены в таблицу доступных классов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2643">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="95a33-2644">`typeName` может быть именем типа, дополненным его пространством имен или именем сборки, которое включает спецификацию имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2644">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="95a33-2645">См. раздел <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2645">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="95a33-2646">Если `typeName` включает пространство имен, но не имя сборки, этот метод выполняет поиск только в сборке вызывающего объекта и mscorlib. dll в указанном порядке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2646">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="95a33-2647">Если typeName имеет полное имя с частичным или полным именем сборки, этот метод выполняет поиск в указанной сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2647">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="95a33-2648">Если сборка имеет строгое имя, требуется полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2648">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="95a33-2649">Свойство <xref:System.Type.AssemblyQualifiedName%2A> возвращает полное имя типа, включая вложенные типы, имя сборки и аргументы типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2649">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</span></span> <span data-ttu-id="95a33-2650">Все компиляторы, поддерживающие среду CLR, будут выдавать простое имя вложенного класса, а отражение при запросе создает искаженное имя в соответствии со следующими соглашениями.</span><span class="sxs-lookup"><span data-stu-id="95a33-2650">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-2651">В .NET Framework версии 2,0 архитектура процессора добавляется в удостоверение сборки и может быть указана в качестве части строк имен сборок.</span><span class="sxs-lookup"><span data-stu-id="95a33-2651">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="95a33-2652">Например, "ProcessorArchitecture = MSIL".</span><span class="sxs-lookup"><span data-stu-id="95a33-2652">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="95a33-2653">Однако он не включается в строку, возвращенную свойством <xref:System.Type.AssemblyQualifiedName%2A>, по причинам совместимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-2653">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="95a33-2654">Можно также загрузить типы, создав объект <xref:System.Reflection.AssemblyName> и передав его в соответствующую перегрузку метода <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2654">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="95a33-2655">Затем можно использовать метод <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> для загрузки типов из сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2655">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="95a33-2656">См. также раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2656">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="95a33-2657">Разделитель</span><span class="sxs-lookup"><span data-stu-id="95a33-2657">Delimiter</span></span>|<span data-ttu-id="95a33-2658">Значение</span><span class="sxs-lookup"><span data-stu-id="95a33-2658">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="95a33-2659">Обратная косая черта (\\)</span><span class="sxs-lookup"><span data-stu-id="95a33-2659">Backslash (\\)</span></span>|<span data-ttu-id="95a33-2660">Escape-символ.</span><span class="sxs-lookup"><span data-stu-id="95a33-2660">Escape character.</span></span>|  
|<span data-ttu-id="95a33-2661">Обратная кавычка (')</span><span class="sxs-lookup"><span data-stu-id="95a33-2661">Backtick (\`)</span></span>|<span data-ttu-id="95a33-2662">Предшествует одной или нескольким цифрам, представляющим количество параметров типа, расположенных в конце имени универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2662">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="95a33-2663">Квадратные скобки ([])</span><span class="sxs-lookup"><span data-stu-id="95a33-2663">Brackets ([])</span></span>|<span data-ttu-id="95a33-2664">Заключите список аргументов универсального типа для сконструированного универсального типа. в списке аргументов типа заключите тип, квалифицированный сборкой.</span><span class="sxs-lookup"><span data-stu-id="95a33-2664">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="95a33-2665">Запятая (,)</span><span class="sxs-lookup"><span data-stu-id="95a33-2665">Comma (,)</span></span>|<span data-ttu-id="95a33-2666">Предшествует имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2666">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="95a33-2667">Точка (.)</span><span class="sxs-lookup"><span data-stu-id="95a33-2667">Period (.)</span></span>|<span data-ttu-id="95a33-2668">Обозначает идентификаторы пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-2668">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="95a33-2669">Знак плюса (+)</span><span class="sxs-lookup"><span data-stu-id="95a33-2669">Plus sign (+)</span></span>|<span data-ttu-id="95a33-2670">Предшествует вложенному классу.</span><span class="sxs-lookup"><span data-stu-id="95a33-2670">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="95a33-2671">Например, полное имя класса может выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-2671">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="95a33-2672">Если пространство имен было Топнамеспаце. Re+ Namespace, строка должна предшествовать знаку плюс (+) с escape-символом (\\), чтобы предотвратить его интерпретацию как разделитель вложения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2672">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="95a33-2673">Отражение выдает эту строку следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-2673">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="95a33-2674">"+ +" Преобразуется в "\\+\\+", а "\\" преобразуется в "\\\\".</span><span class="sxs-lookup"><span data-stu-id="95a33-2674">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="95a33-2675">Это полное имя можно сохранить и позже использовать для загрузки <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2675">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="95a33-2676">Чтобы найти и загрузить <xref:System.Type>, используйте <xref:System.Type.GetType%2A> либо с именем типа, либо с полным именем типа сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2676">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="95a33-2677"><xref:System.Type.GetType%2A> с именем типа будет искать только <xref:System.Type> в сборке вызывающего объекта, а затем в системной сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2677"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="95a33-2678"><xref:System.Type.GetType%2A> с полным именем типа сборки будет искать <xref:System.Type> в любой сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2678"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="95a33-2679">Имена типов могут содержать конечные символы, которые обозначают дополнительные сведения о типе, например, является ли тип ссылочным типом, типом указателя или типом массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-2679">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="95a33-2680">Чтобы получить имя типа без этих замыкающих символов, используйте `t.GetElementType().ToString()`, где `t` — это тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-2680">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="95a33-2681">Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2681">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="95a33-2682">В имени сборки учитываются пробелы перед разделителем ",", но пробелы после разделителя "," игнорируются.</span><span class="sxs-lookup"><span data-stu-id="95a33-2682">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="95a33-2683">Имя универсального типа заканчивается обратным импульсом (\`), за которым следуют цифры, представляющие число аргументов универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2683">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="95a33-2684">Такое искажение имени позволяет компиляторам поддерживать универсальные типы с тем же именем, но с разными числами параметров типа, происходящих в одной области.</span><span class="sxs-lookup"><span data-stu-id="95a33-2684">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="95a33-2685">Например, отражение возвращает искаженные имена `Tuple`1` and `кортеж`2` из универсальных методов `Tuple(Of T)` и `Tuple(Of T0, T1)` в Visual Basic или `Tuple<T>` и`\<T0, T1>` кортежа в Visual C#.</span><span class="sxs-lookup"><span data-stu-id="95a33-2685">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="95a33-2686">Для универсальных типов список аргументов типа заключается в квадратные скобки, а аргументы типа разделяются запятыми.</span><span class="sxs-lookup"><span data-stu-id="95a33-2686">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="95a33-2687">Например, универсальный <xref:System.Collections.Generic.Dictionary%602> имеет два параметра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2687">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="95a33-2688"><xref:System.Collections.Generic.Dictionary%602> `MyType` с ключами типа <xref:System.String> могут быть представлены следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-2688">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="95a33-2689">Чтобы указать тип с указанием сборки в списке аргументов типа, заключите тип сборки в квадратные скобки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2689">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="95a33-2690">В противном случае запятые, разделяющие части имени с указанием сборки, будут интерпретироваться как разделители дополнительных аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2690">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="95a33-2691">Например, <xref:System.Collections.Generic.Dictionary%602> `MyType` из MyAssembly. dll с ключами типа <xref:System.String>можно указать следующим образом:</span><span class="sxs-lookup"><span data-stu-id="95a33-2691">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="95a33-2692">Тип с указанием сборки может быть заключен в квадратные скобки только в том случае, если он присутствует в списке параметров типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2692">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="95a33-2693">Правила поиска сборок для полных и неквалифицированных типов в списках параметров типов совпадают с правилами для полных и неполных неуниверсальных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2693">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="95a33-2694">Типы, допускающие значение null, являются особым случаем универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2694">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="95a33-2695">Например, <xref:System.Int32> Nullable представляется строкой "System. Nullable" 1 [System. Int32] ".</span><span class="sxs-lookup"><span data-stu-id="95a33-2695">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-2696">В C#, C++и Visual Basic можно также получить типы, допускающие значение null, с помощью операторов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2696">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="95a33-2697">Например, тип <xref:System.Boolean>, допускающего значение null, возвращается `typeof(Nullable<bool>)` C#в, с помощью C++`Nullable<Boolean>::typeid` в и `GetType(Nullable(Of Boolean))` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="95a33-2697">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="95a33-2698">В следующей таблице показан синтаксис, используемый с `GetType` для различных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2698">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="95a33-2699">Для получения</span><span class="sxs-lookup"><span data-stu-id="95a33-2699">To Get</span></span>|<span data-ttu-id="95a33-2700">Использовать</span><span class="sxs-lookup"><span data-stu-id="95a33-2700">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="95a33-2701"><xref:System.Int32> Nullable</span><span class="sxs-lookup"><span data-stu-id="95a33-2701">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="95a33-2702">Неуправляемый указатель на `MyType`</span><span class="sxs-lookup"><span data-stu-id="95a33-2702">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="95a33-2703">Неуправляемый указатель на указатель на `MyType`</span><span class="sxs-lookup"><span data-stu-id="95a33-2703">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="95a33-2704">Управляемый указатель или ссылка на `MyType`</span><span class="sxs-lookup"><span data-stu-id="95a33-2704">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="95a33-2705">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2705">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="95a33-2706">Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.</span><span class="sxs-lookup"><span data-stu-id="95a33-2706">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="95a33-2707">Родительский класс и вложенный класс</span><span class="sxs-lookup"><span data-stu-id="95a33-2707">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="95a33-2708">Одномерный массив с нижней границей 0</span><span class="sxs-lookup"><span data-stu-id="95a33-2708">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="95a33-2709">Одномерный массив с неизвестной нижней границей</span><span class="sxs-lookup"><span data-stu-id="95a33-2709">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="95a33-2710">N-мерный массив</span><span class="sxs-lookup"><span data-stu-id="95a33-2710">An n-dimensional array</span></span>|<span data-ttu-id="95a33-2711">Запятая (,) внутри квадратных скобок, всего n – 1 раз.</span><span class="sxs-lookup"><span data-stu-id="95a33-2711">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="95a33-2712">Например, `System.Object[,,]` представляет трехмерный массив `Object`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2712">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="95a33-2713">Массив двумерных массивов</span><span class="sxs-lookup"><span data-stu-id="95a33-2713">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="95a33-2714">Прямоугольный двухмерный массив с неизвестными нижними границами</span><span class="sxs-lookup"><span data-stu-id="95a33-2714">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="95a33-2715">Универсальный тип с одним аргументом типа</span><span class="sxs-lookup"><span data-stu-id="95a33-2715">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="95a33-2716">Универсальный тип с двумя аргументами типа</span><span class="sxs-lookup"><span data-stu-id="95a33-2716">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="95a33-2717">Универсальный тип с двумя аргументами типа с указанием сборки</span><span class="sxs-lookup"><span data-stu-id="95a33-2717">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="95a33-2718">Квалифицированный в сборке универсальный тип с аргументом типа сборки</span><span class="sxs-lookup"><span data-stu-id="95a33-2718">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="95a33-2719">Универсальный тип, аргумент типа которого является универсальным типом с двумя аргументами типа</span><span class="sxs-lookup"><span data-stu-id="95a33-2719">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2720"><paramref name="typeName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2720"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="95a33-2721">Инициализатор класса вызывается и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-2721">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="95a33-2722"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и тип не найден.</span><span class="sxs-lookup"><span data-stu-id="95a33-2722"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="95a33-2723">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2723">-or-</span></span> 
 <span data-ttu-id="95a33-2724"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции.</span><span class="sxs-lookup"><span data-stu-id="95a33-2724"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="95a33-2725">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2725">-or-</span></span> 
 <span data-ttu-id="95a33-2726"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.</span><span class="sxs-lookup"><span data-stu-id="95a33-2726"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="95a33-2727">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2727">-or-</span></span> 
 <span data-ttu-id="95a33-2728"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.</span><span class="sxs-lookup"><span data-stu-id="95a33-2728"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="95a33-2729">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2729">-or-</span></span> 
 <span data-ttu-id="95a33-2730"><paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2730"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-2731"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис.</span><span class="sxs-lookup"><span data-stu-id="95a33-2731"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="95a33-2732">Например, "MyType[,\*,]".</span><span class="sxs-lookup"><span data-stu-id="95a33-2732">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="95a33-2733">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2733">-or-</span></span> 
 <span data-ttu-id="95a33-2734"><paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2734"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="95a33-2735">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2735">-or-</span></span> 
 <span data-ttu-id="95a33-2736"><paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2736"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="95a33-2737">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2737">-or-</span></span> 
 <span data-ttu-id="95a33-2738"><paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2738"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="95a33-2739"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.</span><span class="sxs-lookup"><span data-stu-id="95a33-2739"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="95a33-2740">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</span><span class="sxs-lookup"><span data-stu-id="95a33-2740">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="95a33-2741">Сборка или одна из ее зависимостей является недопустимой.</span><span class="sxs-lookup"><span data-stu-id="95a33-2741">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="95a33-2742">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2742">-or-</span></span>  
  
 <span data-ttu-id="95a33-2743">В текущий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка была скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="95a33-2743">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="95a33-2744">Указание полных имен типов</span><span class="sxs-lookup"><span data-stu-id="95a33-2744">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="95a33-2745">Имя получаемого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2745">The name of the type to get.</span></span> <span data-ttu-id="95a33-2746">Если задан параметр <paramref name="typeResolver" />, имя типа может быть любой строкой, которую может разрешить объект <paramref name="typeResolver" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2746">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="95a33-2747">Если задан параметр <paramref name="assemblyResolver" /> или если используется стандартное разрешение типов, параметр <paramref name="typeName" /> должен быть именем с указанием сборки (см. описание свойства <see cref="P:System.Type.AssemblyQualifiedName" />), кроме случаев, когда этот тип находится в текущей выполняемой сборке или в библиотеке Mscorlib.dll — тогда достаточно задать имя типа с указанием пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-2747">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="95a33-2748">Метод, находящий и возвращающий сборку, заданную в параметре <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2748">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="95a33-2749">Имя сборки передается методу <paramref name="assemblyResolver" /> в виде объекта <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2749">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="95a33-2750">Если объект <paramref name="typeName" /> не содержит имя сборки, метод <paramref name="assemblyResolver" /> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="95a33-2750">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="95a33-2751">Если метод <paramref name="assemblyResolver" /> не указан, выполняется стандартное разрешение сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2751">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="95a33-2752">Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</span><span class="sxs-lookup"><span data-stu-id="95a33-2752">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="95a33-2753">В противном случае возможно повышение привилегий для вредоносного кода.</span><span class="sxs-lookup"><span data-stu-id="95a33-2753">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="95a33-2754">Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</span><span class="sxs-lookup"><span data-stu-id="95a33-2754">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="95a33-2755">Метод, находящий и возвращающий тип, заданный в параметре <paramref name="typeName" />, из сборки, возвращенной методом <paramref name="assemblyResolver" /> или стандартным методом разрешения сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2755">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="95a33-2756">Если сборка не предоставлена, ее может предоставить метод <paramref name="typeResolver" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2756">If no assembly is provided, the <paramref name="typeResolver" /> method can provide one.</span></span> <span data-ttu-id="95a33-2757">Метод также принимает параметр, указывающий, следует ли выполнять поиск без учета регистра; этому параметру передается значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2757">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="95a33-2758">Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</span><span class="sxs-lookup"><span data-stu-id="95a33-2758">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <summary><span data-ttu-id="95a33-2759">Получает тип с указанным именем; дополнительно может предоставлять настраиваемые методы для разрешения сборки и типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2759">Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="95a33-2760">Тип с указанным именем или значение <see langword="null" />, если тип не найден.</span><span class="sxs-lookup"><span data-stu-id="95a33-2760">The type with the specified name, or <see langword="null" /> if the type is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-2761">Сценарии использования для этого метода и сведения о параметрах `assemblyResolver` и `typeResolver` можно найти в перегрузке метода <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2761">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-2762">Если не удается найти `typeName`, вызов метода <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2762">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`.</span></span> <span data-ttu-id="95a33-2763">Исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="95a33-2763">It does not throw an exception.</span></span> <span data-ttu-id="95a33-2764">Чтобы управлять тем, возникает ли исключение, вызовите перегрузку метода <xref:System.Type.GetType%2A>, имеющего параметр `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2764">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="95a33-2765">Вызов этой перегрузки метода аналогичен вызову перегрузки метода <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> и указанию `false` для параметров `throwOnError` и `ignoreCase`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2765">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2766">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2766"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="95a33-2767">Инициализатор класса вызывается и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-2767">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-2768">Произошла ошибка при интерпретации <paramref name="typeName" /> в имя типа и имя сборки (например, если имя простого типа содержит неэкранированный специальный знак).</span><span class="sxs-lookup"><span data-stu-id="95a33-2768">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="95a33-2769">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2769">-or-</span></span> 
 <span data-ttu-id="95a33-2770"><paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2770"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="95a33-2771">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2771">-or-</span></span> 
 <span data-ttu-id="95a33-2772"><paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2772"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="95a33-2773">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2773">-or-</span></span> 
 <span data-ttu-id="95a33-2774"><paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2774"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="95a33-2775"><paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2775"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="95a33-2776">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</span><span class="sxs-lookup"><span data-stu-id="95a33-2776">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="95a33-2777">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2777">-or-</span></span> 
 <span data-ttu-id="95a33-2778"><paramref name="typeName" /> содержит недопустимое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2778"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="95a33-2779">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2779">-or-</span></span> 
 <span data-ttu-id="95a33-2780"><paramref name="typeName" /> является допустимым именем сборки без имени типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2780"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="95a33-2781">Сборка или одна из ее зависимостей является недопустимой.</span><span class="sxs-lookup"><span data-stu-id="95a33-2781">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="95a33-2782">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2782">-or-</span></span>  
  
 <span data-ttu-id="95a33-2783">Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</span><span class="sxs-lookup"><span data-stu-id="95a33-2783">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="95a33-2784">Имя получаемого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2784">The name of the type to get.</span></span> <span data-ttu-id="95a33-2785">Если задан параметр <paramref name="typeResolver" />, имя типа может быть любой строкой, которую может разрешить объект <paramref name="typeResolver" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2785">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="95a33-2786">Если задан параметр <paramref name="assemblyResolver" /> или если используется стандартное разрешение типов, параметр <paramref name="typeName" /> должен быть именем с указанием сборки (см. описание свойства <see cref="P:System.Type.AssemblyQualifiedName" />), кроме случаев, когда этот тип находится в текущей выполняемой сборке или в библиотеке Mscorlib.dll — тогда достаточно задать имя типа с указанием пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-2786">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="95a33-2787">Метод, находящий и возвращающий сборку, заданную в параметре <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2787">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="95a33-2788">Имя сборки передается методу <paramref name="assemblyResolver" /> в виде объекта <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2788">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="95a33-2789">Если объект <paramref name="typeName" /> не содержит имя сборки, метод <paramref name="assemblyResolver" /> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="95a33-2789">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="95a33-2790">Если метод <paramref name="assemblyResolver" /> не указан, выполняется стандартное разрешение сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2790">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="95a33-2791">Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</span><span class="sxs-lookup"><span data-stu-id="95a33-2791">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="95a33-2792">В противном случае возможно повышение привилегий для вредоносного кода.</span><span class="sxs-lookup"><span data-stu-id="95a33-2792">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="95a33-2793">Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</span><span class="sxs-lookup"><span data-stu-id="95a33-2793">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="95a33-2794">Метод, находящий и возвращающий тип, заданный в параметре <paramref name="typeName" />, из сборки, возвращенной методом <paramref name="assemblyResolver" /> или стандартным методом разрешения сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2794">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="95a33-2795">Если сборка не предоставлена, этот метод может предоставить ее.</span><span class="sxs-lookup"><span data-stu-id="95a33-2795">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="95a33-2796">Метод также принимает параметр, указывающий, следует ли выполнять поиск без учета регистра; этому параметру передается значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2796">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="95a33-2797">Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</span><span class="sxs-lookup"><span data-stu-id="95a33-2797">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="95a33-2798">Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2798"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="95a33-2799">Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них.</span><span class="sxs-lookup"><span data-stu-id="95a33-2799">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="95a33-2800">См. раздел "Исключения".</span><span class="sxs-lookup"><span data-stu-id="95a33-2800">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="95a33-2801">Возвращает тип с заданным именем и указывает, следует ли создавать исключение в случае невозможности найти тип, а также может предоставлять настраиваемые методы для разрешения сборки и типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2801">Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="95a33-2802">Тип с указанным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-2802">The type with the specified name.</span></span> <span data-ttu-id="95a33-2803">Если тип не найден, параметр <paramref name="throwOnError" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2803">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="95a33-2804">В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2804">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="95a33-2805">См. раздел "Исключения".</span><span class="sxs-lookup"><span data-stu-id="95a33-2805">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-2806">Сценарии использования для этого метода и сведения о параметрах `assemblyResolver` и `typeResolver` можно найти в перегрузке метода <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2806">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="95a33-2807">Вызов этой перегрузки метода аналогичен вызову перегрузки метода <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> и указанию `false` для параметра `ignoreCase`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2807">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2808">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2808"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="95a33-2809">Инициализатор класса вызывается и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-2809">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="95a33-2810"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и тип не найден.</span><span class="sxs-lookup"><span data-stu-id="95a33-2810"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="95a33-2811">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2811">-or-</span></span> 
 <span data-ttu-id="95a33-2812"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции.</span><span class="sxs-lookup"><span data-stu-id="95a33-2812"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="95a33-2813">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2813">-or-</span></span> 
 <span data-ttu-id="95a33-2814"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.</span><span class="sxs-lookup"><span data-stu-id="95a33-2814"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="95a33-2815">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2815">-or-</span></span> 
 <span data-ttu-id="95a33-2816"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.</span><span class="sxs-lookup"><span data-stu-id="95a33-2816"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="95a33-2817">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2817">-or-</span></span> 
 <span data-ttu-id="95a33-2818"><paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2818"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-2819">Произошла ошибка при интерпретации <paramref name="typeName" /> в имя типа и имя сборки (например, если имя простого типа содержит неэкранированный специальный знак).</span><span class="sxs-lookup"><span data-stu-id="95a33-2819">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="95a33-2820">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2820">-or-</span></span> 
 <span data-ttu-id="95a33-2821"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис (например "MyType[,\*,]").</span><span class="sxs-lookup"><span data-stu-id="95a33-2821"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="95a33-2822">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2822">-or-</span></span> 
 <span data-ttu-id="95a33-2823"><paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2823"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="95a33-2824">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2824">-or-</span></span> 
 <span data-ttu-id="95a33-2825"><paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2825"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="95a33-2826">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2826">-or-</span></span> 
 <span data-ttu-id="95a33-2827"><paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2827"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="95a33-2828"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.</span><span class="sxs-lookup"><span data-stu-id="95a33-2828"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span>  
  
<span data-ttu-id="95a33-2829">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2829">-or-</span></span> 
 <span data-ttu-id="95a33-2830"><paramref name="typeName" /> содержит недопустимое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2830"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="95a33-2831">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2831">-or-</span></span> 
 <span data-ttu-id="95a33-2832"><paramref name="typeName" /> является допустимым именем сборки без имени типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2832"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="95a33-2833">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</span><span class="sxs-lookup"><span data-stu-id="95a33-2833">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="95a33-2834">Сборка или одна из ее зависимостей является недопустимой.</span><span class="sxs-lookup"><span data-stu-id="95a33-2834">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="95a33-2835">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-2835">-or-</span></span>  
  
 <span data-ttu-id="95a33-2836">Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</span><span class="sxs-lookup"><span data-stu-id="95a33-2836">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="95a33-2837">Имя получаемого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2837">The name of the type to get.</span></span> <span data-ttu-id="95a33-2838">Если задан параметр <paramref name="typeResolver" />, имя типа может быть любой строкой, которую может разрешить объект <paramref name="typeResolver" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2838">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="95a33-2839">Если задан параметр <paramref name="assemblyResolver" /> или если используется стандартное разрешение типов, параметр <paramref name="typeName" /> должен быть именем с указанием сборки (см. описание свойства <see cref="P:System.Type.AssemblyQualifiedName" />), кроме случаев, когда этот тип находится в текущей выполняемой сборке или в библиотеке Mscorlib.dll — тогда достаточно задать имя типа с указанием пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-2839">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="95a33-2840">Метод, находящий и возвращающий сборку, заданную в параметре <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2840">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="95a33-2841">Имя сборки передается методу <paramref name="assemblyResolver" /> в виде объекта <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2841">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="95a33-2842">Если объект <paramref name="typeName" /> не содержит имя сборки, метод <paramref name="assemblyResolver" /> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="95a33-2842">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="95a33-2843">Если метод <paramref name="assemblyResolver" /> не указан, выполняется стандартное разрешение сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2843">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="95a33-2844">Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</span><span class="sxs-lookup"><span data-stu-id="95a33-2844">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="95a33-2845">В противном случае возможно повышение привилегий для вредоносного кода.</span><span class="sxs-lookup"><span data-stu-id="95a33-2845">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="95a33-2846">Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</span><span class="sxs-lookup"><span data-stu-id="95a33-2846">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="95a33-2847">Метод, находящий и возвращающий тип, заданный в параметре <paramref name="typeName" />, из сборки, возвращенной методом <paramref name="assemblyResolver" /> или стандартным методом разрешения сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2847">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="95a33-2848">Если сборка не предоставлена, этот метод может предоставить ее.</span><span class="sxs-lookup"><span data-stu-id="95a33-2848">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="95a33-2849">Метод также принимает параметр, указывающий, следует ли выполнять поиск без учета регистра; этому параметру передается значение <paramref name="ignoreCase" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2849">The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <paramref name="ignoreCase" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="95a33-2850">Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</span><span class="sxs-lookup"><span data-stu-id="95a33-2850">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="95a33-2851">Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2851"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="95a33-2852">Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них.</span><span class="sxs-lookup"><span data-stu-id="95a33-2852">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="95a33-2853">См. раздел "Исключения".</span><span class="sxs-lookup"><span data-stu-id="95a33-2853">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="95a33-2854">Значение <see langword="true" />, чтобы не учитывать регистр при поиске <paramref name="typeName" />, значение <see langword="false" />, чтобы учитывать регистр при поиске <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2854"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="95a33-2855">Получает тип с заданным именем и указывает, следует ли выполнять поиск без учета регистра и следует ли создавать исключение в случае невозможности найти тип, а также может предоставлять настраиваемые методы для разрешения сборки и типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2855">Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="95a33-2856">Тип с указанным именем.</span><span class="sxs-lookup"><span data-stu-id="95a33-2856">The type with the specified name.</span></span> <span data-ttu-id="95a33-2857">Если тип не найден, параметр <paramref name="throwOnError" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2857">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="95a33-2858">В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2858">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="95a33-2859">См. раздел "Исключения".</span><span class="sxs-lookup"><span data-stu-id="95a33-2859">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-2860">Используйте этот перегруженный метод и связанные с ним перегрузки (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> и <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>), чтобы заменить реализацию метода <xref:System.Type.GetType%2A> по умолчанию более гибкими реализациями.</span><span class="sxs-lookup"><span data-stu-id="95a33-2860">Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations.</span></span> <span data-ttu-id="95a33-2861">Предоставляя собственные методы, которые разрешают имена типов и имена сборок, содержащих их, можно выполнить следующие действия.</span><span class="sxs-lookup"><span data-stu-id="95a33-2861">By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</span></span>  
  
-   <span data-ttu-id="95a33-2862">Управление версией сборки, из которой загружается тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-2862">Control which version of an assembly a type is loaded from.</span></span>  
  
-   <span data-ttu-id="95a33-2863">Укажите другое место для поиска имени типа, не включающего в себя имя сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2863">Provide another place to look for a type name that does not include an assembly name.</span></span>  
  
-   <span data-ttu-id="95a33-2864">Загрузка сборок с использованием частичных имен сборок.</span><span class="sxs-lookup"><span data-stu-id="95a33-2864">Load assemblies using partial assembly names.</span></span>  
  
-   <span data-ttu-id="95a33-2865">Возвращают подклассы <xref:System.Type?displayProperty=nameWithType>, которые не создаются средой CLR.</span><span class="sxs-lookup"><span data-stu-id="95a33-2865">Return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the common language runtime (CLR).</span></span>  
  
 <span data-ttu-id="95a33-2866">Например, при сериализации с поддержкой версий этот метод позволяет выполнять поиск "наилучшего" сборки с помощью частичного имени.</span><span class="sxs-lookup"><span data-stu-id="95a33-2866">For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</span></span> <span data-ttu-id="95a33-2867">Для других перегрузок метода <xref:System.Type.GetType%2A> требуется имя типа с указанием сборки, которое включает номер версии.</span><span class="sxs-lookup"><span data-stu-id="95a33-2867">Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.</span></span>  
  
 <span data-ttu-id="95a33-2868">Альтернативным реализациям системы типов может потребоваться возврат подклассов <xref:System.Type?displayProperty=nameWithType>, которые не создаются средой CLR. все типы, возвращаемые другими перегрузками метода <xref:System.Type.GetType%2A>, являются типами среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2868">Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.</span></span>  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a><span data-ttu-id="95a33-2869">Примечания об использовании</span><span class="sxs-lookup"><span data-stu-id="95a33-2869">Usage Notes</span></span>  
 <span data-ttu-id="95a33-2870">Этот перегруженный метод и связанные с ним перегрузки анализируют `typeName` в имя типа и имя сборки, а затем разрешают имена.</span><span class="sxs-lookup"><span data-stu-id="95a33-2870">This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names.</span></span> <span data-ttu-id="95a33-2871">Разрешение имени сборки происходит до разрешения имени типа, так как имя типа должно быть разрешено в контексте сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2871">Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-2872">Если вы не знакомы с концепцией имен типов с указанием сборки, см. сведения в свойстве <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2872">If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.</span></span>  
  
 <span data-ttu-id="95a33-2873">Если `typeName` не является именем сборки, разрешение сборки пропускается.</span><span class="sxs-lookup"><span data-stu-id="95a33-2873">If `typeName` is not an assembly-qualified name, assembly resolution is skipped.</span></span> <span data-ttu-id="95a33-2874">Неполные имена типов могут быть разрешены в контексте библиотеки mscorlib. dll или сборки, выполняющейся в данный момент, либо при необходимости можно указать сборку в параметре `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2874">Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter.</span></span> <span data-ttu-id="95a33-2875">Влияние включения или пропущения имени сборки для различных типов разрешения имен отображается в виде таблицы в разделе [Разрешение смешанных имен](#mixed_name_resolution) .</span><span class="sxs-lookup"><span data-stu-id="95a33-2875">The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.</span></span>  
  
 <span data-ttu-id="95a33-2876">Общие замечания об использовании:</span><span class="sxs-lookup"><span data-stu-id="95a33-2876">General usage notes:</span></span>  
  
-   <span data-ttu-id="95a33-2877">Не передавайте методы `assemblyResolver` или `typeResolver`, если они поступают от неизвестных или ненадежных вызывающих объектов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2877">Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers.</span></span> <span data-ttu-id="95a33-2878">Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</span><span class="sxs-lookup"><span data-stu-id="95a33-2878">Use only methods that you provide or that you are familiar with.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="95a33-2879">Использование методов от неизвестных или ненадежных вызывающих объектов может привести к повышению привилегий для вредоносного кода.</span><span class="sxs-lookup"><span data-stu-id="95a33-2879">Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</span></span>  
  
-   <span data-ttu-id="95a33-2880">Если опустить параметры `assemblyResolver` и (или) `typeResolver`, то значение параметра `throwOnError` передается методам, которые выполняют разрешение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-2880">If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.</span></span>  
  
-   <span data-ttu-id="95a33-2881">Если `throwOnError` `true`, этот метод выдает <xref:System.TypeLoadException>, когда `typeResolver` возвращает `null`, и <xref:System.IO.FileNotFoundException>, когда `assemblyResolver` возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2881">If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.</span></span>  
  
-   <span data-ttu-id="95a33-2882">Этот метод не перехватывает исключения, созданные `assemblyResolver` и `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2882">This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`.</span></span> <span data-ttu-id="95a33-2883">Вы несете ответственность за любые исключения, вызываемые методами сопоставителя.</span><span class="sxs-lookup"><span data-stu-id="95a33-2883">You are responsible for any exceptions that are thrown by the resolver methods.</span></span>  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a><span data-ttu-id="95a33-2884">Разрешение сборок</span><span class="sxs-lookup"><span data-stu-id="95a33-2884">Resolving Assemblies</span></span>  
 <span data-ttu-id="95a33-2885">Метод `assemblyResolver` получает объект <xref:System.Reflection.AssemblyName>, который создается путем анализа имени строковой сборки, включенной в `typeName`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2885">The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`.</span></span> <span data-ttu-id="95a33-2886">Если `typeName` не содержит имя сборки, `assemblyResolver` не вызывается и `null` передается в `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2886">If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.</span></span>  
  
 <span data-ttu-id="95a33-2887">Если `assemblyResolver` не указан, для поиска сборки используется стандартная сборка.</span><span class="sxs-lookup"><span data-stu-id="95a33-2887">If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly.</span></span> <span data-ttu-id="95a33-2888">Если указан `assemblyResolver`, метод <xref:System.Type.GetType%2A> не выполняет стандартную проверку. в этом случае необходимо убедиться, что `assemblyResolver` может обрабатывать все передаваемые им сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2888">If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.</span></span>  
  
 <span data-ttu-id="95a33-2889">Метод `assemblyResolver` должен возвращать `null`, если сборка не может быть разрешена.</span><span class="sxs-lookup"><span data-stu-id="95a33-2889">The `assemblyResolver` method should return `null` if the assembly cannot be resolved.</span></span> <span data-ttu-id="95a33-2890">Если `assemblyResolver` возвращает `null`, `typeResolver` не вызывается и дальнейшая обработка не выполняется; Кроме того, если `throwOnError` `true`, выдается <xref:System.IO.FileNotFoundException>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2890">If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="95a33-2891">Если <xref:System.Reflection.AssemblyName>, передаваемый в `assemblyResolver`, является неполным именем, то один или несколько его частей `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2891">If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`.</span></span> <span data-ttu-id="95a33-2892">Например, если у него нет версии, свойство <xref:System.Reflection.AssemblyName.Version%2A> `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2892">For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`.</span></span> <span data-ttu-id="95a33-2893">Если свойство <xref:System.Reflection.AssemblyName.Version%2A>, свойство <xref:System.Reflection.AssemblyName.CultureInfo%2A> и метод <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> возвращают `null`, то было указано только простое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2893">If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied.</span></span> <span data-ttu-id="95a33-2894">Метод `assemblyResolver` может использовать или игнорировать все части имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2894">The `assemblyResolver` method can use or ignore all parts of the assembly name.</span></span>  
  
 <span data-ttu-id="95a33-2895">Влияние различных параметров разрешения сборки отображается в виде таблицы в разделе [разрешения смешанных имен](#mixed_name_resolution) для простых и имен типов с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2895">The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a><span data-ttu-id="95a33-2896">Разрешение типов</span><span class="sxs-lookup"><span data-stu-id="95a33-2896">Resolving Types</span></span>  
 <span data-ttu-id="95a33-2897">Если `typeName` не указывает имя сборки, `typeResolver` вызывается всегда.</span><span class="sxs-lookup"><span data-stu-id="95a33-2897">If `typeName` does not specify an assembly name, `typeResolver` is always called.</span></span> <span data-ttu-id="95a33-2898">Если `typeName` указывает имя сборки, `typeResolver` вызывается только в том случае, если имя сборки успешно разрешено.</span><span class="sxs-lookup"><span data-stu-id="95a33-2898">If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved.</span></span> <span data-ttu-id="95a33-2899">Если `assemblyResolver` или стандартная сборка вернула `null`, `typeResolver` не вызывается.</span><span class="sxs-lookup"><span data-stu-id="95a33-2899">If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.</span></span>  
  
 <span data-ttu-id="95a33-2900">Метод `typeResolver` получает три аргумента:</span><span class="sxs-lookup"><span data-stu-id="95a33-2900">The `typeResolver` method receives three arguments:</span></span>  
  
-   <span data-ttu-id="95a33-2901">Сборка для поиска или `null`, если `typeName` не содержит имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2901">The assembly to search or `null` if `typeName` does not contain an assembly name.</span></span>  
  
-   <span data-ttu-id="95a33-2902">Простое имя типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2902">The simple name of the type.</span></span> <span data-ttu-id="95a33-2903">В случае вложенного типа это самый внешний вмещающий тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-2903">In the case of a nested type, this is the outermost containing type.</span></span> <span data-ttu-id="95a33-2904">В случае универсального типа это простое имя универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2904">In the case of a generic type, this is the simple name of the generic type.</span></span>  
  
-   <span data-ttu-id="95a33-2905">Логическое значение, которое `true`, если регистр имен типов должен игнорироваться.</span><span class="sxs-lookup"><span data-stu-id="95a33-2905">A Boolean value that is `true` if the case of type names is to be ignored.</span></span>  
  
 <span data-ttu-id="95a33-2906">Реализация определяет способ использования этих аргументов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2906">The implementation determines the way these arguments are used.</span></span> <span data-ttu-id="95a33-2907">Метод `typeResolver` должен возвращать `null`, если он не может разрешить тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-2907">The `typeResolver` method should return `null` if it cannot resolve the type.</span></span> <span data-ttu-id="95a33-2908">Если `typeResolver` возвращает `null` и `throwOnError` `true`, эта перегрузка <xref:System.Type.GetType%2A> создает исключение <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2908">If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.</span></span>  
  
 <span data-ttu-id="95a33-2909">Эффекты различных параметров разрешения типов отображаются в виде таблицы в разделе " [Разрешение смешанных имен](#mixed_name_resolution) " для простых и имен типов с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2909">The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
#### <a name="resolving-nested-types"></a><span data-ttu-id="95a33-2910">Разрешение вложенных типов</span><span class="sxs-lookup"><span data-stu-id="95a33-2910">Resolving Nested Types</span></span>  
 <span data-ttu-id="95a33-2911">Если `typeName` является вложенным типом, в `typeResolver`передается только имя самого внешнего вмещающего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2911">If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`.</span></span> <span data-ttu-id="95a33-2912">Когда `typeResolver` возвращает этот тип, метод <xref:System.Type.GetNestedType%2A> вызывается рекурсивно, пока не будет разрешен самый внутренний вложенный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-2912">When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.</span></span>  
  
#### <a name="resolving-generic-types"></a><span data-ttu-id="95a33-2913">Разрешение универсальных типов</span><span class="sxs-lookup"><span data-stu-id="95a33-2913">Resolving Generic Types</span></span>  
 <span data-ttu-id="95a33-2914"><xref:System.Type.GetType%2A> вызывается рекурсивно для разрешения универсальных типов: сначала для разрешения самого универсального типа, а затем для разрешения его аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-2914">The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</span></span> <span data-ttu-id="95a33-2915">Если аргумент типа является универсальным, <xref:System.Type.GetType%2A> вызывается рекурсивно для разрешения его аргументов типа и т. д.</span><span class="sxs-lookup"><span data-stu-id="95a33-2915">If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.</span></span>  
  
 <span data-ttu-id="95a33-2916">Сочетание `assemblyResolver` и `typeResolver` должно быть способно разрешать все уровни этой рекурсии.</span><span class="sxs-lookup"><span data-stu-id="95a33-2916">The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion.</span></span> <span data-ttu-id="95a33-2917">Например, предположим, что вы задаете `assemblyResolver`, который управляет загрузкой `MyAssembly`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2917">For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`.</span></span> <span data-ttu-id="95a33-2918">Предположим, что требуется разрешить универсальный тип `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-2918">Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span></span> <span data-ttu-id="95a33-2919">Вы можете передать следующее имя универсального типа:</span><span class="sxs-lookup"><span data-stu-id="95a33-2919">You might pass the following generic type name:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="95a33-2920">Обратите внимание, что `MyType` является единственным аргументом типа с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2920">Notice that `MyType` is the only assembly-qualified type argument.</span></span> <span data-ttu-id="95a33-2921">Имена классов <xref:System.Collections.Generic.Dictionary%602> и <xref:System.String> не задаются с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2921">The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified.</span></span> <span data-ttu-id="95a33-2922">`typeResolver` должен иметь возможность обрабатывать сборку или `null`, так как она будет получать `null` для <xref:System.Collections.Generic.Dictionary%602> и <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2922">Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>.</span></span> <span data-ttu-id="95a33-2923">Это можно сделать, вызвав перегрузку метода <xref:System.Type.GetType%2A>, который принимает строку, так как оба неполных имени типа находятся в mscorlib. dll:</span><span class="sxs-lookup"><span data-stu-id="95a33-2923">It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 <span data-ttu-id="95a33-2924">Метод `assemblyResolver` не вызывается для типа словаря и строкового типа, так как эти имена типов не являются полными сборками.</span><span class="sxs-lookup"><span data-stu-id="95a33-2924">The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</span></span>  
  
 <span data-ttu-id="95a33-2925">Теперь предположим, что вместо `System.String`первый универсальный тип аргумента — `YourType`, из `YourAssembly`:</span><span class="sxs-lookup"><span data-stu-id="95a33-2925">Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="95a33-2926">Так как эта сборка не является ни mscorlib. dll, ни выполняющейся сборкой, нельзя разрешить `YourType` без имени сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2926">Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name.</span></span> <span data-ttu-id="95a33-2927">Так как `assemblyResolve` будет вызываться рекурсивно, он должен иметь возможность обрабатывать этот случай.</span><span class="sxs-lookup"><span data-stu-id="95a33-2927">Because your `assemblyResolve` will be called recursively, it must be able to handle this case.</span></span> <span data-ttu-id="95a33-2928">Вместо того чтобы возвращать `null` для сборок, отличных от `MyAssembly`, теперь она выполняет загрузку сборки с помощью заданного объекта <xref:System.Reflection.AssemblyName>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2928">Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 <span data-ttu-id="95a33-2929">Вернуться к [заметкам об использовании](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="95a33-2929">Back to [Usage Notes](#usage_notes).</span></span>  
  
#### <a name="resolving-type-names-with-special-characters"></a><span data-ttu-id="95a33-2930">Разрешение имен типов с помощью специальных символов</span><span class="sxs-lookup"><span data-stu-id="95a33-2930">Resolving Type Names with Special Characters</span></span>  
 <span data-ttu-id="95a33-2931">Некоторые символы имеют особое значение в именах с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2931">Certain characters have special meanings in assembly-qualified names.</span></span> <span data-ttu-id="95a33-2932">Если простое имя типа содержит эти символы, то символы приводят к ошибкам синтаксического анализа, если простое имя является частью имени с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2932">If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</span></span> <span data-ttu-id="95a33-2933">Чтобы избежать ошибок синтаксического анализа, необходимо экранировать специальные символы с помощью обратной косой черты, прежде чем можно будет передать полное имя сборки методу <xref:System.Type.GetType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2933">To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="95a33-2934">Например, если тип имеет имя `Strange]Type`, необходимо добавить escape-символ перед квадратной скобкой следующим образом: `Strange\]Type`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2934">For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\]Type`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-2935">Имена с такими специальными символами не могут быть созданы C#в Visual Basic или, но могут быть созданы с помощью языка MSIL или путем выпуска динамических сборок.</span><span class="sxs-lookup"><span data-stu-id="95a33-2935">Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</span></span>  
  
 <span data-ttu-id="95a33-2936">В следующей таблице приведены специальные символы для имен типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2936">The following table shows the special characters for type names.</span></span>  
  
|<span data-ttu-id="95a33-2937">Знак</span><span class="sxs-lookup"><span data-stu-id="95a33-2937">Character</span></span>|<span data-ttu-id="95a33-2938">Значение</span><span class="sxs-lookup"><span data-stu-id="95a33-2938">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="95a33-2939">`,` (запятая)</span><span class="sxs-lookup"><span data-stu-id="95a33-2939">`,` (comma)</span></span>|<span data-ttu-id="95a33-2940">Разделитель для имен, соответствующих сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2940">Delimiter for assembly-qualified names.</span></span>|  
|<span data-ttu-id="95a33-2941">`[]` (квадратные скобки)</span><span class="sxs-lookup"><span data-stu-id="95a33-2941">`[]` (square brackets)</span></span>|<span data-ttu-id="95a33-2942">В качестве пары суффиксов указывает тип массива; в качестве пары разделителей заключите списки универсальных аргументов и имена с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2942">As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</span></span>|  
|<span data-ttu-id="95a33-2943">`&` (амперсанд)</span><span class="sxs-lookup"><span data-stu-id="95a33-2943">`&` (ampersand)</span></span>|<span data-ttu-id="95a33-2944">В качестве суффикса указывает, что тип является ссылочным типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-2944">As a suffix, indicates that a type is a reference type.</span></span>|  
|<span data-ttu-id="95a33-2945">`*` (звездочка)</span><span class="sxs-lookup"><span data-stu-id="95a33-2945">`*` (asterisk)</span></span>|<span data-ttu-id="95a33-2946">В качестве суффикса указывает, что тип является типом указателя.</span><span class="sxs-lookup"><span data-stu-id="95a33-2946">As a suffix, indicates that a type is a pointer type.</span></span>|  
|<span data-ttu-id="95a33-2947">`+` (плюс)</span><span class="sxs-lookup"><span data-stu-id="95a33-2947">`+` (plus)</span></span>|<span data-ttu-id="95a33-2948">Разделитель для вложенных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-2948">Delimiter for nested types.</span></span>|  
|<span data-ttu-id="95a33-2949">`\` (обратная косая черта)</span><span class="sxs-lookup"><span data-stu-id="95a33-2949">`\` (backslash)</span></span>|<span data-ttu-id="95a33-2950">Escape-символ.</span><span class="sxs-lookup"><span data-stu-id="95a33-2950">Escape character.</span></span>|  
  
 <span data-ttu-id="95a33-2951">Такие свойства, как <xref:System.Type.AssemblyQualifiedName%2A>, возвращают правильно экранированные строки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2951">Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings.</span></span> <span data-ttu-id="95a33-2952">Необходимо передать правильно экранированные строки в метод <xref:System.Type.GetType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2952">You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="95a33-2953">В свою очередь, метод <xref:System.Type.GetType%2A> передает правильно экранированные имена в `typeResolver` и в методы разрешения типов по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-2953">In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods.</span></span> <span data-ttu-id="95a33-2954">Если необходимо сравнить имя с неэкранированным именем в `typeResolver`, необходимо удалить escape-символы.</span><span class="sxs-lookup"><span data-stu-id="95a33-2954">If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.</span></span>  
  
 <span data-ttu-id="95a33-2955">Вернуться к [заметкам об использовании](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="95a33-2955">Back to [Usage Notes](#usage_notes).</span></span>  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a><span data-ttu-id="95a33-2956">Разрешение смешанных имен</span><span class="sxs-lookup"><span data-stu-id="95a33-2956">Mixed Name Resolution</span></span>  
 <span data-ttu-id="95a33-2957">В следующей таблице приведены сведения о взаимодействии между `assemblyResolver`, `typeResolver`и разрешением имен по умолчанию для всех сочетаний имени типа и имени сборки в `typeName`:</span><span class="sxs-lookup"><span data-stu-id="95a33-2957">The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:</span></span>  
  
|<span data-ttu-id="95a33-2958">Содержимое типа Name</span><span class="sxs-lookup"><span data-stu-id="95a33-2958">Contents of type name</span></span>|<span data-ttu-id="95a33-2959">Метод сопоставителя сборок</span><span class="sxs-lookup"><span data-stu-id="95a33-2959">Assembly resolver method</span></span>|<span data-ttu-id="95a33-2960">Метод распознавателя типов</span><span class="sxs-lookup"><span data-stu-id="95a33-2960">Type resolver method</span></span>|<span data-ttu-id="95a33-2961">Результат</span><span class="sxs-lookup"><span data-stu-id="95a33-2961">Result</span></span>|  
|---------------------------|------------------------------|--------------------------|------------|  
|<span data-ttu-id="95a33-2962">тип, сборка</span><span class="sxs-lookup"><span data-stu-id="95a33-2962">type, assembly</span></span>|<span data-ttu-id="95a33-2963">null</span><span class="sxs-lookup"><span data-stu-id="95a33-2963">null</span></span>|<span data-ttu-id="95a33-2964">null</span><span class="sxs-lookup"><span data-stu-id="95a33-2964">null</span></span>|<span data-ttu-id="95a33-2965">Эквивалентно вызову перегрузки метода <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2965">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span>|  
|<span data-ttu-id="95a33-2966">тип, сборка</span><span class="sxs-lookup"><span data-stu-id="95a33-2966">type, assembly</span></span>|<span data-ttu-id="95a33-2967">предоставляется</span><span class="sxs-lookup"><span data-stu-id="95a33-2967">provided</span></span>|<span data-ttu-id="95a33-2968">null</span><span class="sxs-lookup"><span data-stu-id="95a33-2968">null</span></span>|<span data-ttu-id="95a33-2969">`assemblyResolver` возвращает сборку или возвращает `null`, если не удается разрешить сборку.</span><span class="sxs-lookup"><span data-stu-id="95a33-2969">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="95a33-2970">Если сборка разрешается, то перегрузка метода <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> используется для загрузки типа из сборки. в противном случае не будет пытаться разрешить тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-2970">If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</span></span>|  
|<span data-ttu-id="95a33-2971">тип, сборка</span><span class="sxs-lookup"><span data-stu-id="95a33-2971">type, assembly</span></span>|<span data-ttu-id="95a33-2972">null</span><span class="sxs-lookup"><span data-stu-id="95a33-2972">null</span></span>|<span data-ttu-id="95a33-2973">предоставляется</span><span class="sxs-lookup"><span data-stu-id="95a33-2973">provided</span></span>|<span data-ttu-id="95a33-2974">Эквивалентно преобразованию имени сборки в объект <xref:System.Reflection.AssemblyName> и вызова перегрузки метода <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> для получения сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2974">Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> method overload to get the assembly.</span></span> <span data-ttu-id="95a33-2975">Если сборка разрешается, она передается в `typeResolver`; в противном случае `typeResolver` не вызывается, и дальнейшая попытка разрешения этого типа не требуется.</span><span class="sxs-lookup"><span data-stu-id="95a33-2975">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="95a33-2976">тип, сборка</span><span class="sxs-lookup"><span data-stu-id="95a33-2976">type, assembly</span></span>|<span data-ttu-id="95a33-2977">предоставляется</span><span class="sxs-lookup"><span data-stu-id="95a33-2977">provided</span></span>|<span data-ttu-id="95a33-2978">предоставляется</span><span class="sxs-lookup"><span data-stu-id="95a33-2978">provided</span></span>|<span data-ttu-id="95a33-2979">`assemblyResolver` возвращает сборку или возвращает `null`, если не удается разрешить сборку.</span><span class="sxs-lookup"><span data-stu-id="95a33-2979">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="95a33-2980">Если сборка разрешается, она передается в `typeResolver`; в противном случае `typeResolver` не вызывается, и дальнейшая попытка разрешения этого типа не требуется.</span><span class="sxs-lookup"><span data-stu-id="95a33-2980">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="95a33-2981">type</span><span class="sxs-lookup"><span data-stu-id="95a33-2981">type</span></span>|<span data-ttu-id="95a33-2982">NULL, указано</span><span class="sxs-lookup"><span data-stu-id="95a33-2982">null, provided</span></span>|<span data-ttu-id="95a33-2983">null</span><span class="sxs-lookup"><span data-stu-id="95a33-2983">null</span></span>|<span data-ttu-id="95a33-2984">Эквивалентно вызову перегрузки метода <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-2984">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="95a33-2985">Так как имя сборки не указано, поиск выполняется только в mscorlib. dll и в выполняющейся сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-2985">Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</span></span> <span data-ttu-id="95a33-2986">Если указан `assemblyResolver`, он игнорируется.</span><span class="sxs-lookup"><span data-stu-id="95a33-2986">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="95a33-2987">type</span><span class="sxs-lookup"><span data-stu-id="95a33-2987">type</span></span>|<span data-ttu-id="95a33-2988">NULL, указано</span><span class="sxs-lookup"><span data-stu-id="95a33-2988">null, provided</span></span>|<span data-ttu-id="95a33-2989">предоставляется</span><span class="sxs-lookup"><span data-stu-id="95a33-2989">provided</span></span>|<span data-ttu-id="95a33-2990">`typeResolver` вызывается, и для сборки передается `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-2990">`typeResolver` is called, and `null` is passed for the assembly.</span></span> <span data-ttu-id="95a33-2991">`typeResolver` может предоставить тип из любой сборки, включая сборки, которые она загружает для назначения.</span><span class="sxs-lookup"><span data-stu-id="95a33-2991">`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose.</span></span> <span data-ttu-id="95a33-2992">Если указан `assemblyResolver`, он игнорируется.</span><span class="sxs-lookup"><span data-stu-id="95a33-2992">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="95a33-2993">сборка</span><span class="sxs-lookup"><span data-stu-id="95a33-2993">assembly</span></span>|<span data-ttu-id="95a33-2994">NULL, указано</span><span class="sxs-lookup"><span data-stu-id="95a33-2994">null, provided</span></span>|<span data-ttu-id="95a33-2995">NULL, указано</span><span class="sxs-lookup"><span data-stu-id="95a33-2995">null, provided</span></span>|<span data-ttu-id="95a33-2996">Создается <xref:System.IO.FileLoadException>, так как имя сборки анализируется так, как если бы оно было именем типа с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2996">A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</span></span> <span data-ttu-id="95a33-2997">В результате получается недопустимое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-2997">This results in an invalid assembly name.</span></span>|  
  
 <span data-ttu-id="95a33-2998">Назад: [Примечания об использовании](#usage_notes), [разрешение сборок](#resolving_assemblies), [Разрешение типов](#resolving_types).</span><span class="sxs-lookup"><span data-stu-id="95a33-2998">Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-2999">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-2999"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="95a33-3000">Инициализатор класса вызывается и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-3000">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="95a33-3001"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и тип не найден.</span><span class="sxs-lookup"><span data-stu-id="95a33-3001"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="95a33-3002">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3002">-or-</span></span> 
 <span data-ttu-id="95a33-3003"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции.</span><span class="sxs-lookup"><span data-stu-id="95a33-3003"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="95a33-3004">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3004">-or-</span></span> 
 <span data-ttu-id="95a33-3005"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.</span><span class="sxs-lookup"><span data-stu-id="95a33-3005"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="95a33-3006">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3006">-or-</span></span> 
 <span data-ttu-id="95a33-3007"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.</span><span class="sxs-lookup"><span data-stu-id="95a33-3007"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="95a33-3008">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3008">-or-</span></span> 
 <span data-ttu-id="95a33-3009"><paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3009"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-3010">Произошла ошибка при интерпретации <paramref name="typeName" /> в имя типа и имя сборки (например, если имя простого типа содержит неэкранированный специальный знак).</span><span class="sxs-lookup"><span data-stu-id="95a33-3010">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="95a33-3011">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3011">-or-</span></span> 
 <span data-ttu-id="95a33-3012"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис (например "MyType[,\*,]").</span><span class="sxs-lookup"><span data-stu-id="95a33-3012"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="95a33-3013">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3013">-or-</span></span> 
 <span data-ttu-id="95a33-3014"><paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3014"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="95a33-3015">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3015">-or-</span></span> 
 <span data-ttu-id="95a33-3016"><paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3016"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="95a33-3017">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3017">-or-</span></span> 
 <span data-ttu-id="95a33-3018"><paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3018"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="95a33-3019"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.</span><span class="sxs-lookup"><span data-stu-id="95a33-3019"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="95a33-3020">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</span><span class="sxs-lookup"><span data-stu-id="95a33-3020">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="95a33-3021">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3021">-or-</span></span> 
 <span data-ttu-id="95a33-3022"><paramref name="typeName" /> содержит недопустимое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-3022"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="95a33-3023">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3023">-or-</span></span> 
 <span data-ttu-id="95a33-3024"><paramref name="typeName" /> является допустимым именем сборки без имени типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3024"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="95a33-3025">Сборка или одна из ее зависимостей является недопустимой.</span><span class="sxs-lookup"><span data-stu-id="95a33-3025">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="95a33-3026">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3026">-or-</span></span>  
  
 <span data-ttu-id="95a33-3027">Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</span><span class="sxs-lookup"><span data-stu-id="95a33-3027">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="95a33-3028">Массив объектов, типы которых нужно определить.</span><span class="sxs-lookup"><span data-stu-id="95a33-3028">An array of objects whose types to determine.</span></span></param>
        <summary><span data-ttu-id="95a33-3029">Возвращает типы объектов в указанном массиве.</span><span class="sxs-lookup"><span data-stu-id="95a33-3029">Gets the types of the objects in the specified array.</span></span></summary>
        <returns><span data-ttu-id="95a33-3030">Массив объектов <see cref="T:System.Type" />, представляющих типы соответствующих элементов в массиве <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3030">An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="95a33-3031">В следующем примере кода показано, как использовать метод <xref:System.Type.GetTypeArray%2A> для перечисления типов элементов массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-3031">The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-3032"><paramref name="args" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3032"><paramref name="args" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-3033">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3033">-or-</span></span> 
<span data-ttu-id="95a33-3034">Один или несколько элементов в <paramref name="args" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3034">One or more of the elements in <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="95a33-3035">Вызываются инициализаторы класса, и по крайней мере один из них создает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-3035">The class initializers are invoked and at least one throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="95a33-3036">Тип, код базового типа которого требуется получить.</span><span class="sxs-lookup"><span data-stu-id="95a33-3036">The type whose underlying type code to get.</span></span></param>
        <summary><span data-ttu-id="95a33-3037">Возвращает код базового типа указанного объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3037">Gets the underlying type code of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-3038">Код базового типа или <see cref="F:System.TypeCode.Empty" />, если <paramref name="type" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3038">The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3039">При наследовании от <xref:System.Type>можно изменить поведение этого метода, переопределив метод <xref:System.Type.GetTypeCodeImpl%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3039">When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3040">В следующем примере кода показано, как можно использовать перечисление <xref:System.TypeCode>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3040">The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used.</span></span> <span data-ttu-id="95a33-3041">В блоке принятия решений в методе `WriteObjectInfo` проверяется <xref:System.TypeCode> параметра <xref:System.Object>, и на консоль записывается соответствующее сообщение.</span><span class="sxs-lookup"><span data-stu-id="95a33-3041">In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.</span></span>  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-3042">Возвращает код базового типа этого экземпляра <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3042">Returns the underlying type code of this <see cref="T:System.Type" /> instance.</span></span></summary>
        <returns><span data-ttu-id="95a33-3043">Код типа базового типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3043">The type code of the underlying type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3044">Этот метод обеспечивает реализацию для `static` (в C#) или `Shared` (в Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-3044">This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method.</span></span> <span data-ttu-id="95a33-3045">При наследовании от <xref:System.Type>можно переопределить этот метод, чтобы обеспечить собственную реализацию <xref:System.Type.GetTypeCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3045">When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-3046">Возвращает тип, связанный с заданным кодом CLSID.</span><span class="sxs-lookup"><span data-stu-id="95a33-3046">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="95a33-3047">Код CLSID извлекаемого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3047">The CLSID of the type to get.</span></span></param>
        <summary><span data-ttu-id="95a33-3048">Возвращает тип, связанный с заданным кодом CLSID.</span><span class="sxs-lookup"><span data-stu-id="95a33-3048">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
        <returns><span data-ttu-id="95a33-3049"><see langword="System.__ComObject" /> вне зависимости от того, допустим ли код CLSID.</span><span class="sxs-lookup"><span data-stu-id="95a33-3049"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3050">Метод <xref:System.Type.GetTypeFromCLSID%2A> поддерживает доступ с поздним связыванием к неуправляемым COM-объектам из .NET Framework приложений, если известно, что идентификатор класса (CLSID) COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3050">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="95a33-3051">Идентификатор класса для COM-классов определяется в ключе HKEY_CLASSES_ROOT\CLSID реестра.</span><span class="sxs-lookup"><span data-stu-id="95a33-3051">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="95a33-3052">Можно получить значение свойства <xref:System.Type.IsCOMObject%2A>, чтобы определить, является ли тип, возвращаемый этим методом, COM-объектом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3052">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="95a33-3053">Можно вызвать метод <xref:System.Type.GetTypeFromProgID%2A> для доступа с поздним связыванием к COM-объектам, известный программному идентификатору (ProgID).</span><span class="sxs-lookup"><span data-stu-id="95a33-3053">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="95a33-3054">Создание экземпляра неуправляемого COM-объекта из его CLSID состоит из двух этапов:</span><span class="sxs-lookup"><span data-stu-id="95a33-3054">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="95a33-3055">Получите объект <xref:System.Type>, представляющий`__ComObject`, соответствующий CLSID, вызвав метод <xref:System.Type.GetTypeFromCLSID%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3055">Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="95a33-3056">Вызовите метод <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>, чтобы создать экземпляр COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3056">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="95a33-3057">См. пример для иллюстрации.</span><span class="sxs-lookup"><span data-stu-id="95a33-3057">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="95a33-3058">Перегрузка <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> игнорирует все исключения, которые могут возникнуть при создании экземпляра <xref:System.Type> объекта на основе аргумента `clsid`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3058">The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument.</span></span> <span data-ttu-id="95a33-3059">Обратите внимание, что исключение не возникает, если `clsid` не найдено в реестре.</span><span class="sxs-lookup"><span data-stu-id="95a33-3059">Note that no exception is thrown if `clsid` is not found in the registry.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3060">В следующем примере используется CLSID [объекта приложения](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) Microsoft Word для получения типа COM, представляющего приложение Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="95a33-3060">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="95a33-3061">Затем он создает экземпляр типа, вызывая метод <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> и закрывает его, вызывая метод [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) .</span><span class="sxs-lookup"><span data-stu-id="95a33-3061">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="95a33-3062">Этот метод предназначен для использования при работе с COM-объектами, а не с .NET Framework объектами.</span><span class="sxs-lookup"><span data-stu-id="95a33-3062">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="95a33-3063">Все управляемые объекты, включая те, которые видимы для COM (то есть их <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> атрибут <see langword="true" />) имеют идентификатор GUID, возвращаемый свойством <see cref="P:System.Type.GUID" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3063">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="95a33-3064">Несмотря на то, что метод возвращает объект <see cref="T:System.Type" />, соответствующий идентификатору GUID для .NET Framework объектов, нельзя использовать этот <see cref="T:System.Type" /> объект для создания экземпляра типа путем вызова метода <see cref="M:System.Activator.CreateInstance(System.Type)" />, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="95a33-3064">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="95a33-3065">[! код-CSharp[System. Type. жеттипефромклсид # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! код-VB[System. Type. жеттипефромклсид # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="95a33-3065">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="95a33-3066">Вместо этого <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> следует использовать только для получения идентификатора GUID неуправляемого COM-объекта, а результирующий <see cref="T:System.Type" /> объект, который передается в метод <see cref="M:System.Activator.CreateInstance(System.Type)" />, должен представлять неуправляемый COM-объект.</span><span class="sxs-lookup"><span data-stu-id="95a33-3066">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="95a33-3067">Код CLSID извлекаемого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3067">The CLSID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="95a33-3068">Значение <see langword="true" /> для вызова любого возникшего исключения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3068"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="95a33-3069">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3069">-or-</span></span> 
 <span data-ttu-id="95a33-3070">Значение <see langword="false" /> для игнорирования всех происходящих исключений.</span><span class="sxs-lookup"><span data-stu-id="95a33-3070"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="95a33-3071">Возвращает тип, связанный с заданным кодом CLSID, позволяющий определить, будет ли выбрасываться исключение в случае происхождения ошибки при загрузке типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3071">Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="95a33-3072"><see langword="System.__ComObject" /> вне зависимости от того, допустим ли код CLSID.</span><span class="sxs-lookup"><span data-stu-id="95a33-3072"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3073">Метод <xref:System.Type.GetTypeFromCLSID%2A> поддерживает доступ с поздним связыванием к неуправляемым COM-объектам из .NET Framework приложений, если известно, что идентификатор класса (CLSID) COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3073">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="95a33-3074">Идентификатор класса для COM-классов определяется в ключе HKEY_CLASSES_ROOT\CLSID реестра.</span><span class="sxs-lookup"><span data-stu-id="95a33-3074">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="95a33-3075">Можно получить значение свойства <xref:System.Type.IsCOMObject%2A>, чтобы определить, является ли тип, возвращаемый этим методом, COM-объектом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3075">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="95a33-3076">Можно вызвать метод <xref:System.Type.GetTypeFromProgID%2A> для доступа с поздним связыванием к COM-объектам, известный программному идентификатору (ProgID).</span><span class="sxs-lookup"><span data-stu-id="95a33-3076">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="95a33-3077">Создание экземпляра неуправляемого COM-объекта из его CLSID состоит из двух этапов:</span><span class="sxs-lookup"><span data-stu-id="95a33-3077">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="95a33-3078">Получите объект <xref:System.Type>, представляющий `__ComObject`, соответствующий CLSID, вызвав метод <xref:System.Type.GetTypeFromCLSID%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3078">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="95a33-3079">Вызовите метод <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>, чтобы создать экземпляр COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3079">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="95a33-3080">См. пример для иллюстрации.</span><span class="sxs-lookup"><span data-stu-id="95a33-3080">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="95a33-3081">Исключения, такие как <xref:System.OutOfMemoryException>, будут выдаваться при указании `true` для `throwOnError`, но не будут завершаться ошибкой для незарегистрированных идентификаторов CLSID.</span><span class="sxs-lookup"><span data-stu-id="95a33-3081">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3082">В следующем примере используется CLSID [объекта приложения](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) Microsoft Word для получения типа COM, представляющего приложение Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="95a33-3082">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="95a33-3083">Затем он создает экземпляр типа, вызывая метод <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> и закрывает его, вызывая метод [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) .</span><span class="sxs-lookup"><span data-stu-id="95a33-3083">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="95a33-3084">При возникновении ошибки при загрузке типа возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-3084">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="95a33-3085">Этот метод предназначен для использования при работе с COM-объектами, а не с .NET Framework объектами.</span><span class="sxs-lookup"><span data-stu-id="95a33-3085">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="95a33-3086">Все управляемые объекты, включая те, которые видимы для COM (то есть их <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> атрибут <see langword="true" />) имеют идентификатор GUID, возвращаемый свойством <see cref="P:System.Type.GUID" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3086">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="95a33-3087">Несмотря на то, что метод возвращает объект <see cref="T:System.Type" />, соответствующий идентификатору GUID для .NET Framework объектов, нельзя использовать этот <see cref="T:System.Type" /> объект для создания экземпляра типа путем вызова метода <see cref="M:System.Activator.CreateInstance(System.Type)" />, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="95a33-3087">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="95a33-3088">[! код-CSharp[System. Type. жеттипефромклсид # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! код-VB[System. Type. жеттипефромклсид # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="95a33-3088">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="95a33-3089">Вместо этого <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> следует использовать только для получения идентификатора GUID неуправляемого COM-объекта, а результирующий <see cref="T:System.Type" /> объект, который передается в метод <see cref="M:System.Activator.CreateInstance(System.Type)" />, должен представлять неуправляемый COM-объект.</span><span class="sxs-lookup"><span data-stu-id="95a33-3089">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="95a33-3090">Код CLSID извлекаемого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3090">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="95a33-3091">Сервер, с которого должен быть загружен тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3091">The server from which to load the type.</span></span> <span data-ttu-id="95a33-3092">Если в качестве имени сервера задано значение <see langword="null" />, этот метод автоматически перейдет к поиску на локальном компьютере.</span><span class="sxs-lookup"><span data-stu-id="95a33-3092">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="95a33-3093">Возвращает с указанного сервера тип, связанный с заданным кодом CLSID.</span><span class="sxs-lookup"><span data-stu-id="95a33-3093">Gets the type associated with the specified class identifier (CLSID) from the specified server.</span></span></summary>
        <returns><span data-ttu-id="95a33-3094"><see langword="System.__ComObject" /> вне зависимости от того, допустим ли код CLSID.</span><span class="sxs-lookup"><span data-stu-id="95a33-3094"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3095">Метод <xref:System.Type.GetTypeFromCLSID%2A> поддерживает доступ с поздним связыванием к неуправляемым COM-объектам из .NET Framework приложений, если известно, что идентификатор класса (CLSID) COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3095">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="95a33-3096">Идентификатор класса для COM-классов определяется в ключе HKEY_CLASSES_ROOT\CLSID реестра.</span><span class="sxs-lookup"><span data-stu-id="95a33-3096">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="95a33-3097">Можно получить значение свойства <xref:System.Type.IsCOMObject%2A>, чтобы определить, является ли тип, возвращаемый этим методом, COM-объектом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3097">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="95a33-3098">Можно вызвать метод <xref:System.Type.GetTypeFromProgID%2A> для доступа с поздним связыванием к COM-объектам, известный программному идентификатору (ProgID).</span><span class="sxs-lookup"><span data-stu-id="95a33-3098">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="95a33-3099">Создание экземпляра неуправляемого COM-объекта из его CLSID состоит из двух этапов:</span><span class="sxs-lookup"><span data-stu-id="95a33-3099">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="95a33-3100">Получите объект <xref:System.Type>, представляющий `__ComObject`, соответствующий CLSID, вызвав метод <xref:System.Type.GetTypeFromCLSID%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3100">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="95a33-3101">Вызовите метод <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>, чтобы создать экземпляр COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3101">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3102">В следующем примере используется CLSID [объекта приложения](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) Microsoft Word для получения типа COM, представляющего приложение Microsoft Word с сервера с именем computer17.Central.contoso.com.</span><span class="sxs-lookup"><span data-stu-id="95a33-3102">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="95a33-3103">Затем он создает экземпляр типа, вызывая метод <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> и закрывает его, вызывая метод [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) .</span><span class="sxs-lookup"><span data-stu-id="95a33-3103">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="95a33-3104">Этот метод предназначен для использования при работе с COM-объектами, а не с .NET Framework объектами.</span><span class="sxs-lookup"><span data-stu-id="95a33-3104">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="95a33-3105">Все управляемые объекты, включая те, которые видимы для COM (то есть их <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> атрибут <see langword="true" />) имеют идентификатор GUID, возвращаемый свойством <see cref="P:System.Type.GUID" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3105">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="95a33-3106">Несмотря на то, что метод возвращает объект <see cref="T:System.Type" />, соответствующий идентификатору GUID для .NET Framework объектов, нельзя использовать этот <see cref="T:System.Type" /> объект для создания экземпляра типа путем вызова метода <see cref="M:System.Activator.CreateInstance(System.Type)" />, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="95a33-3106">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="95a33-3107">[! код-CSharp[System. Type. жеттипефромклсид # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! код-VB[System. Type. жеттипефромклсид # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="95a33-3107">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="95a33-3108">Вместо этого <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> следует использовать только для получения идентификатора GUID неуправляемого COM-объекта, а результирующий <see cref="T:System.Type" /> объект, который передается в метод <see cref="M:System.Activator.CreateInstance(System.Type)" />, должен представлять неуправляемый COM-объект.</span><span class="sxs-lookup"><span data-stu-id="95a33-3108">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="95a33-3109">Код CLSID извлекаемого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3109">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="95a33-3110">Сервер, с которого должен быть загружен тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3110">The server from which to load the type.</span></span> <span data-ttu-id="95a33-3111">Если в качестве имени сервера задано значение <see langword="null" />, этот метод автоматически перейдет к поиску на локальном компьютере.</span><span class="sxs-lookup"><span data-stu-id="95a33-3111">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="95a33-3112">Значение <see langword="true" /> для вызова любого возникшего исключения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3112"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="95a33-3113">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3113">-or-</span></span> 
 <span data-ttu-id="95a33-3114">Значение <see langword="false" /> для игнорирования всех происходящих исключений.</span><span class="sxs-lookup"><span data-stu-id="95a33-3114"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="95a33-3115">Возвращает с указанного сервера тип, связанный с заданным кодом CLSID, позволяющий определить, будет ли выбрасываться исключение при происхождении ошибки во время загрузки типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3115">Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="95a33-3116"><see langword="System.__ComObject" /> вне зависимости от того, допустим ли код CLSID.</span><span class="sxs-lookup"><span data-stu-id="95a33-3116"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3117">Метод <xref:System.Type.GetTypeFromCLSID%2A> поддерживает доступ с поздним связыванием к неуправляемым COM-объектам из .NET Framework приложений, если известно, что идентификатор класса (CLSID) COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3117">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="95a33-3118">Идентификатор класса для COM-классов определяется в ключе HKEY_CLASSES_ROOT\CLSID реестра.</span><span class="sxs-lookup"><span data-stu-id="95a33-3118">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="95a33-3119">Можно получить значение свойства <xref:System.Type.IsCOMObject%2A>, чтобы определить, является ли тип, возвращаемый этим методом, COM-объектом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3119">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="95a33-3120">Можно вызвать метод <xref:System.Type.GetTypeFromProgID%2A> для доступа с поздним связыванием к COM-объектам, известный программному идентификатору (ProgID).</span><span class="sxs-lookup"><span data-stu-id="95a33-3120">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="95a33-3121">Создание экземпляра неуправляемого COM-объекта из его CLSID состоит из двух этапов:</span><span class="sxs-lookup"><span data-stu-id="95a33-3121">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="95a33-3122">Получите объект <xref:System.Type>, представляющий `__ComObject`, соответствующий CLSID, вызвав метод <xref:System.Type.GetTypeFromCLSID%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3122">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="95a33-3123">Вызовите метод <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>, чтобы создать экземпляр COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3123">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="95a33-3124">Исключения, такие как <xref:System.OutOfMemoryException>, будут выдаваться при указании `true` для `throwOnError`, но не будут завершаться ошибкой для незарегистрированных идентификаторов CLSID.</span><span class="sxs-lookup"><span data-stu-id="95a33-3124">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3125">В следующем примере используется CLSID [объекта приложения](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) Microsoft Word для получения типа COM, представляющего приложение Microsoft Word с сервера с именем computer17.Central.contoso.com.</span><span class="sxs-lookup"><span data-stu-id="95a33-3125">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="95a33-3126">Затем он создает экземпляр типа, вызывая метод <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> и закрывает его, вызывая метод [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) .</span><span class="sxs-lookup"><span data-stu-id="95a33-3126">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="95a33-3127">При возникновении ошибки при загрузке типа возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-3127">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="95a33-3128">Этот метод предназначен для использования при работе с COM-объектами, а не с .NET Framework объектами.</span><span class="sxs-lookup"><span data-stu-id="95a33-3128">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="95a33-3129">Все управляемые объекты, включая те, которые видимы для COM (то есть их <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> атрибут <see langword="true" />) имеют идентификатор GUID, возвращаемый свойством <see cref="P:System.Type.GUID" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3129">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="95a33-3130">Несмотря на то, что метод <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> возвращает объект <see cref="T:System.Type" />, соответствующий идентификатору GUID для конкретного управляемого объекта, нельзя использовать этот <see cref="T:System.Type" /> объект для создания экземпляра типа путем вызова метода <see cref="M:System.Activator.CreateInstance(System.Type)" />, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="95a33-3130">Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="95a33-3131">[! код-CSharp[System. Type. жеттипефромклсид # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! код-VB[System. Type. жеттипефромклсид # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="95a33-3131">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="95a33-3132">Вместо этого <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> следует использовать только для получения идентификатора GUID неуправляемого COM-объекта, а результирующий <see cref="T:System.Type" /> объект, который передается в метод <see cref="M:System.Activator.CreateInstance(System.Type)" />, должен представлять неуправляемый COM-объект.</span><span class="sxs-lookup"><span data-stu-id="95a33-3132">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="95a33-3133">Объект, который ссылается на тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3133">The object that refers to the type.</span></span></param>
        <summary><span data-ttu-id="95a33-3134">Возвращает тип, на который ссылается указанный дескриптор типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3134">Gets the type referenced by the specified type handle.</span></span></summary>
        <returns><span data-ttu-id="95a33-3135">Тип, на который ссылается заданный дескриптор <see cref="T:System.RuntimeTypeHandle" />, или значение <see langword="null" />, если значение свойства <see cref="P:System.RuntimeTypeHandle.Value" /> параметра <paramref name="handle" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3135">The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3136">Дескрипторы допустимы только в том домене приложения, в котором они были получены.</span><span class="sxs-lookup"><span data-stu-id="95a33-3136">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3137">В следующем примере метод <xref:System.Type.GetTypeFromHandle%2A> используется для получения объекта <xref:System.Type> из <xref:System.RuntimeTypeHandle>, предоставляемого методом <xref:System.Type.GetTypeHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3137">The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.</span></span>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="95a33-3138">Инициализатор класса вызывается и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-3138">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-3139">Возвращает тип, связанный с заданным идентификатором ProgID.</span><span class="sxs-lookup"><span data-stu-id="95a33-3139">Gets the type associated with the specified program identifier (ProgID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="95a33-3140">Идентификатор ProgID извлекаемого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3140">The ProgID of the type to get.</span></span></param>
        <summary><span data-ttu-id="95a33-3141">Возвращает тип, связанный с указанным идентификатором ProgID, и возвращает значение NULL, если при загрузке объекта <see cref="T:System.Type" /> возникла ошибка.</span><span class="sxs-lookup"><span data-stu-id="95a33-3141">Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-3142">Тип, связанный с указанным идентификатором ProgID, если идентификатор <paramref name="progID" /> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3142">The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3143">Этот метод предоставляется для поддержки COM.</span><span class="sxs-lookup"><span data-stu-id="95a33-3143">This method is provided for COM support.</span></span> <span data-ttu-id="95a33-3144">Идентификаторы ProgID не используются в Microsoft .NET Framework, поскольку они были заменены концепцией пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-3144">ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-3145">Свойство <paramref name="progID" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3145"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95a33-3146">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3146">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="95a33-3147">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3147">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="95a33-3148">Идентификатор ProgID извлекаемого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3148">The ProgID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="95a33-3149">Значение<see langword="true" /> для вызова любого возникшего исключения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3149"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="95a33-3150">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3150">-or-</span></span> 
 <span data-ttu-id="95a33-3151">Значение <see langword="false" /> для игнорирования всех происходящих исключений.</span><span class="sxs-lookup"><span data-stu-id="95a33-3151"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="95a33-3152">Возвращает тип, связанный с заданным идентификатором ProgID, позволяющим определить, будет ли выбрасываться исключение при происхождении ошибки во время загрузки типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3152">Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="95a33-3153">Тип, связанный с указанным идентификатором ProgID, если идентификатор <paramref name="progID" /> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3153">The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3154">Этот метод предоставляется для поддержки COM.</span><span class="sxs-lookup"><span data-stu-id="95a33-3154">This method is provided for COM support.</span></span> <span data-ttu-id="95a33-3155">Идентификаторы программ не используются в Microsoft .NET Framework, поскольку они были заменены концепцией пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-3155">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3156">В следующем примере тип извлекается путем передачи ProgID, указывая, следует ли создавать исключение, если ProgID является недопустимым.</span><span class="sxs-lookup"><span data-stu-id="95a33-3156">The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</span></span> <span data-ttu-id="95a33-3157">Затем в примере отображается идентификатор ClassID, связанный с ProgID, а также любое применимое сообщение об исключении.</span><span class="sxs-lookup"><span data-stu-id="95a33-3157">The example then displays the ClassID related to the ProgID, along with any applicable exception message.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-3158"><paramref name="progID" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3158"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="95a33-3159">Указанный идентификатор ProgID не зарегистрирован.</span><span class="sxs-lookup"><span data-stu-id="95a33-3159">The specified ProgID is not registered.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95a33-3160">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3160">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="95a33-3161">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3161">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="95a33-3162">Идентификатор ProgID извлекаемого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3162">The progID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="95a33-3163">Сервер, с которого должен быть загружен тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3163">The server from which to load the type.</span></span> <span data-ttu-id="95a33-3164">Если в качестве имени сервера задано значение <see langword="null" />, этот метод автоматически перейдет к поиску на локальном компьютере.</span><span class="sxs-lookup"><span data-stu-id="95a33-3164">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="95a33-3165">Возвращает с указанного сервера тип, связанный с заданным идентификатором ProgID, и возвращает значение NULL, если при загрузке типа произошла ошибка.</span><span class="sxs-lookup"><span data-stu-id="95a33-3165">Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</span></span></summary>
        <returns><span data-ttu-id="95a33-3166">Тип, связанный с заданным идентификатором ProgID, если идентификатор <paramref name="progID" /> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3166">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3167">Этот метод предоставляется для поддержки COM.</span><span class="sxs-lookup"><span data-stu-id="95a33-3167">This method is provided for COM support.</span></span> <span data-ttu-id="95a33-3168">Идентификаторы программ не используются в Microsoft .NET Framework, поскольку они были заменены концепцией пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-3168">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3169">В следующем примере тип извлекается путем передачи идентификатора ProgID и имени сервера.</span><span class="sxs-lookup"><span data-stu-id="95a33-3169">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="95a33-3170">Затем в примере отображается идентификатор ClassID, связанный с идентификатором ProgID, или исключение, если идентификатор ProgID или имя сервера являются недопустимыми.</span><span class="sxs-lookup"><span data-stu-id="95a33-3170">The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-3171">Свойство <paramref name="prodID" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3171"><paramref name="prodID" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95a33-3172">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3172">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="95a33-3173">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3173">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="95a33-3174">Идентификатор ProgID извлекаемого типа <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3174">The progID of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="server"><span data-ttu-id="95a33-3175">Сервер, с которого должен быть загружен тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3175">The server from which to load the type.</span></span> <span data-ttu-id="95a33-3176">Если в качестве имени сервера задано значение <see langword="null" />, этот метод автоматически перейдет к поиску на локальном компьютере.</span><span class="sxs-lookup"><span data-stu-id="95a33-3176">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="95a33-3177">Значение <see langword="true" /> для вызова любого возникшего исключения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3177"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="95a33-3178">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3178">-or-</span></span> 
 <span data-ttu-id="95a33-3179">Значение <see langword="false" /> для игнорирования всех происходящих исключений.</span><span class="sxs-lookup"><span data-stu-id="95a33-3179"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="95a33-3180">Возвращает с указанного сервера тип, связанный с заданным идентификатором progID, который позволяет определить, будет ли выбрасываться исключение при происхождении ошибки во время загрузки типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3180">Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="95a33-3181">Тип, связанный с заданным идентификатором ProgID, если идентификатор <paramref name="progID" /> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3181">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3182">Этот метод предоставляется для поддержки COM.</span><span class="sxs-lookup"><span data-stu-id="95a33-3182">This method is provided for COM support.</span></span> <span data-ttu-id="95a33-3183">Идентификаторы программ не используются в Microsoft .NET Framework, поскольку они были заменены концепцией пространства имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-3183">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3184">В следующем примере тип извлекается путем передачи идентификатора ProgID и имени сервера.</span><span class="sxs-lookup"><span data-stu-id="95a33-3184">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="95a33-3185">Затем в примере отображается идентификатор ClassID, связанный с идентификатором ProgID, указывающий, следует ли создавать исключение, если идентификатор ProgID или имя сервера являются недопустимыми.</span><span class="sxs-lookup"><span data-stu-id="95a33-3185">The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-3186">Свойство <paramref name="progID" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3186"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="95a33-3187">Указанный идентификатор progID не зарегистрирован.</span><span class="sxs-lookup"><span data-stu-id="95a33-3187">The specified progID is not registered.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95a33-3188">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3188">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="95a33-3189">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3189">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95a33-3190">Объект, для которого требуется получить дескриптор типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3190">The object for which to get the type handle.</span></span></param>
        <summary><span data-ttu-id="95a33-3191">Возвращает дескриптор <see cref="T:System.Type" /> для указанного объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3191">Gets the handle for the <see cref="T:System.Type" /> of a specified object.</span></span></summary>
        <returns><span data-ttu-id="95a33-3192">Дескриптор типа <see cref="T:System.Type" /> для указанного объекта <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3192">The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3193">Дескрипторы допустимы только в том домене приложения, в котором они были получены.</span><span class="sxs-lookup"><span data-stu-id="95a33-3193">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3194">В следующем примере определяется класс `MyClass1`, получается его экземпляр и извлекается маркер среды выполнения объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3194">The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.</span></span>  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-3195">Свойство <paramref name="o" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3195"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3196">Возвращает идентификатор GUID, связанный с объектом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3196">Gets the GUID associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="95a33-3197">Идентификатор GUID, связанный с объектом <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3197">The GUID associated with the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3198">Идентификатор GUID связан с типом с помощью атрибута <xref:System.Runtime.InteropServices.GuidAttribute>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3198">A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3199">В следующем примере создается класс `MyClass1` с открытым методом, создается объект `Type`, соответствующий `MyClass1`, и структура <xref:System.Guid> с помощью свойства `GUID` класса `Type`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3199">The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.</span></span>  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3200">Возвращает значение, позволяющее определить, содержит ли текущий объект <see cref="T:System.Type" /> в себе другой тип или ссылку на другой тип (иными словами, является ли текущий объект <see cref="T:System.Type" /> массивом, указателем либо параметром или же он передается по ссылке).</span><span class="sxs-lookup"><span data-stu-id="95a33-3200">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <value><span data-ttu-id="95a33-3201">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является массивом, указателем или параметром, переданным по ссылке; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3201"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3202">Например, введите. GetType ("Int32 []"). Хаселементтипе возвращает `true`, но Type. GetType ("Int32"). Хаселементтипе возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3202">For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`.</span></span> <span data-ttu-id="95a33-3203">Хаселементтипе также возвращает `true` для "Int32 \*" и "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="95a33-3203">HasElementType also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
 <span data-ttu-id="95a33-3204">Если текущий <xref:System.Type> представляет универсальный тип или параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3204">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3205">В следующем примере возвращается `true` или `false` в зависимости от того, является ли объект массивом, ссылочным типом или указателем.</span><span class="sxs-lookup"><span data-stu-id="95a33-3205">The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.</span></span>  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-3206">При переопределении в производном классе реализует свойство <see cref="P:System.Type.HasElementType" /> и определяет, что содержится в текущем объекте <see cref="T:System.Type" />: непосредственно другой тип или же указывающая на него ссылка (иными словами, является ли текущий объект <see cref="T:System.Type" /> массивом, указателем или параметром или же он передается по ссылке).</span><span class="sxs-lookup"><span data-stu-id="95a33-3206">When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="95a33-3207">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является массивом, указателем или параметром, переданным по ссылке; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3207"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3208">Например, введите. GetType ("Int32 []"). Хаселементтипеимпл возвращает `true`, но Type. GetType ("Int32"). Хаселементтипеимпл возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3208">For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`.</span></span> <span data-ttu-id="95a33-3209">Хаселементтипеимпл также возвращает `true` для "Int32 \*" и "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="95a33-3209">HasElementTypeImpl also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3210">В следующем примере определяется класс `MyTypeDelegator`, который переопределяет метод `HasElementTypeImpl`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3210">The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="95a33-3211">Основной класс проверяет свойство `HasElementType` и отображает тип элемента.</span><span class="sxs-lookup"><span data-stu-id="95a33-3211">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-3212">Вызывает определенный член текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3212">Invokes a specific member of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-3213">Строка, содержащая имя вызываемого элемента — конструктора, метода, свойства или поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-3213">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="95a33-3214">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3214">-or-</span></span> 
<span data-ttu-id="95a33-3215">Пустая строка ("") — в этом случае будет вызван член по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-3215">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="95a33-3216">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3216">-or-</span></span> 
<span data-ttu-id="95a33-3217">Для членов <see langword="IDispatch" /> — строка, представляющая идентификатор DispID, например "[DispID=3]".</span><span class="sxs-lookup"><span data-stu-id="95a33-3217">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="95a33-3218">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-3218">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span> <span data-ttu-id="95a33-3219">Тип доступа может быть обозначен одним из флагов <see langword="BindingFlags" />, например <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> и т.д.</span><span class="sxs-lookup"><span data-stu-id="95a33-3219">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="95a33-3220">Тип поиска указывать необязательно.</span><span class="sxs-lookup"><span data-stu-id="95a33-3220">The type of lookup need not be specified.</span></span> <span data-ttu-id="95a33-3221">Если тип поиска не указан, используются флаги <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3221">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="95a33-3222">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3222">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="95a33-3223">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3223">-or-</span></span> 
<span data-ttu-id="95a33-3224">Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3224">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="95a33-3225">Обратите внимание, что для успешного вызова перегруженных версий метода с переменными аргументами может потребоваться явное объявление объекта <see cref="T:System.Reflection.Binder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3225">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="95a33-3226">Объект, для которого следует вызвать указанный член.</span><span class="sxs-lookup"><span data-stu-id="95a33-3226">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="95a33-3227">Массив с аргументами, передаваемыми вызываемому члену.</span><span class="sxs-lookup"><span data-stu-id="95a33-3227">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <summary><span data-ttu-id="95a33-3228">Вызывает указанный член, соответствующий заданным ограничениям привязки и указанному списку аргументов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3228">Invokes the specified member, using the specified binding constraints and matching the specified argument list.</span></span></summary>
        <returns><span data-ttu-id="95a33-3229">Объект, представляющий возвращаемое значение вызываемого элемента.</span><span class="sxs-lookup"><span data-stu-id="95a33-3229">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3230">Нельзя использовать <xref:System.Type.InvokeMember%2A> для вызова универсального метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-3230">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="95a33-3231">Для определения элементов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3231">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-3232">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые члены.</span><span class="sxs-lookup"><span data-stu-id="95a33-3232">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="95a33-3233">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск не являющиеся открытыми члены (то есть закрытые и защищенные члены).</span><span class="sxs-lookup"><span data-stu-id="95a33-3233">Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-3234">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить статические элементы вверх по иерархии.</span><span class="sxs-lookup"><span data-stu-id="95a33-3234">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="95a33-3235">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3235">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-3236">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3236">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-3237">`BindingFlags.DeclaredOnly` искать только члены, объявленные в <xref:System.Type>, а не члены, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-3237">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-3238">Для обозначения действия, выполняемого с элементом, можно использовать следующие флаги вызова <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3238">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="95a33-3239">`CreateInstance` вызвать конструктор.</span><span class="sxs-lookup"><span data-stu-id="95a33-3239">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="95a33-3240">`name` игнорируется.</span><span class="sxs-lookup"><span data-stu-id="95a33-3240">`name` is ignored.</span></span> <span data-ttu-id="95a33-3241">Недопустимый с другими флагами вызова.</span><span class="sxs-lookup"><span data-stu-id="95a33-3241">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="95a33-3242">`InvokeMethod` вызывать метод, но не конструктор или инициализатор типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3242">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="95a33-3243">Недопустимо для `SetField` или `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3243">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="95a33-3244">Если `InvokeMethod` указывается сама по себе, автоматически включаются `BindingFlags.Public`, `BindingFlags.Instance`и `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3244">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="95a33-3245">`GetField`, чтобы получить значение поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-3245">`GetField` to get the value of a field.</span></span> <span data-ttu-id="95a33-3246">Недопустимый для `SetField`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3246">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="95a33-3247">`SetField`, чтобы задать значение поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-3247">`SetField` to set the value of a field.</span></span> <span data-ttu-id="95a33-3248">Недопустимый для `GetField`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3248">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="95a33-3249">`GetProperty` получить свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-3249">`GetProperty` to get a property.</span></span> <span data-ttu-id="95a33-3250">Недопустимый для `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3250">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="95a33-3251">`SetProperty` задать свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-3251">`SetProperty` to set a property.</span></span> <span data-ttu-id="95a33-3252">Недопустимый для `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3252">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="95a33-3253">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3253">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-3254">Метод будет вызываться, если выполняются оба следующих условия.</span><span class="sxs-lookup"><span data-stu-id="95a33-3254">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="95a33-3255">Число параметров в объявлении метода равно числу аргументов в массиве `args` (если для элемента не определены аргументы по умолчанию и не указан `BindingFlags.OptionalParamBinding`).</span><span class="sxs-lookup"><span data-stu-id="95a33-3255">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="95a33-3256">Тип каждого аргумента может быть преобразован связывателем в тип параметра.</span><span class="sxs-lookup"><span data-stu-id="95a33-3256">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="95a33-3257">Связыватель найдет все методы сопоставления.</span><span class="sxs-lookup"><span data-stu-id="95a33-3257">The binder will find all of the matching methods.</span></span> <span data-ttu-id="95a33-3258">Эти методы обнаруживаются в зависимости от типа запрашиваемой привязки (<xref:System.Reflection.BindingFlags> значения `InvokeMethod`, `GetProperty`и т. д.).</span><span class="sxs-lookup"><span data-stu-id="95a33-3258">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="95a33-3259">Набор методов фильтруется по имени, числу аргументов и набору модификаторов поиска, определенных в связывателе.</span><span class="sxs-lookup"><span data-stu-id="95a33-3259">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="95a33-3260">После выбора метода вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="95a33-3260">After the method is selected, it is invoked.</span></span> <span data-ttu-id="95a33-3261">На этом этапе проверяется доступность.</span><span class="sxs-lookup"><span data-stu-id="95a33-3261">Accessibility is checked at that point.</span></span> <span data-ttu-id="95a33-3262">Поиск может управлять тем, какой набор методов выполняется в зависимости от атрибута доступности, связанного с методом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3262">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="95a33-3263">Метод <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> класса <xref:System.Reflection.Binder> отвечает за выбор вызываемого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-3263">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="95a33-3264">Связыватель по умолчанию выбирает наиболее конкретное соответствие.</span><span class="sxs-lookup"><span data-stu-id="95a33-3264">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="95a33-3265">Ограничения доступа игнорируются для полностью доверенного кода. Это значит, что доступ к частным конструкторам, методам, полям и свойствам можно получить и вызвать с помощью <xref:System.Reflection> всякий раз, когда код полностью надежен.</span><span class="sxs-lookup"><span data-stu-id="95a33-3265">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="95a33-3266">`Type.InvokeMember` можно использовать для задания определенного значения поля, указав <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3266">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95a33-3267">Например, если необходимо задать открытое поле экземпляра с именем F для класса C, а F — `String`, можно использовать такой код:</span><span class="sxs-lookup"><span data-stu-id="95a33-3267">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 <span data-ttu-id="95a33-3268">Если F является `String[]`, можно использовать такой код:</span><span class="sxs-lookup"><span data-stu-id="95a33-3268">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 <span data-ttu-id="95a33-3269">что приведет к инициализации поля F в новый массив.</span><span class="sxs-lookup"><span data-stu-id="95a33-3269">which will initialize the field F to this new array.</span></span> <span data-ttu-id="95a33-3270">Можно также использовать `Type.InvokeMember` для задания позиции в массиве, указав индекс значения, а затем следующее значение с помощью следующего кода:</span><span class="sxs-lookup"><span data-stu-id="95a33-3270">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 <span data-ttu-id="95a33-3271">Это изменит строку "z" в массиве, который F содержит строку "b".</span><span class="sxs-lookup"><span data-stu-id="95a33-3271">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="95a33-3272">При вызове элемента `IDispatch` можно указать DISPID вместо имени члена, используя формат строки "[DispID = # #]".</span><span class="sxs-lookup"><span data-stu-id="95a33-3272">When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="95a33-3273">Например, если DISPID Микоммесод имеет значение 3, можно указать строку "[DISPID = 3]" вместо "Микоммесод".</span><span class="sxs-lookup"><span data-stu-id="95a33-3273">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="95a33-3274">Вызов члена по DISPID выполняется быстрее, чем поиск члена по имени.</span><span class="sxs-lookup"><span data-stu-id="95a33-3274">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="95a33-3275">В сложных сценариях статистической обработки идентификатор DispID иногда является единственным способом вызова нужного члена.</span><span class="sxs-lookup"><span data-stu-id="95a33-3275">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3276">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым членам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор разрешений, не являющихся открытыми, ограничен набором разрешений вызывающего объекта. или подмножество.</span><span class="sxs-lookup"><span data-stu-id="95a33-3276">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="95a33-3277">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="95a33-3277">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="95a33-3278">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="95a33-3278">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3279">В следующем примере для доступа к членам типа используется `InvokeMember`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3279">The following example uses `InvokeMember` to access members of a type.</span></span>  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-3280"><paramref name="invokeAttr" /> не содержит <see langword="CreateInstance" />, а <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3280"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-3281"><paramref name="invokeAttr" /> не является допустимым атрибутом <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3281"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="95a33-3282">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3282">-or-</span></span> 
 <span data-ttu-id="95a33-3283"><paramref name="invokeAttr" /> не содержит одного из следующих флагов привязки: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3283"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3284">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3284">-or-</span></span> 
 <span data-ttu-id="95a33-3285"><paramref name="invokeAttr" /> содержит <see langword="CreateInstance" /> в сочетании с <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3285"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3286">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3286">-or-</span></span> 
 <span data-ttu-id="95a33-3287"><paramref name="invokeAttr" /> содержит как <see langword="GetField" />, так и <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3287"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="95a33-3288">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3288">-or-</span></span> 
 <span data-ttu-id="95a33-3289"><paramref name="invokeAttr" /> содержит как <see langword="GetProperty" />, так и <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3289"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3290">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3290">-or-</span></span> 
 <span data-ttu-id="95a33-3291"><paramref name="invokeAttr" /> содержит <see langword="InvokeMethod" /> в сочетании с <see langword="SetField" /> или <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3291"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3292">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3292">-or-</span></span> 
 <span data-ttu-id="95a33-3293"><paramref name="invokeAttr" /> содержит <see langword="SetField" />, а <paramref name="args" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="95a33-3293"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="95a33-3294">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3294">-or-</span></span> 
<span data-ttu-id="95a33-3295">Этот метод вызывается для объекта COM, и один из следующих флагов привязки не был передан: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> или <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3295">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3296">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3296">-or-</span></span> 
<span data-ttu-id="95a33-3297">Один из массивов именованных параметров содержит строку, имеющую значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3297">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="95a33-3298">Указанный член является инициализатором класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-3298">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="95a33-3299">Невозможно найти поле или свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-3299">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="95a33-3300">Невозможно найти метод, который соответствует аргументам в <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3300">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="95a33-3301">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3301">-or-</span></span> 
<span data-ttu-id="95a33-3302">Текущий объект <see cref="T:System.Type" /> представляет тип, содержащий параметры открытого типа, то есть <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3302">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="95a33-3303">Невозможно вызвать указанный член для <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3303">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-3304">Несколько методов соответствуют критериям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-3304">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-3305">Платформа .NET Compact Framework сейчас не поддерживает этот метод.</span><span class="sxs-lookup"><span data-stu-id="95a33-3305">The .NET Compact Framework does not currently support this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="95a33-3306">Метод, представленный <paramref name="name" />, имеет один или несколько незаданных параметров универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3306">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="95a33-3307">То есть свойство <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> метода возвращает <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3307">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="95a33-3308">для доступа к членам, не являющимся открытыми, независимо от набора их разрешений.</span><span class="sxs-lookup"><span data-stu-id="95a33-3308">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="95a33-3309">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="95a33-3309">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="95a33-3310">для вызова неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="95a33-3310">to call unmanaged code.</span></span> <span data-ttu-id="95a33-3311">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="95a33-3311">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-3312">Строка, содержащая имя вызываемого элемента — конструктора, метода, свойства или поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-3312">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="95a33-3313">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3313">-or-</span></span> 
<span data-ttu-id="95a33-3314">Пустая строка ("") — в этом случае будет вызван член по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-3314">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="95a33-3315">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3315">-or-</span></span> 
<span data-ttu-id="95a33-3316">Для членов <see langword="IDispatch" /> — строка, представляющая идентификатор DispID, например "[DispID=3]".</span><span class="sxs-lookup"><span data-stu-id="95a33-3316">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="95a33-3317">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-3317">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span> <span data-ttu-id="95a33-3318">Тип доступа может быть обозначен одним из флагов <see langword="BindingFlags" />, например <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> и т.д.</span><span class="sxs-lookup"><span data-stu-id="95a33-3318">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="95a33-3319">Тип поиска указывать необязательно.</span><span class="sxs-lookup"><span data-stu-id="95a33-3319">The type of lookup need not be specified.</span></span> <span data-ttu-id="95a33-3320">Если тип поиска не указан, используются флаги <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3320">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="95a33-3321">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3321">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="95a33-3322">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3322">-or-</span></span> 
<span data-ttu-id="95a33-3323">Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3323">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="95a33-3324">Обратите внимание, что для успешного вызова перегруженных версий метода с переменными аргументами может потребоваться явное объявление объекта <see cref="T:System.Reflection.Binder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3324">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="95a33-3325">Объект, для которого следует вызвать указанный член.</span><span class="sxs-lookup"><span data-stu-id="95a33-3325">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="95a33-3326">Массив с аргументами, передаваемыми вызываемому члену.</span><span class="sxs-lookup"><span data-stu-id="95a33-3326">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="culture"><span data-ttu-id="95a33-3327">Объект, представляющий используемые языковые стандарты глобализации. Его задание может понадобиться для выполнения преобразований, зависящих от языкового стандарта, например преобразования числовой строки <see cref="T:System.String" /> к типу <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3327">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</span></span>  
  
<span data-ttu-id="95a33-3328">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3328">-or-</span></span> 
<span data-ttu-id="95a33-3329">Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования объекта <see cref="T:System.Globalization.CultureInfo" /> текущего потока.</span><span class="sxs-lookup"><span data-stu-id="95a33-3329">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <summary><span data-ttu-id="95a33-3330">Вызывает указанный член, соответствующий заданным ограничениям привязки, списку аргументов, а также языку и региональным параметрам.</span><span class="sxs-lookup"><span data-stu-id="95a33-3330">Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</span></span></summary>
        <returns><span data-ttu-id="95a33-3331">Объект, представляющий возвращаемое значение вызываемого элемента.</span><span class="sxs-lookup"><span data-stu-id="95a33-3331">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3332">Хотя связыватель по умолчанию не обрабатывает <xref:System.Globalization.CultureInfo> (параметр `culture`), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательского связывателя, который обрабатывает `culture`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3332">Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `culture`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3333">Нельзя использовать <xref:System.Type.InvokeMember%2A> для вызова универсального метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-3333">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="95a33-3334">Для определения элементов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3334">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-3335">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые члены.</span><span class="sxs-lookup"><span data-stu-id="95a33-3335">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="95a33-3336">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск неоткрытые члены (т. е. частные, внутренние и защищенные члены).</span><span class="sxs-lookup"><span data-stu-id="95a33-3336">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-3337">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить статические элементы вверх по иерархии.</span><span class="sxs-lookup"><span data-stu-id="95a33-3337">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="95a33-3338">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3338">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-3339">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3339">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-3340">`BindingFlags.DeclaredOnly` искать только члены, объявленные в <xref:System.Type>, а не члены, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-3340">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-3341">Для обозначения действия, выполняемого с элементом, можно использовать следующие флаги вызова <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3341">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="95a33-3342">`CreateInstance` вызвать конструктор.</span><span class="sxs-lookup"><span data-stu-id="95a33-3342">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="95a33-3343">`name` игнорируется.</span><span class="sxs-lookup"><span data-stu-id="95a33-3343">`name` is ignored.</span></span> <span data-ttu-id="95a33-3344">Недопустимый с другими флагами вызова.</span><span class="sxs-lookup"><span data-stu-id="95a33-3344">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="95a33-3345">`InvokeMethod` вызывать метод, но не конструктор или инициализатор типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3345">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="95a33-3346">Недопустимо для `SetField` или `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3346">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="95a33-3347">Если `InvokeMethod` указывается сама по себе, автоматически включаются `BindingFlags.Public`, `BindingFlags.Instance`и `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3347">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="95a33-3348">`GetField`, чтобы получить значение поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-3348">`GetField` to get the value of a field.</span></span> <span data-ttu-id="95a33-3349">Недопустимый для `SetField`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3349">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="95a33-3350">`SetField`, чтобы задать значение поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-3350">`SetField` to set the value of a field.</span></span> <span data-ttu-id="95a33-3351">Недопустимый для `GetField`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3351">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="95a33-3352">`GetProperty` получить свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-3352">`GetProperty` to get a property.</span></span> <span data-ttu-id="95a33-3353">Недопустимый для `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3353">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="95a33-3354">`SetProperty` задать свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-3354">`SetProperty` to set a property.</span></span> <span data-ttu-id="95a33-3355">Недопустимый для `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3355">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="95a33-3356">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3356">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-3357">Метод будет вызываться, если выполняются оба следующих условия.</span><span class="sxs-lookup"><span data-stu-id="95a33-3357">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="95a33-3358">Число параметров в объявлении метода равно числу аргументов в массиве `args` (если для элемента не определены аргументы по умолчанию и не указан `BindingFlags.OptionalParamBinding`).</span><span class="sxs-lookup"><span data-stu-id="95a33-3358">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="95a33-3359">Тип каждого аргумента может быть преобразован связывателем в тип параметра.</span><span class="sxs-lookup"><span data-stu-id="95a33-3359">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="95a33-3360">Связыватель найдет все методы сопоставления.</span><span class="sxs-lookup"><span data-stu-id="95a33-3360">The binder will find all of the matching methods.</span></span> <span data-ttu-id="95a33-3361">Эти методы обнаруживаются в зависимости от типа запрашиваемой привязки (<xref:System.Reflection.BindingFlags> значения `InvokeMethod`, `GetProperty`и т. д.).</span><span class="sxs-lookup"><span data-stu-id="95a33-3361">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="95a33-3362">Набор методов фильтруется по имени, числу аргументов и набору модификаторов поиска, определенных в связывателе.</span><span class="sxs-lookup"><span data-stu-id="95a33-3362">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="95a33-3363">После выбора метода вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="95a33-3363">After the method is selected, it is invoked.</span></span> <span data-ttu-id="95a33-3364">На этом этапе проверяется доступность.</span><span class="sxs-lookup"><span data-stu-id="95a33-3364">Accessibility is checked at that point.</span></span> <span data-ttu-id="95a33-3365">Поиск может управлять тем, какой набор методов выполняется в зависимости от атрибута доступности, связанного с методом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3365">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="95a33-3366">Метод <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> класса <xref:System.Reflection.Binder> отвечает за выбор вызываемого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-3366">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="95a33-3367">Связыватель по умолчанию выбирает наиболее конкретное соответствие.</span><span class="sxs-lookup"><span data-stu-id="95a33-3367">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="95a33-3368">Ограничения доступа игнорируются для полностью доверенного кода. Таким образом, закрытые конструкторы, методы, поля и свойства могут быть доступны и вызываться посредством отражения всякий раз, когда код полностью надежен.</span><span class="sxs-lookup"><span data-stu-id="95a33-3368">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="95a33-3369">`Type.InvokeMember` можно использовать для задания определенного значения поля, указав <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3369">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95a33-3370">Например, если необходимо задать открытое поле экземпляра с именем F для класса C, а F — `String` можно использовать такой код:</span><span class="sxs-lookup"><span data-stu-id="95a33-3370">For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 <span data-ttu-id="95a33-3371">Если F является `String[]`, можно использовать такой код:</span><span class="sxs-lookup"><span data-stu-id="95a33-3371">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 <span data-ttu-id="95a33-3372">что приведет к инициализации поля F в новый массив.</span><span class="sxs-lookup"><span data-stu-id="95a33-3372">which will initialize the field F to this new array.</span></span> <span data-ttu-id="95a33-3373">Можно также использовать `Type.InvokeMember` для задания позиции в массиве, указав индекс значения, а затем следующее значение с помощью следующего кода:</span><span class="sxs-lookup"><span data-stu-id="95a33-3373">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 <span data-ttu-id="95a33-3374">Это изменит строку "z" в массиве, который F содержит строку "b".</span><span class="sxs-lookup"><span data-stu-id="95a33-3374">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="95a33-3375">При вызове элемента `IDispatch` можно указать DISPID вместо имени члена, используя формат строки "[DispID = # #]".</span><span class="sxs-lookup"><span data-stu-id="95a33-3375">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="95a33-3376">Например, если DISPID Микоммесод имеет значение 3, можно указать строку "[DISPID = 3]" вместо "Микоммесод".</span><span class="sxs-lookup"><span data-stu-id="95a33-3376">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="95a33-3377">Вызов члена по DISPID выполняется быстрее, чем поиск члена по имени.</span><span class="sxs-lookup"><span data-stu-id="95a33-3377">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="95a33-3378">В сложных сценариях статистической обработки идентификатор DispID иногда является единственным способом вызова нужного члена.</span><span class="sxs-lookup"><span data-stu-id="95a33-3378">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3379">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым членам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор разрешений, не являющихся открытыми, ограничен набором разрешений вызывающего объекта. или подмножество.</span><span class="sxs-lookup"><span data-stu-id="95a33-3379">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="95a33-3380">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="95a33-3380">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="95a33-3381">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="95a33-3381">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-3382"><paramref name="invokeAttr" /> не содержит <see langword="CreateInstance" />, а <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3382"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-3383"><paramref name="invokeAttr" /> не является допустимым атрибутом <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3383"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="95a33-3384">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3384">-or-</span></span> 
 <span data-ttu-id="95a33-3385"><paramref name="invokeAttr" /> не содержит одного из следующих флагов привязки: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3385"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3386">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3386">-or-</span></span> 
 <span data-ttu-id="95a33-3387"><paramref name="invokeAttr" /> содержит <see langword="CreateInstance" /> в сочетании с <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3387"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3388">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3388">-or-</span></span> 
 <span data-ttu-id="95a33-3389"><paramref name="invokeAttr" /> содержит как <see langword="GetField" />, так и <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3389"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="95a33-3390">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3390">-or-</span></span> 
 <span data-ttu-id="95a33-3391"><paramref name="invokeAttr" /> содержит как <see langword="GetProperty" />, так и <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3391"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3392">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3392">-or-</span></span> 
 <span data-ttu-id="95a33-3393"><paramref name="invokeAttr" /> содержит <see langword="InvokeMethod" /> в сочетании с <see langword="SetField" /> или <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3393"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3394">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3394">-or-</span></span> 
 <span data-ttu-id="95a33-3395"><paramref name="invokeAttr" /> содержит <see langword="SetField" />, а <paramref name="args" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="95a33-3395"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="95a33-3396">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3396">-or-</span></span> 
<span data-ttu-id="95a33-3397">Этот метод вызывается для объекта COM, и один из следующих флагов привязки не был передан: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> или <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3397">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3398">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3398">-or-</span></span> 
<span data-ttu-id="95a33-3399">Один из массивов именованных параметров содержит строку, имеющую значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3399">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="95a33-3400">Указанный член является инициализатором класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-3400">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="95a33-3401">Невозможно найти поле или свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-3401">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="95a33-3402">Невозможно найти метод, который соответствует аргументам в <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3402">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="95a33-3403">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3403">-or-</span></span> 
<span data-ttu-id="95a33-3404">Текущий объект <see cref="T:System.Type" /> представляет тип, содержащий параметры открытого типа, то есть <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3404">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="95a33-3405">Невозможно вызвать указанный член для <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3405">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-3406">Несколько методов соответствуют критериям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-3406">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="95a33-3407">Метод, представленный <paramref name="name" />, имеет один или несколько незаданных параметров универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3407">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="95a33-3408">То есть свойство <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> метода возвращает <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3408">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="95a33-3409">для доступа к членам, не являющимся открытыми, независимо от набора их разрешений.</span><span class="sxs-lookup"><span data-stu-id="95a33-3409">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="95a33-3410">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="95a33-3410">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="95a33-3411">для вызова неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="95a33-3411">to call unmanaged code.</span></span> <span data-ttu-id="95a33-3412">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="95a33-3412">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="95a33-3413">Строка, содержащая имя вызываемого элемента — конструктора, метода, свойства или поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-3413">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="95a33-3414">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3414">-or-</span></span> 
<span data-ttu-id="95a33-3415">Пустая строка ("") — в этом случае будет вызван член по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-3415">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="95a33-3416">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3416">-or-</span></span> 
<span data-ttu-id="95a33-3417">Для членов <see langword="IDispatch" /> — строка, представляющая идентификатор DispID, например "[DispID=3]".</span><span class="sxs-lookup"><span data-stu-id="95a33-3417">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="95a33-3418">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.</span><span class="sxs-lookup"><span data-stu-id="95a33-3418">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span> <span data-ttu-id="95a33-3419">Тип доступа может быть обозначен одним из флагов <see langword="BindingFlags" />, например <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> и т.д.</span><span class="sxs-lookup"><span data-stu-id="95a33-3419">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="95a33-3420">Тип поиска указывать необязательно.</span><span class="sxs-lookup"><span data-stu-id="95a33-3420">The type of lookup need not be specified.</span></span> <span data-ttu-id="95a33-3421">Если тип поиска не указан, используются флаги <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3421">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="95a33-3422">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3422">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="95a33-3423">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3423">-or-</span></span> 
<span data-ttu-id="95a33-3424">Пустая ссылка (Nothing в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3424">A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="95a33-3425">Обратите внимание, что для успешного вызова перегруженных версий метода с переменными аргументами может потребоваться явное объявление объекта <see cref="T:System.Reflection.Binder" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3425">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="95a33-3426">Объект, для которого следует вызвать указанный член.</span><span class="sxs-lookup"><span data-stu-id="95a33-3426">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="95a33-3427">Массив с аргументами, передаваемыми вызываемому члену.</span><span class="sxs-lookup"><span data-stu-id="95a33-3427">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="modifiers"><span data-ttu-id="95a33-3428">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3428">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="args" /> array.</span></span> <span data-ttu-id="95a33-3429">Атрибуты, связанные с параметром, хранятся в сигнатуре члена.</span><span class="sxs-lookup"><span data-stu-id="95a33-3429">A parameter's associated attributes are stored in the member's signature.</span></span>  
  
<span data-ttu-id="95a33-3430">Связыватель по умолчанию обрабатывает этот параметр только при вызове COM-компонента.</span><span class="sxs-lookup"><span data-stu-id="95a33-3430">The default binder processes this parameter only when calling a COM component.</span></span></param>
        <param name="culture"><span data-ttu-id="95a33-3431">Объект <see cref="T:System.Globalization.CultureInfo" />, представляющий используемый языковой стандарт глобализации. Он может понадобиться для выполнения преобразований, зависящих от языкового стандарта, например приведения числа в строковом формате к типу Double.</span><span class="sxs-lookup"><span data-stu-id="95a33-3431">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</span></span>  
  
<span data-ttu-id="95a33-3432">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3432">-or-</span></span> 
<span data-ttu-id="95a33-3433">Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования объекта <see cref="T:System.Globalization.CultureInfo" /> текущего потока.</span><span class="sxs-lookup"><span data-stu-id="95a33-3433">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <param name="namedParameters"><span data-ttu-id="95a33-3434">Массив, содержащий имена параметров, в которые передаются значения элементов массива <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3434">An array containing the names of the parameters to which the values in the <paramref name="args" /> array are passed.</span></span></param>
        <summary><span data-ttu-id="95a33-3435">При переопределении в производном классе вызывает указанный член, соответствующий заданным ограничениям привязки, списку аргументов, модификаторов, а также языку и региональным параметрам.</span><span class="sxs-lookup"><span data-stu-id="95a33-3435">When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</span></span></summary>
        <returns><span data-ttu-id="95a33-3436">Объект, представляющий возвращаемое значение вызываемого элемента.</span><span class="sxs-lookup"><span data-stu-id="95a33-3436">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3437">`InvokeMember` вызывает член конструктора или член метода, получает или задает член свойства, Возвращает или задает элемент поля данных либо возвращает или задает элемент члена массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-3437">`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3438">Нельзя использовать <xref:System.Type.InvokeMember%2A> для вызова универсального метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-3438">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="95a33-3439">При вызове элемента `IDispatch` можно указать DISPID вместо имени члена, используя формат строки "[DispID = # #]".</span><span class="sxs-lookup"><span data-stu-id="95a33-3439">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="95a33-3440">Например, если DISPID Микоммесод имеет значение 3, можно указать строку "[DISPID = 3]" вместо "Микоммесод".</span><span class="sxs-lookup"><span data-stu-id="95a33-3440">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="95a33-3441">Вызов члена по DISPID выполняется быстрее, чем поиск члена по имени.</span><span class="sxs-lookup"><span data-stu-id="95a33-3441">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="95a33-3442">В сложных сценариях статистической обработки идентификатор DispID иногда является единственным способом вызова нужного члена.</span><span class="sxs-lookup"><span data-stu-id="95a33-3442">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
 <span data-ttu-id="95a33-3443">Несмотря на то, что связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> или <xref:System.Globalization.CultureInfo> (параметры `modifiers` и `culture`), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType>ный класс для написания пользовательского связывателя, который обрабатывает `modifiers` и `culture`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3443">Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers` and `culture`.</span></span> <span data-ttu-id="95a33-3444">`ParameterModifier` используется только при вызове через COM-взаимодействие, и обрабатываются только параметры, передаваемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-3444">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="95a33-3445">Каждый параметр в массиве `namedParameters` получает значение в соответствующем элементе в массиве `args`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3445">Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array.</span></span> <span data-ttu-id="95a33-3446">Если длина `args` превышает длину `namedParameters`, оставшиеся значения аргументов передаются по порядку.</span><span class="sxs-lookup"><span data-stu-id="95a33-3446">If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.</span></span>  
  
 <span data-ttu-id="95a33-3447">Массив `namedParameters` можно использовать для изменения порядка следования аргументов во входном массиве.</span><span class="sxs-lookup"><span data-stu-id="95a33-3447">The `namedParameters` array can be used to change the order of arguments in an input array.</span></span> <span data-ttu-id="95a33-3448">Например, при наличии метода `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` в Visual Basic) и входного массива `{ 42, "x" }`, входной массив может быть передан в неизменном виде в `args`, если для `{ "b", "a" }` указан массив `namedParameters`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3448">For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, "x" }`, the input array can be passed unchanged to `args` if the array `{ "b", "a" }` is supplied for `namedParameters`.</span></span>  
  
 <span data-ttu-id="95a33-3449">Для определения элементов, включаемых в поиск, можно использовать следующие флаги фильтра <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3449">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="95a33-3450">Укажите `BindingFlags.Public`, чтобы включить в поиск открытые члены.</span><span class="sxs-lookup"><span data-stu-id="95a33-3450">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="95a33-3451">Укажите `BindingFlags.NonPublic`, чтобы включить в поиск неоткрытые члены (т. е. частные, внутренние и защищенные члены).</span><span class="sxs-lookup"><span data-stu-id="95a33-3451">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="95a33-3452">Укажите `BindingFlags.FlattenHierarchy`, чтобы включить статические элементы вверх по иерархии.</span><span class="sxs-lookup"><span data-stu-id="95a33-3452">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="95a33-3453">Для изменения работы поиска можно использовать следующие флаги модификатора <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3453">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="95a33-3454">`BindingFlags.IgnoreCase`, чтобы игнорировать регистр `name`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3454">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="95a33-3455">`BindingFlags.DeclaredOnly` искать только члены, объявленные в <xref:System.Type>, а не члены, которые были просто унаследованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-3455">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="95a33-3456">Для обозначения действия, выполняемого с элементом, можно использовать следующие флаги вызова <xref:System.Reflection.BindingFlags>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3456">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="95a33-3457">`CreateInstance` вызвать конструктор.</span><span class="sxs-lookup"><span data-stu-id="95a33-3457">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="95a33-3458">`name` игнорируется.</span><span class="sxs-lookup"><span data-stu-id="95a33-3458">`name` is ignored.</span></span> <span data-ttu-id="95a33-3459">Недопустимый с другими флагами вызова.</span><span class="sxs-lookup"><span data-stu-id="95a33-3459">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="95a33-3460">`InvokeMethod` вызывать метод, но не конструктор или инициализатор типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3460">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="95a33-3461">Недопустимо для `SetField` или `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3461">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="95a33-3462">Если `InvokeMethod` указывается сама по себе, автоматически включаются `BindingFlags.Public`, `BindingFlags.Instance`и `BindingFlags.Static`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3462">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="95a33-3463">`GetField`, чтобы получить значение поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-3463">`GetField` to get the value of a field.</span></span> <span data-ttu-id="95a33-3464">Недопустимый для `SetField`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3464">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="95a33-3465">`SetField`, чтобы задать значение поля.</span><span class="sxs-lookup"><span data-stu-id="95a33-3465">`SetField` to set the value of a field.</span></span> <span data-ttu-id="95a33-3466">Недопустимый для `GetField`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3466">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="95a33-3467">`GetProperty` получить свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-3467">`GetProperty` to get a property.</span></span> <span data-ttu-id="95a33-3468">Недопустимый для `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3468">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="95a33-3469">`SetProperty` задать свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-3469">`SetProperty` to set a property.</span></span> <span data-ttu-id="95a33-3470">Недопустимый для `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3470">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="95a33-3471">Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3471">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="95a33-3472">Метод будет вызываться, если выполняются оба следующих условия.</span><span class="sxs-lookup"><span data-stu-id="95a33-3472">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="95a33-3473">Число параметров в объявлении метода равно числу аргументов в массиве `args` (если для элемента не определены аргументы по умолчанию и не указан `BindingFlags.OptionalParamBinding`).</span><span class="sxs-lookup"><span data-stu-id="95a33-3473">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="95a33-3474">Тип каждого аргумента может быть преобразован связывателем в тип параметра.</span><span class="sxs-lookup"><span data-stu-id="95a33-3474">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="95a33-3475">Связыватель найдет все методы сопоставления.</span><span class="sxs-lookup"><span data-stu-id="95a33-3475">The binder will find all of the matching methods.</span></span> <span data-ttu-id="95a33-3476">Эти методы обнаруживаются в зависимости от типа запрашиваемой привязки (<xref:System.Reflection.BindingFlags> значения `InvokeMethod`, `GetProperty`и т. д.).</span><span class="sxs-lookup"><span data-stu-id="95a33-3476">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="95a33-3477">Набор методов фильтруется по имени, числу аргументов и набору модификаторов поиска, определенных в связывателе.</span><span class="sxs-lookup"><span data-stu-id="95a33-3477">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="95a33-3478">После выбора метода вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="95a33-3478">After the method is selected, it is invoked.</span></span> <span data-ttu-id="95a33-3479">На этом этапе проверяется доступность.</span><span class="sxs-lookup"><span data-stu-id="95a33-3479">Accessibility is checked at that point.</span></span> <span data-ttu-id="95a33-3480">Поиск может управлять тем, какой набор методов выполняется в зависимости от атрибута доступности, связанного с методом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3480">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="95a33-3481">Метод <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> класса <xref:System.Reflection.Binder> отвечает за выбор вызываемого метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-3481">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="95a33-3482">Связыватель по умолчанию выбирает наиболее конкретное соответствие.</span><span class="sxs-lookup"><span data-stu-id="95a33-3482">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="95a33-3483">`InvokeMember` можно использовать для вызова методов с параметрами, имеющими значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-3483">`InvokeMember` can be used to invoke methods with parameters that have default values.</span></span> <span data-ttu-id="95a33-3484">Для привязки к этим методам для отражения требуется указать <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3484">To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> to be specified.</span></span> <span data-ttu-id="95a33-3485">Для параметра, имеющего значение по умолчанию, можно указать другое значение или указать <xref:System.Reflection.Missing.Value?displayProperty=nameWithType>, чтобы использовать значение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-3485">For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> to use the default value.</span></span>  
  
 <span data-ttu-id="95a33-3486">Например, рассмотрим метод MyMethod (int x, float y = 2,0).</span><span class="sxs-lookup"><span data-stu-id="95a33-3486">For example, consider a method such as MyMethod(int x, float y = 2.0).</span></span> <span data-ttu-id="95a33-3487">Чтобы вызвать этот метод только с первым аргументом метода MyMethod (4), передайте один из приведенных выше флагов привязки и передайте два аргумента, а именно, 4 для первого аргумента и `Missing.Value` для второго аргумента.</span><span class="sxs-lookup"><span data-stu-id="95a33-3487">To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument.</span></span> <span data-ttu-id="95a33-3488">Если вы не используете `Missing.Value`, вы не можете опустить необязательные параметры с помощью метода `Invoke`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3488">Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method.</span></span> <span data-ttu-id="95a33-3489">Если это необходимо, используйте вместо этого `InvokeMember`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3489">If you must do so, use `InvokeMember` instead.</span></span>  
  
 <span data-ttu-id="95a33-3490">Ограничения доступа игнорируются для полностью доверенного кода. Это значит, что доступ к частным конструкторам, методам, полям и свойствам можно получить и вызвать с помощью <xref:System.Reflection> всякий раз, когда код полностью надежен.</span><span class="sxs-lookup"><span data-stu-id="95a33-3490">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="95a33-3491">`Type.InvokeMember` можно использовать для задания определенного значения поля, указав <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3491">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95a33-3492">Например, если необходимо задать открытое поле экземпляра с именем F для класса C, а F — `String`, можно использовать такой код:</span><span class="sxs-lookup"><span data-stu-id="95a33-3492">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 <span data-ttu-id="95a33-3493">Если F является `String[]`, можно использовать такой код:</span><span class="sxs-lookup"><span data-stu-id="95a33-3493">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 <span data-ttu-id="95a33-3494">что приведет к инициализации поля F в новый массив.</span><span class="sxs-lookup"><span data-stu-id="95a33-3494">which will initialize the field F to this new array.</span></span> <span data-ttu-id="95a33-3495">Можно также использовать `Type.InvokeMember` для задания позиции в массиве, указав индекс значения, а затем следующее значение с помощью следующего кода:</span><span class="sxs-lookup"><span data-stu-id="95a33-3495">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 <span data-ttu-id="95a33-3496">Это изменит строку "z" в массиве, который F содержит строку "b".</span><span class="sxs-lookup"><span data-stu-id="95a33-3496">This will change string "z" in the array that F holds to string "b".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3497">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым членам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор разрешений, не являющихся открытыми, ограничен набором разрешений вызывающего объекта. или подмножество.</span><span class="sxs-lookup"><span data-stu-id="95a33-3497">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="95a33-3498">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="95a33-3498">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="95a33-3499">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="95a33-3499">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-3500"><paramref name="invokeAttr" /> не содержит <see langword="CreateInstance" />, а <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3500"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-3501"><paramref name="args" /> и <paramref name="modifiers" /> имеют разную длину.</span><span class="sxs-lookup"><span data-stu-id="95a33-3501"><paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.</span></span>  
  
<span data-ttu-id="95a33-3502">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3502">-or-</span></span> 
 <span data-ttu-id="95a33-3503"><paramref name="invokeAttr" /> не является допустимым атрибутом <see cref="T:System.Reflection.BindingFlags" /> .</span><span class="sxs-lookup"><span data-stu-id="95a33-3503"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="95a33-3504">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3504">-or-</span></span> 
 <span data-ttu-id="95a33-3505"><paramref name="invokeAttr" /> не содержит одного из следующих флагов привязки: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3505"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3506">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3506">-or-</span></span> 
 <span data-ttu-id="95a33-3507"><paramref name="invokeAttr" /> содержит <see langword="CreateInstance" /> в сочетании с <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3507"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3508">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3508">-or-</span></span> 
 <span data-ttu-id="95a33-3509"><paramref name="invokeAttr" /> содержит как <see langword="GetField" />, так и <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3509"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="95a33-3510">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3510">-or-</span></span> 
 <span data-ttu-id="95a33-3511"><paramref name="invokeAttr" /> содержит как <see langword="GetProperty" />, так и <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3511"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3512">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3512">-or-</span></span> 
 <span data-ttu-id="95a33-3513"><paramref name="invokeAttr" /> содержит <see langword="InvokeMethod" /> в сочетании с <see langword="SetField" /> или <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3513"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3514">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3514">-or-</span></span> 
 <span data-ttu-id="95a33-3515"><paramref name="invokeAttr" /> содержит <see langword="SetField" />, а <paramref name="args" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="95a33-3515"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="95a33-3516">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3516">-or-</span></span> 
<span data-ttu-id="95a33-3517">Массив именованных параметров больше, чем массив аргументов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3517">The named parameter array is larger than the argument array.</span></span>  
  
<span data-ttu-id="95a33-3518">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3518">-or-</span></span> 
<span data-ttu-id="95a33-3519">Этот метод вызывается для объекта COM, и один из следующих флагов привязки не был передан: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> или <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3519">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="95a33-3520">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3520">-or-</span></span> 
<span data-ttu-id="95a33-3521">Один из массивов именованных параметров содержит строку, имеющую значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3521">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="95a33-3522">Указанный член является инициализатором класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-3522">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="95a33-3523">Невозможно найти поле или свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-3523">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="95a33-3524">Невозможно найти метод, который соответствует аргументам в <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3524">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="95a33-3525">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3525">-or-</span></span> 
<span data-ttu-id="95a33-3526">Невозможно найти члены с именами аргументов, указанными в <paramref name="namedParameters" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3526">No member can be found that has the argument names supplied in <paramref name="namedParameters" />.</span></span>  
  
<span data-ttu-id="95a33-3527">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-3527">-or-</span></span> 
<span data-ttu-id="95a33-3528">Текущий объект <see cref="T:System.Type" /> представляет тип, содержащий параметры открытого типа, то есть <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3528">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="95a33-3529">Невозможно вызвать указанный член для <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3529">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="95a33-3530">Несколько методов соответствуют критериям привязки.</span><span class="sxs-lookup"><span data-stu-id="95a33-3530">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="95a33-3531">Метод, представленный <paramref name="name" />, имеет один или несколько незаданных параметров универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3531">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="95a33-3532">То есть свойство <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> метода возвращает <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3532">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="95a33-3533">для доступа к членам, не являющимся открытыми, независимо от набора их разрешений.</span><span class="sxs-lookup"><span data-stu-id="95a33-3533">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="95a33-3534">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="95a33-3534">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="95a33-3535">для вызова неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="95a33-3535">to call unmanaged code.</span></span> <span data-ttu-id="95a33-3536">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="95a33-3536">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3537">Возвращает значение, показывающее, является ли данный объект <see cref="T:System.Type" /> абстрактным объектом, который должен быть переопределен.</span><span class="sxs-lookup"><span data-stu-id="95a33-3537">Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</span></span></summary>
        <value><span data-ttu-id="95a33-3538">Значение <see langword="true" />, если класс <see cref="T:System.Type" /> является абстрактным; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3538"><see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3539">Свойство <xref:System.Type.IsAbstract%2A> возвращает `true` в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="95a33-3539">The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:</span></span>  
  
-   <span data-ttu-id="95a33-3540">Текущий тип является абстрактным; то есть он не может быть создан, но может служить только базовым классом для производных классов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3540">The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</span></span> <span data-ttu-id="95a33-3541">В C#абстрактные классы помечаются ключевым словом [abstract](~/docs/csharp/language-reference/keywords/abstract.md) . в Visual Basic они помечаются ключевым словом [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) .</span><span class="sxs-lookup"><span data-stu-id="95a33-3541">In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.</span></span>  
  
-   <span data-ttu-id="95a33-3542">Текущий тип является интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3542">The current type is an interface.</span></span>  
  
 <span data-ttu-id="95a33-3543">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3543">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3544">В следующем примере создается массив <xref:System.Type> объектов, представляющих следующие типы: Contains Type возвращает значение, `true`, если указанный объект `abstract`. в противном случае возвращается `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3544">The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.</span></span>  
  
-   <span data-ttu-id="95a33-3545">`AbstractClass`, абстрактный класс (класс, помеченный как `abstract` C# в и `MustInherit` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-3545">`AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).</span></span>  
  
-   <span data-ttu-id="95a33-3546">`DerivedClass`, класс, наследующий от `AbstractClass`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3546">`DerivedClass`, a class that inherits from `AbstractClass`.</span></span>  
  
-   <span data-ttu-id="95a33-3547">`SingleClass`, не наследуемый класс.</span><span class="sxs-lookup"><span data-stu-id="95a33-3547">`SingleClass`, a non-inheritable class.</span></span> <span data-ttu-id="95a33-3548">Он определяется как `sealed` в C# и `NotInheritable` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="95a33-3548">It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.</span></span>  
  
-   <span data-ttu-id="95a33-3549">`ITypeInfo`интерфейс.</span><span class="sxs-lookup"><span data-stu-id="95a33-3549">`ITypeInfo`, an interface.</span></span>  
  
-   <span data-ttu-id="95a33-3550">`ImplementingClass`, класс, реализующий интерфейс `ITypeInfo`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3550">`ImplementingClass`, a class that implements the `ITypeInfo` interface.</span></span>  
  
 <span data-ttu-id="95a33-3551">Метод возвращает `true` только для `AbstractClass`, абстрактного класса и `ITypeInfo`интерфейса.</span><span class="sxs-lookup"><span data-stu-id="95a33-3551">The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.</span></span>  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3552">Возвращает значение, позволяющее определить, выбран ли для объекта <see langword="AnsiClass" /> атрибут формата строки <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3552">Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="95a33-3553">Значение <see langword="true" />, если для данного объекта <see langword="AnsiClass" /> выбран атрибут формата строки <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3553"><see langword="true" /> if the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3554"><xref:System.Reflection.TypeAttributes.StringFormatMask> выбирает атрибуты формата строки.</span><span class="sxs-lookup"><span data-stu-id="95a33-3554">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="95a33-3555">Атрибуты формата строки улучшают взаимодействие, определяя, как должны интерпретироваться строки.</span><span class="sxs-lookup"><span data-stu-id="95a33-3555">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="95a33-3556">Если текущий <xref:System.Type> представляет универсальный тип, это свойство относится к определению универсального типа, из которого был создан тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3556">If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="95a33-3557">Например, если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3557">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="95a33-3558">Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3558">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3559">В следующем примере выполняется получение сведений о поле и проверка атрибута `AnsiClass`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3559">The following example gets the field information and checks for the `AnsiClass` attribute.</span></span>  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public virtual bool IsArray { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsArray As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsArray { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3560">Возвращает значение, показывающее, является ли тип массивом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3560">Gets a value that indicates whether the type is an array.</span></span></summary>
        <value><span data-ttu-id="95a33-3561">Значение <see langword="true" />, если текущий тип является массивом; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3561"><see langword="true" /> if the current type is an array; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3562">Свойство <xref:System.Type.IsArray%2A> возвращает `false` для класса <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3562">The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class.</span></span> <span data-ttu-id="95a33-3563">Он также возвращает `false`, если текущий экземпляр является <xref:System.Type> объектом, представляющим тип коллекции или интерфейс, предназначенный для работы с коллекциями, такими как <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3563">It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="95a33-3564">Чтобы проверить наличие массива, используйте такой код:</span><span class="sxs-lookup"><span data-stu-id="95a33-3564">To check for an array, use code such as:</span></span>  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 <span data-ttu-id="95a33-3565">Если текущий тип представляет универсальный тип или параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3565">If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="95a33-3566">Это свойство доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3566">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3567">В следующем примере демонстрируется использование свойства <xref:System.Type.IsArray%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3567">The following example demonstrates using the <xref:System.Type.IsArray%2A> property.</span></span>  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-3568">При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsArray" /> и определяет, является ли данный объект <see cref="T:System.Type" /> массивом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3568">When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</span></span></summary>
        <returns><span data-ttu-id="95a33-3569">Значение <see langword="true" />, если <see cref="T:System.Type" /> является массивом; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3569"><see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3570">Экземпляр класса <xref:System.Array> должен возвращать `false`, так как он является объектом, а не массивом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3570">An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3571">В следующем примере переопределяется метод `IsArrayImpl` в классе `MyTypeDelegator`, проверяет, является ли переменная массивом, и отображает результат.</span><span class="sxs-lookup"><span data-stu-id="95a33-3571">The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="95a33-3572">Тип для сравнения с текущим типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3572">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="95a33-3573">Определяет, можно ли присвоить экземпляр указанного типа переменной текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3573">Determines whether an instance of a specified type can be assigned to a variable of the current type.</span></span></summary>
        <returns><span data-ttu-id="95a33-3574"><see langword="true" />, если истинно любое из следующих условий:</span><span class="sxs-lookup"><span data-stu-id="95a33-3574"><see langword="true" /> if any of the following conditions is true:</span></span> <span data-ttu-id="95a33-3575">
-   <paramref name="c" /> и текущий экземпляр принадлежат к одному типу.</span><span class="sxs-lookup"><span data-stu-id="95a33-3575">
-   <paramref name="c" /> and the current instance represent the same type.</span></span>  
  <span data-ttu-id="95a33-3576">
-   <paramref name="c" /> прямо или косвенно унаследован от текущего экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-3576">
-   <paramref name="c" /> is derived either directly or indirectly from the current instance.</span></span> <span data-ttu-id="95a33-3577">Параметр <paramref name="c" /> является производным непосредственно от текущего экземпляра, если он наследуется от него. Параметр <paramref name="c" /> является косвенно производным от текущего экземпляра, если он наследуется от последовательности одного или нескольких классов, наследуемых от текущего экземпляра.</span><span class="sxs-lookup"><span data-stu-id="95a33-3577"><paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</span></span>  
  
<span data-ttu-id="95a33-3578">– Текущий экземпляр является интерфейсом, который реализуется параметром <paramref name="c" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3578">-   The current instance is an interface that <paramref name="c" /> implements.</span></span>  
  <span data-ttu-id="95a33-3579">
-   <paramref name="c" /> является параметром универсального типа, а текущий экземпляр представляет одно из ограничений, наложенных на параметр <paramref name="c" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3579">
-   <paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.</span></span>  
  
<span data-ttu-id="95a33-3580">В приведенном ниже примере текущий экземпляр является объектом <see cref="T:System.Type" />, который представляет класс <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3580">In the following example, the current instance is a <see cref="T:System.Type" /> object that represents the <see cref="T:System.IO.Stream" /> class.</span></span> <span data-ttu-id="95a33-3581"><c>GenericWithConstraint</c> — это универсальный тип, параметр универсального типа которого должен иметь тип <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3581"><c>GenericWithConstraint</c> is a generic type whose generic type parameter must be of type    <see cref="T:System.IO.Stream" />.</span></span> <span data-ttu-id="95a33-3582">Передача этого параметра универсального типа в <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> означает, что экземпляр параметра универсального типа можно присвоить объекту <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3582">Passing its generic type parameter to the <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indicates that  an instance of the generic type parameter can be assigned to an <see cref="T:System.IO.Stream" /> object.</span></span>  
  
<span data-ttu-id="95a33-3583">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="95a33-3583">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span></span> <span data-ttu-id="95a33-3584">
-   <paramref name="c" /> представляет тип значения, а текущий экземпляр представляет <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-3584">
-   <paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span></span>  
  
 <span data-ttu-id="95a33-3585">Значение <see langword="false" />, если не выполняется ни одно из этих условий или значение параметра <paramref name="c" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3585"><see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3586">Метод <xref:System.Type.IsAssignableFrom%2A> можно использовать для определения того, может ли экземпляр `c` быть назначен экземпляру текущего типа, метод наиболее удобен при обработке объектов, типы которых неизвестны во время разработки и позволяют условное присваивание. , как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="95a33-3586">The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 <span data-ttu-id="95a33-3587">Таким образом, этот метод гарантирует, что строка кода, подобная приведенной ниже, будет выполняться во время выполнения без создания исключения <xref:System.InvalidCastException> или аналогичного исключения:</span><span class="sxs-lookup"><span data-stu-id="95a33-3587">This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 <span data-ttu-id="95a33-3588">Этот метод может быть переопределен производным классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3588">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3589">Определение универсального типа не может быть назначено из закрытого сконструированного типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3589">A generic type definition is not assignable from a closed constructed type.</span></span> <span data-ttu-id="95a33-3590">То есть нельзя присвоить закрытый сконструированный тип `MyGenericList<int>` (`MyGenericList(Of Integer)` в Visual Basic) переменной типа `MyGenericList<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3590">That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.</span></span>  
  
 <span data-ttu-id="95a33-3591">Если параметр `c` имеет тип <xref:System.Reflection.Emit.TypeBuilder>, результат основан на типе, который должен быть построен.</span><span class="sxs-lookup"><span data-stu-id="95a33-3591">If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built.</span></span> <span data-ttu-id="95a33-3592">В следующем примере кода демонстрируется использование созданного типа с именем `B`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3592">The following code example demonstrates this using a built type named `B`.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3593">В следующем примере демонстрируется метод `IsAssignableFrom` с использованием определенных классов, целочисленных массивов и универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3593">The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.</span></span>  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3594">Возвращает значение, позволяющее определить, выбран ли для объекта <see langword="AutoClass" /> атрибут формата строки <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3594">Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="95a33-3595">Значение <see langword="true" />, если для данного объекта <see langword="AutoClass" /> выбран атрибут формата строки <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3595"><see langword="true" /> if the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3596"><xref:System.Reflection.TypeAttributes.StringFormatMask> выбирает атрибуты формата строки.</span><span class="sxs-lookup"><span data-stu-id="95a33-3596">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="95a33-3597">Атрибуты формата строки улучшают взаимодействие, определяя, как должны интерпретироваться строки.</span><span class="sxs-lookup"><span data-stu-id="95a33-3597">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="95a33-3598">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3598">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="95a33-3599">Например, если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3599">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="95a33-3600">Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3600">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3601">Получает значение, указывающее, выкладываются ли поля текущего типа автоматически средой CLR.</span><span class="sxs-lookup"><span data-stu-id="95a33-3601">Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</span></span></summary>
        <value><span data-ttu-id="95a33-3602">Значение <see langword="true" />, если свойство <see cref="P:System.Type.Attributes" /> текущего типа включает <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3602"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3603">Это свойство предоставляется для удобства.</span><span class="sxs-lookup"><span data-stu-id="95a33-3603">This property is provided as a convenience.</span></span> <span data-ttu-id="95a33-3604">Кроме того, можно использовать значение перечисления <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>, чтобы выбрать атрибуты макета типа, а затем проверить, задан ли <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3604">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="95a33-3605">Значения перечисления <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>и <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> указывают способ расположения полей типа в памяти.</span><span class="sxs-lookup"><span data-stu-id="95a33-3605">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="95a33-3606">Для динамических типов можно указать <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> при создании типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3606">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="95a33-3607">В коде примените к типу атрибут <xref:System.Runtime.InteropServices.StructLayoutAttribute> со значением перечисления <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType>, чтобы среда выполнения самостоятельно определила соответствующий способ размещения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-3607">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3608">Нельзя использовать метод <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>, чтобы определить, применен ли <xref:System.Runtime.InteropServices.StructLayoutAttribute> к типу.</span><span class="sxs-lookup"><span data-stu-id="95a33-3608">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="95a33-3609">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3609">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="95a33-3610">Например, если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется с помощью `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="95a33-3610">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="95a33-3611">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3611">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3612">В следующем примере создается экземпляр типа и отображается свойство <xref:System.Type.IsAutoLayout%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3612">The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.</span></span>  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="95a33-3613">Метаданные и компоненты с самоописанием</span><span class="sxs-lookup"><span data-stu-id="95a33-3613">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public virtual bool IsByRef { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRef As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRef { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3614">Возвращает значение, указывающее, передан ли объект <see cref="T:System.Type" /> по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-3614">Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <value><span data-ttu-id="95a33-3615">Значение<see langword="true" /> , если объект <see cref="T:System.Type" /> передан по ссылке; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3615"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3616">Чтобы получить фактический тип, удалите ссылку на тип, переданный по ссылке, а затем вызовите <xref:System.Type.GetElementType%2A> для этого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3616">To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3617">В следующем примере показано использование свойства `IsByRef` для проверки передачи указанного типа по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-3617">The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference.</span></span> <span data-ttu-id="95a33-3618">В примере определяется класс `MyTypeDelegator`, который переопределяет метод `HasElementTypeImpl`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3618">The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="95a33-3619">Основной класс проверяет свойство `HasElementType` и отображает тип элемента.</span><span class="sxs-lookup"><span data-stu-id="95a33-3619">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-3620">При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsByRef" /> и определяет, передается ли данный объект <see cref="T:System.Type" /> по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-3620">When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="95a33-3621">Значение<see langword="true" /> , если объект <see cref="T:System.Type" /> передан по ссылке; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3621"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3622">Получает значение, позволяющее определить, является объект <see cref="T:System.Type" /> классом или делегатом (иными словами, не является типом значения или интерфейсом).</span><span class="sxs-lookup"><span data-stu-id="95a33-3622">Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</span></span></summary>
        <value><span data-ttu-id="95a33-3623">Значение<see langword="true" /> , если объект <see cref="T:System.Type" /> является классом; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3623"><see langword="true" /> if the <see cref="T:System.Type" /> is a class; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3624">Это свойство возвращает `true` для классов, а также для делегатов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3624">This property returns `true` for classes as well as delegates.</span></span> <span data-ttu-id="95a33-3625">Он возвращает `false` для типов значений (для структур и перечислений), даже если они упакованы.</span><span class="sxs-lookup"><span data-stu-id="95a33-3625">It returns `false` for value types (for structures and enumerations) even if they are boxed.</span></span>  
  
 <span data-ttu-id="95a33-3626">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `true`. Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает `true`, если определение универсального типа является определением класса; то есть он не определяет интерфейс или тип значения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3626">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3627">Это свойство возвращает `true` для `Type` экземпляров, представляющих классы <xref:System.Enum> и <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3627">This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes.</span></span> <span data-ttu-id="95a33-3628">Эти два класса являются базовыми типами для перечислений и типов значений, но они не являются перечислениями или типами значений.</span><span class="sxs-lookup"><span data-stu-id="95a33-3628">These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</span></span> <span data-ttu-id="95a33-3629">Дополнительные сведения см. в разделе Свойства <xref:System.Type.IsValueType%2A> и <xref:System.Type.IsEnum%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3629">For more information, see the <xref:System.Type.IsValueType%2A> and <xref:System.Type.IsEnum%2A> properties.</span></span>  
  
 <span data-ttu-id="95a33-3630">Значение перечисления <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> позволяет отличать объявление типа как класс или интерфейс. Однако классы и типы значений помечаются атрибутом <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3630">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="95a33-3631">Если вы получаете значение свойства типа Attributes и используете значение <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>, чтобы определить, является ли тип классом, а не типом значения, необходимо также вызвать свойство <xref:System.Type.IsValueType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3631">If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property.</span></span> <span data-ttu-id="95a33-3632">В примере перечисления <xref:System.Reflection.TypeAttributes> содержатся дополнительные сведения, а также анексампле.</span><span class="sxs-lookup"><span data-stu-id="95a33-3632">The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.</span></span>  
  
 <span data-ttu-id="95a33-3633">Это свойство доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3633">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3634">В следующем примере создается экземпляр типа и указывается, является ли тип классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3634">The following example creates an instance of a type and indicates whether the type is a class.</span></span>  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3635">Возвращает значение, указывающее, является ли объект <see cref="T:System.Type" /> COM-объектом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3635">Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <value><span data-ttu-id="95a33-3636">Значение <see langword="true" />, если <see cref="T:System.Type" /> является COM-объектом, в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3636"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3637">Этот метод возвращает `false` для COM-интерфейсов, так как они не являются объектами.</span><span class="sxs-lookup"><span data-stu-id="95a33-3637">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="95a33-3638">COM-интерфейсы можно реализовать с помощью объектов Microsoft .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="95a33-3638">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 <span data-ttu-id="95a33-3639">Можно также загрузить класс COM и получить `Type` объект для этого COM-класса с помощью средства [Tlbimp. exe (программа импорта библиотек типов)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) .</span><span class="sxs-lookup"><span data-stu-id="95a33-3639">You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span>  
  
 <span data-ttu-id="95a33-3640">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3640">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="95a33-3641">Например, если текущий <xref:System.Type> представляет `MyGenericType<int`> (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3641">For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="95a33-3642">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3642">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-3643">При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsCOMObject" /> и определяет, является ли объект <see cref="T:System.Type" /> COM-объектом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3643">When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <returns><span data-ttu-id="95a33-3644">Значение <see langword="true" />, если <see cref="T:System.Type" /> является COM-объектом, в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3644"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3645">Этот метод возвращает `false` для COM-интерфейсов, так как они не являются объектами.</span><span class="sxs-lookup"><span data-stu-id="95a33-3645">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="95a33-3646">COM-интерфейсы можно реализовать с помощью объектов Microsoft .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="95a33-3646">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public abstract bool IsConstructedGenericType { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsConstructedGenericType As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsConstructedGenericType { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3647">Возвращает значение, указывающее, представляет ли этот данный объект сконструированный универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3647">Gets a value that indicates whether this object represents a constructed generic type.</span></span> <span data-ttu-id="95a33-3648">Можно создать экземпляры сконструированного универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3648">You can create instances of a constructed generic type.</span></span></summary>
        <value><span data-ttu-id="95a33-3649">Значение <see langword="true" />, если этот объект представляет сконструированный универсальный тип; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3649"><see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3650">Сконструированный универсальный тип имеет явные типы, предоставленные для всех его параметров универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3650">A constructed generic type has had explicit types supplied for all of its generic type parameters.</span></span> <span data-ttu-id="95a33-3651">Он также называется закрытым универсальным типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3651">It is also referred to as a closed generic type.</span></span>  
  
 <span data-ttu-id="95a33-3652">Если это свойство имеет значение `true`, можно создавать экземпляры текущего типа. Если это `false`, вы не можете.</span><span class="sxs-lookup"><span data-stu-id="95a33-3652">When this property is `true`, you can create instances of the current type; when it is `false`, you can't.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3653">Возвращает значение, позволяющее определить, можно ли поместить в контекст объект <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3653">Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <value><span data-ttu-id="95a33-3654">Значение<see langword="true" /> , если объект <see cref="T:System.Type" /> может быть помещен в контекст; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3654"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3655">Контекст перехватывает вызовы членов класса и принудительно применяет политики, применяемые к классу, например синхронизацию.</span><span class="sxs-lookup"><span data-stu-id="95a33-3655">A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</span></span> <span data-ttu-id="95a33-3656">Более подробные сведения о контекстах удаленного взаимодействия см. в разделе <xref:System.Runtime.Remoting.Contexts.Context>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3656">For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.</span></span>  
  
 <span data-ttu-id="95a33-3657">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3657">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3658">В следующем примере демонстрируются свойства `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>и <xref:System.Type.IsPrimitive%2A> класса <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3658">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="95a33-3659">Он проверяет, может ли данный тип размещаться в контексте, может ли он быть маршалирован по ссылке и является ли тип примитивным типом данных.</span><span class="sxs-lookup"><span data-stu-id="95a33-3659">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-3660">Реализует свойство <see cref="P:System.Type.IsContextful" /> и определяет, можно ли поместить в контекст данный объект <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3660">Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <returns><span data-ttu-id="95a33-3661">Значение<see langword="true" /> , если объект <see cref="T:System.Type" /> может быть помещен в контекст; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3661"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3662">Этот метод может быть переопределен производным классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3662">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="95a33-3663">Контекст перехватывает вызовы членов класса и применяет политики, применяемые к классу, например синхронизацию.</span><span class="sxs-lookup"><span data-stu-id="95a33-3663">A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3664">В следующем примере демонстрируется использование метода `IsContextfulImpl`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3664">The following example demonstrates a use of the `IsContextfulImpl` method.</span></span>  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberSignature Language="C#" Value="public bool IsEnum { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEnum As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnum { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3665">Возвращает значение, позволяющее определить, представляет ли текущий объект <see cref="T:System.Type" /> перечисление.</span><span class="sxs-lookup"><span data-stu-id="95a33-3665">Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</span></span></summary>
        <value><span data-ttu-id="95a33-3666">Значение <see langword="true" />, если текущий объект <see cref="T:System.Type" /> представляет перечисление; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3666"><see langword="true" /> if the current <see cref="T:System.Type" /> represents an enumeration; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3667">Это свойство возвращает `true` для перечисления, но не для самого типа <xref:System.Enum>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3667">This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.</span></span>  
  
 <span data-ttu-id="95a33-3668">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3668">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="95a33-3669">Например, если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3669">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="95a33-3670">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3670">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="95a33-3671">Это свойство доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3671">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3672">В следующем примере показано, как использовать свойство `IsEnum`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3672">The following example demonstrates how to use the `IsEnum` property.</span></span>  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="95a33-3673">Проверяемое значение.</span><span class="sxs-lookup"><span data-stu-id="95a33-3673">The value to be tested.</span></span></param>
        <summary><span data-ttu-id="95a33-3674">Возвращает значение, показывающее, имеется ли в текущем типе перечисления указанное значение.</span><span class="sxs-lookup"><span data-stu-id="95a33-3674">Returns a value that indicates whether the specified value exists in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="95a33-3675">Значение <see langword="true" />, если указанное значение является членом текущего типа перечисления; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3675"><see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-3676">Текущий тип не является перечислением.</span><span class="sxs-lookup"><span data-stu-id="95a33-3676">The current type is not an enumeration.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-3677">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3677"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="95a33-3678"><paramref name="value" /> имеет тип, который не может быть базовым типом перечисления.</span><span class="sxs-lookup"><span data-stu-id="95a33-3678"><paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="95a33-3679">Тип модели COM, который проверяется на эквивалентность текущему типу.</span><span class="sxs-lookup"><span data-stu-id="95a33-3679">The COM type that is tested for equivalence with the current type.</span></span></param>
        <summary><span data-ttu-id="95a33-3680">Определяет, имеют ли два типа модели COM одинаковые удостоверения и могут ли они считаться эквивалентными.</span><span class="sxs-lookup"><span data-stu-id="95a33-3680">Determines whether two COM types have the same identity and are eligible for type equivalence.</span></span></summary>
        <returns><span data-ttu-id="95a33-3681">Значение <see langword="true" />, если типы модели COM эквивалентны; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3681"><see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="95a33-3682">Этот метод также возвращает значение <see langword="false" />, если один тип находится в сборке, загружаемой для исполнения, а другой — в сборке, загружаемой в контекст, предназначенный только для отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3682">This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3683">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]среда CLR поддерживает внедрение сведений о типах для COM-типов непосредственно в управляемые сборки, а не требует, чтобы управляемые сборки получали сведения о типах для COM-типов из сборок взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="95a33-3683">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="95a33-3684">Так как внедренные сведения о типах включают в себя только типы и члены, которые действительно используются в управляемой сборке, в двух управляемых сборках могут быть очень разные представления одного типа COM.</span><span class="sxs-lookup"><span data-stu-id="95a33-3684">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="95a33-3685">Все управляемые сборки имеют разные объекты <xref:System.Type> для обозначения представления типа COM.</span><span class="sxs-lookup"><span data-stu-id="95a33-3685">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="95a33-3686">Среда CLR поддерживает эквивалентность типов между этими разными представлениями для интерфейсов, структур, перечислений и делегатов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3686">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>  
  
 <span data-ttu-id="95a33-3687">Эквивалентность типов означает, что COM-объект, передаваемый из одной управляемой сборки в другую, можно привести к соответствующему управляемому типу в принимающей сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-3687">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span> <span data-ttu-id="95a33-3688">Метод <xref:System.Type.IsEquivalentTo%2A> позволяет сборке определить, что COM-объект, полученный из другой сборки, имеет то же удостоверение COM, что и один из встроенных типов взаимодействия первой сборки, и, таким образом, может быть приведен к этому типу.</span><span class="sxs-lookup"><span data-stu-id="95a33-3688">The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</span></span>  
  
 <span data-ttu-id="95a33-3689">Дополнительные сведения см. в разделе [эквивалентность типов и внедренные типы взаимодействия](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-3689">For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3690">Возвращает значение, указывающее, выкладываются ли поля текущего типа с явно заданными смещениями.</span><span class="sxs-lookup"><span data-stu-id="95a33-3690">Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</span></span></summary>
        <value><span data-ttu-id="95a33-3691">Значение <see langword="true" />, если свойство <see cref="P:System.Type.Attributes" /> текущего типа включает <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3691"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3692">Это свойство предоставляется для удобства.</span><span class="sxs-lookup"><span data-stu-id="95a33-3692">This property is provided as a convenience.</span></span> <span data-ttu-id="95a33-3693">Кроме того, можно использовать значение перечисления <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>, чтобы выбрать атрибуты макета типа, а затем проверить, задан ли <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3693">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="95a33-3694">Значения перечисления <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>и <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> указывают способ расположения полей типа в памяти.</span><span class="sxs-lookup"><span data-stu-id="95a33-3694">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="95a33-3695">Для динамических типов можно указать <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> при создании типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3695">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="95a33-3696">В коде примените к типу атрибут <xref:System.Runtime.InteropServices.StructLayoutAttribute> со значением перечисления <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>, чтобы указать, что смещения, с которых начинаются поля, указаны явно.</span><span class="sxs-lookup"><span data-stu-id="95a33-3696">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3697">Нельзя использовать метод <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>, чтобы определить, применен ли <xref:System.Runtime.InteropServices.StructLayoutAttribute> к типу.</span><span class="sxs-lookup"><span data-stu-id="95a33-3697">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="95a33-3698">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3698">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="95a33-3699">Например, если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3699">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="95a33-3700">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3700">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3701">В следующем примере создается экземпляр типа и отображается значение его свойства <xref:System.Type.IsExplicitLayout%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3701">The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property.</span></span> <span data-ttu-id="95a33-3702">В нем используется класс `MySystemTime`, который также входит в пример кода для <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3702">It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span></span>  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="95a33-3703">Метаданные и компоненты с самоописанием</span><span class="sxs-lookup"><span data-stu-id="95a33-3703">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public abstract bool IsGenericParameter { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsGenericParameter As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsGenericParameter { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3704">Возвращает значение, позволяющее определить, представляет ли текущий объект <see cref="T:System.Type" /> параметр типа в определении универсального типа или метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-3704">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</span></span></summary>
        <value><span data-ttu-id="95a33-3705">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> представляет параметр определения универсального типа; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3705"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition or generic method definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3706"><xref:System.Type> объекты, представляющие параметры универсального типа, можно получить, вызвав метод <xref:System.Type.GetGenericArguments%2A> объекта <xref:System.Type>, который представляет определение универсального типа, или метод <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> объекта <xref:System.Reflection.MethodInfo>, представляющий определение универсального метода.</span><span class="sxs-lookup"><span data-stu-id="95a33-3706"><xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
-   <span data-ttu-id="95a33-3707">Для определения универсального типа или метода свойство <xref:System.Type.IsGenericParameter%2A> возвращает `true` для каждого элемента результирующего массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-3707">For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.</span></span>  
  
-   <span data-ttu-id="95a33-3708">Для закрытого сконструированного типа или метода свойство <xref:System.Type.IsGenericParameter%2A> возвращает `false` для каждого элемента массива, возвращаемого методом <xref:System.Type.GetGenericArguments%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3708">For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.</span></span>  
  
-   <span data-ttu-id="95a33-3709">Для открытого сконструированного типа или метода некоторые элементы массива могут быть конкретными типами, а другие могут быть параметрами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3709">For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</span></span> <span data-ttu-id="95a33-3710"><xref:System.Type.IsGenericParameter%2A> возвращает `false` для типов и `true` для параметров типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3710"><xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters.</span></span> <span data-ttu-id="95a33-3711">В примере кода для свойства <xref:System.Type.ContainsGenericParameters%2A> демонстрируется универсальный класс с сочетанием типов и параметров типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3711">The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.</span></span>  
  
 <span data-ttu-id="95a33-3712">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3712">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3713">В следующем примере используется свойство <xref:System.Type.IsGenericParameter%2A> для проверки параметров универсального типа в универсальном типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-3713">The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="95a33-3714">Отражение и универсальные типы</span><span class="sxs-lookup"><span data-stu-id="95a33-3714">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="95a33-3715">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-3715">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3716">Возвращает значение, указывающее, является ли текущий тип универсальным.</span><span class="sxs-lookup"><span data-stu-id="95a33-3716">Gets a value indicating whether the current type is a generic type.</span></span></summary>
        <value><span data-ttu-id="95a33-3717"><see langword="true" />, если текущий тип является универсальным типом; в противном случае <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3717"><see langword="true" /> if the current type is a generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3718">Используйте свойство <xref:System.Type.IsGenericType%2A>, чтобы определить, представляет ли объект <xref:System.Type> универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3718">Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type.</span></span> <span data-ttu-id="95a33-3719">Используйте свойство <xref:System.Type.ContainsGenericParameters%2A>, чтобы определить, представляет ли объект <xref:System.Type> открытый сконструированный тип или закрытый сконструированный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3719">Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3720">Свойство <xref:System.Type.IsGenericType%2A> возвращает `false`, если немедленный тип не является универсальным.</span><span class="sxs-lookup"><span data-stu-id="95a33-3720">The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic.</span></span> <span data-ttu-id="95a33-3721">Например, массив, элементы которого имеют тип `A<int>` (`A(Of Integer)` в Visual Basic), не является универсальным типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3721">For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.</span></span>  
  
 <span data-ttu-id="95a33-3722">В следующей таблице перечислены инвариантные условия для общих терминов, используемых в универсальном отражении.</span><span class="sxs-lookup"><span data-stu-id="95a33-3722">The following table summarizes the invariant conditions for common terms used in generic reflection.</span></span>  
  
|<span data-ttu-id="95a33-3723">Термин</span><span class="sxs-lookup"><span data-stu-id="95a33-3723">Term</span></span>|<span data-ttu-id="95a33-3724">Инвариант</span><span class="sxs-lookup"><span data-stu-id="95a33-3724">Invariant</span></span>|  
|----------|---------------|  
|<span data-ttu-id="95a33-3725">определение универсального типа</span><span class="sxs-lookup"><span data-stu-id="95a33-3725">generic type definition</span></span>|<span data-ttu-id="95a33-3726">Значение свойства <xref:System.Type.IsGenericTypeDefinition%2A> — `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3726">The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="95a33-3727">Определяет универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3727">Defines a generic type.</span></span> <span data-ttu-id="95a33-3728">Сконструированный тип создается путем вызова метода <xref:System.Type.MakeGenericType%2A> для объекта <xref:System.Type>, который представляет определение универсального типа и задает массив аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3728">A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.</span></span><br /><br /> <span data-ttu-id="95a33-3729"><xref:System.Type.MakeGenericType%2A> могут вызываться только в определениях универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3729"><xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.</span></span><br /><br /> <span data-ttu-id="95a33-3730">Любое определение универсального типа является универсальным типом (свойство <xref:System.Type.IsGenericType%2A> `true`), но наоборот не имеет значения true.</span><span class="sxs-lookup"><span data-stu-id="95a33-3730">Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.</span></span>|  
|<span data-ttu-id="95a33-3731">универсальный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-3731">generic type</span></span>|<span data-ttu-id="95a33-3732">Значение свойства <xref:System.Type.IsGenericType%2A> — `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3732">The <xref:System.Type.IsGenericType%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="95a33-3733">Может быть определением универсального типа, открытым сконструированным типом или закрытым сконструированным типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3733">Can be a generic type definition, an open constructed type, or a closed constructed type.</span></span><br /><br /> <span data-ttu-id="95a33-3734">Обратите внимание, что тип массива, элемент которого является универсальным, сам по себе не является универсальным типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3734">Note that an array type whose element type is generic is not itself a generic type.</span></span> <span data-ttu-id="95a33-3735">То же самое справедливо для объекта <xref:System.Type>, представляющего указатель на универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3735">The same is true of a <xref:System.Type> object representing a pointer to a generic type.</span></span>|  
|<span data-ttu-id="95a33-3736">открытый сконструированный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-3736">open constructed type</span></span>|<span data-ttu-id="95a33-3737">Значение свойства <xref:System.Type.ContainsGenericParameters%2A> — `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3737">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="95a33-3738">Примерами являются универсальные типы, которые имеют неназначенные параметры типа, тип, вложенный в определение универсального типа или в открытый сконструированный тип, или универсальный тип с аргументом типа, для которого `true`свойство <xref:System.Type.ContainsGenericParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3738">Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="95a33-3739">Невозможно создать экземпляр открытого сконструированного типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3739">It is not possible to create an instance of an open constructed type.</span></span><br /><br /> <span data-ttu-id="95a33-3740">Обратите внимание, что не все открытые сконструированные типы являются универсальными.</span><span class="sxs-lookup"><span data-stu-id="95a33-3740">Note that not all open constructed types are generic.</span></span> <span data-ttu-id="95a33-3741">Например, массив, тип элемента которого является определением универсального типа, не является универсальным, а указатель на открытый сконструированный тип не является универсальным.</span><span class="sxs-lookup"><span data-stu-id="95a33-3741">For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</span></span>|  
|<span data-ttu-id="95a33-3742">закрытый сконструированный тип</span><span class="sxs-lookup"><span data-stu-id="95a33-3742">closed constructed type</span></span>|<span data-ttu-id="95a33-3743">Значение свойства <xref:System.Type.ContainsGenericParameters%2A> — `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3743">The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.</span></span><br /><br /> <span data-ttu-id="95a33-3744">При рекурсивном исследовании тип не имеет неназначенных универсальных параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-3744">When examined recursively, the type has no unassigned generic parameters.</span></span>|  
|<span data-ttu-id="95a33-3745">параметр универсального типа</span><span class="sxs-lookup"><span data-stu-id="95a33-3745">generic type parameter</span></span>|<span data-ttu-id="95a33-3746">Значение свойства <xref:System.Type.IsGenericParameter%2A> — `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3746">The <xref:System.Type.IsGenericParameter%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="95a33-3747">Значение свойства <xref:System.Type.ContainsGenericParameters%2A> — `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3747">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="95a33-3748">В определении универсального типа заполнитель для типа, который будет назначен позже.</span><span class="sxs-lookup"><span data-stu-id="95a33-3748">In a generic type definition, a placeholder for a type that will be assigned later.</span></span>|  
|<span data-ttu-id="95a33-3749">аргумент универсального типа</span><span class="sxs-lookup"><span data-stu-id="95a33-3749">generic type argument</span></span>|<span data-ttu-id="95a33-3750">Может быть любым типом, включая параметр универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3750">Can be any type, including a generic type parameter.</span></span><br /><br /> <span data-ttu-id="95a33-3751">Аргументы типа указываются в виде массива объектов <xref:System.Type>, переданных в метод <xref:System.Type.MakeGenericType%2A> при создании сконструированного универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3751">Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type.</span></span> <span data-ttu-id="95a33-3752">Если создаются экземпляры результирующего типа, свойство <xref:System.Type.ContainsGenericParameters%2A> должно быть `false` для всех аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3752">If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.</span></span>|  
  
 <span data-ttu-id="95a33-3753">В следующем примере кода и таблице показаны некоторые из этих терминов и инвариантов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3753">The following code example and table illustrate some of these terms and invariants.</span></span> <span data-ttu-id="95a33-3754">Класс `Derived` является особым интересом, так как его базовый тип является сконструированным типом, который имеет смесь типов и параметров типа в списке аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3754">The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 <span data-ttu-id="95a33-3755">В следующей таблице приведены примеры использования и сборки на классах `Base`, `Derived`и `G`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3755">The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`.</span></span> <span data-ttu-id="95a33-3756">Если код C++ и C# совпадает, отображается только одна запись.</span><span class="sxs-lookup"><span data-stu-id="95a33-3756">When the C++ and C# code is the same, only one entry is shown.</span></span>  
  
|<span data-ttu-id="95a33-3757">Пример</span><span class="sxs-lookup"><span data-stu-id="95a33-3757">Example</span></span>|<span data-ttu-id="95a33-3758">Инварианты</span><span class="sxs-lookup"><span data-stu-id="95a33-3758">Invariants</span></span>|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|<span data-ttu-id="95a33-3759">Для этого типа:</span><span class="sxs-lookup"><span data-stu-id="95a33-3759">For this type:</span></span><br /><br /> <span data-ttu-id="95a33-3760"><xref:System.Type.IsGenericType%2A> — `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3760"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="95a33-3761">Свойство <xref:System.Type.IsGenericTypeDefinition%2A> имеет значение `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3761"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="95a33-3762"><xref:System.Type.ContainsGenericParameters%2A> — `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3762"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|<span data-ttu-id="95a33-3763">Для этого типа:</span><span class="sxs-lookup"><span data-stu-id="95a33-3763">For this type:</span></span><br /><br /> <span data-ttu-id="95a33-3764">Свойство <xref:System.Type.IsGenericType%2A> имеет значение `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3764"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="95a33-3765">Свойство <xref:System.Type.IsGenericTypeDefinition%2A> имеет значение `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3765"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="95a33-3766"><xref:System.Type.ContainsGenericParameters%2A> — `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3766"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|<span data-ttu-id="95a33-3767">Для типа переменной `d`:</span><span class="sxs-lookup"><span data-stu-id="95a33-3767">For the type of variable `d`:</span></span><br /><br /> <span data-ttu-id="95a33-3768"><xref:System.Type.IsGenericType%2A> `false`, так как `d` является массивом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3768"><xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.</span></span><br /><br /> <span data-ttu-id="95a33-3769">Свойство <xref:System.Type.IsGenericTypeDefinition%2A> имеет значение `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3769"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="95a33-3770">Свойство <xref:System.Type.ContainsGenericParameters%2A> имеет значение `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3770"><xref:System.Type.ContainsGenericParameters%2A> is `false`.</span></span>|  
|<span data-ttu-id="95a33-3771">`T`, `U`и `V` (везде, где они отображаются)</span><span class="sxs-lookup"><span data-stu-id="95a33-3771">`T`, `U`, and `V` (everywhere they appear)</span></span>|<span data-ttu-id="95a33-3772"><xref:System.Type.IsGenericParameter%2A> — `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3772"><xref:System.Type.IsGenericParameter%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="95a33-3773"><xref:System.Type.IsGenericType%2A> `false`, так как невозможно ограничить параметр типа универсальными типами.</span><span class="sxs-lookup"><span data-stu-id="95a33-3773"><xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.</span></span><br /><br /> <span data-ttu-id="95a33-3774">Свойство <xref:System.Type.IsGenericTypeDefinition%2A> имеет значение `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3774"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="95a33-3775"><xref:System.Type.ContainsGenericParameters%2A> `true`, так как `T`, `U`и `V` сами являются параметрами универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3775"><xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters.</span></span> <span data-ttu-id="95a33-3776">Это не подразумевает никаких действий с аргументами типа, назначенными им позже.</span><span class="sxs-lookup"><span data-stu-id="95a33-3776">This does not imply anything about type arguments that are assigned to them later.</span></span>|  
|<span data-ttu-id="95a33-3777">Тип поля `F`</span><span class="sxs-lookup"><span data-stu-id="95a33-3777">The type of field `F`</span></span>|<span data-ttu-id="95a33-3778">Свойство <xref:System.Type.IsGenericType%2A> имеет значение `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3778"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="95a33-3779"><xref:System.Type.IsGenericTypeDefinition%2A> `false`, так как тип был назначен параметру типа `G`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3779"><xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to the type parameter of `G`.</span></span> <span data-ttu-id="95a33-3780">Обратите внимание, что это эквивалентно вызову метода <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3780">Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.</span></span><br /><br /> <span data-ttu-id="95a33-3781"><xref:System.Type.ContainsGenericParameters%2A> `true`, так как тип поля `F` имеет аргумент типа, который является открытым сконструированным типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3781"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type.</span></span> <span data-ttu-id="95a33-3782">Сконструированный тип открыт, так как его аргумент типа (то есть `Base`) является определением универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3782">The constructed type is open because its type argument (that is, `Base`) is a generic type definition.</span></span> <span data-ttu-id="95a33-3783">Это иллюстрирует рекурсивную природу свойства <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3783">This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.</span></span>|  
|<span data-ttu-id="95a33-3784">Вложенный класс `Nested`</span><span class="sxs-lookup"><span data-stu-id="95a33-3784">The nested class `Nested`</span></span>|<span data-ttu-id="95a33-3785"><xref:System.Type.IsGenericType%2A> `true`, несмотря на то, что класс `Nested` не имеет собственных параметров универсального типа, так как он вложен в универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3785"><xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.</span></span><br /><br /> <span data-ttu-id="95a33-3786"><xref:System.Type.IsGenericTypeDefinition%2A> — `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3786"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span> <span data-ttu-id="95a33-3787">То есть можно вызвать метод <xref:System.Type.MakeGenericType%2A> и указать параметр типа включающего типа, `Derived`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3787">That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.</span></span><br /><br /> <span data-ttu-id="95a33-3788"><xref:System.Type.ContainsGenericParameters%2A> `true`, так как включающий тип, `Derived`, имеет параметры универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3788"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters.</span></span> <span data-ttu-id="95a33-3789">Это иллюстрирует рекурсивную природу свойства <xref:System.Type.ContainsGenericParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3789">This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3790">В следующем примере кода выводятся значения свойств <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>и <xref:System.Type.ContainsGenericParameters%2A> для типов, описанных в разделе "Примечания".</span><span class="sxs-lookup"><span data-stu-id="95a33-3790">The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section.</span></span> <span data-ttu-id="95a33-3791">Пояснения значений свойств см. в сопроводительной таблице в разделе "Примечания".</span><span class="sxs-lookup"><span data-stu-id="95a33-3791">For explanations of the property values, see the accompanying table in Remarks.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="95a33-3792">Отражение и универсальные типы</span><span class="sxs-lookup"><span data-stu-id="95a33-3792">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="95a33-3793">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-3793">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3794">Возвращает значение, позволяющее определить, представляет ли текущий объект <see cref="T:System.Type" /> определение универсального типа, на основе которого можно сконструировать другие универсальные типы.</span><span class="sxs-lookup"><span data-stu-id="95a33-3794">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</span></span></summary>
        <value><span data-ttu-id="95a33-3795">Значение <see langword="true" />, если этот объект <see cref="T:System.Type" /> представляет определение универсального типа; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3795"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a generic type definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3796">Определение универсального типа — это шаблон, из которого могут быть созданы другие типы.</span><span class="sxs-lookup"><span data-stu-id="95a33-3796">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="95a33-3797">Например, из определения универсального типа `G<T>` (выраженного в C# синтаксисе; `G(Of T)` в Visual Basic или `generic <typename T> ref class G` C++в) можно создать и создать экземпляр типа `G<int>` (`G(Of Integer)` в Visual Basic), вызвав метод <xref:System.Type.MakeGenericType%2A> с универсальный список аргументов, содержащий тип <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3797">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type.</span></span> <span data-ttu-id="95a33-3798">При наличии объекта <xref:System.Type>, представляющего этот сконструированный тип, метод <xref:System.Type.GetGenericTypeDefinition%2A> Возвращает определение универсального типа обратно.</span><span class="sxs-lookup"><span data-stu-id="95a33-3798">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.</span></span>  
  
 <span data-ttu-id="95a33-3799">Используйте свойство <xref:System.Type.IsGenericTypeDefinition%2A>, чтобы определить, можно ли создавать новые типы из текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3799">Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type.</span></span> <span data-ttu-id="95a33-3800">Если свойство <xref:System.Type.IsGenericTypeDefinition%2A> возвращает `true`, можно вызвать метод <xref:System.Type.MakeGenericType%2A>, чтобы создать новые универсальные типы.</span><span class="sxs-lookup"><span data-stu-id="95a33-3800">If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.</span></span>  
  
 <span data-ttu-id="95a33-3801">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3801">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3802">В следующем примере отображаются сведения о типе, в том числе о том, является ли он определением универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3802">The following example displays information about a type, including whether or not it is a generic type definition.</span></span> <span data-ttu-id="95a33-3803">Информация отображается для сконструированного типа, для определения универсального типа и для обычного типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3803">Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="95a33-3804">Отражение и универсальные типы</span><span class="sxs-lookup"><span data-stu-id="95a33-3804">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="95a33-3805">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-3805">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3806">Возвращает значение, позволяющее определить, есть ли у объекта <see cref="T:System.Type" /> атрибут <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />, свидетельствующий о том, что объект был импортирован из библиотеки COM-типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3806">Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</span></span></summary>
        <value><span data-ttu-id="95a33-3807">Значение <see langword="true" />, если у <see cref="T:System.Type" /> есть атрибут <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3807"><see langword="true" /> if the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3808">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3808">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="95a33-3809">Например, если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется с помощью `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="95a33-3809">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="95a33-3810">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3810">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95a33-3811">Объект, который требуется сравнить с текущим типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3811">The object to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="95a33-3812">Определяет, является ли указанный объект экземпляром текущего типа <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3812">Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-3813">Значение <see langword="true" />, если текущий объект <see langword="Type" /> входит в иерархию наследования объекта, представленного параметром <paramref name="o" /> или если текущий объект <see langword="Type" /> является интерфейсом, реализуемым параметром <paramref name="o" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3813"><see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements.</span></span> <span data-ttu-id="95a33-3814">Значение <see langword="false" />, если не выполняется ни одно из перечисленных условий, параметр <paramref name="o" /> имеет значение <see langword="null" /> или текущий объект <see langword="Type" /> является открытым универсальным типом (то есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> возвращает значение <see langword="true" />).</span><span class="sxs-lookup"><span data-stu-id="95a33-3814"><see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3815">Этот метод может быть переопределен производным классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3815">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3816">Сконструированный тип не является экземпляром определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3816">A constructed type is not an instance of its generic type definition.</span></span> <span data-ttu-id="95a33-3817">То есть `MyGenericList<int>` (`MyGenericList(Of Integer)` в Visual Basic) не является экземпляром `MyGenericList<T>` (`MyGenericList(Of T)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-3817">That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3818">В следующем примере иллюстрируется использование метода `IsInstanceOfType`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3818">The following example demonstrates the use of the `IsInstanceOfType` method.</span></span>  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3819">Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> интерфейсом (иными словами, не является классом или типом значения).</span><span class="sxs-lookup"><span data-stu-id="95a33-3819">Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</span></span></summary>
        <value><span data-ttu-id="95a33-3820">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является интерфейсом; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3820"><see langword="true" /> if the <see cref="T:System.Type" /> is an interface; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3821"><xref:System.Reflection.TypeAttributes.ClassSemanticsMask> отличает объявление типа как класс, интерфейс или тип значения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3821">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.</span></span>  
  
 <span data-ttu-id="95a33-3822">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3822">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="95a33-3823">Это свойство доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3823">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3824">В следующем примере создается интерфейс, проверяется тип интерфейса и указывается, имеет ли класс заданное свойство `IsInterface`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3824">The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.</span></span>  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3825">Возвращает значение, указывающее, выкладываются ли поля текущего типа последовательно, в том порядке, в котором они были определены, или выдаются в метаданные.</span><span class="sxs-lookup"><span data-stu-id="95a33-3825">Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</span></span></summary>
        <value><span data-ttu-id="95a33-3826">Значение <see langword="true" />, если свойство <see cref="P:System.Type.Attributes" /> текущего типа включает <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3826"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3827">Это свойство предоставляется для удобства.</span><span class="sxs-lookup"><span data-stu-id="95a33-3827">This property is provided as a convenience.</span></span> <span data-ttu-id="95a33-3828">Кроме того, можно использовать значение перечисления <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>, чтобы выбрать атрибуты макета типа, а затем проверить, задан ли <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3828">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="95a33-3829">Значения перечисления <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>и <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> указывают способ расположения полей типа в памяти.</span><span class="sxs-lookup"><span data-stu-id="95a33-3829">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="95a33-3830">Для динамических типов можно указать <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> при создании типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3830">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="95a33-3831">В коде примените к типу атрибут <xref:System.Runtime.InteropServices.StructLayoutAttribute> со значением перечисления <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>, чтобы указать, что макет является последовательным.</span><span class="sxs-lookup"><span data-stu-id="95a33-3831">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value to the type, to specify that layout is sequential.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3832">Нельзя использовать метод <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>, чтобы определить, применен ли <xref:System.Runtime.InteropServices.StructLayoutAttribute> к типу.</span><span class="sxs-lookup"><span data-stu-id="95a33-3832">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="95a33-3833">Дополнительные сведения см. в разделе 9.1.2 спецификации документации по Common Language Infrastructure (CLI) "Partition II: определение метаданных и семантика".</span><span class="sxs-lookup"><span data-stu-id="95a33-3833">For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="95a33-3834">Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.</span><span class="sxs-lookup"><span data-stu-id="95a33-3834">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="95a33-3835">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-3835">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="95a33-3836">Например, если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3836">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="95a33-3837">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3837">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3838">В следующем примере создается экземпляр класса, для которого было задано значение перечисления <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> в классе <xref:System.Runtime.InteropServices.StructLayoutAttribute>, проверяется наличие свойства <xref:System.Type.IsLayoutSequential%2A> и отображается результат.</span><span class="sxs-lookup"><span data-stu-id="95a33-3838">The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="95a33-3839">Метаданные и компоненты с самоописанием</span><span class="sxs-lookup"><span data-stu-id="95a33-3839">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3840">Возвращает значение, указывающее, маршалирован ли объект <see cref="T:System.Type" /> по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-3840">Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <value><span data-ttu-id="95a33-3841">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> маршалируется по ссылке; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3841"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="95a33-3842">В следующем примере демонстрируются свойства `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>и <xref:System.Type.IsPrimitive%2A> класса <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3842">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="95a33-3843">Он проверяет, может ли данный тип размещаться в контексте, может ли он быть маршалирован по ссылке и является ли тип примитивным типом данных.</span><span class="sxs-lookup"><span data-stu-id="95a33-3843">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-3844">Реализует свойство <see cref="P:System.Type.IsMarshalByRef" /> и определяет, маршалируется ли объект <see cref="T:System.Type" /> по ссылке.</span><span class="sxs-lookup"><span data-stu-id="95a33-3844">Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <returns><span data-ttu-id="95a33-3845">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> маршалируется по ссылке; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3845"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3846">Этот метод может быть переопределен производным классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-3846">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3847">В следующем примере определяется, маршалируется ли заданный тип по ссылке, и отображается результат.</span><span class="sxs-lookup"><span data-stu-id="95a33-3847">The following example determines whether the given type is marshaled by reference and displays the result.</span></span>  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3848">Возвращает значение, позволяющее определить, представляет ли текущий объект <see cref="T:System.Type" /> тип, определение которого вложено в определение другого типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3848">Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</span></span></summary>
        <value><span data-ttu-id="95a33-3849">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> вложен в другой тип; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3849"><see langword="true" /> if the <see cref="T:System.Type" /> is nested inside another type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3850">Свойство <xref:System.Type.IsNested%2A> возвращает `true` для всех вложенных типов, независимо от видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3850">The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility.</span></span> <span data-ttu-id="95a33-3851">Чтобы проверить вложение и видимость одновременно, используйте связанные свойства <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>или <xref:System.Type.IsNestedPublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3851">To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3852">Элемент перечисления <xref:System.Reflection.TypeAttributes.VisibilityMask> выбирает атрибуты видимости для типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3852">The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3853">В следующем примере создается внешний класс с несколькими вложенными классами, которые имеют различные типы видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3853">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="95a33-3854">Затем он получает значение ряда свойств <xref:System.Type>, связанных с видимостью, для родительского типа и всех его вложенных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3854">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3855">Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> вложенным и видимым только в своей сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-3855">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</span></span></summary>
        <value><span data-ttu-id="95a33-3856">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и видимым только в своей сборке; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3856"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3857">Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3857">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="95a33-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3859">В следующем примере создается внешний класс с несколькими вложенными классами, которые имеют различные типы видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3859">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="95a33-3860">Затем он получает значение ряда свойств <xref:System.Type>, связанных с видимостью, для родительского типа и всех его вложенных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3860">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3861">Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> вложенным и видимым только для классов, принадлежащих одновременно к семейству и сборке этого объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-3861">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</span></span></summary>
        <value><span data-ttu-id="95a33-3862">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и видимым только классам, принадлежащим одновременно к семейству и сборке этого объекта; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3862"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3863">Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3863">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="95a33-3864"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3864"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-3865">Языки C# и Visual Basic не включают семантику, позволяющую определить вложенный тип, видимый только защищенным типам в собственной сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-3865">The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</span></span> <span data-ttu-id="95a33-3866">`protected internal` видимость в C# и `Protected Friend` видимость в Visual Basic определить вложенный тип, видимый как для защищенных типов, так и для типов в той же сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-3866">`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</span></span>  
  
 <span data-ttu-id="95a33-3867">Семейство объекта <xref:System.Type> определяется как все объекты того же <xref:System.Type> и его подтипов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3867">A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3868">В следующем примере создается внешний класс с несколькими вложенными классами, которые имеют различные типы видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3868">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="95a33-3869">Затем он получает значение ряда свойств <xref:System.Type>, связанных с видимостью, для родительского типа и всех его вложенных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3869">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3870">Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> вложенным и видимым только в своем семействе.</span><span class="sxs-lookup"><span data-stu-id="95a33-3870">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</span></span></summary>
        <value><span data-ttu-id="95a33-3871">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и видимым только внутри собственного семейства; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3871"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own family; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3872">Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3872">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="95a33-3873"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3873"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="95a33-3874">Семейство объекта <xref:System.Type> определяется как все объекты точно того же <xref:System.Type> и его подтипов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3874">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3875">В следующем примере создается внешний класс с несколькими вложенными классами, которые имеют различные типы видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3875">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="95a33-3876">Затем он получает значение ряда свойств <xref:System.Type>, связанных с видимостью, для родительского типа и всех его вложенных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3876">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3877">Возвращает значение, позволяющее определить, является ли данный объект <see cref="T:System.Type" /> вложенным и видимым только для классов, принадлежащих либо к его семейству, либо к его сборке.</span><span class="sxs-lookup"><span data-stu-id="95a33-3877">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</span></span></summary>
        <value><span data-ttu-id="95a33-3878">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и видимым только классам, принадлежащим его семейству или его сборке; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3878"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3879">Если видимость типа `protected internal` в C# или `Protected Friend` в Visual Basic, свойство <xref:System.Type.IsNestedFamORAssem%2A> возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3879">If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.</span></span>  
  
 <span data-ttu-id="95a33-3880">Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3880">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="95a33-3881"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3881"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="95a33-3882">Семейство объекта <xref:System.Type> определяется как все объекты точно того же <xref:System.Type> и его подтипов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3882">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3883">В следующем примере создается внешний класс с несколькими вложенными классами, которые имеют различные типы видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3883">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="95a33-3884">Затем он получает значение ряда свойств <xref:System.Type>, связанных с видимостью, для родительского типа и всех его вложенных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3884">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3885">Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> вложенным и объявленным как закрытый.</span><span class="sxs-lookup"><span data-stu-id="95a33-3885">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</span></span></summary>
        <value><span data-ttu-id="95a33-3886">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и объявленным как закрытый; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3886"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3887">Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3887">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="95a33-3888"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3888"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3889">В следующем примере создается внешний класс с несколькими вложенными классами, которые имеют различные типы видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3889">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="95a33-3890">Затем он получает значение ряда свойств <xref:System.Type>, связанных с видимостью, для родительского типа и всех его вложенных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3890">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3891">Возвращает значение, позволяющее определить, является ли класс вложенным и объявленным как открытый.</span><span class="sxs-lookup"><span data-stu-id="95a33-3891">Gets a value indicating whether a class is nested and declared public.</span></span></summary>
        <value><span data-ttu-id="95a33-3892">Значение<see langword="true" /> , если данный класс является вложенным и объявленным как открытый; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3892"><see langword="true" /> if the class is nested and declared public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3893">Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3893">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="95a33-3894"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3894"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3895">В следующем примере создается внешний класс с несколькими вложенными классами, которые имеют различные типы видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3895">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="95a33-3896">Затем он получает значение ряда свойств <xref:System.Type>, связанных с видимостью, для родительского типа и всех его вложенных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3896">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3897">Возвращает значение, позволяющее определить, не был ли объект <see cref="T:System.Type" /> объявлен как открытый.</span><span class="sxs-lookup"><span data-stu-id="95a33-3897">Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</span></span></summary>
        <value><span data-ttu-id="95a33-3898">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> не объявлен как открытый и не является вложенным типом; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3898"><see langword="true" /> if the <see cref="T:System.Type" /> is not declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3899">Не используйте это свойство вместе с вложенными типами. Вместо этого используйте свойство <xref:System.Type.IsNestedPublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3899">Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.</span></span>  
  
 <span data-ttu-id="95a33-3900">Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3900">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3901">В этом примере используется свойство `IsNotPublic` для получения видимости типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-3901">This example uses the `IsNotPublic` property to get the visibility of the type.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="95a33-3902">В следующем примере кода показано, почему нельзя использовать `IsPublic` и `IsNotPublic` для вложенных классов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3902">The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 <span data-ttu-id="95a33-3903">Для вложенных классов игнорируйте результаты `IsPublic` и `IsNotPublic` и обратите внимание только на результаты `IsNestedPublic` и `IsNestedPrivate`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3903">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`.</span></span> <span data-ttu-id="95a33-3904">Результат отражения для этого фрагмента кода будет следующим:</span><span class="sxs-lookup"><span data-stu-id="95a33-3904">The reflection output for this code fragment would be as follows:</span></span>  
  
|<span data-ttu-id="95a33-3905">Класс</span><span class="sxs-lookup"><span data-stu-id="95a33-3905">Class</span></span>|<span data-ttu-id="95a33-3906">иснотпублик</span><span class="sxs-lookup"><span data-stu-id="95a33-3906">IsNotPublic</span></span>|<span data-ttu-id="95a33-3907">NonPublic</span><span class="sxs-lookup"><span data-stu-id="95a33-3907">IsPublic</span></span>|<span data-ttu-id="95a33-3908">иснестедпублик</span><span class="sxs-lookup"><span data-stu-id="95a33-3908">IsNestedPublic</span></span>|<span data-ttu-id="95a33-3909">иснестедпривате</span><span class="sxs-lookup"><span data-stu-id="95a33-3909">IsNestedPrivate</span></span>|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|<span data-ttu-id="95a33-3910">А</span><span class="sxs-lookup"><span data-stu-id="95a33-3910">A</span></span>|<span data-ttu-id="95a33-3911">FALSE</span><span class="sxs-lookup"><span data-stu-id="95a33-3911">FALSE</span></span>|<span data-ttu-id="95a33-3912">TRUE</span><span class="sxs-lookup"><span data-stu-id="95a33-3912">TRUE</span></span>|<span data-ttu-id="95a33-3913">FALSE</span><span class="sxs-lookup"><span data-stu-id="95a33-3913">FALSE</span></span>|<span data-ttu-id="95a33-3914">FALSE</span><span class="sxs-lookup"><span data-stu-id="95a33-3914">FALSE</span></span>|  
|<span data-ttu-id="95a33-3915">С</span><span class="sxs-lookup"><span data-stu-id="95a33-3915">B</span></span>|<span data-ttu-id="95a33-3916">FALSE</span><span class="sxs-lookup"><span data-stu-id="95a33-3916">FALSE</span></span>|<span data-ttu-id="95a33-3917">FALSE</span><span class="sxs-lookup"><span data-stu-id="95a33-3917">FALSE</span></span>|<span data-ttu-id="95a33-3918">TRUE</span><span class="sxs-lookup"><span data-stu-id="95a33-3918">TRUE</span></span>|<span data-ttu-id="95a33-3919">FALSE</span><span class="sxs-lookup"><span data-stu-id="95a33-3919">FALSE</span></span>|  
|<span data-ttu-id="95a33-3920">В</span><span class="sxs-lookup"><span data-stu-id="95a33-3920">C</span></span>|<span data-ttu-id="95a33-3921">FALSE</span><span class="sxs-lookup"><span data-stu-id="95a33-3921">FALSE</span></span>|<span data-ttu-id="95a33-3922">FALSE</span><span class="sxs-lookup"><span data-stu-id="95a33-3922">FALSE</span></span>|<span data-ttu-id="95a33-3923">FALSE</span><span class="sxs-lookup"><span data-stu-id="95a33-3923">FALSE</span></span>|<span data-ttu-id="95a33-3924">true</span><span class="sxs-lookup"><span data-stu-id="95a33-3924">TRUE</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public virtual bool IsPointer { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsPointer As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsPointer { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3925">Возвращает значение, указывающее, является ли объект <see cref="T:System.Type" /> указателем.</span><span class="sxs-lookup"><span data-stu-id="95a33-3925">Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <value><span data-ttu-id="95a33-3926">Значение <see langword="true" />, если <see cref="T:System.Type" /> является указателем; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3926"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3927">Если текущий <xref:System.Type> представляет универсальный тип или параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3927">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="95a33-3928">Это свойство доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3928">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3929">В следующем примере показано использование свойства `IsPointer`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3929">The following example shows a use of the `IsPointer` property.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-3930">При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsPointer" /> и определяет, является ли объект <see cref="T:System.Type" /> указателем.</span><span class="sxs-lookup"><span data-stu-id="95a33-3930">When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <returns><span data-ttu-id="95a33-3931">Значение <see langword="true" />, если <see cref="T:System.Type" /> является указателем; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3931"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3932">Возвращает значение, указывающее, является ли <see cref="T:System.Type" /> одним из типов-примитивов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3932">Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <value><span data-ttu-id="95a33-3933">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является одним из типов-примитивов; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3933"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3934">Типы-примитивы: <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>и <xref:System.IntPtr>.<xref:System.UIntPtr><xref:System.Char><xref:System.Double><xref:System.Single></span><span class="sxs-lookup"><span data-stu-id="95a33-3934">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
 <span data-ttu-id="95a33-3935">Если текущий <xref:System.Type> представляет универсальный тип или параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3935">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3936">В следующем примере демонстрируются свойства `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>и <xref:System.Type.IsPrimitive%2A> класса <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3936">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="95a33-3937">Он проверяет, может ли данный тип размещаться в контексте, может ли он быть маршалирован по ссылке и является ли тип примитивным типом данных.</span><span class="sxs-lookup"><span data-stu-id="95a33-3937">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-3938">При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsPrimitive" /> и определяет, является ли объект <see cref="T:System.Type" /> одним из типов-примитивов.</span><span class="sxs-lookup"><span data-stu-id="95a33-3938">When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <returns><span data-ttu-id="95a33-3939">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является одним из типов-примитивов; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3939"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3940">Примитивные типы: <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>и <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3940">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3941">В следующем примере определяется, является ли заданный тип типом-примитивом, и отображается результат.</span><span class="sxs-lookup"><span data-stu-id="95a33-3941">The following example determines whether the given type is a primitive type and displays the result.</span></span>  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3942">Возвращает значение, позволяющее определить, был ли объект <see cref="T:System.Type" /> объявлен как открытый.</span><span class="sxs-lookup"><span data-stu-id="95a33-3942">Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</span></span></summary>
        <value><span data-ttu-id="95a33-3943">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> объявлен как открытый и не является вложенным типом; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3943"><see langword="true" /> if the <see cref="T:System.Type" /> is declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3944">Не используйте с вложенными типами. Вместо этого используйте <xref:System.Type.IsNestedPublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3944">Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.</span></span>  
  
 <span data-ttu-id="95a33-3945">Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3945">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.</span></span>  
  
 <span data-ttu-id="95a33-3946"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.</span><span class="sxs-lookup"><span data-stu-id="95a33-3946"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3947">В следующем примере создается экземпляр `MyTestClass`, проверяется свойство `IsPublic` и отображается результат.</span><span class="sxs-lookup"><span data-stu-id="95a33-3947">The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.</span></span>  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 <span data-ttu-id="95a33-3948">Для вложенных классов игнорируйте результаты `IsPublic` и `IsNotPublic` и обратите внимание только на результаты <xref:System.Type.IsNestedPublic%2A> и <xref:System.Type.IsNestedPrivate%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3948">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3949">Возвращает значение, позволяющее определить, был ли объект <see cref="T:System.Type" /> объявлен как запечатанный.</span><span class="sxs-lookup"><span data-stu-id="95a33-3949">Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</span></span></summary>
        <value><span data-ttu-id="95a33-3950">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> объявлен как запечатанный; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3950"><see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3951">Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3951">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-3952">В следующем примере создается экземпляр класса `sealed`, проверяется свойство `IsSealed` и отображается результат.</span><span class="sxs-lookup"><span data-stu-id="95a33-3952">The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3953">Возвращает значение, которое указывает, является ли текущий тип критически важным для безопасности или защищенным критически важным для безопасности на данном уровне доверия и, следовательно, может ли он выполнять критические операции.</span><span class="sxs-lookup"><span data-stu-id="95a33-3953">Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="95a33-3954">Значение <see langword="true" />, если текущий тип является критически важным для безопасности или защищенным критически важным для безопасности на текущем уровне доверия; значение <see langword="false" />, если он является прозрачным.</span><span class="sxs-lookup"><span data-stu-id="95a33-3954"><see langword="true" /> if the current type is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3955">Свойства <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>и <xref:System.Type.IsSecurityTransparent%2A> сообщают уровень прозрачности типа на текущем уровне доверия, как определено средой CLR.</span><span class="sxs-lookup"><span data-stu-id="95a33-3955">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="95a33-3956">Сочетания этих свойств показаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="95a33-3956">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="95a33-3957">Уровень безопасности</span><span class="sxs-lookup"><span data-stu-id="95a33-3957">Security level</span></span>|<span data-ttu-id="95a33-3958">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="95a33-3958">IsSecurityCritical</span></span>|<span data-ttu-id="95a33-3959">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="95a33-3959">IsSecuritySafeCritical</span></span>|<span data-ttu-id="95a33-3960">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="95a33-3960">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="95a33-3961">Critical</span><span class="sxs-lookup"><span data-stu-id="95a33-3961">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="95a33-3962">Критически важный</span><span class="sxs-lookup"><span data-stu-id="95a33-3962">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="95a33-3963">Прозрачный</span><span class="sxs-lookup"><span data-stu-id="95a33-3963">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="95a33-3964">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3964">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="95a33-3965">Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-3965">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="95a33-3966">Если сборка загружается в домен приложения с частичным доверием (например, в изолированный домен приложения), среда выполнения игнорирует заметки безопасности сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-3966">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="95a33-3967">Сборка и все ее типы считаются прозрачными.</span><span class="sxs-lookup"><span data-stu-id="95a33-3967">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="95a33-3968">Среда выполнения расплачивает внимание на аннотации безопасности сборки с частичным доверием только в том случае, если эта сборка загружается в полностью доверенный домен приложения (например, в домен приложения по умолчанию для классического приложения).</span><span class="sxs-lookup"><span data-stu-id="95a33-3968">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="95a33-3969">В отличие от этого, надежная сборка (то есть сборка со строгим именем, установленная в глобальном кэше сборок) всегда загружается с полным доверием независимо от уровня доверия домена приложения, поэтому текущий уровень доверия всегда является полностью доверенным.</span><span class="sxs-lookup"><span data-stu-id="95a33-3969">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="95a33-3970">Определить текущие уровни доверия для сборок и доменов приложений можно с помощью свойств <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3970">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="95a33-3971">Дополнительные сведения о отражении и прозрачности см. в разделе [вопросы безопасности при отражении](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-3971">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="95a33-3972">Сведения о прозрачности см. в разделе [изменения безопасности](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-3972">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="95a33-3973">Соображения о безопасности для отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-3973">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="95a33-3974">Изменения системы безопасности в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="95a33-3974">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3975">Возвращает значение, которое указывает, является ли текущий тип защищенным критически важным для безопасности на текущем уровне доверия и, следовательно, может ли он выполнять критические операции и предоставлять доступ прозрачному коду.</span><span class="sxs-lookup"><span data-stu-id="95a33-3975">Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="95a33-3976">Значение <see langword="true" />, если текущий тип является защищенным критически важным для безопасности на текущем уровне доверия; значение <see langword="false" />, если он является критически важным для безопасности или прозрачным.</span><span class="sxs-lookup"><span data-stu-id="95a33-3976"><see langword="true" /> if the current type is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3977">Свойства <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>и <xref:System.Type.IsSecurityTransparent%2A> сообщают уровень прозрачности типа на текущем уровне доверия, как определено средой CLR.</span><span class="sxs-lookup"><span data-stu-id="95a33-3977">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="95a33-3978">Сочетания этих свойств показаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="95a33-3978">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="95a33-3979">Уровень безопасности</span><span class="sxs-lookup"><span data-stu-id="95a33-3979">Security level</span></span>|<span data-ttu-id="95a33-3980">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="95a33-3980">IsSecurityCritical</span></span>|<span data-ttu-id="95a33-3981">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="95a33-3981">IsSecuritySafeCritical</span></span>|<span data-ttu-id="95a33-3982">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="95a33-3982">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="95a33-3983">Critical</span><span class="sxs-lookup"><span data-stu-id="95a33-3983">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="95a33-3984">Критически важный</span><span class="sxs-lookup"><span data-stu-id="95a33-3984">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="95a33-3985">Прозрачный</span><span class="sxs-lookup"><span data-stu-id="95a33-3985">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="95a33-3986">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="95a33-3986">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="95a33-3987">Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-3987">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="95a33-3988">Если сборка загружается в домен приложения с частичным доверием (например, в изолированный домен приложения), среда выполнения игнорирует заметки безопасности сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-3988">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="95a33-3989">Сборка и все ее типы считаются прозрачными.</span><span class="sxs-lookup"><span data-stu-id="95a33-3989">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="95a33-3990">Среда выполнения расплачивает внимание на аннотации безопасности сборки с частичным доверием только в том случае, если эта сборка загружается в полностью доверенный домен приложения (например, в домен приложения по умолчанию для классического приложения).</span><span class="sxs-lookup"><span data-stu-id="95a33-3990">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="95a33-3991">В отличие от этого, надежная сборка (то есть сборка со строгим именем, установленная в глобальном кэше сборок) всегда загружается с полным доверием независимо от уровня доверия домена приложения, поэтому текущий уровень доверия всегда является полностью доверенным.</span><span class="sxs-lookup"><span data-stu-id="95a33-3991">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="95a33-3992">Определить текущие уровни доверия для сборок и доменов приложений можно с помощью свойств <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-3992">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="95a33-3993">Дополнительные сведения о отражении и прозрачности см. в разделе [вопросы безопасности при отражении](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-3993">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="95a33-3994">Сведения о прозрачности см. в разделе [изменения безопасности](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-3994">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="95a33-3995">Соображения о безопасности для отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-3995">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="95a33-3996">Изменения системы безопасности в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="95a33-3996">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-3997">Получает значение, которое указывает, является ли текущий тип прозрачным на текущем уровне доверия и, следовательно, не может выполнять критические операции.</span><span class="sxs-lookup"><span data-stu-id="95a33-3997">Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="95a33-3998">Значение <see langword="true" />, если текущий тип является прозрачным на текущем уровне доверия; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-3998"><see langword="true" /> if the type is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-3999">Если это свойство возвращает `true`, свойства <xref:System.Type.IsSecurityCritical%2A> и <xref:System.Type.IsSecuritySafeCritical%2A> возвращают `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-3999">If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="95a33-4000">Свойства <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>и <xref:System.Type.IsSecurityTransparent%2A> сообщают уровень прозрачности типа на текущем уровне доверия, как определено средой CLR.</span><span class="sxs-lookup"><span data-stu-id="95a33-4000">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="95a33-4001">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4001">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="95a33-4002">Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-4002">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="95a33-4003">Если сборка загружается в домен приложения с частичным доверием (например, в изолированный домен приложения), среда выполнения игнорирует заметки безопасности сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-4003">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="95a33-4004">Сборка и все ее типы считаются прозрачными.</span><span class="sxs-lookup"><span data-stu-id="95a33-4004">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="95a33-4005">Среда выполнения расплачивает внимание на аннотации безопасности сборки с частичным доверием только в том случае, если эта сборка загружается в полностью доверенный домен приложения (например, в домен приложения по умолчанию для классического приложения).</span><span class="sxs-lookup"><span data-stu-id="95a33-4005">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="95a33-4006">В отличие от этого, надежная сборка (то есть сборка со строгим именем, установленная в глобальном кэше сборок) всегда загружается с полным доверием независимо от уровня доверия домена приложения, поэтому текущий уровень доверия всегда является полностью доверенным.</span><span class="sxs-lookup"><span data-stu-id="95a33-4006">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="95a33-4007">Определить текущие уровни доверия для сборок и доменов приложений можно с помощью свойств <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4007">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="95a33-4008">Дополнительные сведения о отражении и прозрачности см. в разделе [вопросы безопасности при отражении](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-4008">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="95a33-4009">Сведения о прозрачности см. в разделе [изменения безопасности](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-4009">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="95a33-4010">Соображения о безопасности для отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-4010">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="95a33-4011">Изменения системы безопасности в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="95a33-4011">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberSignature Language="C#" Value="public bool IsSerializable { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSerializable As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSerializable { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4012">Возвращает значение, позволяющее определить, сериализуем ли объект <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4012">Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</span></span></summary>
        <value><span data-ttu-id="95a33-4013">Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является сериализуемым; в противным случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4013"><see langword="true" /> if the <see cref="T:System.Type" /> is serializable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="95a33-4014">Типы, определенные в .NET Standard, не помечаются <xref:System.SerializableAttribute>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4014">Types that are defined in the .NET Standard are not marked with <xref:System.SerializableAttribute>.</span></span> <span data-ttu-id="95a33-4015">Вместо этого каждая реализация .NET определяет, является ли тип сериализуемым.</span><span class="sxs-lookup"><span data-stu-id="95a33-4015">Instead, each .NET implementation determines whether a type is serializable.</span></span> <span data-ttu-id="95a33-4016">Во время выполнения можно использовать свойство <xref:System.Type.IsSerializable%2A>, чтобы определить, поддерживает ли реализация сериализацию экземпляра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4016">At run time, you can use the <xref:System.Type.IsSerializable%2A> property to determine whether that implementation supports serialization of an instance of the type.</span></span> <span data-ttu-id="95a33-4017">Дополнительные сведения и пример см. в разделе [как определить, является ли объект .NET Standard сериализуемым](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-4017">For more information and an example, see [How to determine if a .NET Standard object is serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span></span>
  
 <span data-ttu-id="95a33-4018">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-4018">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="95a33-4019">Например, если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4019">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="95a33-4020">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4020">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4021">В следующем примере создается экземпляр класса `MyTestClass`, задается атрибут [Serializable] и проверяется свойство `IsSerializable` для `true` или `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4021">The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.</span></span>  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4022">Возвращает значение, позволяющее определить, требует ли имя данного объекта специальной обработки.</span><span class="sxs-lookup"><span data-stu-id="95a33-4022">Gets a value indicating whether the type has a name that requires special handling.</span></span></summary>
        <value><span data-ttu-id="95a33-4023">Значение<see langword="true" /> , если имя типа требует специальной обработки; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4023"><see langword="true" /> if the type has a name that requires special handling; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4024">Имена, начинающиеся с или содержащие символы подчеркивания (_), методы доступа к свойствам и перегрузки операторов, являются примерами типов, которые могут требовать особой обработки некоторыми компиляторами.</span><span class="sxs-lookup"><span data-stu-id="95a33-4024">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</span></span>  
  
 <span data-ttu-id="95a33-4025">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-4025">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="95a33-4026">Например, если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4026">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="95a33-4027">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4027">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="95a33-4028">Тип для сравнения с текущим типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-4028">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="95a33-4029">Определяет, является ли текущий <see cref="T:System.Type" /> производным от указанного <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4029">Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-4030">Значение <see langword="true" />, если текущий объект <see langword="Type" /> является производным от <paramref name="c" />; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4030"><see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="95a33-4031">Этот метод также возвращает значение <see langword="false" />, если параметр <paramref name="c" /> и текущий объект <see langword="Type" /> равны.</span><span class="sxs-lookup"><span data-stu-id="95a33-4031">This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4032">Можно вызвать метод <xref:System.Type.IsSubclassOf%2A>, чтобы определить одно из следующих:</span><span class="sxs-lookup"><span data-stu-id="95a33-4032">You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:</span></span>  
  
-   <span data-ttu-id="95a33-4033">Является ли один класс производным от другого.</span><span class="sxs-lookup"><span data-stu-id="95a33-4033">Whether one class derives from another.</span></span>  
  
-   <span data-ttu-id="95a33-4034">Является ли тип производным от <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4034">Whether a type derives from <xref:System.ValueType>.</span></span> <span data-ttu-id="95a33-4035">Однако <xref:System.Type.IsValueType%2A> является более эффективным способом определения того, является ли тип типом значения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4035">However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.</span></span>  
  
-   <span data-ttu-id="95a33-4036">Является ли тип производным от <xref:System.Enum>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4036">Whether a type derives from <xref:System.Enum>.</span></span> <span data-ttu-id="95a33-4037">Однако метод <xref:System.Type.IsEnum%2A> является более эффективным способом определения того, является ли тип перечислением.</span><span class="sxs-lookup"><span data-stu-id="95a33-4037">However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.</span></span>  
  
-   <span data-ttu-id="95a33-4038">Является ли тип делегатом, то есть является ли он производным от <xref:System.Delegate> или <xref:System.MulticastDelegate>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4038">Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.</span></span>  
  
 <span data-ttu-id="95a33-4039">Метод <xref:System.Type.IsSubclassOf%2A> нельзя использовать для определения того, является ли интерфейс производным от другого интерфейса или реализует ли класс интерфейс.</span><span class="sxs-lookup"><span data-stu-id="95a33-4039">The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</span></span> <span data-ttu-id="95a33-4040">Для этой цели используйте метод <xref:System.Type.IsAssignableFrom%2A>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="95a33-4040">Use the <xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 <span data-ttu-id="95a33-4041">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, он является производным от своего ограничения класса или от <xref:System.Object?displayProperty=nameWithType>, если у него нет ограничения класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-4041">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=nameWithType> if it has no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-4042">За исключением случаев использования с интерфейсами, <xref:System.Type.IsSubclassOf%2A> является инверсией <xref:System.Type.IsAssignableFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4042">Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>.</span></span> <span data-ttu-id="95a33-4043">То есть, если `t1.IsSubclassOf(t2)` `true`, `t2.IsAssignableFrom(t1)` также `true`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4043">That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.</span></span>  
  
 <span data-ttu-id="95a33-4044">Этот метод может быть переопределен производным классом.</span><span class="sxs-lookup"><span data-stu-id="95a33-4044">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4045">В следующем примере создается класс с именем `Class1` и производный класс с именем `DerivedC1`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4045">The following example creates a class named `Class1` and a derived class named `DerivedC1`.</span></span> <span data-ttu-id="95a33-4046">Он вызывает метод <xref:System.Type.IsSubclassOf%2A>, чтобы продемонстрировать, что `DerivedC1` является подклассом `Class1`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4046">It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.</span></span>  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-4047">Свойство <paramref name="c" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4047"><paramref name="c" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4048">Возвращает значение, позволяющее определить, выбран ли для объекта <see langword="UnicodeClass" /> атрибут формата строки <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4048">Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="95a33-4049">Значение <see langword="true" />, если для данного объекта <see langword="UnicodeClass" /> выбран атрибут формата строки <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4049"><see langword="true" /> if the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4050"><xref:System.Reflection.TypeAttributes.StringFormatMask> используется для выбора атрибутов формата строки.</span><span class="sxs-lookup"><span data-stu-id="95a33-4050">The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes.</span></span> <span data-ttu-id="95a33-4051">Атрибуты формата строки улучшают взаимодействие, определяя, как должны интерпретироваться строки.</span><span class="sxs-lookup"><span data-stu-id="95a33-4051">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="95a33-4052">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-4052">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="95a33-4053">Например, если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4053">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="95a33-4054">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4054">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4055">Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> типом значения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4055">Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</span></span></summary>
        <value><span data-ttu-id="95a33-4056">Значение <see langword="true" />, если тип <see cref="T:System.Type" /> является типом значения; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4056"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4057">Типы значений — это типы, представленные последовательностями битов; типы значений не являются классами или интерфейсами.</span><span class="sxs-lookup"><span data-stu-id="95a33-4057">Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</span></span> <span data-ttu-id="95a33-4058">Типы значений называются структурами в некоторых языках программирования.</span><span class="sxs-lookup"><span data-stu-id="95a33-4058">Value types are referred to as "structs" in some programming languages.</span></span> <span data-ttu-id="95a33-4059">Перечисления — это особый случай типов значений.</span><span class="sxs-lookup"><span data-stu-id="95a33-4059">Enums are a special case of value types.</span></span>  
  
 <span data-ttu-id="95a33-4060">Это свойство возвращает `false` для класса <xref:System.ValueType>, так как <xref:System.ValueType> не является типом значения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4060">This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself.</span></span> <span data-ttu-id="95a33-4061">Это базовый класс для всех типов значений, поэтому ему можно назначить любой тип значения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4061">It is the base class for all value types, and therefore any value type can be assigned to it.</span></span> <span data-ttu-id="95a33-4062">Это невозможно, если <xref:System.ValueType> является типом значения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4062">This would not be possible if <xref:System.ValueType> itself was a value type.</span></span> <span data-ttu-id="95a33-4063">Типы значений упаковываются, если они назначены полю типа <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4063">Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.</span></span>  
  
 <span data-ttu-id="95a33-4064">Это свойство возвращает `true` для перечислений, но не для самого типа <xref:System.Enum>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4064">This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself.</span></span> <span data-ttu-id="95a33-4065">Пример, демонстрирующий такое поведение, см. в разделе <xref:System.Type.IsEnum%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4065">For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.</span></span>  
  
 <span data-ttu-id="95a33-4066">Это свойство доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4066">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4067">В следующем примере создается переменная типа `MyEnum`, проверяется свойство `IsValueType` и отображается результат.</span><span class="sxs-lookup"><span data-stu-id="95a33-4067">The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-4068">Реализует свойство <see cref="P:System.Type.IsValueType" /> и определяет, является ли объект <see cref="T:System.Type" /> типом значения (иными словами, не является классом или интерфейсом).</span><span class="sxs-lookup"><span data-stu-id="95a33-4068">Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</span></span></summary>
        <returns><span data-ttu-id="95a33-4069">Значение <see langword="true" />, если тип <see cref="T:System.Type" /> является типом значения; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4069"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4070">Этот метод предоставляется для реализации альтернативных типов систем.</span><span class="sxs-lookup"><span data-stu-id="95a33-4070">This method is provided to enable the implementation of alternate type systems.</span></span> <span data-ttu-id="95a33-4071">Он обычно не используется в коде приложения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4071">It is not generally used in application code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4072">Возвращает значение, позволяющее определить, можно ли получить доступ к объекту <see cref="T:System.Type" /> из кода за пределами сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-4072">Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</span></span></summary>
        <value><span data-ttu-id="95a33-4073">Значение <see langword="true" />, если текущий объект <see cref="T:System.Type" /> является открытым типом или открытым вложенным типом, все включающие типы которого также являются открытыми; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4073"><see langword="true" /> if the current <see cref="T:System.Type" /> is a public type or a public nested type such that all the enclosing types are public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4074">Это свойство используется для определения того, является ли тип частью открытого интерфейса сборки компонента.</span><span class="sxs-lookup"><span data-stu-id="95a33-4074">Use this property to determine whether a type is part of the public interface of a component assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4075">В следующем примере кода проверяется два класса, только один из которых является видимым за пределами сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-4075">The following code example tests two classes, only one of which is visible outside the assembly.</span></span>  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95a33-4076">Возвращает объект <see cref="T:System.Type" />, который представляет массив текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4076">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public abstract Type MakeArrayType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeArrayType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeArrayType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-4077">Возвращает объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</span><span class="sxs-lookup"><span data-stu-id="95a33-4077">Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></summary>
        <returns><span data-ttu-id="95a33-4078">Объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</span><span class="sxs-lookup"><span data-stu-id="95a33-4078">A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4079">Метод <xref:System.Type.MakeArrayType%2A> предоставляет способ создания типов массивов, типы элементов которых вычисляются во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4079">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
 <span data-ttu-id="95a33-4080">**Примечание** . Среда CLR различает векторы (т. е. одномерные массивы, которые всегда отсчитываются от нуля) и многомерные массивы.</span><span class="sxs-lookup"><span data-stu-id="95a33-4080">**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="95a33-4081">Вектор, который всегда имеет только одно измерение, не совпадает с многомерным массивом, в котором есть только одно измерение.</span><span class="sxs-lookup"><span data-stu-id="95a33-4081">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="95a33-4082">Эту перегрузку метода можно использовать только для создания векторных типов, и это единственный способ создания векторного типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4082">This method overload can only be used to create vector types, and it is the only way to create a vector type.</span></span> <span data-ttu-id="95a33-4083">Используйте перегрузку метода <xref:System.Type.MakeArrayType%28System.Int32%29> для создания многомерных типов массивов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4083">Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4084">В следующем примере кода создается массив, `ref` (`ByRef` в Visual Basic) и типы указателей для класса `Test`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4084">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-4085">Вызванный метод не поддерживается в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-4085">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="95a33-4086">Реализацию должны обеспечивать производные классы.</span><span class="sxs-lookup"><span data-stu-id="95a33-4086">Derived classes must provide an implementation.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="95a33-4087">Текущий тип — <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4087">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="95a33-4088">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4088">-or-</span></span> 
<span data-ttu-id="95a33-4089">Текущий тип — <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4089">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="95a33-4090">То есть <see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4090">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public abstract Type MakeArrayType (int rank);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeArrayType (rank As Integer) As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeArrayType(int rank);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank"><span data-ttu-id="95a33-4091">Размерность массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-4091">The number of dimensions for the array.</span></span> <span data-ttu-id="95a33-4092">Это число должно быть меньше либо равно 32.</span><span class="sxs-lookup"><span data-stu-id="95a33-4092">This number must be less than or equal to 32.</span></span></param>
        <summary><span data-ttu-id="95a33-4093">Возвращает объект <see cref="T:System.Type" />, представляющий массив текущего типа указанной размерности.</span><span class="sxs-lookup"><span data-stu-id="95a33-4093">Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</span></span></summary>
        <returns><span data-ttu-id="95a33-4094">Объект, представляющий массив текущего типа указанной размерности.</span><span class="sxs-lookup"><span data-stu-id="95a33-4094">An object representing an array of the current type, with the specified number of dimensions.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4095">Метод <xref:System.Type.MakeArrayType%2A> предоставляет способ создания типов массивов, типы элементов которых вычисляются во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4095">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-4096">Среда CLR различает векторы (т. е. одномерные массивы, которые всегда отсчитываются от нуля) и многомерные массивы.</span><span class="sxs-lookup"><span data-stu-id="95a33-4096">The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="95a33-4097">Вектор, который всегда имеет только одно измерение, не совпадает с многомерным массивом, в котором есть только одно измерение.</span><span class="sxs-lookup"><span data-stu-id="95a33-4097">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="95a33-4098">Эту перегрузку метода нельзя использовать для создания типа вектора; Если `rank` равен 1, то перегрузка метода возвращает тип многомерного массива, который имеет одно измерение.</span><span class="sxs-lookup"><span data-stu-id="95a33-4098">You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension.</span></span> <span data-ttu-id="95a33-4099">Используйте перегрузку метода <xref:System.Type.MakeArrayType> для создания векторных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4099">Use the <xref:System.Type.MakeArrayType> method overload to create vector types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4100">В следующем примере кода создается массив, `ref` (`ByRef` в Visual Basic) и типы указателей для класса `Test`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4100">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="95a33-4101"><paramref name="rank" /> недопустим.</span><span class="sxs-lookup"><span data-stu-id="95a33-4101"><paramref name="rank" /> is invalid.</span></span> <span data-ttu-id="95a33-4102">Например, 0 или отрицательное число.</span><span class="sxs-lookup"><span data-stu-id="95a33-4102">For example, 0 or negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-4103">Вызванный метод не поддерживается в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-4103">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="95a33-4104">Текущий тип — <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4104">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="95a33-4105">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4105">-or-</span></span> 
<span data-ttu-id="95a33-4106">Текущий тип — <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4106">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="95a33-4107">То есть <see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4107">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span>  
  
<span data-ttu-id="95a33-4108">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4108">-or-</span></span> 
 <span data-ttu-id="95a33-4109">Значение <paramref name="rank" /> больше 32.</span><span class="sxs-lookup"><span data-stu-id="95a33-4109"><paramref name="rank" /> is greater than 32.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public abstract Type MakeByRefType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeByRefType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeByRefType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-4110">Возвращает объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра <see langword="ref" /> (параметра <see langword="ByRef" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-4110">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></summary>
        <returns><span data-ttu-id="95a33-4111">Объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра <see langword="ref" /> (параметра <see langword="ByRef" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-4111">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4112">Метод <xref:System.Type.MakeByRefType%2A> предоставляет способ создания `ref` типов (`ByRef` в Visual Basic) для списков параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-4112">The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
 <span data-ttu-id="95a33-4113">При использовании синтаксиса языка MSIL, если текущий объект <xref:System.Type> представляет <xref:System.Int32>, этот метод возвращает объект <xref:System.Type>, представляющий `Int32&`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4113">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4114">В следующем примере кода создается массив, `ref` (`ByRef` в Visual Basic) и типы указателей для класса `Test`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4114">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-4115">Вызванный метод не поддерживается в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-4115">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="95a33-4116">Текущий тип — <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4116">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="95a33-4117">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4117">-or-</span></span> 
<span data-ttu-id="95a33-4118">Текущий тип — <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4118">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="95a33-4119">То есть <see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4119">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition"><span data-ttu-id="95a33-4120">Определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4120">The generic type definition.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="95a33-4121">Массив аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4121">An array of type arguments.</span></span></param>
        <summary><span data-ttu-id="95a33-4122">Создает универсальный тип сигнатуры, позволяющий сторонним реализациям отражения полностью поддерживать использование типов сигнатур в запросах типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4122">Creates a generic signature type, which allows third party reimplementations of Reflection to fully support the use of signature types in querying type members.</span></span></summary>
        <returns><span data-ttu-id="95a33-4123">Универсальный тип сигнатуры.</span><span class="sxs-lookup"><span data-stu-id="95a33-4123">A generic signature type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public abstract Type MakeGenericType (params Type[] typeArguments);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeGenericType (ParamArray typeArguments As Type()) As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="95a33-4124">Массив типов, который должен быть замещен параметрами типа текущего универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4124">An array of types to be substituted for the type parameters of the current generic type.</span></span></param>
        <summary><span data-ttu-id="95a33-4125">Замещает элементы массива типов для параметров определения текущего универсального типа и возвращает объект <see cref="T:System.Type" />, представляющий сконструированный результирующий тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-4125">Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</span></span></summary>
        <returns><span data-ttu-id="95a33-4126"><see cref="T:System.Type" /> представляет сконструированный тип, сформированный путем замещения элементов объекта <paramref name="typeArguments" /> параметрами текущего универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4126">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4127">Метод <xref:System.Type.MakeGenericType%2A> позволяет написать код, который назначает определенные типы параметрам типа определения универсального типа, создавая таким образом <xref:System.Type> объект, представляющий конкретный сконструированный тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-4127">The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type.</span></span> <span data-ttu-id="95a33-4128">Этот объект <xref:System.Type> можно использовать для создания экземпляров сконструированного типа во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4128">You can use this <xref:System.Type> object to create run-time instances of the constructed type.</span></span>  
  
 <span data-ttu-id="95a33-4129">Типы, созданные с помощью <xref:System.Type.MakeGenericType%2A>, могут быть открытыми, то есть некоторые из их аргументов типа могут быть параметрами типа включающих универсальных методов или типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4129">Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</span></span> <span data-ttu-id="95a33-4130">Такие открытые сконструированные типы можно использовать при выпуске динамических сборок.</span><span class="sxs-lookup"><span data-stu-id="95a33-4130">You might use such open constructed types when you emit dynamic assemblies.</span></span> <span data-ttu-id="95a33-4131">Например, рассмотрим классы `Base` и `Derived` в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="95a33-4131">For example, consider the classes `Base` and `Derived` in the following code.</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="95a33-4132">Чтобы создать `Derived` в динамической сборке, необходимо создать ее базовый тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-4132">To generate `Derived` in a dynamic assembly, it is necessary to construct its base type.</span></span> <span data-ttu-id="95a33-4133">Для этого вызовите метод <xref:System.Type.MakeGenericType%2A> для объекта <xref:System.Type>, представляющего класс `Base`, используя аргументы универсального типа <xref:System.Int32> и параметр типа `V` из `Derived`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4133">To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`.</span></span> <span data-ttu-id="95a33-4134">Поскольку типы и параметры универсального типа представлены в виде объектов <xref:System.Type>, массив, содержащий оба типа, может быть передан в метод <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4134">Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-4135">Сконструированный тип, например `Base<int, V>`, полезен при выдаче кода, но нельзя вызвать метод <xref:System.Type.MakeGenericType%2A> для этого типа, так как он не является определением универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4135">A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition.</span></span> <span data-ttu-id="95a33-4136">Чтобы создать закрытый сконструированный тип, который можно создать, сначала вызовите метод <xref:System.Type.GetGenericTypeDefinition%2A>, чтобы получить <xref:System.Type> объект, представляющий определение универсального типа, а затем вызовите <xref:System.Type.MakeGenericType%2A> с требуемыми аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4136">To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.</span></span>  
  
 <span data-ttu-id="95a33-4137">Объект <xref:System.Type>, возвращаемый <xref:System.Type.MakeGenericType%2A>, совпадает с <xref:System.Type>, полученным путем вызова метода <xref:System.Object.GetType%2A> результирующего сконструированного типа, или метода <xref:System.Object.GetType%2A> любого сконструированного типа, созданного из того же определения универсального типа, использующего тот же самый аргументы типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4137">The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A> method of any constructed type that was created from the same generic type definition using the same type arguments.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95a33-4138">Массив универсальных типов не является универсальным типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-4138">An array of generic types is not itself a generic type.</span></span> <span data-ttu-id="95a33-4139">Невозможно вызвать <xref:System.Type.MakeGenericType%2A> для типа массива, например `C<T>[]` (`Dim ac() As C(Of T)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-4139">You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span></span> <span data-ttu-id="95a33-4140">Чтобы создать закрытый универсальный тип из `C<T>[]`, вызовите <xref:System.Type.GetElementType%2A>, чтобы получить определение универсального типа `C<T>`; Вызовите <xref:System.Type.MakeGenericType%2A> для определения универсального типа, чтобы создать сконструированный тип. и наконец, вызовите метод <xref:System.Type.MakeArrayType%2A> для сконструированного типа, чтобы создать тип массива.</span><span class="sxs-lookup"><span data-stu-id="95a33-4140">To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type.</span></span> <span data-ttu-id="95a33-4141">То же самое касается типов указателей и типов `ref` (`ByRef` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="95a33-4141">The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).</span></span>  
  
 <span data-ttu-id="95a33-4142">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4142">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
## <a name="nested-types"></a><span data-ttu-id="95a33-4143">Вложенные типы</span><span class="sxs-lookup"><span data-stu-id="95a33-4143">Nested Types</span></span>  
 <span data-ttu-id="95a33-4144">Если универсальный тип определяется с помощью C#, C++или Visual Basic, его вложенные типы являются универсальными.</span><span class="sxs-lookup"><span data-stu-id="95a33-4144">If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</span></span> <span data-ttu-id="95a33-4145">Это справедливо, даже если вложенные типы не имеют собственных параметров типа, так как все три языка включают параметры типа включающих типов в списки параметров типа для вложенных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4145">This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</span></span> <span data-ttu-id="95a33-4146">Рассмотрим следующие классы:</span><span class="sxs-lookup"><span data-stu-id="95a33-4146">Consider the following classes:</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 <span data-ttu-id="95a33-4147">Список параметров типа вложенного класса `Inner` имеет два параметра типа, `T` и `U`, первый из которых является параметром типа включающего его класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-4147">The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class.</span></span> <span data-ttu-id="95a33-4148">Аналогично, список параметров типа вложенного класса `Innermost1` имеет три параметра типа, `T`, `U`и `V`, с `T` и `U` поступающими из включающих классов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4148">Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes.</span></span> <span data-ttu-id="95a33-4149">Вложенный класс `Innermost2` имеет два параметра типа, `T` и `U`, которые поступают из его включающих классов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4149">The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.</span></span>  
  
 <span data-ttu-id="95a33-4150">Если список параметров включающего типа имеет более одного параметра типа, все параметры типа в порядке включаются в список параметров типа вложенного типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4150">If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</span></span>  
  
 <span data-ttu-id="95a33-4151">Чтобы создать универсальный тип из определения универсального типа для вложенного типа, вызовите метод <xref:System.Type.MakeGenericType%2A> с массивом, сформированным путем сцепления массивов аргументов типа всех включающих типов, начиная с самого внешнего универсального типа и заканчивая типом Массив аргументов самого вложенного типа, если он имеет собственные параметры типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4151">To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</span></span> <span data-ttu-id="95a33-4152">Чтобы создать экземпляр `Innermost1`, вызовите метод <xref:System.Type.MakeGenericType%2A> с массивом, содержащим три типа, которые будут назначены T, U и V. Чтобы создать экземпляр `Innermost2`, вызовите метод <xref:System.Type.MakeGenericType%2A> с массивом, содержащим два типа, которые будут назначены T и U.</span><span class="sxs-lookup"><span data-stu-id="95a33-4152">To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.</span></span>  
  
 <span data-ttu-id="95a33-4153">Языки распространяют параметры типа для включающих типов таким образом, чтобы можно было использовать параметры типа включающего типа для определения полей вложенных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4153">The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</span></span> <span data-ttu-id="95a33-4154">В противном случае параметры типа не будут находиться в области внутри тела вложенных типов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4154">Otherwise, the type parameters would not be in scope within the bodies of the nested types.</span></span> <span data-ttu-id="95a33-4155">Можно определить вложенные типы без распространения параметров типа для включающих типов, выполнив код в динамических сборках или с помощью [Ilasm. exe (АССЕМБЛЕР IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-4155">It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span> <span data-ttu-id="95a33-4156">Рассмотрим следующий код для ассемблера MSIL:</span><span class="sxs-lookup"><span data-stu-id="95a33-4156">Consider the following code for the MSIL assembler:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="95a33-4157">В этом примере невозможно определить поле типа `T` или `U` в классе `Innermost`, поскольку эти параметры типа находятся вне области действия.</span><span class="sxs-lookup"><span data-stu-id="95a33-4157">In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope.</span></span> <span data-ttu-id="95a33-4158">Следующий код ассемблера определяет вложенные классы, которые ведут себя так, как если C++бы они были определены C#в, Visual Basic и:</span><span class="sxs-lookup"><span data-stu-id="95a33-4158">The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="95a33-4159">Для изучения вложенных классов, определенных в высокоуровневых языках, можно использовать программу [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , а также эту схему именования.</span><span class="sxs-lookup"><span data-stu-id="95a33-4159">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4160">В следующем примере метод <xref:System.Type.MakeGenericType%2A> используется для создания сконструированного типа из определения универсального типа для <xref:System.Collections.Generic.Dictionary%602> типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4160">The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type.</span></span> <span data-ttu-id="95a33-4161">Сконструированный тип представляет <xref:System.Collections.Generic.Dictionary%602> `Test` объектов со строковыми ключами.</span><span class="sxs-lookup"><span data-stu-id="95a33-4161">The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="95a33-4162">Текущий тип не представляет определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4162">The current type does not represent a generic type definition.</span></span> <span data-ttu-id="95a33-4163">То есть <see cref="P:System.Type.IsGenericTypeDefinition" /> возвращает <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4163">That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-4164">Свойство <paramref name="typeArguments" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4164"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="95a33-4165">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4165">-or-</span></span> 
<span data-ttu-id="95a33-4166">Любой элемент <paramref name="typeArguments" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4166">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-4167">Количество элементов в <paramref name="typeArguments" /> не совпадает с количеством параметров типа в текущем определении универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4167">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.</span></span>  
  
<span data-ttu-id="95a33-4168">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4168">-or-</span></span> 
<span data-ttu-id="95a33-4169">Элементы <paramref name="typeArguments" /> не соответствуют ограничениям, указанным для соответствующего параметра типа текущего определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4169">Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</span></span>  
  
<span data-ttu-id="95a33-4170">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4170">-or-</span></span> 
 <span data-ttu-id="95a33-4171"><paramref name="typeArguments" /> содержит элемент, который является типом указателя (<see cref="P:System.Type.IsPointer" /> возвращает <see langword="true" />), типом доступа по ссылке (<see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />) или <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4171"><paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-4172">Вызванный метод не поддерживается в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-4172">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="95a33-4173">Реализацию должны обеспечивать производные классы.</span><span class="sxs-lookup"><span data-stu-id="95a33-4173">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="95a33-4174">Отражение и универсальные типы</span><span class="sxs-lookup"><span data-stu-id="95a33-4174">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="95a33-4175">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-4175">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public abstract Type MakePointerType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakePointerType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakePointerType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-4176">Возвращает объект <see cref="T:System.Type" />, который представляет указатель на текущий тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-4176">Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></summary>
        <returns><span data-ttu-id="95a33-4177">Объект <see cref="T:System.Type" />, который представляет указатель на текущий тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-4177">A <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4178">Метод <xref:System.Type.MakePointerType%2A> предоставляет способ создания типов указателей для списков параметров.</span><span class="sxs-lookup"><span data-stu-id="95a33-4178">The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
 <span data-ttu-id="95a33-4179">При использовании синтаксиса языка MSIL, если текущий объект <xref:System.Type> представляет <xref:System.Int32>, этот метод возвращает объект <xref:System.Type>, представляющий `Int32*`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4179">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4180">В следующем примере кода создается массив, `ref` (`ByRef` в Visual Basic) и типы указателей для класса `Test`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4180">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-4181">Вызванный метод не поддерживается в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-4181">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="95a33-4182">Текущий тип — <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4182">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="95a33-4183">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4183">-or-</span></span> 
<span data-ttu-id="95a33-4184">Текущий тип — <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4184">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="95a33-4185">То есть <see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4185">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4186">Возвращает значение <see cref="T:System.Reflection.MemberTypes" />, позволяющее определить, каким типом является этот член: обычным или вложенным.</span><span class="sxs-lookup"><span data-stu-id="95a33-4186">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></summary>
        <value><span data-ttu-id="95a33-4187">Значение <see cref="T:System.Reflection.MemberTypes" />, позволяющее определить, каким типом является этот член: обычным или вложенным.</span><span class="sxs-lookup"><span data-stu-id="95a33-4187">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4188">Это свойство переопределяет <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4188">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95a33-4189">Таким образом, при просмотре набора <xref:System.Reflection.MemberInfo> объектов, например массива, возвращаемого <xref:System.Type.GetMembers%2A> — свойство <xref:System.Reflection.MemberInfo.MemberType%2A> возвращает <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType>, если данный элемент является вложенным типом.</span><span class="sxs-lookup"><span data-stu-id="95a33-4189">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> when a given member is a nested type.</span></span>  
  
 <span data-ttu-id="95a33-4190">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-4190">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="95a33-4191">Например, если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4191">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="95a33-4192">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4192">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4193">В следующем примере кода показано поле `MemberType` в качестве параметра для метода `GetMember`:</span><span class="sxs-lookup"><span data-stu-id="95a33-4193">The following code example shows the `MemberType` field as a parameter to the `GetMember` method:</span></span>  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4194">Представляет отсутствующее значение в данных объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4194">Represents a missing value in the <see cref="T:System.Type" /> information.</span></span> <span data-ttu-id="95a33-4195">Это поле доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4195">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4196">Используйте поле `Missing` для вызова через отражение, чтобы получить значение параметра по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-4196">Use the `Missing` field for invocation through reflection to obtain the default value of a parameter.</span></span> <span data-ttu-id="95a33-4197">Если поле `Missing` передается в качестве значения параметра, а значение по умолчанию для этого параметра отсутствует, создается <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4197">If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4198">В следующем примере кода показано использование поля `Missing` для вызова метода со своими аргументами по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="95a33-4198">The following code example shows the use of the `Missing` field to invoke a method with its default arguments.</span></span>  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 <span data-ttu-id="95a33-4199">Этот код выводит следующие результаты:</span><span class="sxs-lookup"><span data-stu-id="95a33-4199">This code produces the following output:</span></span>  
  
 <span data-ttu-id="95a33-4200">a = 10 b = 55,3 c = 12</span><span class="sxs-lookup"><span data-stu-id="95a33-4200">a = 10 b = 55.3 c = 12</span></span>  
  
 <span data-ttu-id="95a33-4201">a = 10 b = 1,3 c = 1</span><span class="sxs-lookup"><span data-stu-id="95a33-4201">a = 10 b = 1.3 c = 1</span></span>  
  
 <span data-ttu-id="95a33-4202">a = 10 b = 1,2 c = 1</span><span class="sxs-lookup"><span data-stu-id="95a33-4202">a = 10 b = 1.2 c = 1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4203">Возвращает модуль (DLL), в котором определен текущий объект <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4203">Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</span></span></summary>
        <value><span data-ttu-id="95a33-4204">Модуль, в котором определен текущий объект <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4204">The module in which the current <see cref="T:System.Type" /> is defined.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4205">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает модуль, в котором определено определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4205">If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</span></span> <span data-ttu-id="95a33-4206">Например, при создании экземпляра `MyGenericStack<int>`свойство <xref:System.Type.Module%2A> для сконструированного типа возвращает модуль, в котором определен `MyGenericStack<T>`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4206">For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.</span></span>  
  
 <span data-ttu-id="95a33-4207">Аналогично, если текущий <xref:System.Type> представляет универсальный параметр `T`, это свойство возвращает сборку, содержащую универсальный тип, определяющий `T`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4207">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4208">В следующем примере демонстрируется использование свойств <xref:System.Type.Namespace%2A> и `Module` и метода <xref:System.Type.ToString%2A> <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4208">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4209">При переопределении в производном классе получает имя текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4209">When overridden in a derived class, gets the name of the current type.</span></span></summary>
        <value><span data-ttu-id="95a33-4210">Имя текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4210">The name of the current type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4211">Возвращает пространство имен объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4211">Gets the namespace of the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="95a33-4212">Пространство имен <see cref="T:System.Type" /> или значение <see langword="null" />, если текущий экземпляр не имеет пространства имен или представляет универсальный параметр.</span><span class="sxs-lookup"><span data-stu-id="95a33-4212">The namespace of the <see cref="T:System.Type" />; <see langword="null" /> if the current instance has no namespace or represents a generic parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4213">Пространство имен — это логическое удобство именования времени разработки, используемое главным образом для определения области в приложении и упорядочивания классов и других типов в одной иерархической структуре.</span><span class="sxs-lookup"><span data-stu-id="95a33-4213">A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</span></span> <span data-ttu-id="95a33-4214">С точки зрения среды выполнения пространства имен не существует.</span><span class="sxs-lookup"><span data-stu-id="95a33-4214">From the viewpoint of the runtime, there are no namespaces.</span></span>  
  
 <span data-ttu-id="95a33-4215">Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает пространство имен, содержащее определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4215">If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</span></span> <span data-ttu-id="95a33-4216">Аналогично, если текущий <xref:System.Type> представляет универсальный параметр `T`, это свойство возвращает пространство имен, содержащее определение универсального типа, которое определяет `T`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4216">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.</span></span>  
  
 <span data-ttu-id="95a33-4217">Если текущий объект <xref:System.Type> представляет универсальный параметр, это свойство возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4217">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4218">В следующем примере демонстрируется использование свойств `Namespace` и <xref:System.Type.Module%2A> и метода <xref:System.Type.ToString%2A> <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4218">This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="95a33-4219">Указание полных имен типов</span><span class="sxs-lookup"><span data-stu-id="95a33-4219">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="95a33-4220">Первый из сравниваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4220">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="95a33-4221">Второй из сравниваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4221">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="95a33-4222">Определение равенства двух объектов <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4222">Indicates whether two <see cref="T:System.Type" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="95a33-4223"><see langword="true" />, если значения параметров <paramref name="left" /> и <paramref name="right" /> равны; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4223"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="95a33-4224">Первый из сравниваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4224">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="95a33-4225">Второй из сравниваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4225">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="95a33-4226">Определяет неравенство двух объектов <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4226">Indicates whether two <see cref="T:System.Type" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="95a33-4227"><see langword="true" />, если значения <paramref name="left" /> и <paramref name="right" /> не равны; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4227"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4228">Возвращает объект класса, который использовался для получения этого члена.</span><span class="sxs-lookup"><span data-stu-id="95a33-4228">Gets the class object that was used to obtain this member.</span></span></summary>
        <value><span data-ttu-id="95a33-4229">Объект <see langword="Type" />, с помощью которого был получен данный объект <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4229">The <see langword="Type" /> object through which this <see cref="T:System.Type" /> object was obtained.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4230">Для <xref:System.Type> объектов значение этого свойства всегда совпадает со значением свойства <xref:System.Type.DeclaringType%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4230">For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4231">В этом примере отображается отраженный тип вложенного класса.</span><span class="sxs-lookup"><span data-stu-id="95a33-4231">This example displays the reflected type of a nested class.</span></span>  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="95a33-4232">Имя искомого типа <see cref="T:System.Type" /> с указанием сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-4232">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="throwIfNotFound"><span data-ttu-id="95a33-4233">Значение <see langword="true" />, чтобы в случае невозможности найти тип создавалось исключение <see cref="T:System.TypeLoadException" />; значение <see langword="false" />, чтобы при невозможности найти тип возвращалось значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4233"><see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found.</span></span> <span data-ttu-id="95a33-4234">Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них.</span><span class="sxs-lookup"><span data-stu-id="95a33-4234">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="95a33-4235">См. раздел "Исключения".</span><span class="sxs-lookup"><span data-stu-id="95a33-4235">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="95a33-4236">Значение <see langword="true" />, чтобы не учитывать регистр при поиске <paramref name="typeName" />, значение <see langword="false" />, чтобы учитывать регистр при поиске <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4236"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />; <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="95a33-4237">Возвращает объект <see cref="T:System.Type" /> с заданным именем, позволяющий определить, будет ли учитываться регистр при поиске, и будет ли создаваться исключение в случае невозможности найти тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-4237">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</span></span> <span data-ttu-id="95a33-4238">Тип загружается не для выполнения, а только для отражения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4238">The type is loaded for reflection only, not for execution.</span></span></summary>
        <returns><span data-ttu-id="95a33-4239">Тип с указанным именем, если он существует; в противном случае — значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4239">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span> <span data-ttu-id="95a33-4240">Если тип не найден, параметр <paramref name="throwIfNotFound" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4240">If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="95a33-4241">В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwIfNotFound" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4241">In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />.</span></span> <span data-ttu-id="95a33-4242">См. раздел "Исключения".</span><span class="sxs-lookup"><span data-stu-id="95a33-4242">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4243">Если сборка, содержащая тип, еще не загружена в контекст, предназначенный только для отражения, использование метода <xref:System.Type.ReflectionOnlyGetType%2A> эквивалентно первой загрузке сборки только для отражения, с помощью метода <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> и последующей загрузки типа путем вызова <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="95a33-4243">If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="95a33-4244">Дополнительные сведения об именах с указанием сборки см. в описании свойства <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4244">For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="95a33-4245">Дополнительные сведения об указании имен типов см. в описании перегрузки метода <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4245">For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="95a33-4246">Если сборка уже загружена для выполнения, то в контекст, предназначенный только для отражения, загружается другая копия.</span><span class="sxs-lookup"><span data-stu-id="95a33-4246">If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="95a33-4247">Параметр `throwIfNotFound` указывает, что происходит, если тип не найден, а также подавляет некоторые другие условия исключения, как описано в разделе исключения.</span><span class="sxs-lookup"><span data-stu-id="95a33-4247">The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="95a33-4248">Некоторые исключения создаются независимо от значения `throwIfNotFound`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4248">Some exceptions are thrown regardless of the value of `throwIfNotFound`.</span></span> <span data-ttu-id="95a33-4249">Например, если сборка является недопустимой, создается <xref:System.BadImageFormatException>, даже если `throwIfNotFound` `false`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4249">For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.</span></span>  
  
 <span data-ttu-id="95a33-4250">Дополнительные сведения об использовании контекста, предназначенного только для отражения, см. в разделе [как загружать сборки в контекст, предназначенный только для отражения](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="95a33-4250">For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95a33-4251">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4251"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="95a33-4252">Инициализатор класса вызывается и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="95a33-4252">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="95a33-4253"><paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и тип не найден.</span><span class="sxs-lookup"><span data-stu-id="95a33-4253"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="95a33-4254">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4254">-or-</span></span> 
 <span data-ttu-id="95a33-4255"><paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции.</span><span class="sxs-lookup"><span data-stu-id="95a33-4255"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="95a33-4256">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4256">-or-</span></span> 
 <span data-ttu-id="95a33-4257"><paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.</span><span class="sxs-lookup"><span data-stu-id="95a33-4257"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="95a33-4258">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4258">-or-</span></span> 
 <span data-ttu-id="95a33-4259"><paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.</span><span class="sxs-lookup"><span data-stu-id="95a33-4259"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="95a33-4260">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4260">-or-</span></span> 
 <span data-ttu-id="95a33-4261"><paramref name="typeName" /> представляет массив объектов <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4261"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95a33-4262"><paramref name="typeName" /> не включает имя сборки.</span><span class="sxs-lookup"><span data-stu-id="95a33-4262"><paramref name="typeName" /> does not include the assembly name.</span></span>  
  
<span data-ttu-id="95a33-4263">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4263">-or-</span></span> 
 <span data-ttu-id="95a33-4264"><paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис (например, "MyType[,\*,]").</span><span class="sxs-lookup"><span data-stu-id="95a33-4264"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="95a33-4265">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4265">-or-</span></span> 
 <span data-ttu-id="95a33-4266"><paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4266"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="95a33-4267">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4267">-or-</span></span> 
 <span data-ttu-id="95a33-4268"><paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4268"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="95a33-4269">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4269">-or-</span></span> 
 <span data-ttu-id="95a33-4270"><paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4270"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="95a33-4271"><paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.</span><span class="sxs-lookup"><span data-stu-id="95a33-4271"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="95a33-4272">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</span><span class="sxs-lookup"><span data-stu-id="95a33-4272">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="95a33-4273">Сборка или одна из ее зависимостей является недопустимой.</span><span class="sxs-lookup"><span data-stu-id="95a33-4273">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="95a33-4274">- или -</span><span class="sxs-lookup"><span data-stu-id="95a33-4274">-or-</span></span>  
  
 <span data-ttu-id="95a33-4275">Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</span><span class="sxs-lookup"><span data-stu-id="95a33-4275">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="95a33-4276">Только в .NET Core: этот элемент не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="95a33-4276">.NET Core only: This member is not supported.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="95a33-4277">Указание полных имен типов</span><span class="sxs-lookup"><span data-stu-id="95a33-4277">Specifying Fully Qualified Type Names</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md"><span data-ttu-id="95a33-4278">Практическое руководство. Загрузка сборок в контекст, предназначенный только для отражения</span><span class="sxs-lookup"><span data-stu-id="95a33-4278">How to: Load Assemblies into the Reflection-Only Context</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4279">Возвращает атрибут <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />, описывающий структуру текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4279">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</span></span></summary>
        <value><span data-ttu-id="95a33-4280">Возвращает атрибут <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />, описывающий общие особенности структуры текущего типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4280">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the gross layout features of the current type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4281"><xref:System.Runtime.InteropServices.StructLayoutAttribute> не возвращается методом <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4281"><xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method.</span></span> <span data-ttu-id="95a33-4282">Вместо этого используйте это свойство, чтобы получить его.</span><span class="sxs-lookup"><span data-stu-id="95a33-4282">Instead, use this property to get it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4283">В следующем примере кода сначала определяется класс, структура и структура с особыми атрибутами макета (структуры вложены в класс).</span><span class="sxs-lookup"><span data-stu-id="95a33-4283">The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</span></span> <span data-ttu-id="95a33-4284">Затем в примере используется свойство <xref:System.Type.StructLayoutAttribute%2A> для получения <xref:System.Runtime.InteropServices.StructLayoutAttribute> для каждого типа и отображаются свойства атрибутов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4284">The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.</span></span>  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-4285">Вызванный метод не поддерживается в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="95a33-4285">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="95a33-4286">Зарезервировано для будущего использования.</span><span class="sxs-lookup"><span data-stu-id="95a33-4286">Reserved for future use.</span></span> <span data-ttu-id="95a33-4287">Должно быть равным IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="95a33-4287">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="95a33-4288">Переданный массив имен, которые необходимо сопоставить.</span><span class="sxs-lookup"><span data-stu-id="95a33-4288">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="95a33-4289">Количество сопоставляемых имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-4289">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="95a33-4290">Контекст языкового стандарта для интерпретации имен.</span><span class="sxs-lookup"><span data-stu-id="95a33-4290">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="95a33-4291">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</span><span class="sxs-lookup"><span data-stu-id="95a33-4291">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="95a33-4292">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</span><span class="sxs-lookup"><span data-stu-id="95a33-4292">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4293">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="95a33-4293">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="95a33-4294">Дополнительные сведения о `IDispatch::GetIDsOfNames` см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="95a33-4294">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="95a33-4295">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="95a33-4295">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="95a33-4296">Возвращаемые сведения о типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-4296">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="95a33-4297">Идентификатор языкового стандарта для сведений о типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-4297">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="95a33-4298">Указатель на объект с запрошенными сведениями о типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-4298">A pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="95a33-4299">Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</span><span class="sxs-lookup"><span data-stu-id="95a33-4299">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4300">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="95a33-4300">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="95a33-4301">Дополнительные сведения о `IDispatch::GetTypeInfo` см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="95a33-4301">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="95a33-4302">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="95a33-4302">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="95a33-4303">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</span><span class="sxs-lookup"><span data-stu-id="95a33-4303">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="95a33-4304">Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</span><span class="sxs-lookup"><span data-stu-id="95a33-4304">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4305">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="95a33-4305">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="95a33-4306">Дополнительные сведения о `IDispatch::GetTypeInfoCount` см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="95a33-4306">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="95a33-4307">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="95a33-4307">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="95a33-4308">Идентифицирует член.</span><span class="sxs-lookup"><span data-stu-id="95a33-4308">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="95a33-4309">Зарезервировано для будущего использования.</span><span class="sxs-lookup"><span data-stu-id="95a33-4309">Reserved for future use.</span></span> <span data-ttu-id="95a33-4310">Должно быть равным IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="95a33-4310">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="95a33-4311">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</span><span class="sxs-lookup"><span data-stu-id="95a33-4311">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="95a33-4312">Флаги, описывающие контекст вызова.</span><span class="sxs-lookup"><span data-stu-id="95a33-4312">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="95a33-4313">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</span><span class="sxs-lookup"><span data-stu-id="95a33-4313">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="95a33-4314">Указатель, по которому будет сохранен результат.</span><span class="sxs-lookup"><span data-stu-id="95a33-4314">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="95a33-4315">Указатель на структуру, содержащую сведения об исключении.</span><span class="sxs-lookup"><span data-stu-id="95a33-4315">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="95a33-4316">Индекс первого аргумента, вызвавшего ошибку.</span><span class="sxs-lookup"><span data-stu-id="95a33-4316">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="95a33-4317">Предоставляет доступ к открытым свойствам и методам объекта.</span><span class="sxs-lookup"><span data-stu-id="95a33-4317">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4318">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="95a33-4318">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="95a33-4319">Дополнительные сведения о `IDispatch::Invoke` см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="95a33-4319">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="95a33-4320">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="95a33-4320">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95a33-4321">Возвращает объект типа <see langword="String" />, представляющий имя текущего объекта <see langword="Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4321">Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</span></span></summary>
        <returns><span data-ttu-id="95a33-4322">Объект типа <see cref="T:System.String" />, представляющий имя текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4322">A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4323">Этот метод возвращает полное пространство имен среды CLR и имя для всех типов-примитивов.</span><span class="sxs-lookup"><span data-stu-id="95a33-4323">This method returns the fully qualified common language runtime namespace and name for all primitive types.</span></span> <span data-ttu-id="95a33-4324">Например, C# инструкция `(long)0.Type().ToString()` возвращает «System. Int64» вместо просто «Int64».</span><span class="sxs-lookup"><span data-stu-id="95a33-4324">For example, the C# instruction, `(long)0.Type().ToString()` returns "System.Int64" instead of merely "Int64".</span></span>  
  
 <span data-ttu-id="95a33-4325">Если текущий <xref:System.Type> представляет универсальный тип, тип и его аргументы типа задаются пространством имен и вложенным типом, но не сборкой.</span><span class="sxs-lookup"><span data-stu-id="95a33-4325">If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</span></span> <span data-ttu-id="95a33-4326">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод возвращает неполное имя параметра типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4326">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4327">В следующем примере демонстрируется использование свойств <xref:System.Type.Namespace%2A> и <xref:System.Type.Module%2A> и метода `ToString` <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4327">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 <span data-ttu-id="95a33-4328">В следующем примере сравниваются строки, возвращаемые методом <xref:System.Type.ToString%2A> и свойствами `Name`, <xref:System.Type.FullName%2A>и <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="95a33-4328">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberSignature Language="C#" Value="public abstract RuntimeTypeHandle TypeHandle { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TypeHandle As RuntimeTypeHandle" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4329">Возвращает дескриптор текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4329">Gets the handle for the current <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="95a33-4330">Дескриптор текущего объекта <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4330">The handle for the current <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4331">`TypeHandle` инкапсулирует указатель на внутреннюю структуру данных, представляющую тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-4331">`TypeHandle` encapsulates a pointer to an internal data structure that represents the type.</span></span> <span data-ttu-id="95a33-4332">Этот обработчик уникален во время существования процесса.</span><span class="sxs-lookup"><span data-stu-id="95a33-4332">This handle is unique during the process lifetime.</span></span> <span data-ttu-id="95a33-4333">Этот маркер допустим только в домене приложения, в котором он был получен.</span><span class="sxs-lookup"><span data-stu-id="95a33-4333">The handle is valid only in the application domain in which it was obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95a33-4334">В следующем примере возвращается маркер соответствующего типа и передается в метод, который получает тип из маркера и отображает его.</span><span class="sxs-lookup"><span data-stu-id="95a33-4334">The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</span></span>  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95a33-4335">Платформа .NET Compact Framework в настоящее время не поддерживает это свойство.</span><span class="sxs-lookup"><span data-stu-id="95a33-4335">The .NET Compact Framework does not currently support this property.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4336">Возвращает инициализатор типа.</span><span class="sxs-lookup"><span data-stu-id="95a33-4336">Gets the initializer for the type.</span></span></summary>
        <value><span data-ttu-id="95a33-4337">Объект, содержащий имя конструктора класса <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4337">An object that contains the name of the class constructor for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95a33-4338">Инициализаторы классов также доступны через метод <xref:System.Type.FindMembers%2A> или с помощью перегрузок методов <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>и <xref:System.Type.GetConstructors%2A>, которые принимают <xref:System.Reflection.BindingFlags> в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="95a33-4338">Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.</span></span>  
  
 <span data-ttu-id="95a33-4339">Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, это свойство возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="95a33-4339">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95a33-4340">Указывает на тип, предоставляемый средой CLR, представляющей этот тип.</span><span class="sxs-lookup"><span data-stu-id="95a33-4340">Indicates the type provided by the common language runtime that represents this type.</span></span></summary>
        <value><span data-ttu-id="95a33-4341">Базовый системный тип текущего типа <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="95a33-4341">The underlying system type for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>
