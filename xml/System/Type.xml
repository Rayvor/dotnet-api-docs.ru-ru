<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="436ffc4abbdaf99d1afde6b5f524d719511a0370" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66008785" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет объявления типов для классов, интерфейсов, массивов, значений, перечислений параметров, определений универсальных типов и открытых или закрытых сконструированных универсальных типов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` является корневым элементом <xref:System.Reflection> функциональные возможности и является основным способом получить доступ к метаданным. Использовать члены <xref:System.Type> для получения сведений о объявление типа, о членах типа (например, конструкторы, методы, поля, свойства и события класса), а также модуль и сборки, в которой развернут этот класс.  
  
 Разрешения не требуются для кода использовать отражение для получения сведений о типах и их члены, независимо от их уровней доступа. Разрешения не требуются для кода использовать отражение для доступа к открытым членам или другие члены, уровни доступа которых бы сделать их видимыми во время обычной компиляции. Тем не менее, чтобы код, чтобы использовать отражение для доступа к элементам, которые обычно были бы недоступны, например закрытые или внутренние методы или поля типа protected, ваш класс не наследуется, ваш код должен иметь <xref:System.Security.Permissions.ReflectionPermission>. См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type` — Это абстрактный базовый класс, который поддерживает несколько реализаций. Система будет всегда предоставлять производный класс `RuntimeType`. В отражении всех классов, начинающихся со слова среды выполнения создаются только один раз на объект в системе и поддерживают операции сравнения.  
  
> [!NOTE]
>  В сценариях многопоточности, не блокируют <xref:System.Type> объекты для синхронизации доступа к `static` данных. Другой код, вы можете не управляет, также могут привести к блокировке созданный тип класса. Это может привести к взаимоблокировке. Вместо этого следует синхронизировать доступ к статическим данным, заблокировав закрытый `static` объекта.  
  
> [!NOTE]
>  Производный класс может обращаться к защищенным членам базовых классов вызывающего кода. Кроме того разрешен доступ к членам сборки вызывающего кода. Как правило если доступ разрешен в коде с ранним связыванием вы разрешен и в коде с поздним связыванием.  
  
> [!NOTE]
>  Интерфейсы, расширяющие другие интерфейсы не наследуют методы, определенные в расширенные интерфейсы.  
  
 Содержание  
  
 [Какие типы представляют объект типа?](#WhatTypes)   
 [Получение объекта типа](#Retrieve)   
 [Сравнение типов объектов на равенство](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Какие типы представляют объект типа?  
 Этот класс является потокобезопасным; несколько потоков могут одновременно считывать из экземпляра этого типа. Экземпляр <xref:System.Type> класс может представлять любой из следующих типов:  
  
-   Классы  
  
-   Типы значений  
  
-   Массивы  
  
-   интерфейсов,  
  
-   Перечисления  
  
-   Делегаты  
  
-   Сконструированных универсальных типов и определений универсальных типов  
  
-   Введите аргументы и параметры определения универсального метода, определений универсальных типов и сконструированных универсальных типов  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Получение объекта типа  
 <xref:System.Type> Объект, связанный с определенным типом можно получить следующими способами:  
  
-   Экземпляр <xref:System.Object.GetType%2A?displayProperty=nameWithType> возвращает <xref:System.Type> , представляющий тип экземпляра. Так как все управляемые типы являются производными от <xref:System.Object>, <xref:System.Object.GetType%2A> метод может вызываться в экземпляре любого типа.  
  
     В следующем примере вызывается <xref:System.Object.GetType%2A?displayProperty=nameWithType> метод для определения типа среды выполнения каждого объекта в массиве объектов.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   Статический <xref:System.Type.GetType%2A?displayProperty=nameWithType> методы возвращают <xref:System.Type> объект, который представляет тип, указанный по его полному имени.  
  
-   <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, И <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> методы возвращают `Type` объекты, представляющие типы, определенные в модуле. Первый метод может быть использован для получения массива <xref:System.Type> объекты для всех открытых и закрытых типов, определенных в модуле. (Можно получить экземпляр `Module` через <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> метод, либо с помощью <xref:System.Type.Module%2A?displayProperty=nameWithType> свойство.)  
  
-   <xref:System.Reflection.Assembly?displayProperty=nameWithType> Объект содержит ряд методов для получения классы, определенные в сборке, в том числе <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, и <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   <xref:System.Type.FindInterfaces%2A> Метод возвращает отфильтрованный список типов интерфейсов, поддерживаемых типом.  
  
-   <xref:System.Type.GetElementType%2A> Возвращает метод `Type` объект, представляющий элемент.  
  
-   <xref:System.Type.GetInterfaces%2A> И <xref:System.Type.GetInterface%2A> методы возвращают <xref:System.Type> объекты, представляющие типы интерфейсов, поддерживаемых типом.  
  
-   <xref:System.Type.GetTypeArray%2A> Метод возвращает массив <xref:System.Type> объекты, представляющие типы, заданные свойством произвольный набор объектов. Объекты, указанные с помощью массива типа <xref:System.Object>.  
  
-   <xref:System.Type.GetTypeFromProgID%2A> И <xref:System.Type.GetTypeFromCLSID%2A> предоставляются методы для COM-взаимодействия. Они возвращают <xref:System.Type> , представляющий тип, указанный в `ProgID` или `CLSID`.  
  
-   <xref:System.Type.GetTypeFromHandle%2A> Метод предоставляется для обеспечения взаимодействия. Он возвращает `Type` , представляющий тип, указанный с помощью дескриптора класса.  
  
-   C# `typeof` оператор C++ `typeid` оператор и Visual Basic `GetType` оператор получения `Type` объекта для типа.  
  
-   <xref:System.Type.MakeGenericType%2A> Возвращает <xref:System.Type> объект, представляющий сконструированный универсальный тип, который является открытым сконструированным типом, если его <xref:System.Type.ContainsGenericParameters%2A> возвращает `true`, и закрытого сконструированного типа в противном случае. Можно создать экземпляр универсального типа, только в том случае, если он закрыт.  
  
-   <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, И <xref:System.Type.MakeByRefType%2A> методы возвращают <xref:System.Type> объекты, которые представляют, соответственно, массив указанного типа, указатель на указанный тип и тип ссылочного параметра (`ref` в C# `ByRef`в Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Сравнение типов объектов на равенство  
 Объект <xref:System.Type> объекта, что представляет тип является уникальным, то есть два <xref:System.Type> объекта ссылаются на тот же объект только в том случае, если они принадлежат к одному типу. Это позволяет сравнивать <xref:System.Type> объектов с помощью ссылочное равенство. В следующем примере сравниваются <xref:System.Type> объекты, представляющие количество целочисленных значений, чтобы определить, являются ли они того же типа.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 В следующем примере показано несколько репрезентативных признаков из <xref:System.Type>. C# `typeof` Оператор (`GetType` оператор в Visual Basic) используется для получения <xref:System.Type> объект, представляющий <xref:System.String>. Из этого <xref:System.Type> объекта, <xref:System.Type.GetMethod%2A> метод используется для получения <xref:System.Reflection.MethodInfo> представляющий <xref:System.String.Substring%2A?displayProperty=nameWithType> перегрузку, принимающую начальное положение и длину.
  
 Чтобы определить сигнатура перегрузки, в примере кода создается временный массив, содержащий два <xref:System.Type> объектов представляющий `int` (`Integer` в Visual Basic).  
  
> [!NOTE]
>  Точнее, массив содержит две ссылки на экземпляр <xref:System.Type> , представляющий `int` в текущем домене приложения. Для любого типа имеется только один экземпляр <xref:System.Type> каждого домена приложения.  
  
 В примере кода используется <xref:System.Reflection.MethodInfo> для вызова <xref:System.String.Substring%2A> метод в строке «Hello, World!» и отображает результат.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <block subset="none" type="overrides"><para>При наследовании от <see langword="Type" />, необходимо переопределить следующие члены: 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">Просмотр сведений о типах</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Type" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор вызывается производными классами, во время создания типа объектов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Reflection.Assembly" />, в котором объявлен тип. Для универсальных типов возвращает объект сборки <see cref="T:System.Reflection.Assembly" />, в которой определен универсальный тип.</summary>
        <value>Экземпляр <see cref="T:System.Reflection.Assembly" />, описывающий сборку, которая содержит текущий тип. Для универсальных типов экземпляр описывает сборку, содержащую определение универсального типа, а не сборку, которая создала и использует определенный сконструированный тип.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> объект представляет сконструированный универсальный тип, это свойство возвращает сборку, содержащую определение универсального типа. Предположим, например, создать сборку с именем MyGenerics.dll, который содержит определение универсального типа `MyGenericStack<T>` (`MyGenericStack(Of T)` в Visual Basic, `generic<T> ref class MyGenericStack` в C++). При создании экземпляра `MyGenericStack<int>` (`MyGenericStack(Of Integer)` в Visual Basic) в другой сборке, <xref:System.Type.Assembly%2A> свойство для сконструированного типа возвращает <xref:System.Reflection.Assembly> , представляющий MyGenerics.dll.  
  
 Аналогично Если текущий <xref:System.Type> неприсвоенный универсальный параметр представляет объект `T`, это свойство возвращает сборку, содержащую универсальный тип, который определяет `T`.  
  
 Если <xref:System.Type.Assembly%2A?displayProperty=nameWithType> свойство недоступно в конкретной реализации .NET, таких как .NET Core и универсальной платформы Windows, используйте <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> свойство вместо этого.      
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 Следующий пример отображает имя сборки, связанный с классом и полное имя типа.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя типа с указанием сборки, включающее имя сборки, из которой был загружен объект <see cref="T:System.Type" />.</summary>
        <value>Имя объекта <see cref="T:System.Type" /> с указанием сборки, включающее имя сборки, из которой был загружен объект <see cref="T:System.Type" />, или значение <see langword="null" />, если текущий экземпляр представляет параметр универсального типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Квалифицированное имя типа состоит из имени типа, включая пространство имен, следует запятая, а затем по отображаемому имени сборки. Отображаемое имя сборки, получается с помощью <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> свойство.  
  
> [!NOTE]
>  В .NET Framework версии 2.0 архитектура процессора добавляется удостоверения сборки и может быть указан как часть строки имени сборки. Например «ProcessorArchitecture = msil». Тем не менее, он не включен в строку, возвращаемую <xref:System.Type.AssemblyQualifiedName%2A> свойство, по соображениям совместимости. См. раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 Все компиляторы, которые поддерживают среда CLR, выдают простое имя вложенного класса, а отражение создает искаженное имя при запросе, в соответствии со следующими соглашениями.  
  
|разделитель|Значение|  
|---------------|-------------|  
|Обратная косая черта (\\)|Escape-символ.|  
|Запятая ()|Предшествует имени сборки.|  
|Знак плюс (+)|Перед вложенным классом.|  
|Точка (.)|Определяет идентификаторы пространства имен.|  
|Квадратные скобки ([])|После имени типа обозначает массив этого типа.<br /><br /> -или-<br /><br /> Для универсального типа содержащего список аргументов универсального типа.<br /><br /> -или-<br /><br /> В список аргументов типа содержащего типа с указанием сборки.|  
  
 Например имя с указанием сборки для класса может выглядеть следующим образом:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Если пространство имен содержится знак плюс, например TopNamespace.Sub+Namespace, а затем знак «плюс» (+) будет предшествовать escape-символ (\\) для предотвращения его обрабатывались как разделитель вложений. Эта строка будет порождение отражения следующим образом:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 Объект «++» становится "\\+\\+» и"\\«становится»\\\\«.  
  
 Это полное имя можно сохраняются и впоследствии использовать для загрузки <xref:System.Type>. Чтобы найти и загрузить <xref:System.Type>, использовать <xref:System.Type.GetType%2A> либо с типом имя, либо только имя типа с указанием сборки. <xref:System.Type.GetType%2A> с типом имя только будет искать <xref:System.Type> в сборке вызывающего, а затем в системную сборку. <xref:System.Type.GetType%2A> в сборке будет искать имя типа с указанием <xref:System.Type> в любой сборке.  
  
 Имена типов могут включать конечные символы, определяющие дополнительные сведения о типе, например, является ли тип ссылочным типом, тип указателя или тип массива. Получить имя типа без этих конечных символов, с помощью `t.GetElementType().ToString()`, где `t` — это тип.  
  
 Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки. В имени сборки пробелы перед разделителем «,» существенны, но пробелы после разделителя «,» игнорируются.  
  
 Сами с именем сборки являются универсальные аргументы универсальных типов. Например, в имя типа с указанием сборки для `MyGenericClass<int>` (`MyGenericClass(Of Integer)` в Visual Basic), `int` будет расширен, чтобы имя типа с указанием сборки для <xref:System.Int32>.  
  
 Если текущий <xref:System.Type> представляет универсальный параметр, это свойство возвращает `null`.  
  
   
  
## Examples  
 Следующий пример отображает имя сборки, связанный с классом и полное имя типа.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 В следующем примере сравниваются строки, возвращаемые <xref:System.Type.ToString%2A> метод и `Name`, <xref:System.Type.FullName%2A>, и <xref:System.Type.AssemblyQualifiedName%2A> свойства.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Указание полных имен типов</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает атрибуты, связанные с объектом <see cref="T:System.Type" />.</summary>
        <value>Объект <see cref="T:System.Reflection.TypeAttributes" />, представляющий набор атрибутов типа <see cref="T:System.Type" />, если <see cref="T:System.Type" /> не представляет параметр универсального типа. В противном случае это значение не определено.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые из членов <xref:System.Reflection.TypeAttributes> перечисления являются маски, представляющие группы значений. Каждая группа содержит один элемент, чье базовое значение равно нулю. Например, базовое значение <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> члена в <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> группы равен нулю, так как <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> члена в <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> группы. По этой причине необходимо использовать маску перед началом тестирования для этих значений. Иллюстрация приведена в примере.  
  
> [!TIP]
>  Для большинства целей, например свойства <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, и <xref:System.Type.IsSpecialName%2A> проще в использовании, чем атрибуты типа.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает атрибуты типа определения универсального типа. Например, атрибуты, возвращаемые для `MyGenericClass<int>` (`MyGenericClass(Of Integer)` в Visual Basic) являются атрибутами элемента `MyGenericClass<T>` (`MyGenericClass(Of T)` в Visual Basic).  
  
 Если текущий <xref:System.Type> представляет параметр универсального типа — то есть, в том случае, если <xref:System.Type.IsGenericParameter%2A> возвращает `true` - <xref:System.Reflection.TypeAttributes> не указано значение, возвращаемое этим свойством.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Type.Attributes%2A> свойство.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип, для которого текущий объект <see cref="T:System.Type" /> является непосредственным наследником.</summary>
        <value>Объект <see cref="T:System.Type" />, прямым наследником которого является текущий объект <see cref="T:System.Type" />, или <see langword="null" />, если текущий объект <see langword="Type" /> представляет класс <see cref="T:System.Object" /> или интерфейс.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовый тип является типом, от которого непосредственно наследуется текущий тип. <xref:System.Object> Это единственный тип, который не имеет базового типа, поэтому `null` возвращается как базовый тип <xref:System.Object>.  
  
 Интерфейсы наследуются из нуля или более базовых интерфейсов. Таким образом, это свойство возвращает `null` Если `Type` объект представляет интерфейс. Базовые интерфейсы можно определить с помощью <xref:System.Type.GetInterfaces%2A> или <xref:System.Type.FindInterfaces%2A>.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, базовый тип отражает универсальные аргументы. В качестве примера рассмотрим следующие объявления:  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Для сконструированного типа `C<int>` (`C(Of Integer)` в Visual Basic), <xref:System.Type.BaseType%2A> возвращает `B<int>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа определения универсального типа, <xref:System.Type.BaseType%2A> возвращает ограничение для класса, то есть параметр типа должен наследовать класс. Если имеется без ограничения класса <xref:System.Type.BaseType%2A> возвращает <xref:System.Object?displayProperty=nameWithType>.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Type.BaseType%2A> свойство.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 Следующий пример использует рекурсию для списка полная иерархия наследования каждого класса, найденный в сборке. В примере определяется класс с именем `C` , производный от класса с именем `B`, который, в свою очередь, является производным от класса с именем `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Отражение и универсальные типы</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, имеются ли у текущего объекта <see cref="T:System.Type" /> параметры типа, которые не были замещены указанными типами.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> сам является параметром универсального типа или если для его параметров типа не предоставлены определенные типы; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы создать экземпляр типа, должен быть не определения универсального типа или открытых сконструированных типов в аргументах самого типа, в любой включающих их универсальных типов или в какие-либо элементы типа. — Другими словами, при рекурсивном, тип должен содержать без параметров универсального типа.  
  
 Так как типы могут иметь произвольную сложность, дело обстоит является сложной задачей. Для удобства и уменьшить вероятность ошибок <xref:System.Type.ContainsGenericParameters%2A> свойство обеспечивает стандартный способ для различения закрытые сконструированные типы, которые могут быть созданы, и открыть созданных типов, которые нельзя. Если <xref:System.Type.ContainsGenericParameters%2A> возвращает `true`, тип не может быть создан.  
  
 <xref:System.Type.ContainsGenericParameters%2A> Свойство осуществляет рекурсивно для параметров типа. Например, он возвращает `true` для массива, элементы которого являются типом `A<T>` (`A(Of T)` в Visual Basic), несмотря на то, что массив не является универсальным. Сравните это с поведением <xref:System.Type.IsGenericType%2A> свойство, которое возвращает `false` для массивов.  
  
 Набор примеров классов и таблица, показывающая значения <xref:System.Type.ContainsGenericParameters%2A> свойство, см. в разделе <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере определяется универсальный класс с двумя параметрами типа и затем определяет второй универсальный класс, производный от первого класса. Базовый класс для производного класса имеет два аргумента типа: во-первых, <xref:System.Int32> , а второй — параметр типа производного типа. В примере отображаются сведения об этих универсальных классов, включая должности сообщил <xref:System.Type.GenericParameterPosition%2A> свойство.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Отражение и универсальные типы</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает метод <see cref="T:System.Reflection.MethodBase" />, который представляет объявляемый метод, если текущий <see cref="T:System.Type" /> представляет параметр типа универсального метода.</summary>
        <value>Если текущий объект <see cref="T:System.Type" /> представляет параметр типа универсального метода, класс <see cref="T:System.Reflection.MethodBase" />, представляющий объявляемый метод; в противном случае — значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объявляемый метод является определением универсального метода. То есть если <xref:System.Type.DeclaringMethod%2A> не возвращает `null`, затем `DeclaringMethod.IsGenericMethodDefinition` возвращает `true`.  
  
 <xref:System.Type.DeclaringType%2A> И <xref:System.Type.DeclaringMethod%2A> свойства определяют определение универсального типа или определение универсального метода, в котором изначально был определен параметр универсального типа:  
  
-   Если <xref:System.Type.DeclaringMethod%2A> возвращает <xref:System.Reflection.MethodInfo>, в котором <xref:System.Reflection.MethodInfo> представляет определение универсального метода и текущий <xref:System.Type> представляет параметр типа определения универсального метода.  
  
-   Если <xref:System.Type.DeclaringMethod%2A> возвращает `null`, а затем <xref:System.Type.DeclaringType%2A> свойство всегда возвращает <xref:System.Type> объект, представляющий определение универсального типа и текущий <xref:System.Type> представляет параметр типа универсального типа Определение.  
  
-   Начало <xref:System.Type.DeclaringMethod%2A> свойства в типе которого <xref:System.Type.IsGenericParameter%2A> свойство `false` вызывает <xref:System.InvalidOperationException>.  
  
 <xref:System.Reflection.MethodBase> , Возвращаемый <xref:System.Type.DeclaringMethod%2A> свойство <xref:System.Reflection.MethodInfo> в случае универсального метода, или <xref:System.Reflection.ConstructorInfo> в случае общих конструкторов.  
  
> [!NOTE]
>  Универсальные конструкторы в платформе .NET Framework версии 2.0 не поддерживаются.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере кода определяется класс, с универсального метода, который присваивает аргумент типа для метода и вызывает итоговый сконструированный универсальный метод. Она также отображает сведения о определение универсального метода и сконструированный метод. При отображении сведения о параметры типа определения универсального метода, в `DisplayGenericMethodInfo` метод, в примере кода показано значение <xref:System.Type.DeclaringMethod%2A> свойство для параметра универсального типа метода.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Отражение и универсальные типы</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип, объявивший текущий вложенный тип или параметр универсального типа.</summary>
        <value>Объект <see cref="T:System.Type" />, представляющий включающий тип, если текущий тип является вложенным, или определение универсального типа, если текущий тип является параметром универсального типа, или тип, объявивший этот универсальный метод, если текущий тип является параметром типа универсального метода; в противном случае — значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство возвращает определение универсального типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального метода, это свойство возвращает тип, который содержит определение универсального метода. Если тип универсален, возвращается определение универсального типа. То есть следующий код возвращает определение универсального типа <xref:System.Collections.Generic.List%601> универсальный класс, который содержит <xref:System.Collections.Generic.List%601.ConvertAll%2A> универсальный метод:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, <xref:System.Type.DeclaringType%2A> и <xref:System.Type.DeclaringMethod%2A> свойства определяют определение универсального типа или определение универсального метода, где параметр универсального типа была изначально определена:  
  
-   Если <xref:System.Type.DeclaringMethod%2A> возвращает <xref:System.Reflection.MethodInfo>, в котором <xref:System.Reflection.MethodInfo> представляет определение универсального метода и текущий <xref:System.Type> представляет параметр типа определения универсального метода.  
  
-   Если <xref:System.Type.DeclaringMethod%2A> возвращает `null`, а затем <xref:System.Type.DeclaringType%2A> свойство всегда возвращает <xref:System.Type> объект, представляющий определение универсального типа и текущий <xref:System.Type> представляет параметр типа универсального типа Определение.  
  
-   Начало <xref:System.Type.DeclaringType%2A> свойства в типе которого <xref:System.Type.IsGenericParameter%2A> свойство `false` вызывает <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Этот пример отображает объявляющий тип метода в производном классе.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на связыватель по умолчанию, который реализует внутренние правила выбора соответствующих членов, вызываемых методом <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</summary>
        <value>Ссылка на связыватель, используемый в системе по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Связыватель по умолчанию, предоставляемый среда подходит для всех, кроме очень специфических ситуаций. Если вам нужна binder, следующим правила, которые отличаются от методов связывателя по умолчанию, определяют тип, производный от <xref:System.Reflection.Binder> класса и передавало экземпляр этого типа с помощью `binder` параметр одного из <xref:System.Type.InvokeMember%2A> перегрузки.  
  
 Отражение моделирует правила доступности система общих типов CTS. Например если вызывающий объект находится в той же сборке, вызывающему объекту не требуется специальных разрешений для внутренних членов. В противном случае вызывающий объект должен <xref:System.Security.Permissions.ReflectionPermission>. Это согласуется с поиск членов, которые защищены, частных и т. д.  
  
 Общий принцип является то, что <xref:System.Reflection.Binder.ChangeType%2A> должен выполнять только расширяющие преобразования, которые никогда не потерять данные. Пример расширяющего преобразования преобразует значение 32-разрядное целое число со знаком длиной 64-разрядное целое число со знаком. Этим оно отличается от сужающее преобразование, которое может произойти потеря данных. Примером сужающего преобразования преобразование 64-разрядное знаковое целое число 32-битовое целое число со знаком.  
  
 В следующей таблице перечислены преобразования, поддерживаемые классом связыватель по умолчанию.  
  
|Тип источника|Тип целевого объекта|  
|-----------------|-----------------|  
|Любой тип|Его базовый тип.|  
|Любой тип|Интерфейс, который он реализует.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Non-reference|По ссылке.|  
  
   
  
## Examples  
 В следующем примере возвращается связыватель по умолчанию из `DefaultBinder` свойство и вызывает член класса MyClass, передав `DefaultBinder` значение в качестве параметра <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Разделяет имена в пространстве имен класса <see cref="T:System.Type" />. Это поле доступно только для чтения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет пустой массив типа <see cref="T:System.Type" />. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем коде показано в примере `EmptyTypes` поле, используемое в одном из `GetConstructor` способа получить конструктор, который не принимает никаких параметров.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, совпадает ли базовый системный тип текущего объекта <see cref="T:System.Type" /> с базовым системным типом указанного объекта <see cref="T:System.Object" /> или <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Объект, базовый системный тип которого сравнивается с базовым системным типом текущего типа <see cref="T:System.Type" />. Для успешного сравнения необходимо, чтобы параметр <paramref name="o" /> можно было привести к объекту типа <see cref="T:System.Type" /> или преобразовать в объект такого типа.</param>
        <summary>Определяет, совпадает ли базовый системный тип текущего объекта <see cref="T:System.Type" /> с базовым системным типом указанного объекта <see cref="T:System.Object" />.</summary>
        <returns>Значение <see langword="true" />, если базовый системный тип параметра <paramref name="o" /> совпадает с базовым системным типом текущего объекта <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />. Этот метод также возвращает <see langword="false" /> в следующих случаях:  
  
-   <paramref name="o" /> имеет значение <see langword="null" />.  
  
-   <paramref name="o" /> невозможно привести к объекту или преобразовать в объект <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Он приводит `o` для объекта типа <xref:System.Type> и вызывает <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Type.Equals%28System.Object%29> для сравнения различных <xref:System.Type> экземпляры с различными объектов <xref:System.Object> экземпляров.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Это особенно необходимо отметить в примере:  
  
-   Сравнение <xref:System.Type> объект, который представляет собой целое число с <xref:System.Reflection.TypeInfo> объект, который представляет возвращаемое целое `true` поскольку <xref:System.Reflection.TypeInfo> является производным от <xref:System.Type>.  
  
-   Сравнение <xref:System.Type> , представляющий <xref:System.Collections.Generic.IList%601> объект (открытый универсальный тип) с `List(Of String)` object (закрытого универсального типа) возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Объект, базовый системный тип которого сравнивается с базовым системным типом текущего типа <see cref="T:System.Type" />.</param>
        <summary>Позволяет определить, совпадает ли базовый системный тип текущего объекта <see cref="T:System.Type" /> с базовым системным типом указанного объекта <see cref="T:System.Type" />.</summary>
        <returns>Значение <see langword="true" />, если базовый системный тип параметра <paramref name="o" /> совпадает с базовым системным типом текущего объекта <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере используется `Equals` для сравнения двух типов.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предоставляет фильтр членов, используемый для атрибутов. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это поле хранит ссылку на делегат, используемый <xref:System.Type.FindMembers%2A> метод. Метода, инкапсулируемого данным делегатом принимает два параметра: первый — <xref:System.Reflection.MemberInfo> объекта, а второй – `Object`. Этот метод определяет, является ли `MemberInfo` объект соответствует критериям, заданным `Object`. `Object` Может быть присвоено значение любого из полей в классах <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, или <xref:System.Reflection.MethodImplAttributes>.  
  
 Например `Object` может быть присвоено значение поля из `FieldAttributes` такие как Public. В этом случае, когда `FilterAttribute` делегат вызывается, он возвращает `true` только в том случае, если метод, представленный `MemberInfo` объект дополнен атрибутом открытого поля в метаданных.  
  
   
  
## Examples  
 В следующем примере возвращается `FilterAttribute` делегировать, передает его в качестве параметра <xref:System.Type.FindMembers%2A> метод и отображает заданные элементы и их атрибуты.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет фильтр членов с учетом регистра, применяемый к именам. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это поле хранит ссылку на делегат, используемый <xref:System.Type.FindMembers%2A> метод. Метода, инкапсулируемого данным делегатом принимает два параметра: первый — <xref:System.Reflection.MemberInfo> объекта, а второй – `Object`. Этот метод определяет, является ли `MemberInfo` объект соответствует критериям, заданным `Object`. `Object` Присваивается строковое значение, которое может содержать символ «*» подстановочный знак. Поддерживается только конечный совпадение со строкой.  
  
 Например `Object` может быть присвоено значение «Байт *». В этом случае, когда `FilterName` делегат вызывается, он возвращает `true` только в том случае, если метод, представленный `MemberInfo` объект имеет имя, которое начинается с «Byte».  
  
   
  
## Examples  
 В следующем примере возвращаются методы, связанные с определяемыми пользователем `Application` типа.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет фильтр членов без учета регистра, применяемый к именам. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это поле хранит ссылку на делегат, используемый <xref:System.Type.FindMembers%2A> метод. Метода, инкапсулируемого данным делегатом принимает два параметра: первый — <xref:System.Reflection.MemberInfo> объекта, а второй – `Object`. Этот метод определяет, является ли `MemberInfo` объект соответствует критериям, заданным `Object`. `Object` Присваивается строковое значение, которое может содержать символ «*» подстановочный знак. Поддерживается только конечный совпадение со строкой.  
  
 Например `Object` может быть присвоено значение «Байт *». В этом случае, когда `FilterName` делегат вызывается, он вернет значение true, только если метод, представленный `MemberInfo` объект имеет имя, которое начинается с «byte», без учета регистра.  
  
   
  
## Examples  
 В следующем примере возвращается `MemberFilter` делегировать, передает его в качестве параметра <xref:System.Type.FindMembers%2A> метод и отображает методы и их атрибуты `String` класс, который начинается с прописной или строчной буквы «c»,.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filter">Делегат, сравнивающий интерфейсы с параметром <paramref name="filterCriteria" />.</param>
        <param name="filterCriteria">Критерий поиска, определяющий, должен ли тот или иной интерфейс включаться в возвращаемый массив.</param>
        <summary>Возвращает массив объектов <see cref="T:System.Type" />, представляющий отфильтрованный список интерфейсов, реализованных или наследуемых текущим объектом <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, представляющий отфильтрованный список интерфейсов, которые реализует или наследует текущий объект <see cref="T:System.Type" />, или пустой массив, если после применения фильтра для текущего объекта <see cref="T:System.Type" /> отсутствуют соответствующие реализованные или унаследованные интерфейсы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен производным классом.  
  
 <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> И <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> предоставленных делегатов <xref:System.Reflection.Module?displayProperty=nameWithType> класс может также использоваться, вместо <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> делегировать.  
  
 Все интерфейсы, реализованные этим классом, считаются во время поиска ли для объявления базового класса или в самом классе.  
  
 Этот метод выполняет поиск по иерархии, возвращение каждого соответствующего интерфейса каждый класс реализует интерфейс, а также все соответствующие интерфейсы, каждый из этих интерфейсов реализует (то есть возвращается транзитивное замыкание сопоставления интерфейсов). Каждый интерфейс возвращаются.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, <xref:System.Type.FindInterfaces%2A> поиск всех интерфейсов, объявленных в ограничения для параметра типа, и все интерфейсы, наследуемые через интерфейсы объявлен в соответствии с ограничениями. Если текущий <xref:System.Type> представляет аргумент типа универсального типа, <xref:System.Type.FindInterfaces%2A> ищет все интерфейсы, реализованные с помощью типа, независимо от того, имеется ли они удовлетворяет ограничениям.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> можно возвращать универсальные интерфейсы, даже для типов, которые не являются универсальными. Например, может реализовать неуниверсальный тип `IEnumerable<int>` (`IEnumerable(Of Integer)` в Visual Basic).  
  
   
  
## Examples  
 В следующем примере вычисляется указанный интерфейс реализован или унаследованные указанным типом и затем отображает имена интерфейсов.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Статический инициализатор вызывается и создает исключение.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="memberType">Побитовое сочетание значений перечисления, обозначающее тип искомого члена.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <param name="filter">Делегат, выполняющий сравнение и возвращающий <see langword="true" />, если проверяемый член соответствует условиям, заданным в параметре <paramref name="filterCriteria" />, и <see langword="false" /> в противном случае.</param>
        <param name="filterCriteria">Условие поиска, определяющее, будет ли член включен в возвращаемый массив объектов <see langword="MemberInfo" />.  
  
Поля классов <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> и <see langword="MethodImplAttributes" /> могут использоваться вместе с делегатом <see langword="FilterAttribute" />, предоставляемым этим классом.</param>
        <summary>Возвращает отфильтрованный массив объектов <see cref="T:System.Reflection.MemberInfo" />, тип которого совпадает с указанным типом члена.</summary>
        <returns>Отфильтрованный массив объектов <see cref="T:System.Reflection.MemberInfo" />, имеющих тип указанного члена.  
  
-или- 
Пустой массив, если у текущего <see cref="T:System.Type" /> нет членов типа <paramref name="memberType" />, удовлетворяющих условиям фильтра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Этот метод может быть переопределен производным классом.  
  
Элементы включают свойства, методы, поля, события и т. д.  

Для `FindMembers` метод для успешного получения информация об элементе, `bindingAttr` аргумент должен содержать хотя бы один из <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, вместе с по крайней мере один из <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>. 

 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие члены следует включить в поиск:  
  
-   Укажите `BindingFlags.Instance` для включения при поиске членов экземпляров.  
  
-   Укажите `BindingFlags.Static` для включения в поиск статические члены.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` с участием не являющиеся открытыми (то есть внутренней, закрытые и защищенные члены) для поиска.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные на <xref:System.Type>, не те члены, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
Чтобы получить инициализатор класса (статический конструктор), с помощью этого метода, необходимо указать <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Также можно получить с помощью инициализатор класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
Если текущий <xref:System.Type> представляет параметр типа универсального типа или метода, <xref:System.Type.FindMembers%2A> обрабатывает все члены, объявленные в класс ограничения и ограничения интерфейса параметра типа.  

`filter` Аргумент может принимать пользовательский делегат типа <xref:System.Reflection.MemberFilter>, или он может принимать одно из следующих предопределенных делегаты:

- <xref:System.Type.FilterAttribute?displayProperty=nameWithType>, которая использует<xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, или <xref:System.Reflection.MethodImplAttributes> вспомним `filterCriteria` значение.

- <xref:System.Type.FilterName?displayProperty=nameWithType>, который выполняет сравнение с учетом регистра имени каждого члена с помощью строки, переданной `filterCriteria`.

- <xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>, который выполняет сравнение без учета регистра имени каждого члена с помощью строки, переданной `filterCriteria`.

## Examples  
 Следующий пример находит все члены в классе, который соответствует указанным условиям поиска, а затем отображает соответствующие члены.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает полное имя типа, включая пространство имен, но не сборку.</summary>
        <value>Полное имя типа, включая пространство имен, но не сборку; или значение <see langword="null" />, если текущий экземпляр представляет параметр универсального типа, тип массива, тип указателя, тип <see langword="byref" /> на основе параметра типа либо универсальный тип, который, хотя и не является определением универсального типа, содержит неразрешенные параметры типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например, полное имя <xref:System.String> тип — `System.String`. Сравните это с именем с указанием сборки, возвращенным <xref:System.Type.AssemblyQualifiedName%2A> свойство, которое состоит из полного имени, а также полное имя сборки.  
  
 Если текущий тип представляет закрытый универсальный тип, возвращаемый аргументы типа в строке <xref:System.Type.FullName%2A> свойства определяются их полное имя сборки, несмотря на то, что строковое представление универсального типа не квалифицируется его full имя сборки. В следующем примере показано различие в свойстве FullName для типа, представляющий определение универсального типа и одно из них представляет закрытый универсальный тип.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Это свойство возвращает `null` если:  
  
-   Текущий <xref:System.Type> представляет параметр типа универсального типа.  
  
     В следующем примере извлекается параметр типа <xref:System.Nullable%601> тип и пытается отобразить его <xref:System.Type.FullName%2A> свойство.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   Текущий <xref:System.Type> объект представляет тип массива, тип указателя, или `byref` тип, основанный на параметр универсального типа.  
  
     В следующем примере определяется универсальный тип, `Generictype1<T>`, три метода: `Display(T[])`, который передается массив объектов типа T; `HandleT(T)`, которой передается объект T; и `ChangeValue(ref T)`, который передается по ссылке объект T. Так как C# и Visual Basic не позволяют нам определить как указатель в T `HandleT` метод, у нас есть для вызова <xref:System.Type.MakePointerType%2A> метод <xref:System.Type> , представляющий тип параметра метода, чтобы создать указатель к универсальному типу. Выходные данные примера показано, что во всех трех случаях <xref:System.Type.FullName%2A> свойство `null`.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   Текущий тип содержит параметры универсального типа, которые не были заменены определенных типов (т. е <xref:System.Type.ContainsGenericParameters%2A> возвращает `true`), но тип не является определением универсального типа (то есть <xref:System.Type.IsGenericTypeDefinition%2A> возвращает `false`  
  
     В следующем примере `Derived<T>` наследует от `Base<T>`. <xref:System.Type.BaseType%2A> Свойство получает <xref:System.Type> , представляющий базовый тип `Derived<T>`и его <xref:System.Type.FullName%2A> возвращает `null`.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Чтобы получить <xref:System.Type.FullName%2A> , не `null`, можно использовать <xref:System.Type.GetGenericTypeDefinition%2A> метод для получения определения универсального типа, как показано в примере.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 Следующий пример отображает полное имя указанного типа.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 В следующем примере сравниваются строки, возвращаемые <xref:System.Type.ToString%2A> метод и `Name`, <xref:System.Type.FullName%2A>, и <xref:System.Type.AssemblyQualifiedName%2A> свойства.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Указание полных имен типов</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает сочетание флагов <see cref="T:System.Reflection.GenericParameterAttributes" />, описывающих ковариацию и особые ограничения текущего параметра универсального типа.</summary>
        <value>Побитовое сочетание значений <see cref="T:System.Reflection.GenericParameterAttributes" />, которое описывает ковариацию и особые ограничения текущего параметра универсального типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого свойства содержит флаги, описывающие ли текущий параметр универсального типа является ковариантным и флаги, описывающие особые ограничения. Используйте <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> значение для выбора флаги ковариации и использовать <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> значение для выбора флагов ограничений.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере кода определяется универсальный тип `Test` с двумя параметрами типа, которые имеют различные ограничения. При выполнении программы, ограничения проверяются с использованием <xref:System.Type.GenericParameterAttributes%2A> свойство и <xref:System.Type.GetGenericParameterConstraints%2A> метод.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий объект <see cref="T:System.Type" /> не является параметром универсального типа. То есть свойство <see cref="P:System.Type.IsGenericParameter" /> возвращает значение <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Отражение и универсальные типы</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает позицию параметра типа в списке параметров универсального типа или метода, который объявил параметр, если объект <see cref="T:System.Type" /> представляет параметр универсального типа или метода.</summary>
        <value>Позиция параметра типа в списке параметров типа универсального типа или метода, которые задали этот параметр. Нумерация позиций начинается с 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A> Свойство возвращает позицию параметра типа в списке параметров определения универсального типа или определение универсального метода которой была изначально определена параметра типа. <xref:System.Type.DeclaringType%2A> И <xref:System.Type.DeclaringMethod%2A> свойства определяют определении универсального типа или метода:  
  
-   Если <xref:System.Type.DeclaringMethod%2A> возвращает <xref:System.Reflection.MethodInfo>, в котором <xref:System.Reflection.MethodInfo> представляет определение универсального метода и текущий <xref:System.Type> представляет параметр типа определения универсального метода.  
  
-   Если <xref:System.Type.DeclaringMethod%2A> возвращает `null`, а затем <xref:System.Type.DeclaringType%2A> свойство всегда возвращает <xref:System.Type> объект, представляющий определение универсального типа и текущий <xref:System.Type> представляет параметр типа универсального типа Определение.  
  
 Чтобы обеспечить правильный контекст для значения <xref:System.Type.GenericParameterPosition%2A> свойство, это необходимо для определения универсального типа или метода, параметр типа относится к. Например, рассмотрим возвращаемое значение метода `GetSomething` в следующем коде:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 Тип, возвращаемый `GetSomething` зависит от типа аргументов, предоставляемых классом `A` и `GetSomething` сам. Вы можете получить <xref:System.Reflection.MethodInfo> для `GetSomething`, и в, вы можете получить тип возвращаемого значения. При проверке параметров типа, типа возвращаемого значения, <xref:System.Type.GenericParameterPosition%2A> возвращает 0 для обоих. Положение `V` равно 0, так как `V` является первым параметром типа в списке параметров типа для класса `A`. Положение `X` равно 0, так как `X` является первым параметром в списке параметров типа для типа `GetSomething`.  
  
> [!NOTE]
>  Вызов <xref:System.Type.GenericParameterPosition%2A> свойство вызывает исключение, если текущий <xref:System.Type> не представляет параметр типа. При проверке аргументов типа открытого сконструированного типа, использовать <xref:System.Type.IsGenericParameter%2A> свойство, чтобы сообщить, которые являются параметрами типа, а какие — типы. <xref:System.Type.IsGenericParameter%2A> Возвращает `true` для параметра типа; затем можно использовать <xref:System.Type.GenericParameterPosition%2A> метод для получения его положения и использования <xref:System.Type.DeclaringMethod%2A> и <xref:System.Type.DeclaringType%2A> свойства, чтобы определить, метода или определение, определяющего его типа .  
  
   
  
## Examples  
 В следующем примере определяется универсальный класс с двумя параметрами типа и определяет второй универсальный класс, производный от первого класса. Базовый класс для производного класса имеет два аргумента типа: во-первых, <xref:System.Int32>, а второй — параметр типа производного типа. В примере отображаются сведения об этих универсальных классов, включая должности сообщил <xref:System.Type.GenericParameterPosition%2A> свойство.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий тип не представляет параметр типа. То есть <see cref="P:System.Type.IsGenericParameter" /> возвращает <see langword="false" />.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Отражение и универсальные типы</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает массив аргументов универсального типа для этого типа.</summary>
        <value>Массив аргументов универсального типа для этого типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает только аргументы универсального типа; то есть типы, которые были указаны для параметров универсального типа для текущего типа. Если текущий тип является определением универсального типа, это свойство возвращает пустой массив.  
  
> [!NOTE]
>  При использовании универсального типа универсального метода или другого универсального типа, некоторые из его аргументов универсального типа могут быть параметров универсального типа для включающего метода или типа.  
  
 Чтобы получить параметры универсального типа, типа, представляющий определение универсального типа, используйте <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> свойство. Чтобы получить <xref:System.Reflection.TypeInfo> объект для текущего <xref:System.Type> , используйте <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> метод расширения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает размерность массива.</summary>
        <returns>Целое число, указывающее на количество измерений текущего типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример отображает число измерений в массиве.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Функциональность этого метода не поддерживается в базовом классе и должна быть реализована в производном классе.</exception>
        <exception cref="T:System.ArgumentException">Текущий тип не является массивом.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.Attributes" /> и возвращает побитовое сочетание значений перечисления, указывающих атрибуты, связанные с <see cref="T:System.Type" />.</summary>
        <returns>Объект <see cref="T:System.Reflection.TypeAttributes" />, представляющий набор атрибутов объекта <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает определенный конструктор текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющих число, порядок и тип параметров нужного конструктора.  
  
-или- 
Пустой массив объектов <see cref="T:System.Type" /> для получения конструктора, не имеющего параметров. Подобный пустой массив предоставляется полем <see langword="static" /> с описателем <see cref="F:System.Type.EmptyTypes" />.</param>
        <summary>Выполняет поиск открытого конструктора экземпляра, параметры которого соответствуют типам, содержащимся в указанном массиве.</summary>
        <returns>Объект, представляющий открытый конструктор экземпляра, параметры которого соответствуют типам, указанным в массиве типов параметров, если такой конструктор найден; в противном случае — <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода ищет открытые конструкторы экземпляров и не может использоваться для получения инициализатором класса (статический конструктор). Чтобы получить инициализатором класса, используйте перегрузку, принимающую <xref:System.Reflection.BindingFlags>и укажите <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Также можно получить с помощью инициализатор класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 Если запрашиваемый конструктор не является открытым, этот метод возвращает `null`.  
  
> [!NOTE]
>  Параметры нельзя опускать при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> с параметрами типа, заменены соответствующими аргументами типа. Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод всегда возвращает `null`.  
  
   
  
## Examples  
 В следующем примере извлекается тип `MyClass`, получает <xref:System.Reflection.ConstructorInfo> и отображает сигнатура конструктора.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> — <see langword="null" />.  
  
-или- 
Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
-или- 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров, извлекаемых конструктором.  
  
-или- 
Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить конструктор, который не имеет параметров.  
  
- или - 
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве типов параметра. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Выполняет поиск конструктора, параметры которого соответствуют указанным типам аргументов и модификаторам, используя заданные ограничения привязки.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект <see cref="T:System.Reflection.ConstructorInfo" />, представляющий конструктор, который соответствует указанным требованиям; в противном случае возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если точное соответствие не существует, `binder` попытается преобразовать типы параметров, указанные в `types` массива, чтобы найти совпадение. Если `binder` не удается найти совпадение, затем `null` возвращается.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения конструкторов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых конструкторов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытые конструкторы (то есть внутренней, закрытые и защищенные конструкторы).  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Чтобы получить инициализатор класса (статический конструктор), с помощью этой перегрузки метода, необходимо указать <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Также можно получить с помощью инициализатор класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
> [!NOTE]
>  Параметры нельзя опускать при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> с параметрами типа, заменены соответствующими аргументами типа. Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод всегда возвращает `null`.  
  
   
  
## Examples  
 В следующем коде определяется тип `MyClass1` класса получает <xref:System.Reflection.ConstructorInfo> объекта, соответствующих заданным флагам привязки и отображается подпись конструктора.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> — <see langword="null" />.  
  
-или- 
Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.  
  
-или- 
 Массив <paramref name="modifiers" /> является многомерным.  
  
-или- 
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
-или- 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Объект, определяющий набор применяемых правил, касающихся порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и очистки стека.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров, извлекаемых конструктором.  
  
-или- 
Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить конструктор, который не имеет параметров.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Выполняет поиск конструктора с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений по привязке и соглашений о вызовах.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект, представляющий конструктор, который соответствует указанным требованиям; в противном случае возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что связыватель по умолчанию не выполняет <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательский модуль привязки, который выполняет обработку `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Если точное соответствие не существует, `binder` попытается преобразовать типы параметров, указанные в `types` массива, чтобы найти совпадение. Если `binder` не удается найти совпадение, затем `null` возвращается.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения конструкторов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых конструкторов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытые конструкторы (то есть внутренней, закрытые и защищенные конструкторы).  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Чтобы получить инициализатор класса (статический конструктор), с помощью этого метода, необходимо указать <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Также можно получить с помощью инициализатор класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
> [!NOTE]
>  Параметры нельзя опускать при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> с параметрами типа, заменены соответствующими аргументами типа. Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод всегда возвращает `null`.  
  
   
  
## Examples  
 В следующем примере извлекается тип `MyClass1`, получает <xref:System.Reflection.ConstructorInfo> объект, который соответствует указанным флагам привязки и отображается подпись конструктора.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> — <see langword="null" />.  
  
-или- 
Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.  
  
-или- 
 Массив <paramref name="modifiers" /> является многомерным.  
  
-или- 
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
<see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
-или- 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Объект, определяющий набор применяемых правил, касающихся порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и очистки стека.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров, извлекаемых конструктором.  
  
-или- 
Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить конструктор, который не имеет параметров.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>При переопределении в производном классе ищет конструктор, параметры которого соответствуют указанным типам аргументов и модификаторам, используя для этого заданные ограничения привязки и соглашение о вызовах.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект <see cref="T:System.Reflection.ConstructorInfo" />, представляющий конструктор, который соответствует указанным требованиям; в противном случае возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что связыватель по умолчанию не выполняет <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательский модуль привязки, который выполняет обработку `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Если точное соответствие не существует, `binder` попытается преобразовать типы параметров, указанные в `types` массива, чтобы найти совпадение. Если `binder` не удается найти совпадение, затем `null` возвращается.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения конструкторов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых конструкторов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытые конструкторы (то есть внутренней, закрытые и защищенные конструкторы).  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Этот метод реализует <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> — <see langword="null" />.  
  
-или- 
Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.  
  
-или- 
 Массив <paramref name="modifiers" /> является многомерным.  
  
-или- 
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <exception cref="T:System.NotSupportedException">Текущий тип — <see cref="T:System.Reflection.Emit.TypeBuilder" /> или <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает конструкторы текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все открытые конструкторы, определенные для текущего объекта <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющий все открытые конструкторы экземпляров, определенные для текущего типа <see cref="T:System.Type" />, за исключением инициализатора типа (статический конструктор). Если для текущего объекта <see cref="T:System.Type" /> открытые конструкторы экземпляров не определены или если текущий объект <see cref="T:System.Type" /> представляет параметр типа в определении универсального типа или метода, возвращается пустой массив типа <see cref="T:System.Reflection.ConstructorInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> Метод не возвращает конструкторы в определенном порядке, например порядок объявления. Ваш код не должен зависеть от порядка, в котором возвращаются конструкторы, так как этот порядок меняется.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Эта перегрузка метода вызывает <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> перегрузку метода с <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> в Visual Basic). Его не удастся найти инициализаторы класса (статический конструктор). Чтобы найти инициализаторы класса, используйте перегрузку, принимающую <xref:System.Reflection.BindingFlags>и укажите <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Также можно получить с помощью инициализатор класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> объекты с параметрами типа, заменены соответствующими аргументами типа. Например если класс `C<T>` имеет конструктор `C(T t1)` (`Sub New(ByVal t1 As T)` в Visual Basic), вызов <xref:System.Type.GetConstructors%2A> на `C<int>` возвращает <xref:System.Reflection.ConstructorInfo> , представляющий `C(int t1)` в C# (`Sub New(ByVal t1 As Integer)` в Visual Basic).  
  
 Если текущий <xref:System.Type> представляет параметр универсального типа, <xref:System.Type.GetConstructors%2A> метод возвращает пустой массив.  
  
   
  
## Examples  
 В этом примере показан результат выполнения <xref:System.Type.GetConstructors%2A> перегружать из класса, который имеет два конструктора экземпляра и один статический конструктор.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Ниже приведен результат выполнения этого кода.  
  
 2  
  
 False  
  
 False  
  
 Так как <xref:System.Type.GetConstructors> перегрузка использует только <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, статический конструктор не подсчитывается `for` выражения и не вычисляется `IsStatic`.  
  
 Чтобы найти статические конструкторы, используйте <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> перегружать и передать сочетания (логические `OR`) из <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, как показано в следующем примере кода:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Теперь выводится следующий результат:  
  
 3  
  
 False  
  
 Да  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
<see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</param>
        <summary>При переопределении в производном классе ищет конструкторы, определенные для текущего объекта <see cref="T:System.Type" />, с использованием указанного объекта <see langword="BindingFlags" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющий все конструкторы, определенные для текущего объекта <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки, в том числе и инициализатор типа, если он определен. Возвращает пустой массив типа <see cref="T:System.Reflection.ConstructorInfo" />, если для текущего типа <see cref="T:System.Type" /> не определены конструкторы, если ни один из определенных конструкторов не соответствует ограничениям привязки или если текущий тип <see cref="T:System.Type" /> представляет параметр типа в определении универсального типа или метода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
`bindingAttr` можно использовать для указания, следует ли возвращать только открытые конструкторы либо как открытые и закрытые конструкторы.  
  
Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения конструкторов, включаемых в поиск:  
  
- Укажите `BindingFlags.Static` вместе с `BindingFlags.NonPublic` извлекаемого инициализатор класса (статический конструктор). Также можно получить с помощью инициализатор класса <xref:System.Type.TypeInitializer%2A> свойство.

- Укажите `BindingFlags.Instance` вместе с одним или обоими `BindingFlags.Public` и `BindingFlags.NonPublic` для получения конструкторы экземпляров.   
  
Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  

<xref:System.Type.GetConstructors%2A> Метод не возвращает конструкторы в определенном порядке, например порядок объявления. Ваш код не должен зависеть от порядка, в котором возвращаются конструкторы, так как этот порядок меняется.  

Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> объекты с параметрами типа, заменены соответствующими аргументами типа. Например если класс `C<T>` имеет конструктор `C(T t1)` (`Sub New(ByVal t1 As T)` в Visual Basic), вызов <xref:System.Type.GetConstructors%2A> на `C<int>` возвращает <xref:System.Reflection.ConstructorInfo> , представляющий `C(int t1)` в C# (`Sub New(ByVal t1 As Integer)` в Visual Basic).  
  
Если текущий <xref:System.Type> представляет параметр универсального типа, <xref:System.Type.GetConstructors%2A> метод возвращает пустой массив.  
  
## Examples  

В этом примере показан результат выполнения <xref:System.Type.GetConstructors> перегружать из класса, который имеет два конструктора экземпляра и один статический конструктор.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Ниже приведен результат выполнения этого кода.  
  
 2  
  
 False  
  
 False  
  
 Так как <xref:System.Type.GetConstructors%2A> перегрузка использует только <xref:System.Reflection.BindingFlags.Public> и <xref:System.Reflection.BindingFlags.Instance>, статический конструктор не подсчитывается `for` выражения и не вычисляется `IsStatic`.  
  
 Чтобы найти статические конструкторы, используйте <xref:System.Type.GetConstructors%2A> перегружать и передать его сочетание (логическое или) <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, как показано в следующем примере кода:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Теперь выводится следующий результат:  
  
 3  
  
 False  
  
 Да  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет поиск членов, определенных для текущего объекта <see cref="T:System.Type" />, для которого задан атрибут <see cref="T:System.Reflection.DefaultMemberAttribute" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий все члены по умолчанию текущего объекта <see cref="T:System.Type" />.  
  
-или- 
Пустой массив типа <see cref="T:System.Reflection.MemberInfo" />, если у текущего типа <see cref="T:System.Type" /> нет членов по умолчанию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A> Метод не возвращает элементы в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются элементы, так как этот порядок меняется.  
  
 Этот метод может быть переопределен производным классом.  
  
 Элементы включают свойства, методы, поля, события и т. д.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> объекты с параметрами типа, заменены соответствующими аргументами типа. Например если класс `C<T>` имеет свойство `P` , возвращающий `T`, вызов <xref:System.Type.GetDefaultMembers%2A> на `C<int>` возвращает `int P` в C# (`Property P As Integer` в Visual Basic).  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или членов <xref:System.Object> при возникновении без ограничения класса.  
  
   
  
## Examples  
 Следующий пример получает сведения элемента по умолчанию из `MyClass` и отображает элементы по умолчанию.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает тип <see cref="T:System.Type" /> объекта, на который ссылается данный массив, указатель или ссылка или который инкапсулирован в этих объектах.</summary>
        <returns>Тип объекта <see cref="T:System.Type" />, на который ссылается данный массив, указатель или ссылка или который инкапсулирован в этих объектах, или значение <see langword="null" />, если текущий объект <see cref="T:System.Type" /> не является массивом или указателем, не передается по ссылке либо представляет универсальный тип или параметр типа в определении универсального типа или метода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает `null` для <xref:System.Array> класса.  
  
   
  
## Examples  
 В следующем примере показано использование `GetElementType` метод.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Значение, имя которой требуется извлечь.</param>
        <summary>Возвращает имя константы с заданным значением для текущего типа перечисления.</summary>
        <returns>Имя члена текущего типа перечисления, имеющего указанное значение, или <see langword="null" />, если такая константа не найдена.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Текущий тип не является перечислением.  
  
-или- 
 <paramref name="value" /> не является ни текущим типом, ни имеющим базовый тип, совпадающий с текущим типом.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает имена членов текущего типа перечисления.</summary>
        <returns>Массив, который содержит имена членов перечисления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы массива возвращаемого значения сортируются по двоичным значениям (то есть значениям без знака) констант-перечислителей. Если массив содержит константы-перечислители с тем же значением, порядок соответствующих им имен не задан.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий тип не является перечислением.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает базовый тип текущего типа перечисления.</summary>
        <returns>Базовый тип текущего перечисления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию базовым типом перечисления в C# и Visual Basic является <xref:System.Int32>. Можно указать других целочисленных типов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий тип не является перечислением.  
  
-или- 
Тип перечисления не является допустимым, так как содержит более одного поля экземпляра.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив значений констант в текущем типе перечисления.</summary>
        <returns>Массив, содержащий значения. Элементы массива сортируются по двоичным значениям (то есть значениям без знака) констант перечисления.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Текущий тип не является перечислением.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает определенное событие, которое объявлено или унаследовано в текущем объекте <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя события, которое объявлено или унаследовано текущим типом <see cref="T:System.Type" />.</param>
        <summary>Возвращает объект <see cref="T:System.Reflection.EventInfo" />, представляющий указанное открытое событие.</summary>
        <returns>Объект, представляющий указанное открытое событие, которое объявлено или унаследовано в текущем объекте <see cref="T:System.Type" />, если такое событие найдено; в противном случае — <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие считается открытым для отражения, если он имеет по крайней мере один метод или метод доступа, который является общим. В противном случае событие считается закрытым, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения, с помощью `Or`) для его получения.  
  
 Поиск `name` чувствителен к регистру. Поиск включает общедоступный статический и открытый экземпляр события.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.EventInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет события ограничения класса.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Reflection.EventInfo> объекта и возвращает событие класса button для указанного события.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя события, которое объявлено или унаследовано текущим типом <see cref="T:System.Type" />.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <summary>При переопределении в производном классе возвращает объект <see cref="T:System.Reflection.EventInfo" />, представляющий указанное событие, используя для этого указанные ограничения привязки.</summary>
        <returns>Объект, представляющий указанное событие, которое объявлено или унаследовано текущим типом <see cref="T:System.Type" />, если такое событие найдено; <see langword="null" /> в противном случае.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие события, чтобы включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых событий.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытые событий (то есть внутренней, закрытые и защищенные).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только события, объявленные на <xref:System.Type>, не события, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Событие считается открытым для отражения, если он имеет по крайней мере один метод или метод доступа, который является общим. В противном случае событие считается закрытым, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения, с помощью `Or`) для его получения.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.EventInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет события ограничения класса.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> метод для поиска типа public или не являющиеся открытыми события с именем «Щелкните», не `static` (`Shared` в Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает события, которые объявлены или унаследованы текущим объектом <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все открытые события, которые объявлены или унаследованы текущим объектом <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.EventInfo" />, представляющий все открытые события, которые объявлены или унаследованы текущим объектом <see cref="T:System.Type" />.  
  
-или- 
Пустой массив типа <see cref="T:System.Reflection.EventInfo" />, если в текущем объекте <see cref="T:System.Type" /> нет открытых событий.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие считается открытым для отражения, если он имеет по крайней мере один метод или метод доступа, который является общим. В противном случае событие считается закрытым, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения, с помощью `Or`) для его получения.  
  
 <xref:System.Type.GetEvents%2A> Метод не возвращает события в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются события, так как этот порядок меняется.  
  
 Этот метод может быть переопределен производным классом.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.EventInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет события ограничения класса.  
  
   
  
## Examples  
 В следующем примере извлекается массив <xref:System.Reflection.EventInfo> объекты, возвращаются все события `Button` класса и отображает имена событий. Чтобы скомпилировать этот пример Visual Basic, используйте следующую команду:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.

-или-

 <see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</param>
        <summary>При переопределении в производном классе ищет события, которые объявлены или унаследованы текущим объектом <see cref="T:System.Type" />, используя указанные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.EventInfo" />, представляющий все события, которые объявлены или унаследованы данным объектом <see cref="T:System.Type" /> и удовлетворяют указанным ограничениям привязки.  
  
-или- 
Пустой массив типа <see cref="T:System.Reflection.EventInfo" />, если у текущего типа <see cref="T:System.Type" /> нет событий или ни одно событие не удовлетворяет ограничениям привязки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A> Метод не возвращает события в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются события, так как этот порядок меняется.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие события, чтобы включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых событий.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытые событий (то есть внутренней, закрытые и защищенные). Только защищенные и внутренние события базовых классов, возвращаются; Закрытые события базовых классов не возвращаются.  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.DeclaredOnly` для поиска только события, объявленные на <xref:System.Type>, не события, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Событие считается открытым для отражения, если он имеет по крайней мере один метод или метод доступа, который является общим. В противном случае событие считается закрытым, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения, с помощью `Or`) для его получения.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.EventInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет события ограничения класса.  
  
   
  
## Examples  
 В следующем примере извлекается массив <xref:System.Reflection.EventInfo> объектов, соответствующих заданным флагам привязки, возвращаются все события `Button` класса и отображает имена событий. Чтобы скомпилировать этот пример Visual Basic, используйте следующую команду:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает указанное поле текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого поля данных.</param>
        <summary>Выполняет поиск открытого поля с заданным именем.</summary>
        <returns>Объект, представляющий открытое поле с указанным именем, если такое свойство есть, или <see langword="null" />, если такого свойства нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` чувствителен к регистру. Поиск включает общедоступный статический и открытый экземпляр поля.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.FieldInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет поля ограничения класса.  
  
   
  
## Examples  
 В следующем примере возвращается `Type` объекта для указанного класса, получает <xref:System.Reflection.FieldInfo> объекта в поле и отображает значение поля.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот объект <see cref="T:System.Type" /> является <see cref="T:System.Reflection.Emit.TypeBuilder" />, метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> которого еще не был вызван.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого поля данных.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <summary>Выполняет поиск указанного поля, используя заданные ограничения привязки.</summary>
        <returns>Объект, предоставляющий поле, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения полей, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых полей.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск полей не являющиеся открытыми (то есть внутренней, закрытые и защищенные поля).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только поля, объявленные в <xref:System.Type>, не полями, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.FieldInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет поля ограничения класса.  
  
   
  
## Examples  
 В следующем примере возвращается `Type` объекта для указанного класса, получает <xref:System.Reflection.FieldInfo> объект для поля, которое соответствует указанным флагам привязки и отображает значение поля.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает поля текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все открытые поля текущего объекта <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.FieldInfo" />, представляющий все открытые поля, определенные для текущего объекта <see cref="T:System.Type" />.  
  
-или- 
Пустой массив типа <see cref="T:System.Reflection.FieldInfo" />, если для текущего типа <see cref="T:System.Type" /> открытые поля не определены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> Метод не возвращает поля в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются поля, так как этот порядок меняется.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.FieldInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод осуществляет открытые поля ограничения класса.  
  
   
  
## Examples  
 В следующем примере показано использование `GetFields()` метод.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.

-или-

 <see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</param>
        <summary>При переопределении в производном классе ищет поля, определенные для текущего объекта <see cref="T:System.Type" />, используя указанные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.FieldInfo" />, представляющий все поля, определенные для текущего типа <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки.  
  
-или- 
Пустой массив типа <see cref="T:System.Reflection.FieldInfo" />, если для текущего объекта <see cref="T:System.Type" /> не определены поля или ни одно из определенных полей не удовлетворяет ограничениям привязки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Для `GetFields(BindingFlags)` перегрузки для успешного получения сведений о свойствах, `bindingAttr` аргумент должен содержать хотя бы один из <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, а также по крайней мере один из <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>. 

Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения полей, включаемых в поиск:  
  
- Укажите `BindingFlags.Instance` для включения методов экземпляра. 

- Укажите `BindingFlags.Static` для включения статических методов. 
    
- Укажите `BindingFlags.Public` для включения в поиск открытых полей.  
  
- Укажите `BindingFlags.NonPublic` для включения в поиск полей не являющиеся открытыми (то есть внутренней, закрытые и защищенные поля). Только защищенные и внутренние поля базовых классов, возвращаются; закрытые поля базовых классов не возвращаются.  
  
- Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  

- Укажите `BindingFlags.Default` отдельно, чтобы возвратить пустую <xref:System.Reflection.PropertyInfo> массива.

Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
- `BindingFlags.DeclaredOnly` для поиска только поля, объявленные в <xref:System.Type>, не полями, унаследованные.  
  
Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
<xref:System.Type.GetFields%2A> Метод не возвращает поля в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются поля, так как этот порядок меняется.  

 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.FieldInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод осуществляет открытые поля ограничения класса.  
  
## Examples  
 В следующем примере показано использование `GetFields(BindingFlags)` метод.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив объектов <see cref="T:System.Type" />, которые представляют аргументы закрытого универсального типа или параметры определения универсального типа.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, которые представляют аргументы универсального типа. Возвращает пустой массив, если текущий тип не является универсальным.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы массива возвращаются в порядке, в котором они отображаются в списке аргументов типа для универсального типа.  
  
-   Если текущий тип является закрытым сконструированным типом (то есть <xref:System.Type.ContainsGenericParameters%2A> возвращает `false`), массив, возвращаемый <xref:System.Type.GetGenericArguments%2A> метод содержит типы, которые были назначены параметрам универсального типа определения универсального типа .  
  
-   Если текущий тип является определением универсального типа, массив содержит параметры типа.  
  
-   Если текущий тип является открытым сконструированным типом (то есть <xref:System.Type.ContainsGenericParameters%2A> возвращает `true`) в определенные типы не были назначены все параметры типа и параметры типа заключающих универсальным типам или методам, массив содержит типы и параметры типа. Используйте <xref:System.Type.IsGenericParameter%2A> свойство, чтобы отличить друг от друга. Для демонстрации этого сценария, см. в разделе пример кода для <xref:System.Type.ContainsGenericParameters%2A> свойство.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Type.GetGenericArguments%2A> метод для отображения аргументы типа сконструированного типа и параметров типа определения универсального типа.  
  
 Данный пример кода является частью большего примера для <xref:System.Type.IsGenericTypeDefinition%2A> свойство. См. в разделе большего примера для пример выходных данных.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе. Реализацию должны обеспечивать производные классы.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Отражение и универсальные типы</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив объектов <see cref="T:System.Type" />, которые представляют ограничения, накладываемые на параметр текущего универсального типа.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, которые представляют ограничения, накладываемые на параметр текущего универсального типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждое ограничение параметра универсального типа выражается как <xref:System.Type> объекта. Используйте <xref:System.Type.IsClass%2A> свойства, чтобы определить, является ли ограничение ограничение базового класса; Если свойство возвращает `false`, ограничение является ограничение интерфейса. Если параметр типа без ограничения класса и интерфейса, возвращается пустой массив.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере кода определяется универсальный тип `Test` с двумя параметрами типа, которые имеют различные ограничения. При выполнении программы, ограничения проверяются с использованием <xref:System.Type.GenericParameterAttributes%2A> свойство и <xref:System.Type.GetGenericParameterConstraints%2A> метод.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий объект <see cref="T:System.Type" /> не является параметром универсального типа. То есть свойство <see cref="P:System.Type.IsGenericParameter" /> возвращает значение <see langword="false" />.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, представляющий определение универсального типа, на основе которого можно сконструировать текущий универсальный тип.</summary>
        <returns>Объект <see cref="T:System.Type" />, представляющий универсальный тип, на основе которого можно сконструировать текущий тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Определение универсального типа — это шаблон, из которого можно сконструировать другие типы. Например, из определения универсального типа `G<T>` (выражена в синтаксис C#; `G(Of T)` в Visual Basic или `generic <typename T> ref class G` в C++) можно создавать и создает экземпляр типа `G<int>` (`G(Of Integer)` в Visual Basic). Учитывая <xref:System.Type> объект, представляющий это сконструированный тип, <xref:System.Type.GetGenericTypeDefinition%2A> метод возвращает определение универсального типа.  
  
 Если два сконструированные типы создаются из одного определения универсального типа, с теми же аргументами типа, <xref:System.Type.GetGenericTypeDefinition%2A> метод возвращает тот же <xref:System.Type> объекта для обоих типов.  
  
 При вызове метода <xref:System.Type.GetGenericTypeDefinition%2A> метод <xref:System.Type> объект, который уже представляет определение универсального типа, возвращается текущий <xref:System.Type>.  
  
> [!IMPORTANT]
>  Массив универсальных типов не сам является универсальным. В коде C# `A<int>[] v;` или код Visual Basic `Dim v() As A(Of Integer)`, тип переменной `v` не является универсальным. Используйте <xref:System.Type.IsGenericType%2A> для определения, является ли тип универсальным, перед вызовом <xref:System.Type.GetGenericTypeDefinition%2A>.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере кода создает экземпляр сконструированного типа с помощью обычного создания экземпляра, а затем использует <xref:System.Type.GetType%2A> и <xref:System.Type.GetGenericTypeDefinition%2A> методы для получения сконструированный тип и определение универсального типа. В этом примере используется универсальный <xref:System.Collections.Generic.Dictionary%602> тип, представляющий сконструированный тип <xref:System.Collections.Generic.Dictionary%602> из `Test` объектов со строковыми ключами.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий тип не является универсальным.  То есть <see cref="P:System.Type.IsGenericType" /> возвращает <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе. Реализацию должны обеспечивать производные классы.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Отражение и универсальные типы</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код данного экземпляра.</summary>
        <returns>Хэш-код данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере отображается хэш-код `System.Windows.Forms.Button` класса.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает определенный интерфейс, реализуемый или наследуемый текущим объектом <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого интерфейса. Для универсальных интерфейсов это искаженное имя.</param>
        <summary>Выполняет поиск интерфейса с заданным именем.</summary>
        <returns>Объект, представляющий интерфейс с заданным именем, который реализуется или наследуется текущим объектом <see cref="T:System.Type" />, если такой интерфейс существует; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` чувствителен к регистру.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Type> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск ограничений интерфейса и все интерфейсы, унаследованные от ограничений класса или интерфейса.  
  
> [!NOTE]
>  Для универсальных интерфейсов `name` параметр является искаженное имя, заканчивающееся грависом (\`) и число параметров типа. Это справедливо для определений универсального интерфейса и сконструированных универсальных интерфейсов. Например, чтобы найти `IExample<T>` (`IExample(Of T)` в Visual Basic) или `IExample<string>` (`IExample(Of String)` в Visual Basic), поиск ``"IExample`1"``.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Type.GetInterface%28System.String%29> метод для поиска <xref:System.Collections.Hashtable> класса для <xref:System.Runtime.Serialization.IDeserializationCallback> интерфейс и перечислены методы интерфейса.  
  
 В примере также показано <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> перегрузку метода и <xref:System.Type.GetInterfaceMap%2A> метод.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Текущий <see cref="T:System.Type" /> представляет тип, реализующий тот же универсальный интерфейс с другими аргументами типа.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого интерфейса. Для универсальных интерфейсов это искаженное имя.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы игнорировать регистр той части параметра <paramref name="name" />, в которой задается простое имя интерфейса (регистр части, соответствующей пространству имен, должен быть надлежащим образом соблюден).  
  
-или- 
 Значение <see langword="false" />, для поиска с учетом регистра всех частей параметра <paramref name="name" />.</param>
        <summary>При переопределении в производном классе ищет интерфейс с заданным именем, позволяющий определить, нужно ли выполнять поиск без учета регистра.</summary>
        <returns>Объект, представляющий интерфейс с заданным именем, который реализуется или наследуется текущим объектом <see cref="T:System.Type" />, если такой интерфейс существует; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase` Параметр применяется только к простое имя интерфейса, не к пространству имен. Часть `name` , определяющий пространство имен должно иметь правильный регистр, или интерфейс не будет найден. Например, строка «System.icomparable» находит <xref:System.IComparable> не поддерживает интерфейс, но строка «system.icomparable».  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Type> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск ограничений интерфейса и все интерфейсы, унаследованные от ограничений класса или интерфейса.  
  
> [!NOTE]
>  Для универсальных интерфейсов `name` параметр является искаженное имя, заканчивающееся грависом (\`) и число параметров типа. Это справедливо для определений универсального интерфейса и сконструированных универсальных интерфейсов. Например, чтобы найти `IExample<T>` (`IExample(Of T)` в Visual Basic) или `IExample<string>` (`IExample(Of String)` в Visual Basic), поиск `"IExample`1"".  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> метод, чтобы выполнить поиск без учета регистра из <xref:System.Collections.Hashtable> класса для <xref:System.Collections.IEnumerable> интерфейс.  
  
 В примере также показано <xref:System.Type.GetInterface%28System.String%29> перегрузку метода и <xref:System.Type.GetInterfaceMap%2A> метод.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Текущий <see cref="T:System.Type" /> представляет тип, реализующий тот же универсальный интерфейс с другими аргументами типа.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Тип интерфейса, для которого требуется извлечь сопоставление.</param>
        <summary>Возвращает сопоставление для интерфейса заданного типа.</summary>
        <returns>Объект, представляющий сопоставление интерфейса для <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Карта интерфейса описывает, как интерфейс был сопоставлен с фактическим членам класса, который реализует этот интерфейс.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, тип, параметры заменяются с соответствующими аргументами типа в элементах <xref:System.Reflection.InterfaceMapping> возвращаемого этим методом.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Type.GetInterfaceMap%2A> метод, чтобы определить, как <xref:System.IFormatProvider> интерфейс сопоставляется <xref:System.Globalization.CultureInfo> методов и как <xref:System.IAppDomainSetup> интерфейс сопоставляется <xref:System.AppDomainSetup> свойства. Обратите внимание, что, поскольку <xref:System.IAppDomainSetup> интерфейс определяет набор свойств, возвращенный <xref:System.Reflection.InterfaceMapping> объект включает отдельный <xref:System.Reflection.MethodInfo> объекты для get свойства и методы доступа set.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Тип <paramref name="interfaceType" /> не реализован с помощью текущего типа.  
  
-или- 
Аргумент <paramref name="interfaceType" /> не ссылается на интерфейс.  
  
-или-

Текущий экземпляр или аргумент <paramref name="interfaceType" /> является открытым универсальным типом (то есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />).

-или-


 <paramref name="interfaceType" /> является универсальным интерфейсом, а текущий тип является типом массива.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий тип <see cref="T:System.Type" /> представляет параметр универсального типа, то есть <see cref="P:System.Type.IsGenericParameter" /> имеет значение <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе. Реализацию должны обеспечивать производные классы.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает все интерфейсы, реализуемые или наследуемые текущим объектом <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, представляющий все интерфейсы, реализуемые или наследуемые текущим типом <see cref="T:System.Type" />.  
  
-или- 
Пустой массив типа <see cref="T:System.Type" /> в случае отсутствия интерфейсов, реализуемых или наследуемых текущим типом <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A> Метод не возвращает интерфейсы в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются интерфейсы, так как этот порядок меняется.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Type> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод выполняет поиск ограничений интерфейса и все интерфейсы, унаследованные от ограничений класса или интерфейса.  
  
   
  
## Examples  
 В следующем примере возвращает тип указанного класса и отображает все интерфейсы, которые этот тип реализует или наследует. Чтобы скомпилировать этот пример Visual Basic, используйте следующие команды компилятора:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Статический инициализатор вызывается и создает исключение.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает указанные члены текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомых открытых членов.</param>
        <summary>Выполняет поиск открытого члена с заданным именем.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий открытые члены с заданным именем, если такие члены есть, и пустой массив, если таких членов нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` чувствителен к регистру. Поиск включает общедоступный статический и открытый экземпляр членов.  
  
 Элементы включают свойства, методы, поля, события и т. д.  
  
 <xref:System.Type.GetMember%2A> Метод не возвращает элементы в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются элементы, так как этот порядок меняется.  
  
 Эта перегрузка метода не удастся найти инициализаторы класса (статический конструктор). Чтобы найти инициализаторы класса, используйте перегрузку, принимающую <xref:System.Reflection.BindingFlags>и укажите <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Также можно получить с помощью инициализатор класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или членов <xref:System.Object> при возникновении без ограничения класса.  
  
> [!NOTE]
>  Для универсальных методов, не используйте аргументы типа в `name`. К примеру, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст "`MyMethod<int>`«, а не для метод с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 В следующем примере отображаются все члены `String` которых начинаются с буквы C.  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя для поиска элементов.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</param>
        <summary>Выполняет поиск указанных членов, используя заданные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий открытые члены с заданным именем, если такие члены есть, и пустой массив, если таких членов нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен производным классом.  
  
 Элементы включают свойства, методы, поля, события и т. д.  
  
 <xref:System.Type.GetMember%2A> Метод не возвращает элементы в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются элементы, так как этот порядок меняется.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие члены следует включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` с участием не являющиеся открытыми (то есть внутренней, закрытые и защищенные члены) для поиска.  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные на <xref:System.Type>, не те члены, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Чтобы получить инициализатор класса (статический конструктор), с помощью этой перегрузки метода, необходимо указать «статический конструктор» для `name`, и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic) для `bindingAttr`. Также можно получить с помощью инициализатор класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или членов <xref:System.Object> при возникновении без ограничения класса.  
  
> [!NOTE]
>  Для универсальных методов, не используйте аргументы типа в `name`. К примеру, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст "`MyMethod<int>`«, а не для метод с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 Следующий пример отображает все открытые статические члены `myString` которых начинаются с буквы C.  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя для поиска элементов.</param>
        <param name="type">Значение, которое нужно найти.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</param>
        <summary>Ищет указанные члены заданного типа, используя установленные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий открытые члены с заданным именем, если такие члены есть, и пустой массив, если таких членов нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы включают свойства, методы, поля, события и т. д.  
  
 <xref:System.Type.GetMember%2A> Метод не возвращает элементы в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются элементы, так как этот порядок меняется.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие члены следует включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` с участием не являющиеся открытыми (то есть внутренней, закрытые и защищенные члены) для поиска.  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные на <xref:System.Type>, не те члены, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Чтобы получить инициализатор класса (статический конструктор), с помощью этой перегрузки метода, необходимо указать «статический конструктор» для `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> для `type`, и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic) для `bindingAttr`. Также можно получить с помощью инициализатор класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или членов <xref:System.Object> при возникновении без ограничения класса.  
  
> [!NOTE]
>  Для универсальных методов, не используйте аргументы типа в `name`. К примеру, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст "`MyMethod<int>`«, а не для метод с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 В следующем примере отображаются все методы объекта `myString` которых начинаются с буквы C.  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Реализацию должен обеспечивать производный класс.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает члены (свойства, методы, поля, события и т. д.) текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все открытые члены текущего объекта <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий все открытые члены текущего типа <see cref="T:System.Type" />.  
  
-или- 
Пустой массив типа <see cref="T:System.Reflection.MemberInfo" />, если у текущего типа <see cref="T:System.Type" /> нет открытых членов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Элементы включают свойства, методы, конструкторы, поля, события и вложенные типы.
  
 <xref:System.Type.GetMembers%2A> Метод не возвращает элементы в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются элементы, так как этот порядок меняется.  
  
 Эта перегрузка метода вызывает <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> перегрузку метода с <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> в Visual Basic). Его не удастся найти инициализаторы класса (статические конструкторы). Чтобы найти инициализаторы класса, вызовите <xref:System.Type.GetMembers(System.Reflection.BindingFlags)> перегружать и укажите <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Также можно получить с помощью инициализатор класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или членов <xref:System.Object> при возникновении без ограничения класса. 
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Type.GetMembers> перегруженный метод для сбора сведений о все открытые члены указанного класса.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</param>
        <summary>При переопределении в производном классе ищет члены, определенные для текущего объекта <see cref="T:System.Type" />, используя указанные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий все члены, определенные для текущего типа <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки.  
  
-или- 
Пустой массив, если для текущего объекта <see cref="T:System.Type" /> не определены члены или ни один из определенных членов не удовлетворяет ограничениям привязки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Элементы включают свойства, методы, конструкторы, поля, события и вложенные типы.

Для `GetMethods(BindingFlags)` перегрузки для успешного получения сведений о методе, `bindingAttr` аргумент должен содержать хотя бы один из <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, а также по крайней мере один из <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>. Единственное исключение — вызов метода с <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, которое возвращает член вложенные типы.

Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие члены следует включить в поиск: 

- Укажите `BindingFlags.Instance` для включения методов экземпляра. 

- Укажите `BindingFlags.Static` для включения статических методов. 
  
- Укажите `BindingFlags.Public` для включения в поиск открытых методов.  
  
- Укажите `BindingFlags.NonPublic` для включения в поиск неоткрытые методы (то есть внутренней, закрытые и защищенные методы). Только защищенные и внутренние методы базовых классов, возвращаются; закрытые методы базовых классов не возвращаются.  
  
- Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  

- Укажите `BindingFlags.Default` отдельно, чтобы возвратить пустую <xref:System.Reflection.MethodInfo> массива.

Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
- `BindingFlags.DeclaredOnly` для поиска только члены, объявленные на <xref:System.Type>, не те члены, унаследованные.  
  
Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  

<xref:System.Type.GetMembers%2A> Метод не возвращает элементы в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются элементы, так как этот порядок меняется.  

 Чтобы получить инициализатор класса (статический конструктор), с помощью этой перегрузки метода, необходимо указать <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Также можно получить с помощью инициализатор класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или членов <xref:System.Object> при возникновении без ограничения класса.  

## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> перегруженный метод для сбора сведений о всех членах открытые экземпляры указанного класса.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает заданный метод текущего класса <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого открытого метода.</param>
        <summary>Выполняет поиск открытого метода с заданным именем.</summary>
        <returns>Объект, представляющий открытый метод с заданным именем, если такой метод есть, и <see langword="null" />, если такого метода нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` чувствителен к регистру. Поиск включает общедоступный статический и открытые методы экземпляра.  
  
 Если метод перегружен и имеет более чем один открытый метод <xref:System.Type.GetMethod%28System.String%29> вызывает метод <xref:System.Reflection.AmbiguousMatchException> исключение. В следующем примере создается исключение, так как присутствует более одного общедоступного перегрузка <xref:System.Int32.ToString%2A?displayProperty=nameWithType> метод.  С другой стороны так как `Person.ToString` переопределения методов <xref:System.Object.ToString%2A?displayProperty=nameWithType> и поэтому не перегружен, <xref:System.Type.GetMethod%28System.String%29> метод способен получить <xref:System.Reflection.MethodInfo> объекта.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Необходимо выполнить одно из следующих действий, чтобы получить определенный метод:  
  
-   Вызовите <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> метод и указать `bindingAttr` аргумент, который однозначно определяет метод. Например, если исключение вызывается, поскольку тип имеет статический и перегрузку экземпляр, можно указать `bindingAttr` аргумент <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.  
  
-   Вызвать перегрузку <xref:System.Type.GetMethod%2A> метод, который включает в себя `types` параметр, который определяет типы параметров метода.  
  
-   Вызовите <xref:System.Type.GetMethods> метод для извлечения массив, содержащий все открытые методы, принадлежащие типу. Затем можно последовательно для идентификации повторяющихся методов с именем `name`.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при возникновении без ограничения класса.  
  
> [!NOTE]
>  Для универсальных методов, не используйте аргументы типа в `name`. К примеру, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст "`MyMethod<int>`«, а не для метод с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 В следующем примере возвращается метод с именем `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого метода.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <summary>Выполняет поиск указанного метода, используя заданные ограничения привязки.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения методов, включаемых в поиск:  
  
-   Необходимо указать либо <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> или <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> Чтобы получить возвращаемое значение.  
  
-   Укажите <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> для включения в поиск открытых методов.  
  
-   Укажите <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> для включения в поиск неоткрытые методы (то есть внутренней, закрытые и защищенные методы).  
  
-   Укажите <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> Чтобы игнорировать регистр `name`.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> для поиска только методы, объявленные на <xref:System.Type>, не те методы, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если метод перегружен и более одного перегруженного метода соответствует ограничениям, указанным по `bindingAttr` аргумент, метод вызывает <xref:System.Reflection.AmbiguousMatchException> исключение. В следующем примере возникает исключение из-за:  
  
-   `TestClass` Тип имеет две перегрузки открытого экземпляра `DisplayValue` метод, `DisplayValue(String)` и `DisplayValue(String, Object[])`.  
  
-   `TestClass` Тип имеет две перегрузки открытого экземпляра `Equals` метода, один из которых наследуется от <xref:System.Object>: `Equals(TestClass)` и `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Необходимо выполнить одно из следующих действий, чтобы получить определенный метод:  
  
-   Измените ограничения привязки. В предыдущем примере, попытка получить открытый экземпляр `Equals` извлекает метод, который объявляется по типу и не наследуется успешно `Equals(TestClass)`.  
  
-   Вызвать перегрузку <xref:System.Type.GetMethod%2A> метод, который включает в себя `types` параметр, который определяет типы параметров метода.  
  
-   Вызовите <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> метод для извлечения массив, содержащий все методы, принадлежащие типу с атрибутами указанную привязку. Затем можно последовательно для идентификации повторяющихся методов с именем `name`. Этот подход проиллюстрирован в предыдущем примере обработчик для <xref:System.Reflection.AmbiguousMatchException> исключение.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при возникновении без ограничения класса.  
  
> [!NOTE]
>  Для универсальных методов, не используйте аргументы типа в `name`. К примеру, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст "`MyMethod<int>`«, а не для метод с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 Следующий пример возвращает метод, который соответствует указанным флагам привязки.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого открытого метода.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.  
  
-или- 
Пустой массив объектов <see cref="T:System.Type" /> (в соответствии со значением поля <see cref="F:System.Type.EmptyTypes" />) для получения метода, не принимающего параметры.</param>
        <summary>Ищет указанный открытый метод, параметры которого соответствуют заданным типам аргументов.</summary>
        <returns>Объект, представляющий открытый метод, параметры которого соответствуют указанным типам аргументов, если они существуют, и <see langword="null" />, если их нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` чувствителен к регистру. Поиск включает общедоступный статический и открытые методы экземпляра.  
  
> [!NOTE]
>  Параметры нельзя опускать при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при возникновении без ограничения класса.  
  
> [!NOTE]
>  `name` Параметр не может включать аргументы типа. К примеру, код C# `GetMethod("MyGenericMethod<int>")` ищет метод с именем текст "`MyGenericMethod<int>`«, а не для метод с именем `MyGenericMethod` , имеет один аргумент универсального типа `int`. Вместо этого используйте `GetMethod("MyGenericMethod")` с соответствующим параметром в `types` массива.  
  
   
  
## Examples  
 В следующем примере вычисляется определенные перегрузки `MethodA`, задающие различные типы аргументов.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Примера требуется `/unsafe` параметр компилятора.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 В следующем примере извлекается <xref:System.Reflection.MethodInfo> объекты, представляющие `Add` методы, не являющегося универсальным типа ( <xref:System.Collections.ArrayList> класс), открытым универсальным типом ( <xref:System.Collections.Generic.List%601> класса) и закрытый универсальный тип ( `List(Of String)` типа.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 В примере определяется `GetAddMethod` метод, который получает соответствующий <xref:System.Reflection.MethodInfo> объекта. Для предоставления `types` аргумент для открытого универсального типа, он вызывает <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> метод. Для предоставления `types` аргумента для закрытого универсального типа, он извлекает значение <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> свойства.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем и заданными параметрами.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.  
  
-или- 
 <paramref name="types" /> — <see langword="null" />.  
  
-или- 
Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого открытого метода.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.  
  
-или- 
Пустой массив объектов <see cref="T:System.Type" /> (в соответствии со значением поля <see cref="F:System.Type.EmptyTypes" />) для получения метода, не принимающего параметры.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />. Используется только при вызове посредством COM-взаимодействия. При этом обрабатываются только параметры, переданные по ссылке. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Выполняет поиск указанного открытого метода, параметры которого соответствуют указанным типам аргументов и модификаторам.</summary>
        <returns>Если поиск выполнен успешно, возвращается объект, представляющий открытый метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что связыватель по умолчанию не выполняет <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательский модуль привязки, который выполняет обработку `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Поиск `name` чувствителен к регистру. Поиск включает общедоступный статический и открытые методы экземпляра.  
  
> [!NOTE]
>  Параметры нельзя опускать при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при возникновении без ограничения класса.  
  
> [!NOTE]
>  Для универсальных методов, не используйте аргументы типа в `name`. К примеру, код C# `GetMethod("MyMethod<int>")` ищет элемент с именем текст "`MyMethod<int>`«, а не для метод с именем `MyMethod` , имеет один аргумент универсального типа `int`. Вместо этого используйте `GetMethod("MyMethod")` с соответствующим параметром в `types` массива.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем и заданными параметрами.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.  
  
-или- 
 <paramref name="types" /> — <see langword="null" />.  
  
-или- 
Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.  
  
-или- 
 Массив <paramref name="modifiers" /> является многомерным.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого метода.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
-или- 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.  
  
-или- 
Пустой массив объектов <see cref="T:System.Type" /> (в соответствии со значением поля <see cref="F:System.Type.EmptyTypes" />) для получения метода, не принимающего параметры.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />. Используется только при вызове посредством COM-взаимодействия. При этом обрабатываются только параметры, переданные по ссылке. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Ищет заданный метод, параметры которого соответствуют указанным типам аргументов и модификаторам, используя установленные ограничения привязки.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что связыватель по умолчанию не выполняет <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательский модуль привязки, который выполняет обработку `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения методов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых методов.  
  
-   Укажите `BindingFlags.NonPublic` для включения закрытых методов (то есть внутренней, закрытые и защищенные методы) для поиска.  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только методы, объявленные на <xref:System.Type>, не те методы, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Параметры нельзя опускать при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при возникновении без ограничения класса.  
  
> [!NOTE]
>  Для универсальных методов, не используйте аргументы типа в `name`. К примеру, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст "`MyMethod<int>`«, а не для метод с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 В следующем примере вычисляется определенные перегрузки `MethodA`, указав ограничениям привязки и различных типов аргументов.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Примера требуется `/unsafe` параметр компилятора.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.  
  
-или- 
 <paramref name="types" /> — <see langword="null" />.  
  
-или- 
Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.  
  
-или- 
 Массив <paramref name="modifiers" /> является многомерным.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого метода.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
-или- 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Объект, определяющий набор применяемых правил, касающихся порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и способа очистки стека.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.  
  
-или- 
Пустой массив объектов <see cref="T:System.Type" /> (в соответствии со значением поля <see cref="F:System.Type.EmptyTypes" />) для получения метода, не принимающего параметры.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />. Используется только при вызове посредством COM-взаимодействия. При этом обрабатываются только параметры, переданные по ссылке. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Ищет метод с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений привязки и соглашений о вызовах.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что связыватель по умолчанию не выполняет <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательский модуль привязки, который выполняет обработку `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `GetXXX` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения методов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых методов.  
  
-   Укажите `BindingFlags.NonPublic` для включения закрытых методов (то есть внутренней, закрытые и защищенные методы) для поиска.  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только методы, объявленные на <xref:System.Type>, не те методы, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Параметры нельзя опускать при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при возникновении без ограничения класса.  
  
> [!NOTE]
>  Для универсальных методов, не используйте аргументы типа в `name`. К примеру, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст "`MyMethod<int>`«, а не для метод с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 В следующем примере вычисляется определенные перегрузки `MethodA`, указав ограничениям привязки, соглашения о вызовах и различных типов аргументов.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Примера требуется `/unsafe` параметр компилятора.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.  
  
-или- 
 <paramref name="types" /> — <see langword="null" />.  
  
-или- 
Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.  
  
-или- 
 Массив <paramref name="modifiers" /> является многомерным.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого метода.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
-или- 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Объект, который задает набор правил, используемых в зависимости от порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и процесса очистки стека.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.  
  
-или- 
Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить метод, который не имеет параметров.  
  
-или- 
 <see langword="null" />. Если значение параметра <paramref name="types" /> равно <see langword="null" />, аргументы метода не проверяются на соответствие условиям.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>При переопределении в производном классе ищет указанный метод, параметры которого соответствуют указанным типам аргументов и модификаторам, используя для этого заданные ограничения привязки и соглашение о вызовах.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что связыватель по умолчанию не выполняет <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательский модуль привязки, который выполняет обработку `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Если значение параметра `types` равно `null`, аргументы метода не проверяются на соответствие условиям.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения методов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых методов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск неоткрытые методы (то есть внутренней, закрытые и защищенные методы).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только методы, объявленные на <xref:System.Type>, не те методы, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.  
  
-или- 
 Массив <paramref name="modifiers" /> является многомерным.  
  
-или- 
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <exception cref="T:System.NotSupportedException">Текущий тип — <see cref="T:System.Reflection.Emit.TypeBuilder" /> или <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает методы текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все открытые методы текущего объекта <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MethodInfo" />, представляющий все открытые методы, определенные для текущего объекта <see cref="T:System.Type" />.  
  
-или- 
Пустой массив типа <see cref="T:System.Reflection.MethodInfo" />, если для текущего типа <see cref="T:System.Type" /> открытые методы не определены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Type.GetMethods%2A> Метод не возвращает методы в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются методы, так как этот порядок меняется.  
  
 Конструкторы не включаются в массив методов, возвращаемый при вызове этого метода. Создать отдельный вызов `GetConstructors()` для получения методов конструктора.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
> [!NOTE]
>  Параметры нельзя опускать при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при возникновении без ограничения класса.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.

-или-

 <see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</param>
        <summary>При переопределении в производном классе ищет методы, определенные для текущего объекта <see cref="T:System.Type" />, используя указанные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MethodInfo" />, представляющий все методы, определенные для текущего типа <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки.  
  
-или- 
Пустой массив типа <see cref="T:System.Reflection.MethodInfo" />, если для текущего объекта <see cref="T:System.Type" /> не определены методы или ни один из определенных методов не удовлетворяет ограничениям привязки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Для `GetMethods(BindingFlags)` перегрузки для успешного получения сведений о методе, `bindingAttr` аргумент должен содержать хотя бы один из <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, а также по крайней мере один из <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>. 
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения методов, включаемых в поиск:  
  
- Укажите `BindingFlags.Instance` для включения методов экземпляра. 

- Укажите `BindingFlags.Static` для включения статических методов. 
  
- Укажите `BindingFlags.Public` для включения в поиск открытых методов.  
  
- Укажите `BindingFlags.NonPublic` для включения в поиск неоткрытые методы (то есть внутренней, закрытые и защищенные методы). Только защищенные и внутренние методы базовых классов, возвращаются; закрытые методы базовых классов не возвращаются.  
  
- Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  

- Укажите `BindingFlags.Default` отдельно, чтобы возвратить пустую <xref:System.Reflection.MethodInfo> массива.
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
- `BindingFlags.DeclaredOnly` для поиска только методы, объявленные на <xref:System.Type>, не те методы, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  

<xref:System.Type.GetMethods%2A> Метод не возвращает методы в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются методы, так как этот порядок меняется.  

Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при возникновении без ограничения класса. 
  
## Examples  
 Следующий пример создает класс с два открытых метода и один защищенный метод, создает `Type` объект, соответствующий `MyTypeClass`, возвращает все открытые и неоткрытые методы и отображает их имена.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает определенный тип, вложенный в текущий объект <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого вложенного типа.</param>
        <summary>Выполняет поиск открытого вложенного типа с заданным именем.</summary>
        <returns>Объект, представляющий открытый вложенный тип с указанным именем, если тип есть, и <see langword="null" />, если такого типа нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` чувствителен к регистру.  
  
 Можно использовать простое имя вложенного класса для `name`. Не уточните его, указав имя внешнего класса. Для универсального вложенного класса следует использовать искаженное имя — то есть, добавление грависом и число универсальных аргументов. Например, используйте строку «внутреннее\`1» для получения универсального вложенных классов `Inner<T>` (`Inner(Of T)` в Visual Basic). Не используйте синтаксис конкретного языка для параметров типа.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет вложенные типы ограничения класса.  
  
 Если вложенный тип является универсальным, этот метод возвращает его определение универсального типа. Это справедливо, даже если включающий универсальный тип является закрытым сконструированным типом.  
  
> [!NOTE]
>  Если текущий <xref:System.Type> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если они имеют собственные имеет тех универсальных параметров. Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированные с использованием [Ilasm.exe (ассемблер IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Сведения о вложенных универсальных типов и о создании вложенных универсальных типов из их определений универсальных типов, см. в разделе <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого вложенного типа.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <summary>При переопределении в производном классе ищет указанный вложенный тип, используя заданные ограничения привязки.</summary>
        <returns>Если поиск выполнен успешно, возвращается объект, предоставляющий вложенный тип, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать простое имя вложенного класса для `name`. Не уточните его, указав имя внешнего класса. Для универсального вложенного класса следует использовать искаженное имя — то есть, добавление грависом и число универсальных параметров. Например, используйте строку «внутреннее\`1» для получения универсального вложенных классов `Inner<T>` (`Inner(Of T)` в Visual Basic). Не используйте синтаксис конкретного языка для параметров типа.  
  
 Следующие <xref:System.Reflection.BindingFlags> фильтра флаги можно использовать для определения, какие вложенные типы будут включены в поиск:  
  
-   Необходимо указать либо <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> или <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> получить возвращаемое значение.  
  
-   Укажите <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> для включения в поиск открытые вложенные типы.  
  
-   Укажите <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> для включения при поиске не являющиеся открытыми вложенные типы (то есть внутренней, закрытые и защищенные вложенные типы).  
  
 Этот метод возвращает только вложенные типы текущего типа. Он не выполняет поиск базовые классы для текущего типа. Чтобы найти типы, вложенные в базовых классах, вы должны пройти в иерархии наследования, вызвав <xref:System.Type.GetNestedType%2A> на каждом уровне.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> игнорируются.  
  
 Вызов этого метода только с <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> флаг или только <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> флаг Возвращает указанные вложенные типы и другие флаги не требуются.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет вложенные типы ограничения класса.  
  
 Если вложенный тип является универсальным, этот метод возвращает его определение универсального типа. Это справедливо, даже если включающий универсальный тип является закрытым сконструированным типом.  
  
> [!NOTE]
>  Если текущий <xref:System.Type> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если они имеют собственные имеет тех универсальных параметров. Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированные с использованием [Ilasm.exe (ассемблер IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Сведения о вложенных универсальных типов и о создании вложенных универсальных типов из их определений универсальных типов, см. в разделе <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает типы, вложенные в текущий объект <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает открытые типы, вложенные в текущий объект <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, представляющий открытые типы, вложенные в текущий объект <see cref="T:System.Type" /> (нерекурсивный поиск), или пустой массив типа <see cref="T:System.Type" />, если в текущий объект <see cref="T:System.Type" /> не вложен ни один открытый тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A> Метод не возвращает типы в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются типы, так как этот порядок меняется.  
  
 Возвращаются только открытые типы, непосредственно вложенные в текущий тип; Поиск не является рекурсивным.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет вложенные типы ограничения класса.  
  
 Если вложенный тип является универсальным, этот метод возвращает его определение универсального типа. Это справедливо, даже если включающий универсальный тип является закрытым сконструированным типом.  
  
> [!NOTE]
>  Если текущий <xref:System.Type> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если они имеют собственные имеет тех универсальных параметров. Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированные с использованием [Ilasm.exe (ассемблер IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Сведения о вложенных универсальных типов и о создании вложенных универсальных типов из их определений универсальных типов, см. в разделе <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере определяется вложенный класс и `struct` в `MyClass`и затем получает объекты вложенных типов, с использованием типа `MyClass`.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <summary>При переопределении в производном классе ищет типы, вложенные в текущий объект <see cref="T:System.Type" />, используя заданные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, представляющий все типы, вложенные в текущий объект <see cref="T:System.Type" />, удовлетворяющий заданным ограничениям привязки (нерекурсивный поиск), или пустой массив типа <see cref="T:System.Type" />, если вложенные типы, удовлетворяющие ограничениям привязки, не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск вложенных типов не является рекурсивным.  
  
 <xref:System.Type.GetNestedTypes%2A> Метод не возвращает типы в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются типы, так как этот порядок меняется.  
  
 Следующие <xref:System.Reflection.BindingFlags> фильтра флаги можно использовать для определения, какие вложенные типы будут включены в поиск:  
  
-   Необходимо указать либо <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> или <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> получить возвращаемое значение.  
  
-   Укажите <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> для включения в поиск открытые вложенные типы.  
  
-   Укажите <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> для включения при поиске не являющиеся открытыми вложенные типы (то есть внутренней, закрытые и защищенные вложенные типы).  
  
 Этот метод возвращает только вложенные типы текущего типа. Он не выполняет поиск базовые классы для текущего типа. Чтобы найти типы, вложенные в базовых классах, вы должны пройти в иерархии наследования, вызвав <xref:System.Type.GetNestedTypes%2A> на каждом уровне.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> игнорируются.  
  
 Вызов этого метода только с <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> флаг или только <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> флаг Возвращает указанные вложенные типы и другие флаги не требуются.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет вложенные типы ограничения класса.  
  
 Если вложенный тип является универсальным, этот метод возвращает его определение универсального типа. Это справедливо, даже если включающий универсальный тип является закрытым сконструированным типом.  
  
> [!NOTE]
>  Если текущий <xref:System.Type> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если они имеют собственные имеет тех универсальных параметров. Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированные с использованием [Ilasm.exe (ассемблер IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Сведения о вложенных универсальных типов и о создании вложенных универсальных типов из их определений универсальных типов, см. в разделе <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 Следующий пример создает два вложенных открытых классов и два вложенных класса защищенных и выводятся сведения о классах, которые соответствуют указанным ограничениям привязки.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает свойства текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все открытые свойства текущего объекта <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.PropertyInfo" />, представляющий все открытые свойства текущего типа <see cref="T:System.Type" />.  
  
-или- 
Пустой массив типа <see cref="T:System.Reflection.PropertyInfo" />, если у текущего типа <see cref="T:System.Type" /> нет открытых свойств.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этой перегрузки, аналогичен вызову <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> перегрузка с `bindingAttr` аргумент равен `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` в C# и `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` в Visual Basic. Он возвращает все открытые экземпляры и статические свойства, которые определяется типом, представленный текущим <xref:System.Type> объекта, а также тех, унаследованные от базовых типов.  
  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения, с помощью `Or`) для его получения.  
  
 <xref:System.Type.GetProperties%2A> Метод не возвращает свойства в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются свойства, так как этот порядок меняется.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
   
  
## Examples  
 В следующем примере иллюстрируется использование метода `GetProperties`.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.

-или-

 <see cref="F:System.Reflection.BindingFlags.Default" /> для возврата пустого массива.</param>
        <summary>При переопределении в производном классе ищет свойства текущего объекта <see cref="T:System.Type" />, используя указанные ограничения привязки.</summary>
        <returns>Массив объектов, представляющий все свойства текущего <see cref="T:System.Type" />, которые удовлетворяют указанным ограничениям привязки.  
  
-или- 
Пустой массив типа <see cref="T:System.Reflection.PropertyInfo" />, если у текущего типа <see cref="T:System.Type" /> нет свойств или ни одно свойство не удовлетворяет ограничениям привязки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Для `GetProperties(BindingFlags)` перегрузки для успешного получения сведений о свойствах, `bindingAttr` аргумент должен содержать хотя бы один из <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, а также по крайней мере один из <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>. 

Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие свойства следует включить в поиск:  
  
- Укажите `BindingFlags.Instance` для включения методов экземпляра. 

- Укажите `BindingFlags.Static` для включения статических методов. 
  
- Укажите `BindingFlags.Public` для включения в поиск открытые свойства. Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. 
  
- Укажите `BindingFlags.NonPublic` для включения в поиск свойств не являющиеся открытыми (то есть внутренней, закрытые и защищенные свойства). Только защищенные и внутренние свойства базовых классов, возвращаются; частные свойства базовых классов не возвращаются.  
  
- Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  

- Укажите `BindingFlags.Default` отдельно, чтобы возвратить пустую <xref:System.Reflection.PropertyInfo> массива.

 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
- `BindingFlags.DeclaredOnly` для поиска только свойства, объявленные в <xref:System.Type>, не те свойства, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
<xref:System.Type.GetProperties%2A> Метод не возвращает свойства в определенном порядке, такие как алфавитном или в порядке объявления. Ваш код не должен зависеть от порядка, в котором возвращаются свойства, так как этот порядок меняется.  

 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
   
  
## Examples  
 В следующем примере определяется класс с именем `PropertyClass` , включает в себя шесть свойств: два являются открытыми, один является закрытым, один защищен, один является внутренним (`Friend` в Visual Basic), и один protected internal (`Protected Friend` в Visual Basic). Затем он отобразит сведения о некоторых основных свойств (имя и тип, следует ли это чтение и запись и видимость его `get` и `set` методы доступа) для свойств, которые соответствуют указанным ограничениям привязки.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает указанное свойство текущего класса <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая искомое имя открытого свойства.</param>
        <summary>Выполняет поиск открытого свойства с заданным именем.</summary>
        <returns>Объект, представляющий открытое свойство с заданным именем, если такое свойство есть, и <see langword="null" />, если такого свойства нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` чувствителен к регистру. Поиск включает общедоступный статический и открытый экземпляр свойства.  
  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения, с помощью `Or`) для его получения.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
 В ситуациях, когда <xref:System.Reflection.AmbiguousMatchException> происходит включают следующее:  
  
-   Тип содержит два индексированные свойства, которые имеют одинаковое имя, но различное число параметров. Чтобы устранить неоднозначность, используйте перегрузку <xref:System.Type.GetProperty%2A> метод, который задает типы параметров.  
  
-   Производный тип объявляет свойство, которое скрывает унаследованное свойство с тем же именем, с помощью `new` модификатор (`Shadows` в Visual Basic). Чтобы устранить неоднозначность, используйте <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> перегрузки метода и добавьте <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> флаг для ограничения поиска к элементам, которые не наследуются.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] упрощенный синтаксис для доступа к индексированным свойствам и разрешить одно индексированное свойство по умолчанию для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Свойство можно перегрузить.  
  
 В C#, эта функция вызывается индексатором и не может ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, разработчик библиотеки класса можно использовать <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
   
  
## Examples  
 В следующем примере извлекается `Type` объекта класса определяемых пользователем, извлекается свойство этого класса и отображает имя свойства.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 Это свойство имеет внутреннее в метаданных по имени «Item». Любая попытка получить `PropertyInfo` с помощью отражения необходимо указать это внутреннее имя, чтобы правильно возвращает `PropertyInfo` свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащий имя искомого свойства.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
<see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <summary>Ищет указанное свойство, используя заданные ограничения привязки.</summary>
        <returns>Объект, предоставляющий свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения, с помощью `Or`) для его получения.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие свойства следует включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытые свойства.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск свойств не являющиеся открытыми (то есть внутренней, закрытые и защищенные свойства).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только свойства, объявленные в <xref:System.Type>, не те свойства, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
 В ситуациях, когда <xref:System.Reflection.AmbiguousMatchException> происходит включают следующее:  
  
-   Тип содержит два индексированные свойства, которые имеют одинаковое имя, но различное число параметров. Чтобы устранить неоднозначность, используйте перегрузку <xref:System.Type.GetProperty%2A> метод, который задает типы параметров.  
  
-   Производный тип объявляет свойство, которое скрывает унаследованное свойство с тем же именем, с помощью `new` модификатор (`Shadows` в Visual Basic). Чтобы устранить неоднозначность, включите <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> для ограничения поиска к элементам, которые не наследуются.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] упрощенный синтаксис для доступа к индексированным свойствам и разрешить одно индексированное свойство по умолчанию для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Свойство можно перегрузить.  
  
 В C#, эта функция вызывается индексатором и не может ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, разработчик библиотеки класса можно использовать <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
   
  
## Examples  
 В следующем примере извлекается тип пользовательского класса, извлекается свойство этого класса и отображает имя свойства в соответствии с указанным ограничениям привязки.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем и соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая искомое имя открытого свойства.</param>
        <param name="returnType">Возвращаемый тип свойства.</param>
        <summary>Выполняет поиск открытого свойства с заданным именем и типом возвращаемого значения.</summary>
        <returns>Объект, представляющий открытое свойство с заданным именем, если такое свойство есть, и <see langword="null" />, если такого свойства нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения, с помощью `Or`) для его получения.  
  
 Поиск `name` чувствителен к регистру. Поиск включает общедоступный статический и открытый экземпляр свойства.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] упрощенный синтаксис для доступа к индексированным свойствам и разрешить одно индексированное свойство по умолчанию для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Свойство можно перегрузить.  
  
 В C#, эта функция вызывается индексатором и не может ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, разработчик библиотеки класса можно использовать <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
   
  
## Examples  
 В следующем примере определяется класс с одним свойством и возвращает имя и тип свойства.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> имеет значение <see langword="null" />, или <paramref name="returnType" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая искомое имя открытого свойства.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого индексированного свойства.  
  
-или- 
Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</param>
        <summary>Ищет указанное открытое свойство, параметры которого соответствуют указанным типам аргументов.</summary>
        <returns>Объект, представляющий открытое свойство, параметры которого соответствуют указанным типам аргументов, если таковые найдены; в противном случае — <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения, с помощью `Or`) для его получения.  
  
 Поиск `name` чувствителен к регистру. Поиск включает общедоступный статический и открытый экземпляр свойства.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] упрощенный синтаксис для доступа к индексированным свойствам и разрешить одно индексированное свойство по умолчанию для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Свойство можно перегрузить.  
  
 В C#, эта функция вызывается индексатором и не может ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, разработчик библиотеки класса можно использовать <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
   
  
## Examples  
 В следующем примере извлекается `Type` извлекает свойства этого класса объект этого класса, определяемые пользователем и отображает имя свойства и тип свойства, заданные аргументы, передаваемые `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем и соответствующих указанным типам аргументов.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.  
  
-или- 
 <paramref name="types" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.</exception>
        <exception cref="T:System.NullReferenceException">Элемент <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая искомое имя открытого свойства.</param>
        <param name="returnType">Возвращаемый тип свойства.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого индексированного свойства.  
  
-или- 
Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</param>
        <summary>Ищет указанное открытое свойство, параметры которого соответствуют указанным типам аргументов.</summary>
        <returns>Объект, представляющий открытое свойство, параметры которого соответствуют указанным типам аргументов, если таковые найдены; в противном случае — <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения, с помощью `Or`) для его получения.  
  
 Поиск `name` чувствителен к регистру. Поиск включает общедоступный статический и открытый экземпляр свойства.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] упрощенный синтаксис для доступа к индексированным свойствам и разрешить одно индексированное свойство по умолчанию для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Свойство можно перегрузить.  
  
 В C#, эта функция вызывается индексатором и не может ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, разработчик библиотеки класса можно использовать <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем и соответствующих указанным типам аргументов.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.  
  
-или- 
 <paramref name="types" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.</exception>
        <exception cref="T:System.NullReferenceException">Элемент <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая искомое имя открытого свойства.</param>
        <param name="returnType">Возвращаемый тип свойства.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого индексированного свойства.  
  
-или- 
Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Ищет заданное открытое свойство, параметры которого соответствуют указанным типам аргументов и модификаторам.</summary>
        <returns>Объект, представляющий открытое свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения, с помощью `Or`) для его получения.  
  
 Несмотря на то, что связыватель по умолчанию не выполняет <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательский модуль привязки, который выполняет обработку `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Поиск `name` чувствителен к регистру. Поиск включает общедоступный статический и открытый экземпляр свойства.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] упрощенный синтаксис для доступа к индексированным свойствам и разрешить одно индексированное свойство по умолчанию для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Свойство можно перегрузить.  
  
 В C#, эта функция вызывается индексатором и не может ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, разработчик библиотеки класса можно использовать <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
   
  
## Examples  
 Следующий пример получает `Type` объект, соответствующий `MyPropertyClass`, и индексированного свойства этого класса получаются с помощью аргументы, передаваемые `GetProperty` метод.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем и соответствующих указанным типам аргументов и модификаторам.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.  
  
-или- 
 <paramref name="types" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.  
  
-или- 
 Массив <paramref name="modifiers" /> является многомерным.  
  
-или- 
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <exception cref="T:System.NullReferenceException">Элемент <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащий имя искомого свойства.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
-или- 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Возвращаемый тип свойства.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого индексированного свойства.  
  
-или- 
Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Ищет свойство с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений привязки.</summary>
        <returns>Объект, предоставляющий свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединить значения, с помощью `Or`) для его получения.  
  
 Несмотря на то, что связыватель по умолчанию не выполняет <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательский модуль привязки, который выполняет обработку `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие свойства следует включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытые свойства.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск свойств не являющиеся открытыми (то есть внутренней, закрытые и защищенные свойства).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только свойства, объявленные в <xref:System.Type>, не те свойства, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] упрощенный синтаксис для доступа к индексированным свойствам и разрешить одно индексированное свойство по умолчанию для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Свойство можно перегрузить.  
  
 В C#, эта функция вызывается индексатором и не может ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, разработчик библиотеки класса можно использовать <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем и соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.  
  
-или- 
 <paramref name="types" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.  
  
-или- 
 Массив <paramref name="modifiers" /> является многомерным.  
  
-или- 
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <exception cref="T:System.NullReferenceException">Элемент <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащий имя искомого свойства.</param>
        <param name="bindingAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска.  
  
-или- 
 <see cref="System.Reflection.BindingFlags.Default" /> для возврата <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженного члена, приведение типов аргументов и вызов члена с помощью отражения.  
  
-или- 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Возвращаемый тип свойства.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого индексированного свойства.  
  
-или- 
Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="types" />. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>При переопределении в производном классе выполняет поиск заданного свойства, параметры которого соответствуют типам и модификаторам заданных аргументов, с использованием заданных ограничений привязки.</summary>
        <returns>Объект, предоставляющий свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что связыватель по умолчанию не выполняет <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательский модуль привязки, который выполняет обработку `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие свойства следует включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` Чтобы получить возвращаемое значение.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытые свойства.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск свойств не являющиеся открытыми (то есть внутренней, закрытые и защищенные свойства).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверху иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только свойства, объявленные в <xref:System.Type>, не те свойства, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем и соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.  
  
-или- 
 <paramref name="types" /> — <see langword="null" />.  
  
-или- 
Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="types" /> является многомерным.  
  
-или- 
 Массив <paramref name="modifiers" /> является многомерным.  
  
-или- 
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <exception cref="T:System.NotSupportedException">Текущий тип — <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> или <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, предоставляющий указанный тип.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает текущий <see cref="T:System.Type" />.</summary>
        <returns>Текущий контекст <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Указание полных имен типов</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя искомого типа с указанием сборки. См. раздел <see cref="P:System.Type.AssemblyQualifiedName" />. Если тип находится в выполняемой в данный момент сборке или библиотеке Mscorlib.dll, достаточно предоставить имя типа с указанием пространства имен.</param>
        <summary>Возвращает объект <see cref="T:System.Type" /> с указанным именем, учитывая при поиске регистр.</summary>
        <returns>Тип с указанным именем, если он существует; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Type.GetType%2A> метод, чтобы получить <xref:System.Type> объекта для типа в другой сборке, если вы знаете его имя с указанием сборки, который можно получить из <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> приводит к загрузке сборки, указанной в `typeName`. Вы также можете загрузить сборки с помощью <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод, а затем использовать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> метод для получения <xref:System.Type> объектов. Если тип находится в сборке во время компиляции неизвестен в программу, это более эффективно использовать `typeof` в C# или `GetType` оператор в Visual Basic.
  
> [!NOTE]
>  Если `typeName` отсутствует, вызов <xref:System.Type.GetType%28System.String%29> возвращает метод `null`. Он не вызывает исключение. Для управления ли исключение, вызовите перегрузку <xref:System.Type.GetType%2A> метод, который имеет `throwOnError` параметра.  
  
 <xref:System.Type.GetType%2A> работает только на сборки, загруженные с диска. При вызове метода <xref:System.Type.GetType%2A> для поиска типа, определенного в динамическую сборку с использованием <xref:System.Reflection.Emit> служб, могут быть неверными. Поведение зависит от того, ли динамическая сборка является постоянным, то есть, созданные с помощью `RunAndSave` или `Save` режимов доступа <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> перечисления. Если динамическая сборка сохраняется и будет записана на диск перед `GetType` — вызывается, загрузчик найдет сохраненную сборку на диске, загружает эту сборку и возвращает тип из этой сборки. Если сборка не была сохранена на диск, когда `GetType` вызывается, метод возвращает `null`. `GetType` не поддерживает временные динамические сборки; Таким образом, вызов `GetType` для извлечения типа во временную динамическую сборку возвращает `null`.  
  
 Чтобы использовать `GetType` для динамического модуля, Подпишитесь на <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> событий и вызовов `GetType` перед сохранением. В противном случае вы получите две копии сборки в памяти.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Массивы или COM-типы не производится, если они уже были загружены в таблицу доступных классов.  
  
 `typeName` может быть имя типа с указанием его пространство имен или имя с указанием сборки, включающий спецификации имени сборки. См. раздел <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Если `typeName` включает в себя пространство имен, но не имя сборки, этот метод выполняет поиск только в сборке вызывающего объекта и библиотеки Mscorlib.dll, в указанном порядке. Если полное имя сборки частичного или полного typeName, этот метод выполняет поиск в указанной сборке. Если сборка имеет строгое имя, полное имя сборки не требуется.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Свойство возвращает полное имя, включая вложенные типы, имя сборки и аргументы универсального типа. Все компиляторы, которые поддерживают среда CLR будет выдавать простое имя вложенного класса, а отражение создает искаженное имя при запросе, в соответствии со следующими соглашениями.  
  
> [!NOTE]
>  В .NET Framework версии 2.0 архитектура процессора добавляется удостоверения сборки и может быть указан как часть строки имени сборки. Например «ProcessorArchitecture = msil». Тем не менее, он не включен в строку, возвращаемую <xref:System.Type.AssemblyQualifiedName%2A> свойство, по соображениям совместимости. Можно также загрузить типы, создав <xref:System.Reflection.AssemblyName> объекта и передачи его в соответствующую перегрузку <xref:System.Reflection.Assembly.Load%2A> метод. Затем можно использовать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> метод, чтобы загрузить типы из сборки. См. также раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|разделитель|Значение|  
|---------------|-------------|  
|Обратная косая черта (\\)|Escape-символ.|  
|Обратный апостроф (')|Предшествует одной или нескольких цифр, представляющее число параметров типа, находится в конце имени универсального типа.|  
|Квадратные скобки ([])|Заключите список аргументов универсального типа для сконструированного универсального типа; в список аргументов типа заключите типа с указанием сборки.|  
|Запятая ()|Предшествует имени сборки.|  
|Точка (.)|Определяет идентификаторы пространства имен.|  
|Знак плюс (+)|Перед вложенным классом.|  
  
 Например полное имя класса может выглядеть следующим образом:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Если было TopNamespace.Sub+Namespace, то строка пришлось бы предшествовать знак плюс (+) с escape-символ (\\) для предотвращения его обрабатывались как разделитель вложений. Отражение порождает эту строку следующим образом:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Объект «++» становится "\\+\\+» и"\\«становится»\\\\«.  
  
 Это полное имя можно сохраняются и впоследствии использовать для загрузки <xref:System.Type>. Чтобы найти и загрузить <xref:System.Type>, использовать <xref:System.Type.GetType%2A> либо с типом имя, либо только имя типа с указанием сборки. <xref:System.Type.GetType%2A> с типом имя только будет искать <xref:System.Type> в сборке вызывающего, а затем в системную сборку. <xref:System.Type.GetType%2A> в сборке будет искать имя типа с указанием <xref:System.Type> в любой сборке.  
  
 Имена типов могут включать конечные символы, определяющие дополнительные сведения о типе, например, является ли тип ссылочным типом, тип указателя или тип массива. Получить имя типа без этих конечных символов, с помощью `t.GetElementType().ToString()`, где `t` — это тип.  
  
 Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки. В имени сборки пробелы перед разделителем «,» существенны, но пробелы после разделителя «,» игнорируются.  
  
 Имя универсального типа заканчивается — обратный апостроф (\`) следуют цифры, представляющее число аргументов универсального типа. Искажение имени предназначена для обеспечения поддержки универсальных типов с одинаковым именем, но с разным числом параметров типа, происходящих в той же области. Например, отражения возвращает искаженные имена `Tuple`1` and `кортежа`2` из универсальных методов `Tuple(Of T)` и `Tuple(Of T0, T1)` в Visual Basic или `Tuple<T>` и кортежа`\<T0, T1>` в Visual C#.  
  
 Для универсальных типов заключается в квадратные скобки список аргументов типа и аргументы типа разделяются запятыми. Например, универсальный <xref:System.Collections.Generic.Dictionary%602> имеет два параметра типа. Объект <xref:System.Collections.Generic.Dictionary%602> из `MyType` с ключами типа <xref:System.String> может быть представлен следующим образом:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Для указания типа с указанием сборки в список аргументов типа, заключите его в квадратных скобках указывается тип с указанием сборки. В противном случае запятых, разделяющих частей имени с указанием сборки, интерпретируются как разделители дополнительных аргументов типа. Например <xref:System.Collections.Generic.Dictionary%602> из `MyType` fromMyAssembly.dll с ключами типа <xref:System.String>, может быть указан следующим образом:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Тип с указанием сборки могут быть заключены в квадратные скобки, только в том случае, когда он появится в списке параметров типа. Правила поиска сборок для полных и неполных типов в список параметров типа совпадают с правила для полных и неполных неуниверсальных типов.  
  
 Обнуляемые типы представляют собой особый случай универсальных типов. Например, для типа <xref:System.Int32> представлена строкой «System.Nullable'1[System.Int32]».  
  
> [!NOTE]
>  В C#, C++ и Visual Basic можно также получить обнуляемые типы, с помощью операторов типов. Например, допускающий значение NULL <xref:System.Boolean> возвращаемый тип `typeof(Nullable<bool>)` в C#, `Nullable<Boolean>::typeid` в C++, а также по `GetType(Nullable(Of Boolean))` в Visual Basic.  
  
 В следующей таблице показаны синтаксис, используемом с `GetType` для различных типов.  
  
|Чтобы получить|Использовать|  
|------------|---------|  
|Значение необязательной определенности <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Неуправляемый указатель на `MyType`|`Type.GetType("MyType*")`|  
|Неуправляемый указатель на указатель на `MyType`|`Type.GetType("MyType**")`|  
|Управляемый указатель или ссылка на `MyType`|`Type.GetType("MyType&")`. Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.|  
|Родительский и вложенный класс|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Одномерный массив с нижней границей, равной 0|`Type.GetType("MyType[]")`|  
|Одномерный массив с неизвестной нижней границей|`Type.GetType("MyType[*]")`|  
|N мерный массив|Запятая (,) внутри квадратных скобок n-1 раз. Например `System.Object[,,]` представляет трехмерный массив `Object` массива.|  
|Массив одномерных массивов|`Type.GetType("MyType[][]")`|  
|Прямоугольный двухмерный массив с неизвестными нижними границами|`Type.GetType("MyType[,]")`|  
|Универсальный тип с одним аргументом типа|``Type.GetType("MyGenericType`1[MyType]")``|  
|Универсальный тип с двумя аргументами типа|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Универсальный тип с двумя аргументами типа сборки|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|С указанием сборки универсального типа с аргументом типа сборки|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Универсальный тип, тип аргумента является универсальным типом с двумя аргументами типа|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 В следующем примере извлекается тип `System.Int32` и используется для отображения этого объекта <xref:System.Type.FullName%2A> свойство `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 Сборка или одна из ее зависимостей найдена, но не может быть загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
-или- 
В текущий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка была скомпилирована в более поздней версии.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Указание полных имен типов</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя искомого типа с указанием сборки. См. раздел <see cref="P:System.Type.AssemblyQualifiedName" />. Если тип находится в выполняемой в данный момент сборке или библиотеке Mscorlib.dll, достаточно предоставить имя типа с указанием пространства имен.</param>
        <param name="throwOnError">Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />. Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них. См. раздел "Исключения".</param>
        <summary>Возвращает объект <see cref="T:System.Type" /> с заданным именем, выполняя поиск с учетом регистра и указывая, будет ли создаваться исключение в случае невозможности найти тип.</summary>
        <returns>Тип с указанным именем. Если тип не найден, параметр <paramref name="throwOnError" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения. В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwOnError" />. См. раздел "Исключения".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Type.GetType%2A> метод, чтобы получить <xref:System.Type> объекта для типа в другой сборке, если вы знаете его имя с указанием сборки, который можно получить из <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> приводит к загрузке сборки, указанной в `typeName`. Вы также можете загрузить сборки с помощью <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод, а затем использовать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> метод для получения <xref:System.Type> объектов. Если тип находится в сборке во время компиляции неизвестен в программу, это более эффективно использовать `typeof` в C# или `GetType` оператор в Visual Basic.
  
 `GetType` работает только на сборки, загруженные с диска. При вызове метода `GetType` для поиска типа, определенного в динамическую сборку с использованием <xref:System.Reflection.Emit> служб, могут быть неверными. Поведение зависит от того, ли динамическая сборка является постоянным, то есть, созданные с помощью `RunAndSave` или `Save` режимов доступа <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> перечисления. Если динамическая сборка сохраняется и будет записана на диск перед `GetType` — вызывается, загрузчик найдет сохраненную сборку на диске, загружает эту сборку и возвращает тип из этой сборки. Если сборка не была сохранена на диск, когда `GetType` вызывается, метод возвращает `null`. `GetType` не поддерживает временные динамические сборки; Таким образом, вызов `GetType` для извлечения типа во временную динамическую сборку возвращает `null`.  
  
 Чтобы использовать `GetType` для динамического модуля, Подпишитесь на <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> событий и вызовов `GetType` перед сохранением. В противном случае вы получите две копии сборки в памяти.  
  
 `throwOnError` Параметр указывает, что произойдет, если тип не найден, а также подавляются некоторые другие условия исключения, как описано в раздел "исключения". Некоторые исключения создаются независимо от значения `throwOnError`. Например, если найден тип, но не может быть загружен <xref:System.TypeLoadException> возникает даже в том случае, если `throwOnError` является `false`.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Массивы или COM-типы не производится, если они уже были загружены в таблицу доступных классов.  
  
 `typeName` может быть имя типа с указанием его пространство имен или имя с указанием сборки, включающий спецификации имени сборки. См. раздел <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Если `typeName` включает в себя пространство имен, но не имя сборки, этот метод выполняет поиск только в сборке вызывающего объекта и библиотеки Mscorlib.dll, в указанном порядке. Если полное имя сборки частичного или полного typeName, этот метод выполняет поиск в указанной сборке. Если сборка имеет строгое имя, полное имя сборки не требуется.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Свойство возвращает полное имя, включая вложенные типы, имя сборки и универсальных аргументов. Все компиляторы, которые поддерживают среда CLR будет выдавать простое имя вложенного класса, а отражение создает искаженное имя при запросе, в соответствии со следующими соглашениями.  
  
> [!NOTE]
>  В .NET Framework версии 2.0 архитектура процессора добавляется удостоверения сборки и может быть указан как часть строки имени сборки. Например «ProcessorArchitecture = msil». Тем не менее, он не включен в строку, возвращаемую <xref:System.Type.AssemblyQualifiedName%2A> свойство, по соображениям совместимости. Можно также загрузить типы, создав <xref:System.Reflection.AssemblyName> объекта и передачи его в соответствующую перегрузку <xref:System.Reflection.Assembly.Load%2A> метод. Затем можно использовать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> метод, чтобы загрузить типы из сборки. См. также раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|разделитель|Значение|  
|---------------|-------------|  
|Обратная косая черта (\\)|Escape-символ.|  
|Обратный апостроф (')|Предшествует одной или нескольких цифр, представляющее число параметров типа, находится в конце имени универсального типа.|  
|Квадратные скобки ([])|Заключите список аргументов универсального типа для сконструированного универсального типа; в список аргументов типа заключите типа с указанием сборки.|  
|Запятая ()|Предшествует имени сборки.|  
|Точка (.)|Определяет идентификаторы пространства имен.|  
|Знак плюс (+)|Перед вложенным классом.|  
  
 Например полное имя класса может выглядеть следующим образом:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Если было TopNamespace.Sub+Namespace, то строка пришлось бы предшествовать знак плюс (+) с escape-символ (\\) для предотвращения его обрабатывались как разделитель вложений. Отражение порождает эту строку следующим образом:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Объект «++» становится "\\+\\+» и"\\«становится»\\\\«.  
  
 Это полное имя можно сохраняются и впоследствии использовать для загрузки <xref:System.Type>. Чтобы найти и загрузить <xref:System.Type>, использовать <xref:System.Type.GetType%2A> либо с типом имя, либо только имя типа с указанием сборки. <xref:System.Type.GetType%2A> с типом имя только будет искать <xref:System.Type> в сборке вызывающего, а затем в системную сборку. <xref:System.Type.GetType%2A> в сборке будет искать имя типа с указанием <xref:System.Type> в любой сборке.  
  
 Имена типов могут включать конечные символы, определяющие дополнительные сведения о типе, например, является ли тип ссылочным типом, тип указателя или тип массива. Получить имя типа без этих конечных символов, с помощью `t.GetElementType().ToString()`, где `t` — это тип.  
  
 Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки. В имени сборки пробелы перед разделителем «,» существенны, но пробелы после разделителя «,» игнорируются.  
  
 Имя универсального типа заканчивается — обратный апостроф (\`) следуют цифры, представляющее число аргументов универсального типа. Искажение имени предназначена для обеспечения поддержки универсальных типов с одинаковым именем, но с разным числом параметров типа, происходящих в той же области. Например, отражения возвращает искаженные имена `Tuple`1` and `кортежа`2` из универсальных методов `Tuple(Of T)` и `Tuple(Of T0, T1)` в Visual Basic или `Tuple<T>` и кортежа`\<T0, T1>` в Visual C#.  
  
 Для универсальных типов заключается в квадратные скобки список аргументов типа и аргументы типа разделяются запятыми. Например, универсальный <xref:System.Collections.Generic.Dictionary%602> имеет два параметра типа. Объект <xref:System.Collections.Generic.Dictionary%602> из `MyType` с ключами типа <xref:System.String> может быть представлен следующим образом:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Для указания типа с указанием сборки в список аргументов типа, заключите его в квадратных скобках указывается тип с указанием сборки. В противном случае запятых, разделяющих частей имени с указанием сборки, интерпретируются как разделители дополнительных аргументов типа. Например <xref:System.Collections.Generic.Dictionary%602> из `MyType` из MyAssembly.dll, с помощью ключей типа <xref:System.String>, может быть указан следующим образом:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Тип с указанием сборки могут быть заключены в квадратные скобки, только в том случае, когда он появится в списке параметров типа. Правила поиска сборок для полных и неполных типов в список параметров типа совпадают с правила для полных и неполных неуниверсальных типов.  
  
 Обнуляемые типы представляют собой особый случай универсальных типов. Например, для типа <xref:System.Int32> представлена строкой «System.Nullable'1[System.Int32]».  
  
> [!NOTE]
>  В C#, C++ и Visual Basic можно также получить обнуляемые типы, с помощью операторов типов. Например, допускающий значение NULL <xref:System.Boolean> возвращаемый тип `typeof(Nullable<bool>)` в C#, `Nullable<Boolean>::typeid` в C++, а также по `GetType(Nullable(Of Boolean))` в Visual Basic.  
  
 В следующей таблице показаны синтаксис, используемом с `GetType` для различных типов.  
  
|Чтобы получить|Использовать|  
|------------|---------|  
|Значение необязательной определенности <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Неуправляемый указатель на `MyType`|`Type.GetType("MyType*")`|  
|Неуправляемый указатель на указатель на `MyType`|`Type.GetType("MyType**")`|  
|Управляемый указатель или ссылка на `MyType`|`Type.GetType("MyType&")`. Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.|  
|Родительский и вложенный класс|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Одномерный массив с нижней границей, равной 0|`Type.GetType("MyArray[]")`|  
|Одномерный массив с неизвестной нижней границей|`Type.GetType("MyArray[*]")`|  
|N мерный массив|Запятая (,) внутри квадратных скобок n-1 раз. Например `System.Object[,,]` представляет трехмерный массив `Object` массива.|  
|Двумерный массив массива|`Type.GetType("MyArray[][]")`|  
|Прямоугольный двухмерный массив с неизвестными нижними границами|`Type.GetType("MyArray[,]")`|  
|Универсальный тип с одним аргументом типа|``Type.GetType("MyGenericType`1[MyType]")``|  
|Универсальный тип с двумя аргументами типа|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Универсальный тип с двумя аргументами типа сборки|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|С указанием сборки универсального типа с аргументом типа сборки|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Универсальный тип, тип аргумента является универсальным типом с двумя аргументами типа|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 В следующем примере извлекается тип `System.Int32` и используется для отображения этого объекта <xref:System.Type.FullName%2A> свойство `System.Int32`. Если объект типа ссылается на сборку, которая не существует, этот пример создает исключение.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и тип не найден.  
  
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции. 
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.  
  
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.  
  
-или- 
 <paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис. Например, "MyType[,*,]".  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 Сборка или одна из ее зависимостей найдена, но не может быть загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
-или- 
В текущий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка была скомпилирована в более поздней версии.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Указание полных имен типов</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя искомого типа с указанием сборки. См. раздел <see cref="P:System.Type.AssemblyQualifiedName" />. Если тип находится в выполняемой в данный момент сборке или библиотеке Mscorlib.dll, достаточно предоставить имя типа с указанием пространства имен.</param>
        <param name="throwOnError">Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />. Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них. См. раздел "Исключения".</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при поиске <paramref name="typeName" />, значение <see langword="false" />, чтобы учитывать регистр при поиске <paramref name="typeName" />.</param>
        <summary>Возвращает объект <see cref="T:System.Type" /> с указанным именем, позволяющий определить, будет ли создаваться исключение в случае невозможности найти тип и будет ли учитываться регистр при поиске.</summary>
        <returns>Тип с указанным именем. Если тип не найден, параметр <paramref name="throwOnError" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения. В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwOnError" />. См. раздел "Исключения".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Type.GetType%2A> метод, чтобы получить <xref:System.Type> объекта для типа в другой сборке, если вы знаете его имя с указанием сборки, который можно получить из <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> приводит к загрузке сборки, указанной в `typeName`. Вы также можете загрузить сборки с помощью <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод, а затем использовать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> метод для получения <xref:System.Type> объектов. Если тип находится в сборке во время компиляции неизвестен в программу, это более эффективно использовать `typeof` в C# или `GetType` оператор в Visual Basic.
  
 `GetType` работает только на сборки, загруженные с диска. При вызове метода `GetType` для поиска типа, определенного в динамическую сборку с использованием <xref:System.Reflection.Emit> служб, могут быть неверными. Поведение зависит от того, ли динамическая сборка является постоянным, то есть, созданные с помощью `RunAndSave` или `Save` режимов доступа <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> перечисления. Если динамическая сборка сохраняется и будет записана на диск перед `GetType` — вызывается, загрузчик найдет сохраненную сборку на диске, загружает эту сборку и возвращает тип из этой сборки. Если сборка не была сохранена на диск, когда `GetType` вызывается, метод возвращает `null`. `GetType` не поддерживает временные динамические сборки; Таким образом, вызов `GetType` для извлечения типа во временную динамическую сборку возвращает `null`.  
  
 Чтобы использовать `GetType` для динамического модуля, Подпишитесь на <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> событий и вызовов `GetType` перед сохранением. В противном случае вы получите две копии сборки в памяти.  
  
 `throwOnError` Параметр указывает, что произойдет, если тип не найден, а также подавляются некоторые другие условия исключения, как описано в раздел "исключения". Некоторые исключения создаются независимо от значения `throwOnError`. Например, если найден тип, но не может быть загружен <xref:System.TypeLoadException> возникает даже в том случае, если `throwOnError` является `false`.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методы при отражении типа.  
  
|Тип члена|Static|Статическим|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является то, что наследование осуществляется так же, как и для методов, реализующих свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, меток и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события являются по имени и подписи. Если у вас есть свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете получить доступ к методу set в базовом классе.  
  
3.  Настраиваемые атрибуты не являются частью система общих типов CTS.  
  
 Массивы или COM-типы не производится, если они уже были загружены в таблицу доступных классов.  
  
 `typeName` может быть имя типа с указанием его пространство имен или имя с указанием сборки, включающий спецификации имени сборки. См. раздел <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Если `typeName` включает в себя пространство имен, но не имя сборки, этот метод выполняет поиск только в сборке вызывающего объекта и библиотеки Mscorlib.dll, в указанном порядке. Если полное имя сборки частичного или полного typeName, этот метод выполняет поиск в указанной сборке. Если сборка имеет строгое имя, полное имя сборки не требуется.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Свойство возвращает полное имя, включая вложенные типы, имя сборки и аргументы типа. Все компиляторы, которые поддерживают среда CLR будет выдавать простое имя вложенного класса, а отражение создает искаженное имя при запросе, в соответствии со следующими соглашениями.  
  
> [!NOTE]
>  В .NET Framework версии 2.0 архитектура процессора добавляется удостоверения сборки и может быть указан как часть строки имени сборки. Например «ProcessorArchitecture = msil». Тем не менее, он не включен в строку, возвращаемую <xref:System.Type.AssemblyQualifiedName%2A> свойство, по соображениям совместимости. Можно также загрузить типы, создав <xref:System.Reflection.AssemblyName> объекта и передачи его в соответствующую перегрузку <xref:System.Reflection.Assembly.Load%2A> метод. Затем можно использовать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> метод, чтобы загрузить типы из сборки. См. также раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|разделитель|Значение|  
|---------------|-------------|  
|Обратная косая черта (\\)|Escape-символ.|  
|Обратный апостроф (')|Предшествует одной или нескольких цифр, представляющее число параметров типа, находится в конце имени универсального типа.|  
|Квадратные скобки ([])|Заключите список аргументов универсального типа для сконструированного универсального типа; в список аргументов типа заключите типа с указанием сборки.|  
|Запятая ()|Предшествует имени сборки.|  
|Точка (.)|Определяет идентификаторы пространства имен.|  
|Знак плюс (+)|Перед вложенным классом.|  
  
 Например полное имя класса может выглядеть следующим образом:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Если было TopNamespace.Sub+Namespace, то строка пришлось бы предшествовать знак плюс (+) с escape-символ (\\) для предотвращения его обрабатывались как разделитель вложений. Отражение порождает эту строку следующим образом:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Объект «++» становится "\\+\\+» и"\\«становится»\\\\«.  
  
 Это полное имя можно сохраняются и впоследствии использовать для загрузки <xref:System.Type>. Чтобы найти и загрузить <xref:System.Type>, использовать <xref:System.Type.GetType%2A> либо с типом имя, либо только имя типа с указанием сборки. <xref:System.Type.GetType%2A> с типом имя только будет искать <xref:System.Type> в сборке вызывающего, а затем в системную сборку. <xref:System.Type.GetType%2A> в сборке будет искать имя типа с указанием <xref:System.Type> в любой сборке.  
  
 Имена типов могут включать конечные символы, определяющие дополнительные сведения о типе, например, является ли тип ссылочным типом, тип указателя или тип массива. Получить имя типа без этих конечных символов, с помощью `t.GetElementType().ToString()`, где `t` — это тип.  
  
 Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки. В имени сборки пробелы перед разделителем «,» существенны, но пробелы после разделителя «,» игнорируются.  
  
 Имя универсального типа заканчивается — обратный апостроф (\`) следуют цифры, представляющее число аргументов универсального типа. Искажение имени предназначена для обеспечения поддержки универсальных типов с одинаковым именем, но с разным числом параметров типа, происходящих в той же области. Например, отражения возвращает искаженные имена `Tuple`1` and `кортежа`2` из универсальных методов `Tuple(Of T)` и `Tuple(Of T0, T1)` в Visual Basic или `Tuple<T>` и кортежа`\<T0, T1>` в Visual C#.  
  
 Для универсальных типов заключается в квадратные скобки список аргументов типа и аргументы типа разделяются запятыми. Например, универсальный <xref:System.Collections.Generic.Dictionary%602> имеет два параметра типа. Объект <xref:System.Collections.Generic.Dictionary%602> из `MyType` с ключами типа <xref:System.String> может быть представлен следующим образом:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Для указания типа с указанием сборки в список аргументов типа, заключите его в квадратных скобках указывается тип с указанием сборки. В противном случае запятых, разделяющих частей имени с указанием сборки, интерпретируются как разделители дополнительных аргументов типа. Например <xref:System.Collections.Generic.Dictionary%602> из `MyType` из MyAssembly.dll, с помощью ключей типа <xref:System.String>, может быть указан следующим образом:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Тип с указанием сборки могут быть заключены в квадратные скобки, только в том случае, когда он появится в списке параметров типа. Правила поиска сборок для полных и неполных типов в список параметров типа совпадают с правила для полных и неполных неуниверсальных типов.  
  
 Обнуляемые типы представляют собой особый случай универсальных типов. Например, для типа <xref:System.Int32> представлена строкой «System.Nullable'1[System.Int32]».  
  
> [!NOTE]
>  В C#, C++ и Visual Basic можно также получить обнуляемые типы, с помощью операторов типов. Например, допускающий значение NULL <xref:System.Boolean> возвращаемый тип `typeof(Nullable<bool>)` в C#, `Nullable<Boolean>::typeid` в C++, а также по `GetType(Nullable(Of Boolean))` в Visual Basic.  
  
 В следующей таблице показаны синтаксис, используемом с `GetType` для различных типов.  
  
|Чтобы получить|Использовать|  
|------------|---------|  
|Значение необязательной определенности <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Неуправляемый указатель на `MyType`|`Type.GetType("MyType*")`|  
|Неуправляемый указатель на указатель на `MyType`|`Type.GetType("MyType**")`|  
|Управляемый указатель или ссылка на `MyType`|`Type.GetType("MyType&")`. Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.|  
|Родительский и вложенный класс|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Одномерный массив с нижней границей, равной 0|`Type.GetType("MyArray[]")`|  
|Одномерный массив с неизвестной нижней границей|`Type.GetType("MyArray[*]")`|  
|N мерный массив|Запятая (,) внутри квадратных скобок n-1 раз. Например `System.Object[,,]` представляет трехмерный массив `Object` массива.|  
|Двумерный массив массива|`Type.GetType("MyArray[][]")`|  
|Прямоугольный двухмерный массив с неизвестными нижними границами|`Type.GetType("MyArray[,]")`|  
|Универсальный тип с одним аргументом типа|``Type.GetType("MyGenericType`1[MyType]")``|  
|Универсальный тип с двумя аргументами типа|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Универсальный тип с двумя аргументами типа сборки|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|С указанием сборки универсального типа с аргументом типа сборки|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Универсальный тип, тип аргумента является универсальным типом с двумя аргументами типа|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и тип не найден.  
  
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции. 
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.  
  
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.  
  
-или- 
 <paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис. Например, "MyType[,*,]".  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
-или- 
В текущий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка была скомпилирована в более поздней версии.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Указание полных имен типов</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя получаемого типа. Если задан параметр <paramref name="typeResolver" />, имя типа может быть любой строкой, которую может разрешить объект <paramref name="typeResolver" />. Если задан параметр <paramref name="assemblyResolver" /> или если используется стандартное разрешение типов, параметр <paramref name="typeName" /> должен быть именем с указанием сборки (см. описание свойства <see cref="P:System.Type.AssemblyQualifiedName" />), кроме случаев, когда этот тип находится в текущей выполняемой сборке или в библиотеке Mscorlib.dll — тогда достаточно задать имя типа с указанием пространства имен.</param>
        <param name="assemblyResolver">Метод, находящий и возвращающий сборку, заданную в параметре <paramref name="typeName" />. Имя сборки передается методу <paramref name="assemblyResolver" /> в виде объекта <see cref="T:System.Reflection.AssemblyName" />. Если объект <paramref name="typeName" /> не содержит имя сборки, метод <paramref name="assemblyResolver" /> не вызывается. Если метод <paramref name="assemblyResolver" /> не указан, выполняется стандартное разрешение сборки.  
  
Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей. В противном случае возможно повышение привилегий для вредоносного кода. Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</param>
        <param name="typeResolver">Метод, находящий и возвращающий тип, заданный в параметре <paramref name="typeName" />, из сборки, возвращенной методом <paramref name="assemblyResolver" /> или стандартным методом разрешения сборки. Если сборка не предоставлена, ее может предоставить метод <paramref name="typeResolver" />. Метод также принимает параметр, указывающий, следует ли выполнять поиск без учета регистра; этому параметру передается значение <see langword="false" />.  
  
Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</param>
        <summary>Получает тип с указанным именем; дополнительно может предоставлять настраиваемые методы для разрешения сборки и типа.</summary>
        <returns>Тип с указанным именем или значение <see langword="null" />, если тип не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сценарии использования для этого метода и сведения о `assemblyResolver` и `typeResolver` параметров можно найти в <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> перегрузки метода.  
  
> [!NOTE]
>  Если `typeName` отсутствует, вызов <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> возвращает метод `null`. Он не вызывает исключение. Для управления ли исключение, вызовите перегрузку <xref:System.Type.GetType%2A> метод, который имеет `throwOnError` параметра.  
  
 Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> перегрузку метода с указанием `false` для `throwOnError` и `ignoreCase` параметров.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.ArgumentException">Произошла ошибка при интерпретации <paramref name="typeName" /> в имя типа и имя сборки (например, если имя простого типа содержит неэкранированный специальный знак).  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или одна из ее зависимостей найдена, но не может быть загружена.  
  
-или- 
 <paramref name="typeName" /> содержит недопустимое имя сборки.  
  
-или- 
 <paramref name="typeName" /> является допустимым именем сборки без имени типа.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
-или- 
Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя получаемого типа. Если задан параметр <paramref name="typeResolver" />, имя типа может быть любой строкой, которую может разрешить объект <paramref name="typeResolver" />. Если задан параметр <paramref name="assemblyResolver" /> или если используется стандартное разрешение типов, параметр <paramref name="typeName" /> должен быть именем с указанием сборки (см. описание свойства <see cref="P:System.Type.AssemblyQualifiedName" />), кроме случаев, когда этот тип находится в текущей выполняемой сборке или в библиотеке Mscorlib.dll — тогда достаточно задать имя типа с указанием пространства имен.</param>
        <param name="assemblyResolver">Метод, находящий и возвращающий сборку, заданную в параметре <paramref name="typeName" />. Имя сборки передается методу <paramref name="assemblyResolver" /> в виде объекта <see cref="T:System.Reflection.AssemblyName" />. Если объект <paramref name="typeName" /> не содержит имя сборки, метод <paramref name="assemblyResolver" /> не вызывается. Если метод <paramref name="assemblyResolver" /> не указан, выполняется стандартное разрешение сборки.  
  
Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей. В противном случае возможно повышение привилегий для вредоносного кода. Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</param>
        <param name="typeResolver">Метод, находящий и возвращающий тип, заданный в параметре <paramref name="typeName" />, из сборки, возвращенной методом <paramref name="assemblyResolver" /> или стандартным методом разрешения сборки. Если сборка не предоставлена, этот метод может предоставить ее. Метод также принимает параметр, указывающий, следует ли выполнять поиск без учета регистра; этому параметру передается значение <see langword="false" />.  
  
Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</param>
        <param name="throwOnError">Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />. Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них. См. раздел "Исключения".</param>
        <summary>Возвращает тип с заданным именем и указывает, следует ли создавать исключение в случае невозможности найти тип, а также может предоставлять настраиваемые методы для разрешения сборки и типа.</summary>
        <returns>Тип с указанным именем. Если тип не найден, параметр <paramref name="throwOnError" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения. В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwOnError" />. См. раздел "Исключения".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сценарии использования для этого метода и сведения о `assemblyResolver` и `typeResolver` параметров можно найти в <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> перегрузки метода.  
  
 Вызов перегрузки этого метода равносилен вызову метода является <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> перегрузку метода с указанием `false` для `ignoreCase` параметра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и тип не найден.  
  
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции. 
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.  
  
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.  
  
-или- 
 <paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Произошла ошибка при интерпретации <paramref name="typeName" /> в имя типа и имя сборки (например, если имя простого типа содержит неэкранированный специальный знак).  
  
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис (например "MyType[,*,]").  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.  
  
-или- 
 <paramref name="typeName" /> содержит недопустимое имя сборки.  
  
-или- 
 <paramref name="typeName" /> является допустимым именем сборки без имени типа.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
-или- 
Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя получаемого типа. Если задан параметр <paramref name="typeResolver" />, имя типа может быть любой строкой, которую может разрешить объект <paramref name="typeResolver" />. Если задан параметр <paramref name="assemblyResolver" /> или если используется стандартное разрешение типов, параметр <paramref name="typeName" /> должен быть именем с указанием сборки (см. описание свойства <see cref="P:System.Type.AssemblyQualifiedName" />), кроме случаев, когда этот тип находится в текущей выполняемой сборке или в библиотеке Mscorlib.dll — тогда достаточно задать имя типа с указанием пространства имен.</param>
        <param name="assemblyResolver">Метод, находящий и возвращающий сборку, заданную в параметре <paramref name="typeName" />. Имя сборки передается методу <paramref name="assemblyResolver" /> в виде объекта <see cref="T:System.Reflection.AssemblyName" />. Если объект <paramref name="typeName" /> не содержит имя сборки, метод <paramref name="assemblyResolver" /> не вызывается. Если метод <paramref name="assemblyResolver" /> не указан, выполняется стандартное разрешение сборки.  
  
Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей. В противном случае возможно повышение привилегий для вредоносного кода. Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</param>
        <param name="typeResolver">Метод, находящий и возвращающий тип, заданный в параметре <paramref name="typeName" />, из сборки, возвращенной методом <paramref name="assemblyResolver" /> или стандартным методом разрешения сборки. Если сборка не предоставлена, этот метод может предоставить ее. Метод также принимает параметр, указывающий, следует ли выполнять поиск без учета регистра; этому параметру передается значение <paramref name="ignoreCase" />.  
  
Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</param>
        <param name="throwOnError">Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />. Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них. См. раздел "Исключения".</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при поиске <paramref name="typeName" />, значение <see langword="false" />, чтобы учитывать регистр при поиске <paramref name="typeName" />.</param>
        <summary>Получает тип с заданным именем и указывает, следует ли выполнять поиск без учета регистра и следует ли создавать исключение в случае невозможности найти тип, а также может предоставлять настраиваемые методы для разрешения сборки и типа.</summary>
        <returns>Тип с указанным именем. Если тип не найден, параметр <paramref name="throwOnError" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения. В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwOnError" />. См. раздел "Исключения".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку метода и связанные перегрузки (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> и <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) для замены используемой по умолчанию реализации <xref:System.Type.GetType%2A> метод с реализациями более гибким. Предоставляя собственные методы разрешения имен типов и имена сборок, содержащих их, сделайте следующее:  
  
-   Управлять какая версия типа загружается из сборки.  
  
-   Укажите другое место для поиска имени типа, которая не включает имя сборки.  
  
-   Загрузка сборок с помощью частичных имен сборок.  
  
-   Вернуть подклассы <xref:System.Type?displayProperty=nameWithType> , не создаются путем общеязыковой среды выполнения (CLR).  
  
 Например в сериализации, независимой от версии этот метод позволяет найти сборку «best fit» с помощью часть имени. Другие перегрузки <xref:System.Type.GetType%2A> метод требует имя типа с указанием сборки, которое включает номер версии.  
  
 Альтернативные реализации системы типов может потребоваться вернуть подклассы <xref:System.Type?displayProperty=nameWithType> , не создается в среде CLR, все типы, которые возвращаются другие перегрузки <xref:System.Type.GetType%2A> метод являются типами среды выполнения.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Примечания об использовании  
 Эта перегрузка метода и связанные перегрузки проанализировать `typeName` в имя типа и имя сборки и затем разрешать имена. Разрешение имени сборки предшествует разрешения имени типа, так как имя типа должно быть разрешено в контексте сборки.  
  
> [!NOTE]
>  Если вы не знакомы с концепцией имен типов с указанием сборки, см. в разделе <xref:System.Type.AssemblyQualifiedName%2A> свойство.  
  
 Если `typeName` , не является именем с указанием сборки, разрешение сборки пропускается. Неполные имена типов может быть разрешен в контексте Mscorlib.dll или текущей выполняемой сборке или при необходимости можно указать сборку в `typeResolver` параметра. Эффекты, включая или исключая имя сборки для различных видов разрешение имен, отображаются в виде таблицы [смешанной разрешение имен](#mixed_name_resolution) раздел.  
  
 Общие примечания по использованию:  
  
-   Не передавайте методы для `assemblyResolver` или `typeResolver` если они исходят от неизвестных или недоверенных вызывающих модулей. Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.  
  
    > [!CAUTION]
    >  С помощью методов из неизвестных или недоверенных вызывающих модулей может привести повышение привилегий для вредоносного кода.  
  
-   Если опустить `assemblyResolver` и/или `typeResolver` параметры, значение `throwOnError` параметр передается в методы, выполняющие разрешение по умолчанию.  
  
-   Если `throwOnError` — `true`, этот метод вызывает исключение <xref:System.TypeLoadException> при `typeResolver` возвращает `null`и <xref:System.IO.FileNotFoundException> при `assemblyResolver` возвращает `null`.  
  
-   Этот метод не перехватывает исключения, создаваемые `assemblyResolver` и `typeResolver`. Вы несете ответственность за любые исключения, которые вызываются методами распознавателя.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Разрешение сборок  
 `assemblyResolver` Метод получает <xref:System.Reflection.AssemblyName> объект, который создается путем синтаксического анализа строковое имя сборки, включенный в `typeName`. Если `typeName` не содержит имя сборки, `assemblyResolver` не вызывается и `null` передается `typeResolver`.  
  
 Если `assemblyResolver` не указан, стандартная сборкой проверка используется для обнаружения сборки. Если `assemblyResolver` предоставляется, <xref:System.Type.GetType%2A> метод не выполняет стандартные проверки; в этом случае необходимо убедиться, что ваш `assemblyResolver` может обрабатывать все сборки, передайте в него.  
  
 `assemblyResolver` Метод должен возвращать `null` Если сборка не может быть разрешена. Если `assemblyResolver` возвращает `null`, `typeResolver` не вызывается и дальнейшая обработка не выполняется; Кроме того, если `throwOnError` — `true`, <xref:System.IO.FileNotFoundException> возникает исключение.  
  
 Если <xref:System.Reflection.AssemblyName> передаваемый `assemblyResolver` является частичным имя, один или несколько из его частей, `null`. Например, если он не имеет версии <xref:System.Reflection.AssemblyName.Version%2A> свойство `null`. Если <xref:System.Reflection.AssemblyName.Version%2A> свойство, <xref:System.Reflection.AssemblyName.CultureInfo%2A> свойство и <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> метода возвращают `null`, а затем только простое имя сборки было указано. `assemblyResolver` Метод может использовать или игнорировать все части имени сборки.  
  
 Влияние различных параметров разрешения сборок, отображаются в виде таблицы [смешанной разрешение имен](#mixed_name_resolution) раздела, для имен типов простых и с указанием сборки.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Разрешение типов  
 Если `typeName` не указано имя сборки, `typeResolver` всегда вызывается. Если `typeName` указывает имя сборки, `typeResolver` вызывается только в том случае, если имя сборки успешно разрешено. Если `assemblyResolver` или стандартной сборки, проверки возвращает `null`, `typeResolver` не вызывается.  
  
 `typeResolver` Метод принимает три аргумента:  
  
-   Сборка для поиска или `null` Если `typeName` не содержит имя сборки.  
  
-   Простое имя типа. В случае вложенный тип это внешний содержащий тип. В случае универсального типа это простое имя универсального типа.  
  
-   Логическое значение, которое является `true` Если нужно игнорировать регистр имен типов.  
  
 Реализация определяет способ использования этих аргументов. `typeResolver` Метод должен возвращать `null` при невозможности разрешить тип. Если `typeResolver` возвращает `null` и `throwOnError` — `true`, эта перегрузка <xref:System.Type.GetType%2A> вызывает <xref:System.TypeLoadException>.  
  
 Влияние различных параметров разрешения типов отображаются в виде таблицы [смешанной разрешение имен](#mixed_name_resolution) раздела, для имен типов простых и с указанием сборки.  
  
#### <a name="resolving-nested-types"></a>Разрешение вложенных типов  
 Если `typeName` является вложенным типом, только имя внешней содержащий тип передается `typeResolver`. Когда `typeResolver` возвращает этот тип <xref:System.Type.GetNestedType%2A> метод вызывается рекурсивно, пока не будет устранена внутреннего вложенного типа.  
  
#### <a name="resolving-generic-types"></a>Разрешение универсальных типов  
 <xref:System.Type.GetType%2A> Вызывается рекурсивно для разрешения универсальных типов: Во-первых, чтобы определить общий тип, а затем его аргументов типа. Если аргумент типа является универсальным, <xref:System.Type.GetType%2A> вызывается рекурсивно для устранения его аргументов типа и т. д.  
  
 Сочетание `assemblyResolver` и `typeResolver` предоставить должны быть способны все уровни Косвенная рекурсия. Например, предположим, вы предоставляете `assemblyResolver` загрузки, который управляет `MyAssembly`. Предположим, что вы хотите определить общий тип `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` в Visual Basic). Можно передать следующее имя универсального типа:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Обратите внимание, что `MyType` является аргументом типа, только с указанием сборки. Имена <xref:System.Collections.Generic.Dictionary%602> и <xref:System.String> классы не с указанием сборки. Ваш `typeResolver` должен быть дескриптор может либо сборки или `null`, так как он будет получать `null` для <xref:System.Collections.Generic.Dictionary%602> и <xref:System.String>. Он может обрабатывать такую ситуацию путем вызова перегрузки <xref:System.Type.GetType%2A> метод, который принимает строку, так как имена неполных типов находятся в библиотеке Mscorlib.dll:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver` Метод не вызывается для типа словаря и строкового типа, так как эти имена типов не с указанием сборки.  
  
 Теперь предположим, что вместо `System.String`, первый универсальный аргумент имеет тип `YourType`, из `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Так как эта сборка не является ни Mscorlib.dll, ни текущей выполняемой сборке, не удается разрешить `YourType` без имени с указанием сборки. Так как ваш `assemblyResolve` будет вызывается рекурсивно, он должен иметь возможность обрабатывать этот случай. Вместо возвращения `null` для сборок, отличных от `MyAssembly`, она теперь выполняет загрузка сборки с помощью предоставленного <xref:System.Reflection.AssemblyName> объекта.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 К [примечания об использовании](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Разрешение имен типов с помощью специальных символов  
 Некоторые символы имеют специальное значение в именах с указанием сборки. Если имя простого типа содержит эти символы, они вызовут ошибки синтаксического анализа при простое имя является частью имени с указанием сборки. Во избежание ошибки синтаксического анализа, необходимо экранировать специальные символы обратной косой чертой, прежде чем можно передать имя с указанием сборки для <xref:System.Type.GetType%2A> метод. Например, если тип имеет имя `Strange]Type`, escape-символ должны добавляться впереди квадратная скобка следующим образом: `Strange\]Type`.  
  
> [!NOTE]
>  Имена с помощью таких специальных символов не может быть создан в Visual Basic или C#, но могут создаваться с помощью промежуточного языка Майкрософт (MSIL) или путем создания динамических сборок.  
  
 В следующей таблице показаны специальные символы для имен типов.  
  
|Знак|Значение|  
|---------------|-------------|  
|`,` (запятая)|Разделитель для имен с указанием сборки.|  
|`[]` (квадратные скобки)|Как пара суффикс указывает тип массива; как пара разделителей заключает списки универсальных аргументов и имена с указанием сборки.|  
|`&` (амперсанд)|В качестве суффикса указывает, что тип является ссылочным типом.|  
|`*` (звездочка)|В качестве суффикса указывает, что тип является типом указателя.|  
|`+` (плюс)|Разделитель вложенных типов.|  
|`\` (обратная косая черта)|Escape-символ.|  
  
 Свойства, такие как <xref:System.Type.AssemblyQualifiedName%2A> возврата правильно escape-строк. Необходимо передать правильно escape-строк для <xref:System.Type.GetType%2A> метод. В свою очередь <xref:System.Type.GetType%2A> метод передает правильно экранированные имена для `typeResolver` и методы разрешения типа по умолчанию. Если необходимо сравнить имя без escape-символов в имени `typeResolver`, необходимо удалить escape-символы.  
  
 К [примечания об использовании](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Разрешение имен, смешанный  
 В следующей таблице перечислены взаимодействия между `assemblyResolver`, `typeResolver`и разрешение имен по умолчанию, для всех сочетаний имени типа и имени сборки в `typeName`:  
  
|Имя типа содержимого|Метод распознавателя сборок|Метод сопоставления имен типа|Результат|  
|---------------------------|------------------------------|--------------------------|------------|  
|тип сборки|null|null|Аналогичен вызову <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> перегрузки метода.|  
|тип сборки|предоставленный|null|`assemblyResolver` Возвращает сборку, или возвращает `null` при невозможности разрешить сборки. Если сборка не будет разрешена, <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> загрузить тип из сборки используется перегрузка метода; в противном случае отсутствует не пытается разрешить тип.|  
|тип сборки|null|предоставленный|Эквивалентно преобразование имени сборки для <xref:System.Reflection.AssemblyName> объекта и вызывая метод <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> перегруженный метод для получения сборки. Если сборка разрешается, он передается `typeResolver`; в противном случае `typeResolver` не вызывается и дальнейшая попытка разрешить тип.|  
|тип сборки|предоставленный|предоставленный|`assemblyResolver` Возвращает сборку, или возвращает `null` при невозможности разрешить сборки. Если сборка разрешается, он передается `typeResolver`; в противном случае `typeResolver` не вызывается и дальнейшая попытка разрешить тип.|  
|type|значение NULL, в который|null|Аналогичен вызову <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> перегрузки метода. Поскольку имя сборки не указан, производится поиск только библиотеки Mscorlib.dll и текущей выполняемой сборке. Если `assemblyResolver` не указан, он игнорируется.|  
|type|значение NULL, в который|предоставленный|`typeResolver` вызывается, и `null` передается для сборки. `typeResolver` можно предоставить тип из любой сборки, включая сборки, загружаемые для этой цели. Если `assemblyResolver` не указан, он игнорируется.|  
|сборка|значение NULL, в который|значение NULL, в который|Объект <xref:System.IO.FileLoadException> возникает исключение, так как имя сборки анализируется как будто имя типа с указанием сборки. Это приводит к недопустимое имя сборки.|  
  
 Вернуться: [Примечания об использовании](#usage_notes), [разрешение сборок](#resolving_assemblies), [разрешение типов](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и тип не найден.  
  
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции. 
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.  
  
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.  
  
-или- 
 <paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Произошла ошибка при интерпретации <paramref name="typeName" /> в имя типа и имя сборки (например, если имя простого типа содержит неэкранированный специальный знак).  
  
-или- 
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис (например "MyType[,*,]").  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или одна из ее зависимостей найдена, но не может быть загружена.  
  
-или- 
 <paramref name="typeName" /> содержит недопустимое имя сборки.  
  
-или- 
 <paramref name="typeName" /> является допустимым именем сборки без имени типа.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
-или- 
Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args">Массив объектов, типы которых нужно определить.</param>
        <summary>Возвращает типы объектов в указанном массиве.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, представляющих типы соответствующих элементов в массиве <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Type.GetTypeArray%2A> метод, чтобы получить список типов элементов массива.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> — <see langword="null" />.  
  
-или- 
Один или несколько элементов в <paramref name="args" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Вызываются инициализаторы класса, и по крайней мере один из них создает исключение.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип, код базового типа которого требуется получить.</param>
        <summary>Возвращает код базового типа указанного объекта <see cref="T:System.Type" />.</summary>
        <returns>Код базового типа или <see cref="F:System.TypeCode.Empty" />, если <paramref name="type" /> — <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При наследовании от <xref:System.Type>, поведение этого метода можно изменить, переопределив <xref:System.Type.GetTypeCodeImpl%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода показано, как <xref:System.TypeCode> перечисления может использоваться. В блоке решения внутри `WriteObjectInfo` метод, <xref:System.TypeCode> из <xref:System.Object> параметр проверяется, и в соответствующее сообщение записывается в консоль.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает код базового типа этого экземпляра <see cref="T:System.Type" />.</summary>
        <returns>Код типа базового типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обеспечивает реализацию для `static` (в C#) или `Shared` (в Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> метод. При наследовании от <xref:System.Type>, можно переопределить этот метод, чтобы предоставить свою собственную реализацию <xref:System.Type.GetTypeCode%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает тип, связанный с заданным кодом CLSID.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">Код CLSID извлекаемого типа.</param>
        <summary>Возвращает тип, связанный с заданным кодом CLSID.</summary>
        <returns><see langword="System.__ComObject" /> вне зависимости от того, допустим ли код CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Метод поддерживает доступ с поздним связыванием неуправляемый COM-объекты из приложений .NET Framework, когда вы знаете идентификатор COM-объекта класса (CLSID).  Идентификатор класса для классов COM определяется в разделе реестра HKEY_CLASSES_ROOT\CLSID. Можно получить значение <xref:System.Type.IsCOMObject%2A> свойства, чтобы определить, является ли тип возвращаемого этим методом COM-объекта.  
  
> [!TIP]
>  Вы можете вызвать <xref:System.Type.GetTypeFromProgID%2A> метод для доступа с поздним связыванием для COM объектов которого программный идентификатор (ProgID) вы знаете.  
  
 Создание экземпляра неуправляемый COM-объект, из идентификатора CLSID — это двухэтапный процесс:  
  
1.  Получить <xref:System.Type> , представляющий`__ComObject` , соответствующий идентификатор CLSID, вызвав <xref:System.Type.GetTypeFromCLSID%2A> метод.  
  
2.  Вызовите <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> метод для создания экземпляра COM-объекта.  
  
 См. пример для иллюстрации.  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> Перегрузки не обрабатывает любое исключение, которое возникает при создании экземпляра <xref:System.Type> на основе `clsid` аргумент. Обратите внимание, что исключение не вызывается в том случае, если `clsid` не найден в реестре.  
  
   
  
## Examples  
 В следующем примере используется идентификатор CLSID Microsoft Word [объекта приложения](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) для получения типа COM, который представляет экземпляр приложения Microsoft Word. Затем код создает тип путем вызова <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> метод и закрывает его путем вызова [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) метод.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Этот метод предназначен для использования при работе с COM-объектами, а не с объектами .NET Framework. Все управляемые объекты, включая те, которые являются видимыми для COM (то есть их <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> атрибут <see langword="true" />) иметь идентификатор GUID, который возвращается <see cref="P:System.Type.GUID" /> свойство. Несмотря на то, что метод возвращает <see cref="T:System.Type" /> объектов, соответствующий идентификатор GUID для платформы .NET Framework, нельзя использовать этот <see cref="T:System.Type" /> объекта для создания экземпляра типа путем вызова <see cref="M:System.Activator.CreateInstance(System.Type)" /> метода, как показано в следующем примере.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Вместо этого <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> следует использовать только для получения GUID неуправляемый объект COM и полученный в результате <see cref="T:System.Type" /> объект, который передается <see cref="M:System.Activator.CreateInstance(System.Type)" /> метод должен представлять неуправляемый COM-объект.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">Код CLSID извлекаемого типа.</param>
        <param name="throwOnError">Значение <see langword="true" /> для вызова любого возникшего исключения.  
  
-или- 
 Значение <see langword="false" /> для игнорирования всех происходящих исключений.</param>
        <summary>Возвращает тип, связанный с заданным кодом CLSID, позволяющий определить, будет ли выбрасываться исключение в случае происхождения ошибки при загрузке типа.</summary>
        <returns><see langword="System.__ComObject" /> вне зависимости от того, допустим ли код CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Метод поддерживает доступ с поздним связыванием неуправляемый COM-объекты из приложений .NET Framework, когда вы знаете идентификатор COM-объекта класса (CLSID).  Идентификатор класса для классов COM определяется в разделе реестра HKEY_CLASSES_ROOT\CLSID. Можно получить значение <xref:System.Type.IsCOMObject%2A> свойства, чтобы определить, является ли тип возвращаемого этим методом COM-объекта.  
  
> [!TIP]
>  Вы можете вызвать <xref:System.Type.GetTypeFromProgID%2A> метод для доступа с поздним связыванием для COM объектов которого программный идентификатор (ProgID) вы знаете.  
  
 Создание экземпляра неуправляемый COM-объект, из идентификатора CLSID — это двухэтапный процесс:  
  
1.  Получить <xref:System.Type> , представляющий `__ComObject` , соответствующий идентификатор CLSID, вызвав <xref:System.Type.GetTypeFromCLSID%2A> метод.  
  
2.  Вызовите <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> метод для создания экземпляра COM-объекта.  
  
 См. пример для иллюстрации.  
  
 Такие исключения, как <xref:System.OutOfMemoryException> возникает при указании `true` для `throwOnError`, но не заканчивается сбоем для незарегистрированных идентификаторов CLSID.  
  
   
  
## Examples  
 В следующем примере используется идентификатор CLSID Microsoft Word [объекта приложения](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) для получения типа COM, который представляет экземпляр приложения Microsoft Word. Затем код создает тип путем вызова <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> метод и закрывает его путем вызова [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) метод. Исключение возникает в том случае, если произошла ошибка при загрузке типа.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Этот метод предназначен для использования при работе с COM-объектами, а не с объектами .NET Framework. Все управляемые объекты, включая те, которые являются видимыми для COM (то есть их <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> атрибут <see langword="true" />) иметь идентификатор GUID, который возвращается <see cref="P:System.Type.GUID" /> свойство. Несмотря на то, что метод возвращает <see cref="T:System.Type" /> объектов, соответствующий идентификатор GUID для платформы .NET Framework, нельзя использовать этот <see cref="T:System.Type" /> объекта для создания экземпляра типа путем вызова <see cref="M:System.Activator.CreateInstance(System.Type)" /> метода, как показано в следующем примере.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Вместо этого <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> следует использовать только для получения GUID неуправляемый объект COM и полученный в результате <see cref="T:System.Type" /> объект, который передается <see cref="M:System.Activator.CreateInstance(System.Type)" /> метод должен представлять неуправляемый COM-объект.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">Код CLSID извлекаемого типа.</param>
        <param name="server">Сервер, с которого должен быть загружен тип. Если в качестве имени сервера задано значение <see langword="null" />, этот метод автоматически перейдет к поиску на локальном компьютере.</param>
        <summary>Возвращает с указанного сервера тип, связанный с заданным кодом CLSID.</summary>
        <returns><see langword="System.__ComObject" /> вне зависимости от того, допустим ли код CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Метод поддерживает доступ с поздним связыванием неуправляемый COM-объекты из приложений .NET Framework, когда вы знаете идентификатор COM-объекта класса (CLSID).  Идентификатор класса для классов COM определяется в разделе реестра HKEY_CLASSES_ROOT\CLSID. Можно получить значение <xref:System.Type.IsCOMObject%2A> свойства, чтобы определить, является ли тип возвращаемого этим методом COM-объекта.  
  
> [!TIP]
>  Вы можете вызвать <xref:System.Type.GetTypeFromProgID%2A> метод для доступа с поздним связыванием для COM объектов которого программный идентификатор (ProgID) вы знаете.  
  
 Создание экземпляра неуправляемый COM-объект, из идентификатора CLSID — это двухэтапный процесс:  
  
1.  Получить <xref:System.Type> , представляющий `__ComObject` , соответствующий идентификатор CLSID, вызвав <xref:System.Type.GetTypeFromCLSID%2A> метод.  
  
2.  Вызовите <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> метод для создания экземпляра COM-объекта.  
  
   
  
## Examples  
 В следующем примере используется идентификатор CLSID Microsoft Word [объекта приложения](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) для получения типа COM, который представляет экземпляр приложения Microsoft Word с сервера с именем computer17.central.contoso.com. Затем код создает тип путем вызова <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> метод и закрывает его путем вызова [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) метод.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Этот метод предназначен для использования при работе с COM-объектами, а не с объектами .NET Framework. Все управляемые объекты, включая те, которые являются видимыми для COM (то есть их <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> атрибут <see langword="true" />) иметь идентификатор GUID, который возвращается <see cref="P:System.Type.GUID" /> свойство. Несмотря на то, что метод возвращает <see cref="T:System.Type" /> объектов, соответствующий идентификатор GUID для платформы .NET Framework, нельзя использовать этот <see cref="T:System.Type" /> объекта для создания экземпляра типа путем вызова <see cref="M:System.Activator.CreateInstance(System.Type)" /> метода, как показано в следующем примере.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Вместо этого <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> следует использовать только для получения GUID неуправляемый объект COM и полученный в результате <see cref="T:System.Type" /> объект, который передается <see cref="M:System.Activator.CreateInstance(System.Type)" /> метод должен представлять неуправляемый COM-объект.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">Код CLSID извлекаемого типа.</param>
        <param name="server">Сервер, с которого должен быть загружен тип. Если в качестве имени сервера задано значение <see langword="null" />, этот метод автоматически перейдет к поиску на локальном компьютере.</param>
        <param name="throwOnError">Значение <see langword="true" /> для вызова любого возникшего исключения.  
  
-или- 
 Значение <see langword="false" /> для игнорирования всех происходящих исключений.</param>
        <summary>Возвращает с указанного сервера тип, связанный с заданным кодом CLSID, позволяющий определить, будет ли выбрасываться исключение при происхождении ошибки во время загрузки типа.</summary>
        <returns><see langword="System.__ComObject" /> вне зависимости от того, допустим ли код CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Метод поддерживает доступ с поздним связыванием неуправляемый COM-объекты из приложений .NET Framework, когда вы знаете идентификатор COM-объекта класса (CLSID).  Идентификатор класса для классов COM определяется в разделе реестра HKEY_CLASSES_ROOT\CLSID. Можно получить значение <xref:System.Type.IsCOMObject%2A> свойства, чтобы определить, является ли тип возвращаемого этим методом COM-объекта.  
  
> [!TIP]
>  Вы можете вызвать <xref:System.Type.GetTypeFromProgID%2A> метод для доступа с поздним связыванием для COM объектов которого программный идентификатор (ProgID) вы знаете.  
  
 Создание экземпляра неуправляемый COM-объект, из идентификатора CLSID — это двухэтапный процесс:  
  
1.  Получить <xref:System.Type> , представляющий `__ComObject` , соответствующий идентификатор CLSID, вызвав <xref:System.Type.GetTypeFromCLSID%2A> метод.  
  
2.  Вызовите <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> метод для создания экземпляра COM-объекта.  
  
 Такие исключения, как <xref:System.OutOfMemoryException> возникает при указании `true` для `throwOnError`, но не заканчивается сбоем для незарегистрированных идентификаторов CLSID.  
  
   
  
## Examples  
 В следующем примере используется идентификатор CLSID Microsoft Word [объекта приложения](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) для получения типа COM, который представляет экземпляр приложения Microsoft Word с сервера с именем computer17.central.contoso.com. Затем код создает тип путем вызова <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> метод и закрывает его путем вызова [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) метод. Исключение возникает в том случае, если произошла ошибка при загрузке типа.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Этот метод предназначен для использования при работе с COM-объектами, а не с объектами .NET Framework. Все управляемые объекты, включая те, которые являются видимыми для COM (то есть их <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> атрибут <see langword="true" />) иметь идентификатор GUID, который возвращается <see cref="P:System.Type.GUID" /> свойство. Несмотря на то что <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> возвращает <see cref="T:System.Type" /> объект, соответствующий идентификатор GUID для конкретного управляемого объекта, нельзя использовать этот <see cref="T:System.Type" /> объекта для создания экземпляра типа путем вызова <see cref="M:System.Activator.CreateInstance(System.Type)" /> метода, как приведенный ниже Показывает.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Вместо этого <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> следует использовать только для получения GUID неуправляемый объект COM и полученный в результате <see cref="T:System.Type" /> объект, который передается <see cref="M:System.Activator.CreateInstance(System.Type)" /> метод должен представлять неуправляемый COM-объект.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Объект, который ссылается на тип.</param>
        <summary>Возвращает тип, на который ссылается указанный дескриптор типа.</summary>
        <returns>Тип, на который ссылается заданный дескриптор <see cref="T:System.RuntimeTypeHandle" />, или значение <see langword="null" />, если значение свойства <see cref="P:System.RuntimeTypeHandle.Value" /> параметра <paramref name="handle" /> равно <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дескрипторы доступны только в домене приложения, в котором они были получены.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Type.GetTypeFromHandle%2A> метод для получения <xref:System.Type> объекта из <xref:System.RuntimeTypeHandle> предоставляемые <xref:System.Type.GetTypeHandle%2A> метод.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает тип, связанный с заданным идентификатором ProgID.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">Идентификатор ProgID извлекаемого типа.</param>
        <summary>Возвращает тип, связанный с указанным идентификатором ProgID, и возвращает значение NULL, если при загрузке объекта <see cref="T:System.Type" /> возникла ошибка.</summary>
        <returns>Тип, связанный с указанным идентификатором ProgID, если идентификатор <paramref name="progID" /> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для поддержки модели COM. Идентификаторы ProgID не используются в Microsoft .NET Framework, так как они были заменены концепция пространства имен.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> — <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">Идентификатор ProgID извлекаемого типа.</param>
        <param name="throwOnError">Значение <see langword="true" /> для вызова любого возникшего исключения.  
  
-или- 
 Значение <see langword="false" /> для игнорирования всех происходящих исключений.</param>
        <summary>Возвращает тип, связанный с заданным идентификатором ProgID, позволяющим определить, будет ли выбрасываться исключение при происхождении ошибки во время загрузки типа.</summary>
        <returns>Тип, связанный с указанным идентификатором ProgID, если идентификатор <paramref name="progID" /> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для поддержки модели COM. Идентификаторы не используются в Microsoft .NET Framework, так как они были заменены концепция пространства имен.  
  
   
  
## Examples  
 В следующем примере извлекается тип, передав идентификатор ProgID, указывая, следует ли исключение, если идентификатор ProgID является недопустимым. Затем отображается идентификатор ClassID, связанный с ProgID, а также любой соответствующее сообщение об ошибке.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Указанный идентификатор ProgID не зарегистрирован.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">Идентификатор ProgID извлекаемого типа.</param>
        <param name="server">Сервер, с которого должен быть загружен тип. Если в качестве имени сервера задано значение <see langword="null" />, этот метод автоматически перейдет к поиску на локальном компьютере.</param>
        <summary>Возвращает с указанного сервера тип, связанный с заданным идентификатором ProgID, и возвращает значение NULL, если при загрузке типа произошла ошибка.</summary>
        <returns>Тип, связанный с заданным идентификатором ProgID, если идентификатор <paramref name="progID" /> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для поддержки модели COM. Идентификаторы не используются в Microsoft .NET Framework, так как они были заменены концепция пространства имен.  
  
   
  
## Examples  
 В следующем примере извлекается тип путем передачи имени ProgID и сервера. Затем в примере отображается идентификатор ClassID, связанный с ProgID, или создает исключение, если идентификатор ProgID или имя сервера является недопустимым.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prodID" /> — <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">Идентификатор ProgID извлекаемого типа <see cref="T:System.Type" />.</param>
        <param name="server">Сервер, с которого должен быть загружен тип. Если в качестве имени сервера задано значение <see langword="null" />, этот метод автоматически перейдет к поиску на локальном компьютере.</param>
        <param name="throwOnError">Значение <see langword="true" /> для вызова любого возникшего исключения.  
  
-или- 
 Значение <see langword="false" /> для игнорирования всех происходящих исключений.</param>
        <summary>Возвращает с указанного сервера тип, связанный с заданным идентификатором progID, который позволяет определить, будет ли выбрасываться исключение при происхождении ошибки во время загрузки типа.</summary>
        <returns>Тип, связанный с заданным идентификатором ProgID, если идентификатор <paramref name="progID" /> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для поддержки модели COM. Идентификаторы не используются в Microsoft .NET Framework, так как они были заменены концепция пространства имен.  
  
   
  
## Examples  
 В следующем примере извлекается тип путем передачи имени ProgID и сервера. Затем отображается идентификатор ClassID, связанный с ProgID, указывая, следует ли исключение, если идентификатор ProgID или имя сервера является недопустимым.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Указанный идентификатор progID не зарегистрирован.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">Объект, для которого требуется получить дескриптор типа.</param>
        <summary>Возвращает дескриптор <see cref="T:System.Type" /> для указанного объекта.</summary>
        <returns>Дескриптор типа <see cref="T:System.Type" /> для указанного объекта <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дескрипторы доступны только в домене приложения, в котором они были получены.  
  
   
  
## Examples  
 В следующем примере определяется класс `MyClass1`, возвращает его экземпляр и извлекается дескриптор среды выполнения объекта.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает идентификатор GUID, связанный с объектом <see cref="T:System.Type" />.</summary>
        <value>Идентификатор GUID, связанный с объектом <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GUID связан с типом с помощью <xref:System.Runtime.InteropServices.GuidAttribute> атрибута.  
  
   
  
## Examples  
 В следующем примере создается класс `MyClass1` в открытый метод создает `Type` объект, соответствующий `MyClass1`и возвращает <xref:System.Guid> структуры с помощью `GUID` свойство `Type` класса.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, содержит ли текущий объект <see cref="T:System.Type" /> в себе другой тип или ссылку на другой тип (иными словами, является ли текущий объект <see cref="T:System.Type" /> массивом, указателем либо параметром или же он передается по ссылке).</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является массивом, указателем или параметром, переданным по ссылке; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например, Type.GetType("Int32[]"). Возвращает HasElementType `true`, но Type.GetType("Int32"). Возвращает HasElementType `false`. Также возвращает HasElementType `true` для «Int32 *» и «Int32 &».  
  
 Если текущий <xref:System.Type> представляет универсальный тип или параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере возвращается `true` или `false` в зависимости от того, является ли объект является массивом, ссылочный тип или указатель.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.HasElementType" /> и определяет, что содержится в текущем объекте <see cref="T:System.Type" />: непосредственно другой тип или же указывающая на него ссылка (иными словами, является ли текущий объект <see cref="T:System.Type" /> массивом, указателем или параметром или же он передается по ссылке).</summary>
        <returns>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является массивом, указателем или параметром, переданным по ссылке; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например, Type.GetType("Int32[]"). Возвращает HasElementTypeImpl `true`, но Type.GetType("Int32"). Возвращает HasElementTypeImpl `false`. Также возвращает HasElementTypeImpl `true` для «Int32 *» и «Int32 &».  
  
   
  
## Examples  
 В следующем примере определяется класс `MyTypeDelegator`, переопределяющий `HasElementTypeImpl` метод. Главный класс проверяет `HasElementType` свойства и отображает тип элемента.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывает определенный член текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя вызываемого элемента — конструктора, метода, свойства или поля.  
  
-или- 
Пустая строка ("") — в этом случае будет вызван член по умолчанию.  
  
-или- 
Для членов <see langword="IDispatch" /> — строка, представляющая идентификатор DispID, например "[DispID=3]".</param>
        <param name="invokeAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска. Тип доступа может быть обозначен одним из флагов <see langword="BindingFlags" />, например <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> и т.д. Тип поиска указывать необязательно. Если тип поиска не указан, используются флаги <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
-или- 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />. Обратите внимание, что для успешного вызова перегруженных версий метода с переменными аргументами может потребоваться явное объявление объекта <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">Объект, для которого следует вызвать указанный член.</param>
        <param name="args">Массив с аргументами, передаваемыми вызываемому члену.</param>
        <summary>Вызывает указанный член, соответствующий заданным ограничениям привязки и указанному списку аргументов.</summary>
        <returns>Объект, представляющий возвращаемое значение вызываемого элемента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Нельзя использовать <xref:System.Type.InvokeMember%2A> для вызова универсального метода.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие члены следует включить в поиск:  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` с участием не являющиеся открытыми (то есть, закрытые и защищенные члены) для поиска.  
  
-   Укажите `BindingFlags.FlattenHierarchy` включать статические члены вверху иерархии.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные на <xref:System.Type>, не те члены, унаследованные.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги вызова можно использовать для обозначения того, какое действие необходимо выполнить с элементом:  
  
-   `CreateInstance` для вызова конструктора. `name` учитывается. Не является допустимым с другими флагами вызова.  
  
-   `InvokeMethod` для вызова метода, но не конструктор или инициализатор типа. Не является допустимым с `SetField` или `SetProperty`. Если `InvokeMethod` указан сам по себе `BindingFlags.Public`, `BindingFlags.Instance`, и `BindingFlags.Static` включаются автоматически.  
  
-   `GetField` Чтобы получить значение поля. Не является допустимым с `SetField`.  
  
-   `SetField` Чтобы задать значение поля. Не является допустимым с `GetField`.  
  
-   `GetProperty` Для получения свойства. Не является допустимым с `SetProperty`.  
  
-   `SetProperty` Чтобы задать свойство. Не является допустимым с `GetProperty`.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Метод будет вызван, если выполняются оба из следующих условий:  
  
-   Число параметров в объявлении метода равно количеству аргументов в `args` массива (если аргументы по умолчанию не определены в элементе и `BindingFlags.OptionalParamBinding` указан).  
  
-   Тип каждого аргумента можно преобразовать связывателем тип параметра.  
  
 Связыватель находит все совпадающие методы. Эти методы находятся в зависимости от типа связывания (<xref:System.Reflection.BindingFlags> значения `InvokeMethod`, `GetProperty`, и так далее). Набор методов фильтруется по имени, количество аргументов и набора модификаторов поиска, определенных в модуле привязки.  
  
 После выбора метода он вызывается. На этом этапе проверяется доступность. Средство поиска может управлять поиском на основе атрибута доступности, связанное с методом, какой набор методов. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Метод <xref:System.Reflection.Binder> класс отвечает за выбор вызываемого метода. Связыватель по умолчанию выбирает наиболее точное соответствие.  
  
 Ограничения доступа игнорируются для полностью доверенного кода; то есть закрытые конструкторы, методы, поля и свойства можно получить доступ и вызывать через <xref:System.Reflection> каждый раз, когда код имеет полное доверие.  
  
 Можно использовать `Type.InvokeMember` присвоено конкретное значение поля, указав <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Например, если вы хотите задать полю открытого экземпляра F класса C, а F — `String`, можно использовать код, такие как:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Если F `String[]`, можно использовать код, такие как:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 который будет инициализировать поля F этот новый массив. Можно также использовать `Type.InvokeMember` задать для позиции в массиве, указав индекс значение, а затем следующее значение, используя следующий код:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Это изменит строка «z» в массиве F строку «b».  
  
 При вызове `IDispatch` member, укажите идентификатор DispID вместо имени члена, используя формат строки «[DispID = ##]». Например, если идентификатор DispID MyComMethod равно 3, можно указать строку «[DispID = 3]» вместо «MyComMethod». Вызов члена с DispID выполняется быстрее, чем поиск элемента по имени. В сложных сценариях агрегирования идентификатор DispID иногда является единственным способом вызова необходимого члена.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым членам, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав необщедоступные члены ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
   
  
## Examples  
 В следующем примере используется `InvokeMember` для доступа к членам типа.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> не содержит <see langword="CreateInstance" />, а <paramref name="name" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> не является допустимым атрибутом <see cref="T:System.Reflection.BindingFlags" />.  
  
-или- 
 <paramref name="invokeAttr" /> не содержит одного из следующих флагов привязки: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит <see langword="CreateInstance" /> в сочетании с <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит как <see langword="GetField" />, так и <see langword="SetField" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит как <see langword="GetProperty" />, так и <see langword="SetProperty" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит <see langword="InvokeMethod" /> в сочетании с <see langword="SetField" /> или <see langword="SetProperty" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит <see langword="SetField" />, а <paramref name="args" /> содержит более одного элемента.  
  
-или- 
Этот метод вызывается для объекта COM, и один из следующих флагов привязки не был передан: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> или <see langword="BindingFlags.PutRefDispProperty" />.  
  
-или- 
Один из массивов именованных параметров содержит строку, имеющую значение <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Указанный член является инициализатором класса.</exception>
        <exception cref="T:System.MissingFieldException">Невозможно найти поле или свойство.</exception>
        <exception cref="T:System.MissingMethodException">Невозможно найти метод, который соответствует аргументам в <paramref name="args" />.  
  
-или- 
Текущий объект <see cref="T:System.Type" /> представляет тип, содержащий параметры открытого типа, то есть <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Невозможно вызвать указанный член для <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Несколько методов соответствуют критериям привязки.</exception>
        <exception cref="T:System.NotSupportedException">Платформа .NET Compact Framework сейчас не поддерживает этот метод.</exception>
        <exception cref="T:System.InvalidOperationException">Метод, представленный <paramref name="name" />, имеет один или несколько незаданных параметров универсального типа. То есть свойство <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> метода возвращает <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым членам, независимо от их разрешений набора. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на вызов неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя вызываемого элемента — конструктора, метода, свойства или поля.  
  
-или- 
Пустая строка ("") — в этом случае будет вызван член по умолчанию.  
  
-или- 
Для членов <see langword="IDispatch" /> — строка, представляющая идентификатор DispID, например "[DispID=3]".</param>
        <param name="invokeAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска. Тип доступа может быть обозначен одним из флагов <see langword="BindingFlags" />, например <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> и т.д. Тип поиска указывать необязательно. Если тип поиска не указан, используются флаги <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
-или- 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />. Обратите внимание, что для успешного вызова перегруженных версий метода с переменными аргументами может потребоваться явное объявление объекта <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">Объект, для которого следует вызвать указанный член.</param>
        <param name="args">Массив с аргументами, передаваемыми вызываемому члену.</param>
        <param name="culture">Объект, представляющий используемые языковые стандарты глобализации. Его задание может понадобиться для выполнения преобразований, зависящих от языкового стандарта, например преобразования числовой строки <see cref="T:System.String" /> к типу <see cref="T:System.Double" />.  
  
-или- 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования объекта <see cref="T:System.Globalization.CultureInfo" /> текущего потока.</param>
        <summary>Вызывает указанный член, соответствующий заданным ограничениям привязки, списку аргументов, а также языку и региональным параметрам.</summary>
        <returns>Объект, представляющий возвращаемое значение вызываемого элемента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что связыватель по умолчанию не выполняет <xref:System.Globalization.CultureInfo> ( `culture` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательский модуль привязки, который выполняет обработку `culture`.  
  
> [!NOTE]
>  Нельзя использовать <xref:System.Type.InvokeMember%2A> для вызова универсального метода.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие члены следует включить в поиск:  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` с участием не являющиеся открытыми (то есть внутренней, закрытые и защищенные члены) для поиска.  
  
-   Укажите `BindingFlags.FlattenHierarchy` включать статические члены вверху иерархии.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные на <xref:System.Type>, не те члены, унаследованные.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги вызова можно использовать для обозначения того, какое действие необходимо выполнить с элементом:  
  
-   `CreateInstance` для вызова конструктора. `name` учитывается. Не является допустимым с другими флагами вызова.  
  
-   `InvokeMethod` для вызова метода, но не конструктор или инициализатор типа. Не является допустимым с `SetField` или `SetProperty`. Если `InvokeMethod` указан сам по себе `BindingFlags.Public`, `BindingFlags.Instance`, и `BindingFlags.Static` включаются автоматически.  
  
-   `GetField` Чтобы получить значение поля. Не является допустимым с `SetField`.  
  
-   `SetField` Чтобы задать значение поля. Не является допустимым с `GetField`.  
  
-   `GetProperty` Для получения свойства. Не является допустимым с `SetProperty`.  
  
-   `SetProperty` Чтобы задать свойство. Не является допустимым с `GetProperty`.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Метод будет вызван, если выполняются оба из следующих условий:  
  
-   Число параметров в объявлении метода равно количеству аргументов в `args` массива (если аргументы по умолчанию не определены в элементе и `BindingFlags.OptionalParamBinding` указан).  
  
-   Тип каждого аргумента можно преобразовать связывателем тип параметра.  
  
 Связыватель находит все совпадающие методы. Эти методы находятся в зависимости от типа связывания (<xref:System.Reflection.BindingFlags> значения `InvokeMethod`, `GetProperty`, и так далее). Набор методов фильтруется по имени, количество аргументов и набора модификаторов поиска, определенных в модуле привязки.  
  
 После выбора метода он вызывается. На этом этапе проверяется доступность. Средство поиска может управлять поиском на основе атрибута доступности, связанное с методом, какой набор методов. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Метод <xref:System.Reflection.Binder> класс отвечает за выбор вызываемого метода. Связыватель по умолчанию выбирает наиболее точное соответствие.  
  
 Ограничения доступа игнорируются для полностью доверенного кода; то есть закрытые конструкторы, методы, поля и свойства можно получить доступ к и вызывается через отражение, если код является полностью доверенным.  
  
 Можно использовать `Type.InvokeMember` присвоено конкретное значение поля, указав <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Например, если вы хотите задать полю открытого экземпляра F класса C, а F — `String` можно использовать код, такие как:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Если F `String[]`, можно использовать код, такие как:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 который будет инициализировать поля F этот новый массив. Можно также использовать `Type.InvokeMember` задать для позиции в массиве, указав индекс значение, а затем следующее значение, используя следующий код:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Это изменит строка «z» в массиве F строку «b».  
  
 При вызове `IDispatch` член, можно указать идентификатор DispID вместо имени члена, используя формат строки «[DispID = ##]». Например, если идентификатор DispID MyComMethod равно 3, можно указать строку «[DispID = 3]» вместо «MyComMethod». Вызов члена с DispID выполняется быстрее, чем поиск элемента по имени. В сложных сценариях агрегирования идентификатор DispID иногда является единственным способом вызова необходимого члена.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым членам, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав необщедоступные члены ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> не содержит <see langword="CreateInstance" />, а <paramref name="name" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> не является допустимым атрибутом <see cref="T:System.Reflection.BindingFlags" />.  
  
-или- 
 <paramref name="invokeAttr" /> не содержит одного из следующих флагов привязки: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит <see langword="CreateInstance" /> в сочетании с <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит как <see langword="GetField" />, так и <see langword="SetField" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит как <see langword="GetProperty" />, так и <see langword="SetProperty" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит <see langword="InvokeMethod" /> в сочетании с <see langword="SetField" /> или <see langword="SetProperty" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит <see langword="SetField" />, а <paramref name="args" /> содержит более одного элемента.  
  
-или- 
Этот метод вызывается для объекта COM, и один из следующих флагов привязки не был передан: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> или <see langword="BindingFlags.PutRefDispProperty" />.  
  
-или- 
Один из массивов именованных параметров содержит строку, имеющую значение <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Указанный член является инициализатором класса.</exception>
        <exception cref="T:System.MissingFieldException">Невозможно найти поле или свойство.</exception>
        <exception cref="T:System.MissingMethodException">Невозможно найти метод, который соответствует аргументам в <paramref name="args" />.  
  
-или- 
Текущий объект <see cref="T:System.Type" /> представляет тип, содержащий параметры открытого типа, то есть <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Невозможно вызвать указанный член для <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Несколько методов соответствуют критериям привязки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод, представленный <paramref name="name" />, имеет один или несколько незаданных параметров универсального типа. То есть свойство <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> метода возвращает <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым членам, независимо от их разрешений набора. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на вызов неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя вызываемого элемента — конструктора, метода, свойства или поля.  
  
-или- 
Пустая строка ("") — в этом случае будет вызван член по умолчанию.  
  
-или- 
Для членов <see langword="IDispatch" /> — строка, представляющая идентификатор DispID, например "[DispID=3]".</param>
        <param name="invokeAttr">Побитовое сочетание значений перечисления, указывающих способ проведения поиска. Тип доступа может быть обозначен одним из флагов <see langword="BindingFlags" />, например <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> и т.д. Тип поиска указывать необязательно. Если тип поиска не указан, используются флаги <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
-или- 
Пустая ссылка (Nothing в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />. Обратите внимание, что для успешного вызова перегруженных версий метода с переменными аргументами может потребоваться явное объявление объекта <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">Объект, для которого следует вызвать указанный член.</param>
        <param name="args">Массив с аргументами, передаваемыми вызываемому члену.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <paramref name="args" />. Атрибуты, связанные с параметром, хранятся в сигнатуре члена.  
  
Связыватель по умолчанию обрабатывает этот параметр только при вызове COM-компонента.</param>
        <param name="culture">Объект <see cref="T:System.Globalization.CultureInfo" />, представляющий используемый языковой стандарт глобализации. Он может понадобиться для выполнения преобразований, зависящих от языкового стандарта, например приведения числа в строковом формате к типу Double.  
  
-или- 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования объекта <see cref="T:System.Globalization.CultureInfo" /> текущего потока.</param>
        <param name="namedParameters">Массив, содержащий имена параметров, в которые передаются значения элементов массива <paramref name="args" />.</param>
        <summary>При переопределении в производном классе вызывает указанный член, соответствующий заданным ограничениям привязки, списку аргументов, модификаторов, а также языку и региональным параметрам.</summary>
        <returns>Объект, представляющий возвращаемое значение вызываемого элемента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` вызывает член-конструктор или метод, возвращает или задает свойство-член, Получает или задает элемент поля данных, или возвращает или задает элемент массива.  
  
> [!NOTE]
>  Нельзя использовать <xref:System.Type.InvokeMember%2A> для вызова универсального метода.  
  
 При вызове `IDispatch` член, можно указать идентификатор DispID вместо имени члена, используя формат строки «[DispID = ##]». Например, если идентификатор DispID MyComMethod равно 3, можно указать строку «[DispID = 3]» вместо «MyComMethod». Вызов члена с DispID выполняется быстрее, чем поиск элемента по имени. В сложных сценариях агрегирования идентификатор DispID иногда является единственным способом вызова необходимого члена.  
  
 Несмотря на то, что связыватель по умолчанию не выполняет <xref:System.Reflection.ParameterModifier> или <xref:System.Globalization.CultureInfo> ( `modifiers` и `culture` параметров), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс для написания пользовательский модуль привязки, который выполняет обработку `modifiers` и `culture`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Каждый параметр в массиве `namedParameters` получает значение в соответствующем элементе в массиве `args`. Если длина `args` превышает длину `namedParameters`, оставшиеся значения аргументов передаются по порядку.  
  
 `namedParameters` Массива можно использовать для изменения порядка аргументов в входного массива. Например, если метод `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` в Visual Basic) и входной массив `{ 42, "x" }`, входной массив может передаваться в неизмененном виде `args` Если массив `{ "b", "a" }` предоставляется для `namedParameters`.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие члены следует включить в поиск:  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` с участием не являющиеся открытыми (то есть внутренней, закрытые и защищенные члены) для поиска.  
  
-   Укажите `BindingFlags.FlattenHierarchy` включать статические члены вверху иерархии.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги модификаторов, которые можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные на <xref:System.Type>, не те члены, унаследованные.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги вызова можно использовать для обозначения того, какое действие необходимо выполнить с элементом:  
  
-   `CreateInstance` для вызова конструктора. `name` учитывается. Не является допустимым с другими флагами вызова.  
  
-   `InvokeMethod` для вызова метода, но не конструктор или инициализатор типа. Не является допустимым с `SetField` или `SetProperty`. Если `InvokeMethod` указан сам по себе `BindingFlags.Public`, `BindingFlags.Instance`, и `BindingFlags.Static` включаются автоматически.  
  
-   `GetField` Чтобы получить значение поля. Не является допустимым с `SetField`.  
  
-   `SetField` Чтобы задать значение поля. Не является допустимым с `GetField`.  
  
-   `GetProperty` Для получения свойства. Не является допустимым с `SetProperty`.  
  
-   `SetProperty` Чтобы задать свойство. Не является допустимым с `GetProperty`.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Метод будет вызван, если выполняются оба из следующих условий:  
  
-   Число параметров в объявлении метода равно количеству аргументов в `args` массива (если аргументы по умолчанию не определены в элементе и `BindingFlags.OptionalParamBinding` указан).  
  
-   Тип каждого аргумента можно преобразовать связывателем тип параметра.  
  
 Связыватель находит все совпадающие методы. Эти методы находятся в зависимости от типа связывания (<xref:System.Reflection.BindingFlags> значения `InvokeMethod`, `GetProperty`, и так далее). Набор методов фильтруется по имени, количество аргументов и набора модификаторов поиска, определенных в модуле привязки.  
  
 После выбора метода он вызывается. На этом этапе проверяется доступность. Средство поиска может управлять поиском на основе атрибута доступности, связанное с методом, какой набор методов. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Метод <xref:System.Reflection.Binder> класс отвечает за выбор вызываемого метода. Связыватель по умолчанию выбирает наиболее точное соответствие.  
  
 `InvokeMember` можно использовать для вызова методов с параметрами, которые имеют значения по умолчанию. Чтобы привязать эти методы, требует отражения <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> указывать. Для параметра, который имеет значение по умолчанию, можно указать другое значение, или предоставить <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> использовать значение по умолчанию.  
  
 Например, рассмотрим метод, например MyMethod (int x, y с плавающей запятой = 2.0). Чтобы вызвать этот метод только с первым аргументом, как MyMethod(4), передать один из упомянутых выше флагов привязки и два аргумента, а именно, 4 для первого аргумента и `Missing.Value` второго аргумента. Если вы не используете `Missing.Value`, можно не опускать необязательные параметры с `Invoke` метод. Если это необходимо сделать, используйте `InvokeMember` вместо этого.  
  
 Ограничения доступа игнорируются для полностью доверенного кода; то есть закрытые конструкторы, методы, поля и свойства можно получить доступ и вызывать через <xref:System.Reflection> каждый раз, когда код имеет полное доверие.  
  
 Можно использовать `Type.InvokeMember` присвоено конкретное значение поля, указав <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Например, если вы хотите задать полю открытого экземпляра F класса C, а F — `String`, можно использовать код, такие как:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Если F `String[]`, можно использовать код, такие как:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 который будет инициализировать поля F этот новый массив. Можно также использовать `Type.InvokeMember` задать для позиции в массиве, указав индекс значение, а затем следующее значение, используя следующий код:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Это изменит строка «z» в массиве F строку «b».  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым членам, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав необщедоступные члены ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> не содержит <see langword="CreateInstance" />, а <paramref name="name" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="args" /> и <paramref name="modifiers" /> имеют разную длину.  
  
-или- 
 <paramref name="invokeAttr" /> не является допустимым атрибутом <see cref="T:System.Reflection.BindingFlags" />.  
  
-или- 
 <paramref name="invokeAttr" /> не содержит одного из следующих флагов привязки: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит <see langword="CreateInstance" /> в сочетании с <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит как <see langword="GetField" />, так и <see langword="SetField" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит как <see langword="GetProperty" />, так и <see langword="SetProperty" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит <see langword="InvokeMethod" /> в сочетании с <see langword="SetField" /> или <see langword="SetProperty" />.  
  
-или- 
 <paramref name="invokeAttr" /> содержит <see langword="SetField" />, а <paramref name="args" /> содержит более одного элемента.  
  
-или- 
Массив именованных параметров больше, чем массив аргументов.  
  
-или- 
Этот метод вызывается для объекта COM, и один из следующих флагов привязки не был передан: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> или <see langword="BindingFlags.PutRefDispProperty" />.  
  
-или- 
Один из массивов именованных параметров содержит строку, имеющую значение <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Указанный член является инициализатором класса.</exception>
        <exception cref="T:System.MissingFieldException">Невозможно найти поле или свойство.</exception>
        <exception cref="T:System.MissingMethodException">Невозможно найти метод, который соответствует аргументам в <paramref name="args" />.  
  
-или- 
Невозможно найти члены с именами аргументов, указанными в <paramref name="namedParameters" />.  
  
-или- 
Текущий объект <see cref="T:System.Type" /> представляет тип, содержащий параметры открытого типа, то есть <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Невозможно вызвать указанный член для <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Несколько методов соответствуют критериям привязки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод, представленный <paramref name="name" />, имеет один или несколько незаданных параметров универсального типа. То есть свойство <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> метода возвращает <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым членам, независимо от их разрешений набора. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на вызов неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, является ли данный объект <see cref="T:System.Type" /> абстрактным объектом, который должен быть переопределен.</summary>
        <value>Значение <see langword="true" />, если класс <see cref="T:System.Type" /> является абстрактным; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAbstract%2A> Возвращает `true` в следующих случаях:  
  
-   Текущий тип является абстрактным. то есть он не может быть создан, но только может служить базовым классом для производных классов. В C#, абстрактные классы отмечены [абстрактный](~/docs/csharp/language-reference/keywords/abstract.md) ключевого слова; в Visual Basic, они будут отмечены [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) ключевое слово.  
  
-   Текущий тип является интерфейсом.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере создается массив <xref:System.Type> объекты, представляющие следующие типы: содержит возвращаемые значения типа `true` значение, если указанный объект `abstract`; в противном случае он возвращает `false`.  
  
-   `AbstractClass`, абстрактный класс (класс, помеченный как `abstract` в C# и `MustInherit` в Visual Basic).  
  
-   `DerivedClass`, который наследует от класса `AbstractClass`.  
  
-   `SingleClass`, класс не наследуется. Он определяется как `sealed` в C# и `NotInheritable` в Visual Basic.  
  
-   `ITypeInfo`, интерфейс.  
  
-   `ImplementingClass`, класс, реализующий `ITypeInfo` интерфейс.  
  
 Этот метод возвращает `true` только для `AbstractClass`, абстрактного класса, и `ITypeInfo`, интерфейс.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, выбран ли для объекта <see langword="AnsiClass" /> атрибут формата строки <see cref="T:System.Type" />.</summary>
        <value>Значение <see langword="true" />, если для данного объекта <see langword="AnsiClass" /> выбран атрибут формата строки <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Выбирает атрибутов формата строки. Атрибуты формата строки расширяют возможности взаимодействия, определяющий способ интерпретации строки.  
  
 Если текущий <xref:System.Type> представляет универсальный тип, это свойство относится к определению универсального типа, из которого был создан тип. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере возвращаются сведения и проверяет наличие `AnsiClass` атрибута.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, является ли тип массивом.</summary>
        <value>Значение <see langword="true" />, если текущий тип является массивом; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A> Возвращает `false` для <xref:System.Array> класса. Он также возвращает `false` Если текущий экземпляр является <xref:System.Type> , представляющий тип коллекции или интерфейс предназначен для работы с коллекциями, такими как <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Чтобы проверить наличие массива, используйте следующий код:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Если текущий тип представляет универсальный тип или параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Type.IsArray%2A> свойство.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsArray" /> и определяет, является ли данный объект <see cref="T:System.Type" /> массивом.</summary>
        <returns>Значение <see langword="true" />, если <see cref="T:System.Type" /> является массивом; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр <xref:System.Array> должен возвращать класс `false` так, как это объект, не является массивом.  
  
   
  
## Examples  
 В следующем примере переопределяется `IsArrayImpl` метод в `MyTypeDelegator` класса, проверяется, если переменная является массивом и отображает результат.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">Тип для сравнения с текущим типом.</param>
        <summary>Определяет, можно ли присвоить экземпляр указанного типа переменной текущего типа.</summary>
        <returns><see langword="true" />, если истинно любое из следующих условий: 
-   <paramref name="c" /> и текущий экземпляр принадлежат к одному типу.  
  
-   <paramref name="c" /> прямо или косвенно унаследован от текущего экземпляра. Параметр <paramref name="c" /> является производным непосредственно от текущего экземпляра, если он наследуется от него. Параметр <paramref name="c" /> является косвенно производным от текущего экземпляра, если он наследуется от последовательности одного или нескольких классов, наследуемых от текущего экземпляра.  
  
– Текущий экземпляр является интерфейсом, который реализуется параметром <paramref name="c" />.  
  
-   <paramref name="c" /> является параметром универсального типа, а текущий экземпляр представляет одно из ограничений, наложенных на параметр <paramref name="c" />.  
  
В приведенном ниже примере текущий экземпляр является объектом <see cref="T:System.Type" />, который представляет класс <see cref="T:System.IO.Stream" />. <c>GenericWithConstraint</c> — это универсальный тип, параметр универсального типа которого должен иметь тип <see cref="T:System.IO.Stream" />. Передача этого параметра универсального типа в <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> означает, что экземпляр параметра универсального типа можно присвоить объекту <see cref="T:System.IO.Stream" />.  
  
[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" /> представляет тип значения, а текущий экземпляр представляет <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> в Visual Basic).  
  
 Значение <see langword="false" />, если не выполняется ни одно из этих условий или значение параметра <paramref name="c" /> равно <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAssignableFrom%2A> Метод может использоваться, чтобы определить, является ли экземпляр `c` можно назначить к экземпляру текущего типа, метод, наиболее полезен при обработке объектов, типы которых неизвестны во время разработки и обеспечивает условный Назначение, как в примере ниже показано.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Этот метод таким образом гарантирует, что строка кода, как следующие будет выполняться во время выполнения без генерации <xref:System.InvalidCastException> исключение или аналогичное исключение:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Этот метод может быть переопределен производным классом.  
  
> [!NOTE]
>  Определение универсального типа не может быть назначен из закрытого сконструированного типа. То есть нельзя назначить закрытым сконструированным типом `MyGenericList<int>` (`MyGenericList(Of Integer)` в Visual Basic) для переменной типа `MyGenericList<T>`.  
  
 Если `c` принадлежит к типу <xref:System.Reflection.Emit.TypeBuilder>, то результат основан на тип, который выполняется построение. В следующем примере кода демонстрируется это использование типа сборки с именем `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 В следующем примере демонстрируется `IsAssignableFrom` метод использование определенных классов, массива целых чисел и универсальные шаблоны.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, выбран ли для объекта <see langword="AutoClass" /> атрибут формата строки <see cref="T:System.Type" />.</summary>
        <value>Значение <see langword="true" />, если для данного объекта <see langword="AutoClass" /> выбран атрибут формата строки <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Выбирает атрибутов формата строки. Атрибуты формата строки расширяют возможности взаимодействия, определяющий способ интерпретации строки.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, выкладываются ли поля текущего типа автоматически средой CLR.</summary>
        <value>Значение <see langword="true" />, если свойство <see cref="P:System.Type.Attributes" /> текущего типа включает <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляется для удобства. Кроме того, можно использовать <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> значение перечисления для выбора атрибутов макета типа и проверьте наличие ли <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> имеет значение. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, И <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> значения перечисления определяют способ поля типа располагаются в памяти.  
  
 Для динамических типов, можно указать <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> при создании типа. В коде, применить <xref:System.Runtime.InteropServices.StructLayoutAttribute> атрибут <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> значение перечисления в тип, позволяющий определить подходящий способ размещения класса среды выполнения.  
  
> [!NOTE]
>  Нельзя использовать <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> метод, чтобы определить, является ли <xref:System.Runtime.InteropServices.StructLayoutAttribute> был применен к типу.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>.`  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере создается экземпляр типа и отображает <xref:System.Type.IsAutoLayout%2A> свойство.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Метаданные и компоненты с самоописанием</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, передан ли объект <see cref="T:System.Type" /> по ссылке.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> передан по ссылке; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить фактический тип, разыменования тип, который был передан по ссылке, а затем вызовите <xref:System.Type.GetElementType%2A> от конкретного типа.  
  
   
  
## Examples  
 В следующем примере показано использование `IsByRef` свойство для проверки, является ли указанный тип передается по ссылке. В примере определяется класс `MyTypeDelegator`, переопределяющий `HasElementTypeImpl` метод. Главный класс проверяет `HasElementType` свойства и отображает тип элемента.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsByRef" /> и определяет, передается ли данный объект <see cref="T:System.Type" /> по ссылке.</summary>
        <returns>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> передан по ссылке; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, позволяющее определить, является объект <see cref="T:System.Type" /> классом или делегатом (иными словами, не является типом значения или интерфейсом).</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является классом; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает `true` для классов, а также делегаты. Он возвращает `false` для типов значений (для структуры и перечисления) даже в том случае, если они упакованы.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `true`. Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает `true` Если определение универсального типа является определение класса; то есть он не определяет интерфейс или типом значения.  
  
> [!NOTE]
>  Это свойство возвращает `true` для `Type` экземпляры, представляющие <xref:System.Enum> и <xref:System.ValueType> классы. Эти два класса — базовые типы для перечисления и типы значений, соответственно, но они не перечисления или тип значения, сами. Дополнительные сведения см. в разделе <xref:System.Type.IsValueType%2A> и <xref:System.Type.IsEnum%2A> свойства.  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> Значение перечисления, являющийся отличительным признаком объявление типа, как класс или интерфейс. Тем не менее, классов и типов значений будут отмечены <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> атрибута. Если вы извлекаете значение свойства атрибуты типа и используйте <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> значение, чтобы определить, является ли тип класса, а не типом значения, необходимо также вызвать <xref:System.Type.IsValueType%2A> свойство. Пример для <xref:System.Reflection.TypeAttributes> перечисление содержит дополнительные сведения, а также anexample.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 В следующем примере создается экземпляр типа и указывает, является ли тип классом.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли объект <see cref="T:System.Type" /> COM-объектом.</summary>
        <value>Значение <see langword="true" />, если <see cref="T:System.Type" /> является COM-объектом, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает `false` для интерфейсов COM, так как они не являются объектами. COM-интерфейсов может быть реализован объектами Microsoft .NET Framework.  
  
 Можно также загрузить класс COM и получить `Type` объект для этого класса COM с помощью [Tlbimp.exe (программа импорта библиотек типов)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) средство.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип. Например если текущий <xref:System.Type> представляет `MyGenericType<int`> (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsCOMObject" /> и определяет, является ли объект <see cref="T:System.Type" /> COM-объектом.</summary>
        <returns>Значение <see langword="true" />, если <see cref="T:System.Type" /> является COM-объектом, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает `false` для интерфейсов COM, так как они не являются объектами. COM-интерфейсов может быть реализован объектами Microsoft .NET Framework.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли этот данный объект сконструированный универсальный тип. Можно создать экземпляры сконструированного универсального типа.</summary>
        <value>Значение <see langword="true" />, если этот объект представляет сконструированный универсальный тип; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сконструированный универсальный тип был явные типы, передаваемые для всех его параметров универсального типа. Он также называется закрытого универсального типа.  
  
 Если этому свойству присвоено `true`, можно создавать экземпляры текущего типа; в этом случае `false`, вы не можете.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, можно ли поместить в контекст объект <see cref="T:System.Type" />.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> может быть помещен в контекст; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Контекст перехватывает вызовы к членам класса и принудительно применяет политики, которые применяются к классу, таким как синхронизация. Дополнительные сведения о контекстах удаленного взаимодействия, см. в разделе <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере демонстрируется `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, и <xref:System.Type.IsPrimitive%2A> свойства <xref:System.Type> класса. Проверяется ли данный тип может размещаться в контексте, ли он может быть маршалирован по ссылке, и является ли тип примитивный тип данных.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Реализует свойство <see cref="P:System.Type.IsContextful" /> и определяет, можно ли поместить в контекст данный объект <see cref="T:System.Type" />.</summary>
        <returns>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> может быть помещен в контекст; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен производным классом.  
  
 Контекст перехватывает вызовы к членам класса и применять политики, которые применяются к классу, таким как синхронизация.  
  
   
  
## Examples  
 В следующем примере показано использование `IsContextfulImpl` метод.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, представляет ли текущий объект <see cref="T:System.Type" /> перечисление.</summary>
        <value>Значение <see langword="true" />, если текущий объект <see cref="T:System.Type" /> представляет перечисление; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает `true` для перечисления, но не для <xref:System.Enum> сам тип.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать `IsEnum` свойство.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Проверяемое значение.</param>
        <summary>Возвращает значение, показывающее, имеется ли в текущем типе перечисления указанное значение.</summary>
        <returns>Значение <see langword="true" />, если указанное значение является членом текущего типа перечисления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Текущий тип не является перечислением.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> имеет тип, который не может быть базовым типом перечисления.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="other">Тип модели COM, который проверяется на эквивалентность текущему типу.</param>
        <summary>Определяет, имеют ли два типа модели COM одинаковые удостоверения и могут ли они считаться эквивалентными.</summary>
        <returns>Значение <see langword="true" />, если типы модели COM эквивалентны; в противном случае — значение <see langword="false" />. Этот метод также возвращает значение <see langword="false" />, если один тип находится в сборке, загружаемой для исполнения, а другой — в сборке, загружаемой в контекст, предназначенный только для отражения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], среда CLR поддерживает внедрение сведений о типах COM непосредственно в управляемые сборки и не требует получения управляемыми сборками, для получения сведений о типах COM из взаимодействия сборки. Так как внедренные сведения о типах включают в себя только типы и члены, которые действительно используются в управляемой сборке, в двух управляемых сборках могут быть очень разные представления одного типа COM. Все управляемые сборки имеют разные объекты <xref:System.Type> для обозначения представления типа COM. Среда CLR поддерживает эквивалентность типов между этими разными представлениями для интерфейсов, структур, перечислений и делегатов.  
  
 Эквивалентность типов означает, что COM-объект, передаваемый из одной управляемой сборки в другую, можно привести к соответствующему управляемому типу в принимающей сборке. <xref:System.Type.IsEquivalentTo%2A> Метод включает сборку определить, что COM-объект, полученный из другой сборки имеет то же удостоверение COM, как один из типов взаимодействия первой сборки собственные встроенные и таким образом, может быть приведен к этому типу.  
  
 Дополнительные сведения см. в разделе [эквивалентность типов и внедренные типы взаимодействия](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, выкладываются ли поля текущего типа с явно заданными смещениями.</summary>
        <value>Значение <see langword="true" />, если свойство <see cref="P:System.Type.Attributes" /> текущего типа включает <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляется для удобства. Кроме того, можно использовать <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> значение перечисления для выбора атрибутов макета типа и проверьте наличие ли <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> имеет значение. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, И <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> значения перечисления определяют способ поля типа располагаются в памяти.  
  
 Для динамических типов, можно указать <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> при создании типа. В коде, применить <xref:System.Runtime.InteropServices.StructLayoutAttribute> атрибут <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> значение перечисления в тип, чтобы указать, что смещения, с которой начать поля задано явно.  
  
> [!NOTE]
>  Нельзя использовать <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> метод, чтобы определить, является ли <xref:System.Runtime.InteropServices.StructLayoutAttribute> был применен к типу.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере создается экземпляр типа и отображает значение его <xref:System.Type.IsExplicitLayout%2A> свойство. Она использует `MySystemTime` класс, который также находится в примере кода для <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Метаданные и компоненты с самоописанием</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, представляет ли текущий объект <see cref="T:System.Type" /> параметр типа в определении универсального типа или метода.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> представляет параметр определения универсального типа; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> объекты, представляющие параметры универсального типа можно получить, вызвав <xref:System.Type.GetGenericArguments%2A> метод <xref:System.Type> объект, представляющий определение универсального типа, или <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> метод <xref:System.Reflection.MethodInfo> объект, который представляет универсальный метод Определение.  
  
-   Для универсального типа или определение метода <xref:System.Type.IsGenericParameter%2A> возвращает `true` для каждого элемента результирующего массива.  
  
-   Для закрытого сконструированного типа или метода <xref:System.Type.IsGenericParameter%2A> возвращает `false` для каждого элемента массива, возвращаемого <xref:System.Type.GetGenericArguments%2A> метод.  
  
-   Для открытого сконструированного типа или метода некоторые элементы массива могут быть определенные типы и другие могут быть параметрами типа. <xref:System.Type.IsGenericParameter%2A> Возвращает `false` для типов и `true` для параметров типа. В примере кода для <xref:System.Type.ContainsGenericParameters%2A> свойство демонстрирует универсального класса, сочетающее типов и их параметров.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Type.IsGenericParameter%2A> свойство для проверки параметров универсального типа в универсальном типе.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Отражение и универсальные типы</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли текущий тип универсальным.</summary>
        <value><see langword="true" /> Если текущий тип является универсальным типом; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Type.IsGenericType%2A> свойства, чтобы определить ли <xref:System.Type> объект представляет универсальный тип. Используйте <xref:System.Type.ContainsGenericParameters%2A> свойства, чтобы определить ли <xref:System.Type> представляет объект в открытом сконструированном типе или закрытым сконструированным типом.  
  
> [!NOTE]
>  <xref:System.Type.IsGenericType%2A> Возвращает `false` Если непосредственного типа не является универсальным. Например, массив, элементы которого имеют тип `A<int>` (`A(Of Integer)` в Visual Basic) сама по себе не универсального типа.  
  
 В следующей таблице перечислены неизменяемых условий для общих терминов, используемых в отражении универсальных типов.  
  
|Термин|Инвариант|  
|----------|---------------|  
|определение универсального типа|Значение свойства <xref:System.Type.IsGenericTypeDefinition%2A> — `true`.<br /><br /> Определяет универсальный тип. Сконструированный тип создается путем вызова <xref:System.Type.MakeGenericType%2A> метод <xref:System.Type> объект, представляющий определение универсального типа и указав массив аргументов типа.<br /><br /> <xref:System.Type.MakeGenericType%2A> может вызываться только для определений универсальных типов.<br /><br /> Любое определение универсального типа является универсальным типом ( <xref:System.Type.IsGenericType%2A> свойство `true`), но обратное неверно.|  
|универсальный тип|Значение свойства <xref:System.Type.IsGenericType%2A> — `true`.<br /><br /> Может быть определением универсального типа, открытом сконструированном типе или закрытым сконструированным типом.<br /><br /> Обратите внимание, что тип массива, тип элементов которого является универсальным сама по себе не универсального типа. То же самое относится и к <xref:System.Type> объект, представляющий указатель к универсальному типу.|  
|открытый сконструированный тип|Значение свойства <xref:System.Type.ContainsGenericParameters%2A> — `true`.<br /><br /> Примерами являются универсальный тип, который неназначенные параметры типа, тип, который вложен в определении универсального типа или в открытом сконструированном типе или универсальный тип, который имеет аргумент типа, для которого <xref:System.Type.ContainsGenericParameters%2A> свойство `true`.<br /><br /> Не поддерживается для создания экземпляра открытого сконструированного типа.<br /><br /> Обратите внимание на то, что не все открытые сконструированные типы являются универсальными. Например массив, тип элементов которого является определением универсального типа не является универсальным, и указатель на открытый сконструированный тип не является универсальным.|  
|закрытым сконструированным типом|Значение свойства <xref:System.Type.ContainsGenericParameters%2A> — `false`.<br /><br /> При рекурсивном тип не имеет неназначенные универсальных параметров.|  
|параметр универсального типа|Значение свойства <xref:System.Type.IsGenericParameter%2A> — `true`.<br /><br /> Значение свойства <xref:System.Type.ContainsGenericParameters%2A> — `true`.<br /><br /> В определении универсального типа это заполнитель для типа, который будет назначен более поздней версии.|  
|аргумент универсального типа|Может быть любого типа, включая параметр универсального типа.<br /><br /> Аргументы типа указаны как массив <xref:System.Type> объекты передавать <xref:System.Type.MakeGenericType%2A> при создании сконструированному универсальному типу. Если экземпляры для результирующего типа создаваемой <xref:System.Type.ContainsGenericParameters%2A> свойство должно быть `false` для всех аргументов типа.|  
  
 Следующий пример кода и в таблице представлены некоторые из этих условий и инварианты. `Derived` Класс является особый интерес, так как его базовый тип является сконструированный тип, который содержит как типы и параметры типа в списке аргументов.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 В следующей таблице показаны примеры используйте и сборки в классах `Base`, `Derived`, и `G`. Когда кода C++ и C# является одинаковым, отображается только одна запись.  
  
|Пример|Инварианты|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Для этого типа:<br /><br /> <xref:System.Type.IsGenericType%2A> — `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> — `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> — `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Для этого типа:<br /><br /> <xref:System.Type.IsGenericType%2A> — `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> — `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> — `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Для типа переменной `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> — `false` поскольку `d` является массивом.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> — `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> — `false`.|  
|`T`, `U`, и `V` (где они отображаются)|<xref:System.Type.IsGenericParameter%2A> — `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> является `false` , так как нет способа ограничить параметр типа для универсальных типов.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> — `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> — `true` поскольку `T`, `U`, и `V` сами являются параметры универсального типа. Это не означает, что-либо аргументы, которые им назначены более поздней версии.|  
|Тип поля `F`|<xref:System.Type.IsGenericType%2A> — `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> — `false` так, как тип был назначен параметр типа `G`. Обратите внимание, что это эквивалентно вызову <xref:System.Type.MakeGenericType%2A> метод.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> — `true` так как тип поля `F` с аргументом типа, который является открытым сконструированным типом. Сконструированный тип является открытым так как его аргумент типа (то есть `Base`) является определением универсального типа. Это иллюстрирует рекурсивной природе <xref:System.Type.IsGenericType%2A> свойство.|  
|Вложенный класс `Nested`|<xref:System.Type.IsGenericType%2A> — `true`, даже если `Nested` класс не имеет универсальный тип параметров свои собственные, так как он является вложенным в универсальный тип.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> — `true`. То есть можно вызвать <xref:System.Type.MakeGenericType%2A> метод и задать параметр типа данного включающего типа `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> — `true` поскольку включающий тип, `Derived`, имеет параметры универсального типа. Это иллюстрирует рекурсивной природе <xref:System.Type.ContainsGenericParameters%2A> свойство.|  
  
   
  
## Examples  
 В следующем примере кода отображает значение <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, и <xref:System.Type.ContainsGenericParameters%2A> свойств для типов, описанных в разделе "Примечания". Объяснение значения свойств см в "Примечания".  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Отражение и универсальные типы</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, представляет ли текущий объект <see cref="T:System.Type" /> определение универсального типа, на основе которого можно сконструировать другие универсальные типы.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Type" /> представляет определение универсального типа; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Определение универсального типа — это шаблон, из которого можно сконструировать другие типы. Например, из определения универсального типа `G<T>` (выражена в синтаксис C#; `G(Of T)` в Visual Basic или `generic <typename T> ref class G` в C++) можно создавать и создает экземпляр типа `G<int>` (`G(Of Integer)` в Visual Basic), путем вызова <xref:System.Type.MakeGenericType%2A> метод с универсальным аргументом список, содержащий <xref:System.Int32> типа. Учитывая <xref:System.Type> объект, представляющий это сконструированный тип, <xref:System.Type.GetGenericTypeDefinition%2A> метод получает определение универсального типа и обратно еще раз.  
  
 Используйте <xref:System.Type.IsGenericTypeDefinition%2A> свойства, чтобы определить, можно ли создавать новые типы из текущего типа. Если <xref:System.Type.IsGenericTypeDefinition%2A> возвращает `true`, можно вызвать <xref:System.Type.MakeGenericType%2A> метод, чтобы создать новые универсальные типы.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Следующий пример отображает сведения о типе, включая ли он определением универсального типа. Сведения отображаются для сконструированного типа, его определение универсального типа и обычный тип.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Отражение и универсальные типы</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, есть ли у объекта <see cref="T:System.Type" /> атрибут <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />, свидетельствующий о том, что объект был импортирован из библиотеки COM-типов.</summary>
        <value>Значение <see langword="true" />, если у <see cref="T:System.Type" /> есть атрибут <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>.`  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">Объект, который требуется сравнить с текущим типом.</param>
        <summary>Определяет, является ли указанный объект экземпляром текущего типа <see cref="T:System.Type" />.</summary>
        <returns>Значение <see langword="true" />, если текущий объект <see langword="Type" /> входит в иерархию наследования объекта, представленного параметром <paramref name="o" /> или если текущий объект <see langword="Type" /> является интерфейсом, реализуемым параметром <paramref name="o" />. Значение <see langword="false" />, если не выполняется ни одно из перечисленных условий, параметр <paramref name="o" /> имеет значение <see langword="null" /> или текущий объект <see langword="Type" /> является открытым универсальным типом (то есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> возвращает значение <see langword="true" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен производным классом.  
  
> [!NOTE]
>  Сконструированный тип не является экземпляром его определения универсального типа. То есть `MyGenericList<int>` (`MyGenericList(Of Integer)` в Visual Basic) не является экземпляром `MyGenericList<T>` (`MyGenericList(Of T)` в Visual Basic).  
  
   
  
## Examples  
 В следующем примере иллюстрируется использование метода `IsInstanceOfType`.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> интерфейсом (иными словами, не является классом или типом значения).</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является интерфейсом; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> Отличает объявление типа как тип класса, интерфейса или значение.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 Следующий пример создает интерфейс, проверяет тип интерфейса и указывает, имеет ли класс `IsInterface` набор свойств.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, выкладываются ли поля текущего типа последовательно, в том порядке, в котором они были определены, или выдаются в метаданные.</summary>
        <value>Значение <see langword="true" />, если свойство <see cref="P:System.Type.Attributes" /> текущего типа включает <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляется для удобства. Кроме того, можно использовать <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> значение перечисления для выбора атрибутов макета типа и проверьте наличие ли <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> имеет значение. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, И <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> значения перечисления определяют способ поля типа располагаются в памяти.  
  
 Для динамических типов, можно указать <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> при создании типа. В коде, применить <xref:System.Runtime.InteropServices.StructLayoutAttribute> атрибут <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> значение перечисления в тип, чтобы указать, что макет является последовательным.  
  
> [!NOTE]
>  Нельзя использовать <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> метод, чтобы определить, является ли <xref:System.Runtime.InteropServices.StructLayoutAttribute> был применен к типу.  
  
 Дополнительные сведения см. разделе 9.1.2 спецификации Common Language Infrastructure (CLI) документацию по «раздел II: Определение метаданных и семантика». Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере создается экземпляр класса, для которого <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> значение перечисления в <xref:System.Runtime.InteropServices.StructLayoutAttribute> класс было установлено, проверьте наличие <xref:System.Type.IsLayoutSequential%2A> свойство и отображает результат.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Метаданные и компоненты с самоописанием</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, маршалирован ли объект <see cref="T:System.Type" /> по ссылке.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> маршалируется по ссылке; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере демонстрируется `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, и <xref:System.Type.IsPrimitive%2A> свойства <xref:System.Type> класса. Проверяется ли данный тип может размещаться в контексте, ли он может быть маршалирован по ссылке, и является ли тип примитивный тип данных.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Реализует свойство <see cref="P:System.Type.IsMarshalByRef" /> и определяет, маршалируется ли объект <see cref="T:System.Type" /> по ссылке.</summary>
        <returns>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> маршалируется по ссылке; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен производным классом.  
  
   
  
## Examples  
 В следующем примере определяется ли данный тип маршалируется по ссылке и отображает результат.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, представляет ли текущий объект <see cref="T:System.Type" /> тип, определение которого вложено в определение другого типа.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> вложен в другой тип; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A> Возвращает `true` все вложенные типы, независимо от видимости. Чтобы проверить вложение и видимость в то же время, используйте связанные свойства <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, или <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask> Член перечисления выбирает атрибуты видимости для типа.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенные классы, которые имеют различные типы видимости. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и всех его вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> вложенным и видимым только в своей сборке.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и видимым только в своей сборке; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенные классы, которые имеют различные типы видимости. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и всех его вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> вложенным и видимым только для классов, принадлежащих одновременно к семейству и сборке этого объекта.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и видимым только классам, принадлежащим одновременно к семейству и сборке этого объекта; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
> [!NOTE]
>  В языках C# и Visual Basic не включают семантики, вы можете определить вложенный тип, который является видимым только для защищенных типы в сборке. `protected internal` видимость в C# и `Protected Friend` видимости в Visual Basic определяют вложенный тип, который является видимым, защищенные типы и типы в той же сборке.  
  
 Объект <xref:System.Type> семейство объекта определяется как все объекты в одной и той же <xref:System.Type> и из его подтипов.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенные классы, которые имеют различные типы видимости. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и всех его вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> вложенным и видимым только в своем семействе.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и видимым только внутри собственного семейства; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
 Объект <xref:System.Type> семейство объекта определяется как все объекты точного же <xref:System.Type> и из его подтипов.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенные классы, которые имеют различные типы видимости. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и всех его вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли данный объект <see cref="T:System.Type" /> вложенным и видимым только для классов, принадлежащих либо к его семейству, либо к его сборке.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и видимым только классам, принадлежащим его семейству или его сборке; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если видимость типа `protected internal` в C# или `Protected Friend` в Visual Basic, <xref:System.Type.IsNestedFamORAssem%2A> возвращает `true`.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
 Объект <xref:System.Type> семейство объекта определяется как все объекты точного же <xref:System.Type> и из его подтипов.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенные классы, которые имеют различные типы видимости. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и всех его вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> вложенным и объявленным как закрытый.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и объявленным как закрытый; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенные классы, которые имеют различные типы видимости. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и всех его вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли класс вложенным и объявленным как открытый.</summary>
        <value>Значение <see langword="true" />, если данный класс является вложенным и объявленным как открытый; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенные классы, которые имеют различные типы видимости. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и всех его вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, не был ли объект <see cref="T:System.Type" /> объявлен как открытый.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> не объявлен как открытый и не является вложенным типом; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не используйте это свойство для вложенных типов. Используйте <xref:System.Type.IsNestedPublic%2A> свойство вместо этого.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство возвращает `false`.  
  
   
  
## Examples  
 В этом примере используется `IsNotPublic` свойство видимости типа.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 В следующем примере кода показано, почему не удается использовать `IsPublic` и `IsNotPublic` для вложенных классов.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Для вложенных классов игнорировать результаты `IsPublic` и `IsNotPublic` и обратите внимание только результаты `IsNestedPublic` и `IsNestedPrivate`. Выходные данные отражения для этого фрагмента кода будет выглядеть следующим образом:  
  
|Класс|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|А|false|true|false|false|  
|С|false|false|true|false|  
|В|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли объект <see cref="T:System.Type" /> указателем.</summary>
        <value>Значение <see langword="true" />, если <see cref="T:System.Type" /> является указателем; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет универсальный тип или параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 В следующем примере показано использование `IsPointer` свойство.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsPointer" /> и определяет, является ли объект <see cref="T:System.Type" /> указателем.</summary>
        <returns>Значение <see langword="true" />, если <see cref="T:System.Type" /> является указателем; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли <see cref="T:System.Type" /> одним из типов-примитивов.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является одним из типов-примитивов; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Примитивные типы являются <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, и <xref:System.Single>.  
  
 Если текущий <xref:System.Type> представляет универсальный тип или параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере демонстрируется `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, и <xref:System.Type.IsPrimitive%2A> свойства <xref:System.Type> класса. Проверяется ли данный тип может размещаться в контексте, ли он может быть маршалирован по ссылке, и является ли тип примитивный тип данных.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsPrimitive" /> и определяет, является ли объект <see cref="T:System.Type" /> одним из типов-примитивов.</summary>
        <returns>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является одним из типов-примитивов; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Примитивные типы являются <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, и <xref:System.Single>.  
  
   
  
## Examples  
 В следующем примере определяется ли данный тип является типом-примитивом и отображает результат.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, был ли объект <see cref="T:System.Type" /> объявлен как открытый.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> объявлен как открытый и не является вложенным типом; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не используйте для вложенных типов. Используйте <xref:System.Type.IsNestedPublic%2A> вместо этого.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство возвращает `true`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
   
  
## Examples  
 В следующем примере создается экземпляр `MyTestClass`, проверяет наличие `IsPublic` свойство и отображает результат.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Для вложенных классов игнорировать результаты `IsPublic` и `IsNotPublic` и обратите внимание только результаты <xref:System.Type.IsNestedPublic%2A> и <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, был ли объект <see cref="T:System.Type" /> объявлен как запечатанный.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> объявлен как запечатанный; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `true`.  
  
   
  
## Examples  
 В следующем примере создается экземпляр `sealed` класса, проверяется `IsSealed` свойство и отображает результат.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, является ли текущий тип критически важным для безопасности или защищенным критически важным для безопасности на данном уровне доверия и, следовательно, может ли он выполнять критические операции.</summary>
        <value>Значение <see langword="true" />, если текущий тип является критически важным для безопасности или защищенным критически важным для безопасности на текущем уровне доверия; значение <see langword="false" />, если он является прозрачным.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, И <xref:System.Type.IsSecurityTransparent%2A> свойства отчетов уровень прозрачности типа в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR). В следующей таблице показаны сочетания этих свойств:  
  
|Уровень безопасности|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|Надежным с точки зрения|`true`|`true`|`false`|  
|Прозрачный|`false`|`false`|`true`|  
  
 Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.  
  
> [!IMPORTANT]
>  Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки. Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки. Сборка и все типы считаются прозрачными. Среда выполнения уделяет внимание примечания безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения). Напротив доверенная сборка (то есть со строгим именем сборки, которая установлена в глобальном кэше сборок) всегда загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным. Текущие уровни доверия сборок и доменов приложений можно определить с помощью <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> свойства.  
  
 Дополнительные сведения о отражение и прозрачность, см. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Сведения о прозрачности, см. в разделе [изменения системы безопасности](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Соображения о безопасности для отражения</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Изменения системы безопасности в .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, является ли текущий тип защищенным критически важным для безопасности на текущем уровне доверия и, следовательно, может ли он выполнять критические операции и предоставлять доступ прозрачному коду.</summary>
        <value>Значение <see langword="true" />, если текущий тип является защищенным критически важным для безопасности на текущем уровне доверия; значение <see langword="false" />, если он является критически важным для безопасности или прозрачным.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, И <xref:System.Type.IsSecurityTransparent%2A> свойства отчетов уровень прозрачности типа в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR). В следующей таблице показаны сочетания этих свойств:  
  
|Уровень безопасности|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|Надежным с точки зрения|`true`|`true`|`false`|  
|Прозрачный|`false`|`false`|`true`|  
  
 Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.  
  
> [!IMPORTANT]
>  Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки. Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки. Сборка и все типы считаются прозрачными. Среда выполнения уделяет внимание примечания безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения). Напротив доверенная сборка (то есть со строгим именем сборки, которая установлена в глобальном кэше сборок) всегда загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным. Текущие уровни доверия сборок и доменов приложений можно определить с помощью <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> свойства.  
  
 Дополнительные сведения о отражение и прозрачность, см. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Сведения о прозрачности, см. в разделе [изменения системы безопасности](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Соображения о безопасности для отражения</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Изменения системы безопасности в .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое указывает, является ли текущий тип прозрачным на текущем уровне доверия и, следовательно, не может выполнять критические операции.</summary>
        <value>Значение <see langword="true" />, если текущий тип является прозрачным на текущем уровне доверия; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если это свойство возвращает `true`, <xref:System.Type.IsSecurityCritical%2A> и <xref:System.Type.IsSecuritySafeCritical%2A> возвращают свойства `false`.  
  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, И <xref:System.Type.IsSecurityTransparent%2A> свойства отчетов уровень прозрачности типа в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR). Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.  
  
> [!IMPORTANT]
>  Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки. Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки. Сборка и все типы считаются прозрачными. Среда выполнения уделяет внимание примечания безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения). Напротив доверенная сборка (то есть со строгим именем сборки, которая установлена в глобальном кэше сборок) всегда загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным. Текущие уровни доверия сборок и доменов приложений можно определить с помощью <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> свойства.  
  
 Дополнительные сведения о отражение и прозрачность, см. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Сведения о прозрачности, см. в разделе [изменения системы безопасности](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Соображения о безопасности для отражения</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Изменения системы безопасности в .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, сериализуем ли объект <see cref="T:System.Type" />.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является сериализуемым; в противным случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Типы, которые определены в .NET Standard не отмечены <xref:System.SerializableAttribute>. Вместо этого каждая реализация .NET определяет, является ли тип сериализуемым. Во время выполнения, можно использовать <xref:System.Type.IsSerializable%2A> свойства, чтобы определить, поддерживает ли эта реализация сериализации экземпляра типа. Дополнительные сведения и пример см. в разделе [как определить, если объект .NET Standard является сериализуемым](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере создается экземпляр `MyTestClass` классе, задает атрибут [Serializable] и проверяет `IsSerializable` свойство для `true` или `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, требует ли имя данного объекта специальной обработки.</summary>
        <value>Значение <see langword="true" />, если имя типа требует специальной обработки; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имена, которые начинаются с или содержать символа подчеркивания (_), доступа к свойствам и методы перегрузки операторов приведены примеры типов, которые могут потребовать специальной обработки в некоторых компиляторах.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">Тип для сравнения с текущим типом.</param>
        <summary>Определяет, является ли текущий <see cref="T:System.Type" /> производным от указанного <see cref="T:System.Type" />.</summary>
        <returns>Значение <see langword="true" />, если текущий объект <see langword="Type" /> является производным от <paramref name="c" />; в противном случае — <see langword="false" />. Этот метод также возвращает значение <see langword="false" />, если параметр <paramref name="c" /> и текущий объект <see langword="Type" /> равны.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете вызвать <xref:System.Type.IsSubclassOf%2A> метод для определения любой из следующих:  
  
-   Является ли один класс является производным от другого.  
  
-   Является ли один тип является производным от <xref:System.ValueType>. Тем не менее <xref:System.Type.IsValueType%2A> — это более эффективный способ определить, является ли тип типом значения.  
  
-   Является ли один тип является производным от <xref:System.Enum>. Тем не менее <xref:System.Type.IsEnum%2A> метод является более эффективный способ определить, является ли тип перечисления.  
  
-   Является ли тип делегата, то есть ли он является производным от либо <xref:System.Delegate> или <xref:System.MulticastDelegate>.  
  
 <xref:System.Type.IsSubclassOf%2A> Метод не может использоваться для определения, является ли интерфейс производным от другого интерфейса или ли класс реализует интерфейс. Используйте <xref:System.Type.IsAssignableFrom%2A> метод для этой цели, как показано в следующем примере.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, он является производным от ограничения своего класса или из <xref:System.Object?displayProperty=nameWithType> если он не имеет ограничения класса.  
  
> [!NOTE]
>  За исключением случаев использования с интерфейсами, <xref:System.Type.IsSubclassOf%2A> является противоположностью <xref:System.Type.IsAssignableFrom%2A>. То есть если `t1.IsSubclassOf(t2)` — `true`, затем `t2.IsAssignableFrom(t1)` также `true`.  
  
 Этот метод может быть переопределен производным классом.  
  
   
  
## Examples  
 В следующем примере создается класс с именем `Class1` и производный класс с именем `DerivedC1`. Он вызывает <xref:System.Type.IsSubclassOf%2A> метод, чтобы показать, что `DerivedC1` является подклассом `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, выбран ли для объекта <see langword="UnicodeClass" /> атрибут формата строки <see cref="T:System.Type" />.</summary>
        <value>Значение <see langword="true" />, если для данного объекта <see langword="UnicodeClass" /> выбран атрибут формата строки <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Используется для выбора атрибутов формата строки. Атрибуты формата строки расширяют возможности взаимодействия, определяющий способ интерпретации строки.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> типом значения.</summary>
        <value>Значение <see langword="true" />, если тип <see cref="T:System.Type" /> является типом значения; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Типы значений являются типы, которые отображаются в виде последовательности битов; типы значений не являются классами или интерфейсами. Типы значений, называются «структуры» в некоторых языках программирования. Перечисления являются особым случаем типов значений.  
  
 Это свойство возвращает `false` для <xref:System.ValueType> класса, так как <xref:System.ValueType> не является типом значения, сам. Это базовый класс для всех типов значений, и таким образом любой тип значения можно присвоить его. Это было бы невозможным Если <xref:System.ValueType> сам был типом значения. Типы значений упакованы в том случае, если они назначены поле типа <xref:System.ValueType>.  
  
 Это свойство возвращает `true` для перечислений, но не для <xref:System.Enum> сам тип. Пример, демонстрирующий такие действия, см. в разделе <xref:System.Type.IsEnum%2A>.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 В следующем примере создается переменная типа `MyEnum`, проверяет наличие `IsValueType` свойство и отображает результат.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Реализует свойство <see cref="P:System.Type.IsValueType" /> и определяет, является ли объект <see cref="T:System.Type" /> типом значения (иными словами, не является классом или интерфейсом).</summary>
        <returns>Значение <see langword="true" />, если тип <see cref="T:System.Type" /> является типом значения; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для обеспечения реализации альтернативных типов систем. Обычно он не используется в коде приложения.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, можно ли получить доступ к объекту <see cref="T:System.Type" /> из кода за пределами сборки.</summary>
        <value>Значение <see langword="true" />, если текущий объект <see cref="T:System.Type" /> является открытым типом или открытым вложенным типом, все включающие типы которого также являются открытыми; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется для определения, является ли тип частью открытого интерфейса сборки компонентов.  
  
   
  
## Examples  
 В следующем примере кода проверяются два класса, только один из которых является видимым извне.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, который представляет массив текущего типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</summary>
        <returns>Объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> Метод предоставляет возможность создавать типы массивов, типы элементов которых вычисляются во время выполнения.  
  
 **Примечание** среда CLR проводится различие между векторами (то есть одномерные массивы, которые всегда отсчитываемый от нуля) и многомерных массивов. Вектор, который всегда имеет только одно измерение, не совпадает с многомерном массиве, который имеет только одно измерение. Эта перегрузка метода может использоваться только для создания векторных типов, и это единственный способ создания векторных типов. Используйте <xref:System.Type.MakeArrayType%28System.Int32%29> перегруженный метод для создания типов многомерного массива.  
  
   
  
## Examples  
 В следующем примере кода создается массив, `ref` (`ByRef` в Visual Basic) и типы указателей для `Test` класса.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе. Реализацию должны обеспечивать производные классы.</exception>
        <exception cref="T:System.TypeLoadException">Текущий тип — <see cref="T:System.TypedReference" />.  
  
-или- 
Текущий тип — <see langword="ByRef" />. То есть <see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank">Размерность массива. Это число должно быть меньше либо равно 32.</param>
        <summary>Возвращает объект <see cref="T:System.Type" />, представляющий массив текущего типа указанной размерности.</summary>
        <returns>Объект, представляющий массив текущего типа указанной размерности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> Метод предоставляет возможность создавать типы массивов, типы элементов которых вычисляются во время выполнения.  
  
> [!NOTE]
>  Среда CLR проводится различие между векторами (то есть одномерные массивы, которые всегда отсчитываемый от нуля) и многомерных массивов. Вектор, который всегда имеет только одно измерение, не совпадает с многомерном массиве, который имеет только одно измерение. Эту перегрузку метода нельзя использовать для создания типа vector; Если `rank` равно 1, эта перегрузка метода возвращает тип многомерного массива, который имеет одно измерение. Используйте <xref:System.Type.MakeArrayType> перегруженный метод для создания векторных типов.  
  
   
  
## Examples  
 В следующем примере кода создается массив, `ref` (`ByRef` в Visual Basic) и типы указателей для `Test` класса.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" /> недопустим. Например, 0 или отрицательное число.</exception>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе.</exception>
        <exception cref="T:System.TypeLoadException">Текущий тип — <see cref="T:System.TypedReference" />.  
  
-или- 
Текущий тип — <see langword="ByRef" />. То есть <see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />.  
  
-или- 
 Значение <paramref name="rank" /> больше 32.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра <see langword="ref" /> (параметра <see langword="ByRef" /> в Visual Basic).</summary>
        <returns>Объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра <see langword="ref" /> (параметра <see langword="ByRef" /> в Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeByRefType%2A> Метод предоставляет способ создания `ref` типов (`ByRef` в Visual Basic) для параметра перечислены.  
  
 С помощью синтаксиса промежуточного языка Майкрософт (MSIL), если текущий <xref:System.Type> представляет объект <xref:System.Int32>, этот метод возвращает <xref:System.Type> объект, представляющий `Int32&`.  
  
   
  
## Examples  
 В следующем примере кода создается массив, `ref` (`ByRef` в Visual Basic) и типы указателей для `Test` класса.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе.</exception>
        <exception cref="T:System.TypeLoadException">Текущий тип — <see cref="T:System.TypedReference" />.  
  
-или- 
Текущий тип — <see langword="ByRef" />. То есть <see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition">To be added.</param>
        <param name="typeArguments">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Массив типов, который должен быть замещен параметрами типа текущего универсального типа.</param>
        <summary>Замещает элементы массива типов для параметров определения текущего универсального типа и возвращает объект <see cref="T:System.Type" />, представляющий сконструированный результирующий тип.</summary>
        <returns><see cref="T:System.Type" /> представляет сконструированный тип, сформированный путем замещения элементов объекта <paramref name="typeArguments" /> параметрами текущего универсального типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeGenericType%2A> Метод позволяет написать код, который назначает определенные типы параметров типа определения универсального типа, тем самым создавая <xref:System.Type> , представляющий определенный сконструированный тип. Это можно использовать <xref:System.Type> объект для создания экземпляров во время выполнения сконструированного типа.  
  
 Конструировать типы с <xref:System.Type.MakeGenericType%2A> могут быть открыты, то есть некоторые их аргументы могут быть параметры типа заключающих универсальные методы и типы. Такие открытые сконструированные типы можно использовать при выпуске динамических сборок. Например, рассмотрим классы `Base` и `Derived` в следующем коде.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Для создания `Derived` в динамической сборке, бывает необходимо построить его базовый тип. Чтобы сделать это, вызовите <xref:System.Type.MakeGenericType%2A> метод <xref:System.Type> объект, представляющий класс `Base`, используя аргументы универсального типа <xref:System.Int32> и параметр типа `V` из `Derived`. Так как типы и параметры универсального типа, оба представлены <xref:System.Type> объектов, можно передать массив, содержащий оба <xref:System.Type.MakeGenericType%2A> метод.  
  
> [!NOTE]
>  Сконструированный тип, такой как `Base<int, V>` будет полезно при запуске выпуска кода, но нельзя вызывать <xref:System.Type.MakeGenericType%2A> метод для этого типа, так как он не является определением универсального типа. Для создания закрытого сконструированного типа, которое может быть создано, сначала вызовите <xref:System.Type.GetGenericTypeDefinition%2A> метод для получения <xref:System.Type> объект, представляющий определение универсального типа, а затем вызвать <xref:System.Type.MakeGenericType%2A> с аргументами требуемому типу.  
  
 <xref:System.Type> Объект, возвращаемый <xref:System.Type.MakeGenericType%2A> совпадает со значением <xref:System.Type> получен путем вызова <xref:System.Object.GetType%2A> метод итоговый сконструированный тип, или <xref:System.Object.GetType%2A> метод любого сконструированный тип, который был создан с использованием того же универсального Определение типа, с теми же аргументами типа.  
  
> [!NOTE]
>  Массив универсальных типов сама по себе не универсального типа. Нельзя вызывать <xref:System.Type.MakeGenericType%2A> массива введите например `C<T>[]` (`Dim ac() As C(Of T)` в Visual Basic). Для создания закрытого универсального типа из `C<T>[]`, вызовите <xref:System.Type.GetElementType%2A> для получения определения универсального типа `C<T>`; вызвать <xref:System.Type.MakeGenericType%2A> в определении универсального типа для создания сконструированного типа; и Наконец вызовите <xref:System.Type.MakeArrayType%2A> метод сконструированный тип, чтобы создать тип массива. То же самое относится и к типы указателей и `ref` типов (`ByRef` в Visual Basic).  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
## <a name="nested-types"></a>Вложенные типы  
 Если универсальный тип определен с помощью C#, C++ или Visual Basic, его вложенные типы являются универсальными. Это справедливо, даже если вложенные типы не имеют тип параметров собственные, так как все три языка включают параметры типа заключающих типов в список параметров вложенных типов. Рассмотрим следующие классы:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 Список параметров типа вложенного класса `Inner` имеет два параметра типа, `T` и `U`, первая из которых является параметром типа включающего класса. Аналогичным образом, список параметров типа вложенного класса `Innermost1` принимает три параметра типа, `T`, `U`, и `V`, с помощью `T` и `U` ожидается классами. Вложенный класс `Innermost2` имеет два параметра типа, `T` и `U`, который поставляется с классами.  
  
 Если список параметров данного включающего типа имеет более одного параметра типа, все параметры типа в порядке будут включены в списке параметров типа вложенного типа.  
  
 Для конструирования универсального типа из определения универсального типа для вложенного типа, вызовите <xref:System.Type.MakeGenericType%2A> метод с массивом, сформированном путем объединения всех заключающих типов, начиная с внешней универсального типа, и заканчивая массивов аргументов Массив аргументов типа вложенного типа, если он имеет свои собственные параметры типа. Чтобы создать экземпляр `Innermost1`, вызовите <xref:System.Type.MakeGenericType%2A> метод с массив, содержащий три типа, присваиваемое T, U и V. Чтобы создать экземпляр `Innermost2`, вызовите <xref:System.Type.MakeGenericType%2A> метод с массив, содержащий два типа, присваиваемое T и U.  
  
 Языки программирования распространяют параметры типа заключающих типов таким образом, чтобы использовать параметры типа вмещающего типа для определения полей вложенных типов. В противном случае параметры типа в области в телах вложенные типы не будет. Можно определить вложенные типы без распространения параметры типа заключающих типов, путем создания кода в динамических сборках, или с помощью [Ilasm.exe (ассемблер IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Рассмотрим следующий код для ассемблера MSIL.  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 В этом примере не можно определить поля типа `T` или `U` в классе `Innermost`, так как таких параметров типа находятся вне области. Следующий код ассемблера определения вложенных классов, которые ведут себя так, определенных в C++, Visual Basic и C#.  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Можно использовать [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) для проверки вложенные классы, определенные в языках высокого уровня и наблюдать за такая схема именования.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Type.MakeGenericType%2A> метод для создания сконструированного типа из определения универсального типа для <xref:System.Collections.Generic.Dictionary%602> типа. Представляет сконструированный тип <xref:System.Collections.Generic.Dictionary%602> из `Test` объектов со строковыми ключами.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий тип не представляет определение универсального типа. То есть <see cref="P:System.Type.IsGenericTypeDefinition" /> возвращает <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" /> — <see langword="null" />.  
  
-или- 
Любой элемент <paramref name="typeArguments" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Количество элементов в <paramref name="typeArguments" /> не совпадает с количеством параметров типа в текущем определении универсального типа.  
  
-или- 
Элементы <paramref name="typeArguments" /> не соответствуют ограничениям, указанным для соответствующего параметра типа текущего определения универсального типа.  
  
-или- 
 <paramref name="typeArguments" /> содержит элемент, который является типом указателя (<see cref="P:System.Type.IsPointer" /> возвращает <see langword="true" />), типом доступа по ссылке (<see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />) или <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе. Реализацию должны обеспечивать производные классы.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Отражение и универсальные типы</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Практическое руководство. Изучение универсальных типов и создание их экземпляров при помощи отражения</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, который представляет указатель на текущий тип.</summary>
        <returns>Объект <see cref="T:System.Type" />, который представляет указатель на текущий тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A> Метод предоставляет способ для создания типов указателя для списки параметров.  
  
 С помощью синтаксиса промежуточного языка Майкрософт (MSIL), если текущий <xref:System.Type> представляет объект <xref:System.Int32>, этот метод возвращает <xref:System.Type> объект, представляющий `Int32*`.  
  
   
  
## Examples  
 В следующем примере кода создается массив, `ref` (`ByRef` в Visual Basic) и типы указателей для `Test` класса.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе.</exception>
        <exception cref="T:System.TypeLoadException">Текущий тип — <see cref="T:System.TypedReference" />.  
  
-или- 
Текущий тип — <see langword="ByRef" />. То есть <see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение <see cref="T:System.Reflection.MemberTypes" />, позволяющее определить, каким типом является этот член: обычным или вложенным.</summary>
        <value>Значение <see cref="T:System.Reflection.MemberTypes" />, позволяющее определить, каким типом является этот член: обычным или вложенным.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство переопределяет <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. Таким образом, при анализе набора <xref:System.Reflection.MemberInfo> объектов: например, массив, возвращаемый <xref:System.Type.GetMembers%2A> - <xref:System.Reflection.MemberInfo.MemberType%2A> возвращает <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> когда данный элемент является вложенным типом.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, из которого был создан тип. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем коде показано в примере `MemberType` поле в качестве параметра `GetMember` метод:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет отсутствующее значение в данных объекта <see cref="T:System.Type" />. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `Missing` для вызова через отражение для получения значения параметра по умолчанию. Если `Missing` передается в качестве значения параметра, а не значение по умолчанию для этого параметра <xref:System.ArgumentException> возникает исключение.  
  
   
  
## Examples  
 В следующем примере кода показано использование `Missing` поля для вызова метода с аргументами по умолчанию.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Этот код выводит следующие результаты:  
  
 = 10 b = 55.3 c = 12  
  
 = 10 b = 1.3 c = 1  
  
 = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает модуль (DLL), в котором определен текущий объект <see cref="T:System.Type" />.</summary>
        <value>Модуль, в котором определен текущий объект <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает модуль, в котором был определен определения универсального типа. Например, если создать экземпляр `MyGenericStack<int>`, <xref:System.Type.Module%2A> свойство для сконструированного типа возвращает модуль, в котором `MyGenericStack<T>` определен.  
  
 Аналогично Если текущий <xref:System.Type> представляет универсальный параметр `T`, это свойство возвращает сборку, содержащую универсальный тип, который определяет `T`.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Type.Namespace%2A> и `Module` свойства и <xref:System.Type.ToString%2A> метод <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает имя текущего типа.</summary>
        <value>Имя текущего типа.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает пространство имен объекта <see cref="T:System.Type" />.</summary>
        <value>Пространство имен <see cref="T:System.Type" /> или значение <see langword="null" />, если текущий экземпляр не имеет пространства имен или представляет универсальный параметр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пространство имен — логический разработки именования удобства используется главным образом для определения области в приложении и организации классов и других типов в виде одного иерархической структуры. С точки зрения среды выполнения отсутствуют пространства имен.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает пространство имен, содержащее определение универсального типа. Аналогично Если текущий <xref:System.Type> представляет универсальный параметр `T`, это свойство возвращает пространство имен, содержащее определение универсального типа, который определяет `T`.  
  
 Если текущий <xref:System.Type> представляет универсальный параметр, это свойство возвращает `null`.  
  
   
  
## Examples  
 В следующем примере показано использование `Namespace` и <xref:System.Type.Module%2A> свойства и <xref:System.Type.ToString%2A> метод <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Указание полных имен типов</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">Первый из сравниваемых объектов.</param>
        <param name="right">Второй из сравниваемых объектов.</param>
        <summary>Определение равенства двух объектов <see cref="T:System.Type" />.</summary>
        <returns><see langword="true" />, если значения параметров <paramref name="left" /> и <paramref name="right" /> равны; в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">Первый из сравниваемых объектов.</param>
        <param name="right">Второй из сравниваемых объектов.</param>
        <summary>Определяет неравенство двух объектов <see cref="T:System.Type" />.</summary>
        <returns><see langword="true" />, если значения <paramref name="left" /> и <paramref name="right" /> не равны; в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект класса, который использовался для получения этого члена.</summary>
        <value>Объект <see langword="Type" />, с помощью которого был получен данный объект <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для <xref:System.Type> объекты, значение этого свойства всегда равно таким же, как значение <xref:System.Type.DeclaringType%2A> свойства.  
  
   
  
## Examples  
 В этом примере отраженный тип вложенного класса.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя искомого типа <see cref="T:System.Type" /> с указанием сборки.</param>
        <param name="throwIfNotFound">Значение <see langword="true" />, чтобы в случае невозможности найти тип создавалось исключение <see cref="T:System.TypeLoadException" />; значение <see langword="false" />, чтобы при невозможности найти тип возвращалось значение <see langword="null" />. Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них. См. раздел "Исключения".</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при поиске <paramref name="typeName" />, значение <see langword="false" />, чтобы учитывать регистр при поиске <paramref name="typeName" />.</param>
        <summary>Возвращает объект <see cref="T:System.Type" /> с заданным именем, позволяющий определить, будет ли учитываться регистр при поиске, и будет ли создаваться исключение в случае невозможности найти тип. Тип загружается не для выполнения, а только для отражения.</summary>
        <returns>Тип с указанным именем, если он существует; в противном случае — значение <see langword="null" />. Если тип не найден, параметр <paramref name="throwIfNotFound" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения. В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwIfNotFound" />. См. раздел "Исключения".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если сборка, содержащая тип еще не загружена в контекст только для отражения, с помощью <xref:System.Type.ReflectionOnlyGetType%2A> метод является эквивалентно первой загрузке сборки, а только для отражения с помощью <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> метода и затем загрузив тип путем вызова сборки <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> метод. Сведения об именах, с указанием сборки см. в разделе <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> свойство. Дополнительные сведения об указании имен типов см. в разделе <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> перегрузки метода.  
  
 Если сборка уже загружена для выполнения, другая копия загружается в контекст только для отражения.  
  
 `throwIfNotFound` Параметр указывает, что произойдет, если тип не найден, а также подавляются некоторые другие условия исключения, как описано в раздел "исключения". Некоторые исключения создаются независимо от значения `throwIfNotFound`. Например, если сборка не является допустимым <xref:System.BadImageFormatException> возникает даже в том случае, если `throwIfNotFound` является `false`.  
  
 Дополнительные сведения об использовании в контексте только для отражения, см. в разделе [как: Загрузка сборок в контекст, предназначенный только для отражения](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и тип не найден.  
  
-или- 
 <paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции. 
-или- 
 <paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.  
  
-или- 
 <paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.  
  
-или- 
 <paramref name="typeName" /> представляет массив объектов <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> не включает имя сборки.  
  
-или- 
 <paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис (например, "MyType[,*,]").  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
-или- 
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
-или- 
Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Указание полных имен типов</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">Практическое руководство. Загрузка сборок в контекст, предназначенный только для отражения</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает атрибут <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />, описывающий структуру текущего типа.</summary>
        <value>Возвращает атрибут <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />, описывающий общие особенности структуры текущего типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> не возвращаемый <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> метод. Используйте это свойство для его получения.  
  
   
  
## Examples  
 В следующем примере кода сначала определяет класс, структуру и структуру с особыми атрибутами размещения (структуры вложены в классе). Затем в примере используется <xref:System.Type.StructLayoutAttribute%2A> свойство для получения <xref:System.Runtime.InteropServices.StructLayoutAttribute> для каждого типа и отображает свойства атрибутов.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="rgszNames">Переданный массив имен, которые необходимо сопоставить.</param>
        <param name="cNames">Количество сопоставляемых имен.</param>
        <param name="lcid">Контекст языкового стандарта для интерпретации имен.</param>
        <param name="rgDispId">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</param>
        <summary>Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetIDsOfNames`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Возвращаемые сведения о типе.</param>
        <param name="lcid">Идентификатор языкового стандарта для сведений о типе.</param>
        <param name="ppTInfo">Указатель на объект с запрошенными сведениями о типе.</param>
        <summary>Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfo`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</param>
        <summary>Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfoCount`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Идентифицирует член.</param>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="lcid">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</param>
        <param name="wFlags">Флаги, описывающие контекст вызова.</param>
        <param name="pDispParams">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</param>
        <param name="pVarResult">Указатель, по которому будет сохранен результат.</param>
        <param name="pExcepInfo">Указатель на структуру, содержащую сведения об исключении.</param>
        <param name="puArgErr">Индекс первого аргумента, вызвавшего ошибку.</param>
        <summary>Предоставляет доступ к открытым свойствам и методам объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::Invoke`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект типа <see langword="String" />, представляющий имя текущего объекта <see langword="Type" />.</summary>
        <returns>Объект типа <see cref="T:System.String" />, представляющий имя текущего объекта <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает полное распространенных пространством имен среды CLR и имя для всех типов-примитивов. Например, C# инструкция `(long)0.Type().ToString()` возвращает «System.Int64» вместо просто «Int64».  
  
 Если текущий <xref:System.Type> представляет универсальный тип, тип и его аргументов типа являются уточненными пространством имен и вложенного типа, но не сборку. Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод возвращает неполное имя параметра типа.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Type.Namespace%2A> и <xref:System.Type.Module%2A> свойства и `ToString` метод <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 В следующем примере сравниваются строки, возвращаемые <xref:System.Type.ToString%2A> метод и `Name`, <xref:System.Type.FullName%2A>, и <xref:System.Type.AssemblyQualifiedName%2A> свойства.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает дескриптор текущего объекта <see cref="T:System.Type" />.</summary>
        <value>Дескриптор текущего объекта <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` Инкапсулирует указатель на внутреннюю структуру данных, представляющий тип. Этот дескриптор является уникальным во время существования процесса. Дескриптор действителен только в домене приложения, в котором они были получены.  
  
   
  
## Examples  
 В следующем примере возвращает дескриптор соответствующего типа и передает дескриптор методу, который возвращает тип из дескриптора и отображает его.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Платформа .NET Compact Framework в настоящее время не поддерживает это свойство.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает инициализатор типа.</summary>
        <value>Объект, содержащий имя конструктора класса <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Инициализаторы класса также доступны через <xref:System.Type.FindMembers%2A> метод, или с помощью перегрузки <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, и <xref:System.Type.GetConstructors%2A> методов, принимающих <xref:System.Reflection.BindingFlags> как параметр.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство возвращает `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на тип, предоставляемый средой CLR, представляющей этот тип.</summary>
        <value>Базовый системный тип текущего типа <see cref="T:System.Type" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>