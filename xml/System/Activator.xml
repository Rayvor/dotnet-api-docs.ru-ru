<Type Name="Activator" FullName="System.Activator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="021cbadaa32d2056f3fd7224f72385784c86bdc7" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75024341" /></Metadata><TypeSignature Language="C#" Value="public sealed class Activator : System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Activator extends System.Object implements class System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="DocId" Value="T:System.Activator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Activator&#xA;Implements _Activator" />
  <TypeSignature Language="C++ CLI" Value="public ref class Activator sealed : System::Runtime::InteropServices::_Activator" />
  <TypeSignature Language="F#" Value="type Activator = class&#xA;    interface _Activator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Activator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Activator))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Содержит методы, позволяющие локально или удаленно создавать типы объектов или получать ссылки на существующие удаленные объекты. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Activator.CreateInstance%2A> создает экземпляр типа, определенного в сборке, вызывая конструктор, который наилучшим образом соответствует указанным аргументам. Если аргументы не указаны, вызывается конструктор, не принимающий параметров, то есть конструктор без параметров.  
  
 Необходимо иметь достаточные разрешения для поиска и вызова конструктора. в противном случае создается исключение. По умолчанию во время поиска конструктора учитываются только открытые конструкторы. Если не удается найти конструктор или конструктор без параметров, возникает исключение.  
  
 Параметр BINDER указывает объект, который выполняет поиск подходящего конструктора в сборке. Можно указать собственный связыватель и условия поиска. Если связыватель не указан, используется связыватель по умолчанию. Дополнительные сведения см. в описаниях классов <xref:System.Reflection.Binder?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Параметр Evidence влияет на политику безопасности и разрешения для конструктора. Дополнительные сведения см. в описании класса <xref:System.Security.Policy.Evidence?displayProperty=nameWithType>.  
  
 Экземпляр типа может быть создан на локальном или удаленном сайте. Если тип создается удаленно, параметр атрибута активации задает универсальный код ресурса (URI) удаленного сайта. Вызов для создания экземпляра может пройти через промежуточные сайты, прежде чем он достигнет удаленного сайта. Другие атрибуты активации могут изменять среду или контекст, в которых вызов работает на удаленных и промежуточных сайтах.  
  
 Если экземпляр создается локально, возвращается ссылка на этот объект. Если экземпляр создается удаленно, возвращается ссылка на прокси-сервер. Удаленный объект управляется через прокси-сервер, как если бы он был локальным объектом.  
  
 Метод <xref:System.Activator.GetObject%2A> создает прокси-сервер для запущенного в данный момент удаленного объекта, хорошо известного объекта, активируемого сервером, или веб-службы XML. Можно указать носитель подключения, то есть канал. Дополнительные сведения см. в описании класса <xref:System.Runtime.Remoting.Channels.ChannelServices?displayProperty=nameWithType>.  
  
 Сборки содержат определения типов. Метод <xref:System.Activator.CreateInstance%2A> создает экземпляр типа из выполняемой в данный момент сборки. Метод <xref:System.Activator.CreateInstanceFrom%2A> создает экземпляр из файла, содержащего сборку. Метод <xref:System.Activator.CreateComInstanceFrom%2A> создает экземпляр COM-объекта из файла, содержащего сборку.  
  
   
  
## Examples  
 В следующем примере показано, как использовать класс <xref:System.Activator> для динамической конструирования объектов во время выполнения.  
  
 [!code-cpp[ActivatorX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#1)]
 [!code-csharp[ActivatorX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#1)]
 [!code-vb[ActivatorX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает экземпляр COM-объекта, для которого задано имя.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя файла, содержащего сборку, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />.</param>
        <param name="typeName">Имя предпочтительного типа.</param>
        <summary>Создает экземпляр COM-объекта с заданным именем, используя для этого файл именованной сборки и конструктор без параметров.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для распаковки возвращаемого значения используйте метод <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Атрибут <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> со значением `true` должен применяться явно или по умолчанию к типу COM, поэтому метод <xref:System.Activator.CreateComInstanceFrom%2A> может создать экземпляр этого типа. в противном случае выдается <xref:System.TypeLoadException>.  
  
 Сведения о других исключениях, которые могут вызываться вызванными методами, см. в разделе "исключения" в методах <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> и <xref:System.Activator.CreateInstance%2A>.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для создания неоткрытых типов, если вызывающий объект предоставил <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав сборки, содержащей неоткрытые типы, ограничен набором предоставления вызывающего объекта или подмножеством. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="typeName" /> или <paramref name="assemblyName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Невозможно создать экземпляр с помощью модели COM.  
  
- или - 
 <paramref name="typename" /> не найден в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</exception>
        <exception cref="T:System.MemberAccessException">Не удалось создать экземпляр абстрактного класса.  
  
 - или -  
  
 Этот элемент был вызван при помощи механизма позднего связывания.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyName" /> является пустой строкой ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя файла, содержащего сборку, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />.</param>
        <param name="typeName">Имя предпочтительного типа.</param>
        <param name="hashValue">Значение вычисленного хэш-кода.</param>
        <param name="hashAlgorithm">Хэш-алгоритм, используемый для хэширования файлов и создания строгого имени.</param>
        <summary>Создает экземпляр COM-объекта с заданным именем, используя для этого файл именованной сборки и конструктор без параметров.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для распаковки возвращаемого значения используйте метод <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Атрибут <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> со значением `true` должен применяться явно или по умолчанию к типу COM, поэтому метод <xref:System.Activator.CreateComInstanceFrom%2A> может создать экземпляр этого типа. в противном случае выдается <xref:System.TypeLoadException>.  
  
 Сведения о других исключениях, которые могут вызываться вызванными методами, см. в разделе "исключения" в методах <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> и <xref:System.Activator.CreateInstance%2A>.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для создания неоткрытых типов, если вызывающий объект предоставил <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав сборки, содержащей неоткрытые типы, ограничен набором предоставления вызывающего объекта или подмножеством. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="typeName" /> или <paramref name="assemblyName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyName" /> является пустой строкой ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.
        
- или - 
 <paramref name="assemblyName" /> превышает максимальную длину, определенную системой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</exception>
        <exception cref="T:System.IO.FileLoadException">Тип <paramref name="assemblyName" /> найден, но не может быть загружен.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.</exception>
        <exception cref="T:System.Security.SecurityException">База кода, которая не начинается с "file://", была указана без требуемого разрешения <see langword="WebPermission" />.</exception>
        <exception cref="T:System.TypeLoadException">Невозможно создать экземпляр с помощью COM-модели.  
  
- или - 
 <paramref name="typename" /> не найден в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.MemberAccessException">Не удается создать экземпляр абстрактного класса.  
  
 - или -  
  
 Этот элемент был вызван при помощи механизма позднего связывания.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения URI, который начинается с "file://". Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с "file://".</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает экземпляр указанного типа, используя конструктор, соответствующий заданным параметрам.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance activationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="activationContext">Объект контекста активации, задающий объект, который необходимо создать.</param>
        <summary>Создает экземпляр типа, назначенного указанным объектом <see cref="T:System.ActivationContext" />.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для распаковки возвращаемого значения используйте метод <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Контекст активации используется во время активации на основе манифеста для настройки политики домена и обеспечения модели безопасности на основе приложений. Класс <xref:System.ActivationContext> содержит объект <xref:System.ApplicationIdentity>, предоставляющий доступ к манифесту приложения. Дополнительные сведения см. в описании класса <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type -&gt; obj" Usage="System.Activator.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Тип создаваемого объекта.</param>
        <summary>Создает экземпляр указанного типа, используя конструктор этого типа без параметров.</summary>
        <returns>Ссылка на вновь созданный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызываемый конструктор должен быть доступен.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым типам, если вызывающей стороне был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав сборки, содержащей неоткрытые типы, ограничен набором предоставления вызывающего объекта или подмножеством. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
   
  
## Examples  
 В следующем примере кода показано, как вызвать метод <xref:System.Activator.CreateInstance%28System.Type%29>. Создаются экземпляры нескольких различных типов и отображаются их значения по умолчанию.  
  
 [!code-cpp[ActivatorX#4](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/source2.cpp#4)]
 [!code-csharp[ActivatorX#4](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/source2.cs#4)]
 [!code-vb[ActivatorX#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/source2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является объектом <see langword="RuntimeType" />.  
  
- или - 
 Тип <paramref name="type" /> является открытым универсальным типом (то есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="type" /> не может иметь значение <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- или - 
Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.  
  
- или - 
Сборка, содержащая <paramref name="type" />, является динамической сборкой, которая была создана с использованием <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Вызываемый конструктор создает исключение.</exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.MemberAccessException" />.  
  
</para>
          </block>  
  
 Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.MissingMemberException" />.  
  
</para>
          </block>  
  
 Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" /> — это COM-объект, но идентификатор класса, используемый для получения типа, является недопустимым, или идентифицируемый класс не зарегистрирован.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" /> не является допустимым типом.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам независимо от наборов разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext, string[] activationCustomData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext, string[] activationCustomData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext, cli::array &lt;System::String ^&gt; ^ activationCustomData);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext * string[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (activationContext, activationCustomData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8" />
        <Parameter Name="activationCustomData" Type="System.String[]" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="activationContext">Объект контекста активации, задающий объект, который необходимо создать.</param>
        <param name="activationCustomData">Массив строк в кодировке Юникод, содержащих пользовательские данные активации.</param>
        <summary>Создает экземпляр типа, назначенного указанным объектом <see cref="T:System.ActivationContext" /> и активированного с помощью указанных пользовательских данных активации.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для распаковки возвращаемого значения используйте метод <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Контекст активации используется во время активации на основе манифеста для настройки политики домена и обеспечения модели безопасности на основе приложений. Класс <xref:System.ActivationContext> содержит объект <xref:System.ApplicationIdentity>, предоставляющий доступ к манифесту приложения. Дополнительные сведения см. в описании класса <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя сборки, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />. Если параметр <paramref name="assemblyName" /> имеет значение <see langword="null" />, поиск осуществляется в выполняющейся сборке.</param>
        <param name="typeName">Полное имя предпочтительного типа.</param>
        <summary>Создает экземпляр типа с заданным именем, используя для этого именованную сборку и конструктор без параметров.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для распаковки возвращаемого значения используйте <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 `assemblyName` может быть одним из следующих:  
  
-   Простое имя сборки без пути или расширения файла. Например, можно указать `TypeExtensions` для сборки, путь и имя которых — .\Бин\типикстенсионс.длл.  
  
-   Полное имя подписанной сборки, состоящее из его простого имени, версии, языка и региональных параметров и токена открытого ключа; Например, "Типикстенсионс, Version = 1.0.0.0, культура = Neutral, PublicKeyToken = 181869f2f7435b51".  
  
 Дополнительные сведения о том, как среда CLR определяет и загружает сборки, см. [в разделе как среда выполнения находит сборки](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md). Сведения об использовании файла конфигурации приложения для определения расположений сборок см. в разделе [Указание расположения сборки](~/docs/framework/configure-apps/specify-assembly-location.md). Если `assemblyName` найден, он загружается в контексте по умолчанию.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для создания неоткрытых типов, если вызывающий объект предоставил <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав сборки, содержащей неоткрытые типы, ограничен набором предоставления вызывающего объекта или подмножеством. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
   
  
## Examples  
 В следующем примере определяется класс с именем `Person` в сборке с именем `PersonInfo`. Обратите внимание, что класс `Person` имеет два конструктора, один из которых не имеет параметров.  
  
 [!code-csharp[System.Activator.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/personinfo.cs#1)]
 [!code-vb[System.Activator.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/personinfo.vb#1)]  
  
 В следующем примере вызывается метод <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> для создания экземпляра класса `Person`. Для этого требуется ссылка на Персонинфо. dll для добавления в проект. Поскольку метод <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> вызывает конструктор без параметров класса `Person`, в примере присваивается значение свойству `Name`.  
  
 [!code-csharp[System.Activator.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1.cs#2)]
 [!code-vb[System.Activator.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1.vb#2)]  
  
 Однако <xref:System.Activator.CreateInstance%2A> часто вызывается для создания экземпляра типа, который пересекает границы компьютера или неизвестен во время разработки. В этом случае нельзя включить ссылку на сборку в проекте и выполнить вызовы с ранними привязками к членам этого типа. Чтобы обойти это ограничение, в следующем примере используется метод <xref:System.Activator.CreateInstance%2A> вместе с отражением для присвоения значения свойству `Name` объекта `Person` и для отображения его значения.  
  
 [!code-csharp[System.Activator.CreateInstance#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1a.cs#3)]
 [!code-vb[System.Activator.CreateInstance#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1a.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот член был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.  
  
 - или -  
  
 Недопустимые имя сборки или кодовая база.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, bool nonPublic);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * bool -&gt; obj" Usage="System.Activator.CreateInstance (type, nonPublic)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="nonPublic" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип создаваемого объекта.</param>
        <param name="nonPublic">Значение <see langword="true" />, если можно сопоставить как открытый, так и закрытый конструктор без параметров; значение <see langword="false" />, если можно сопоставить только открытый конструктор без параметров.</param>
        <summary>Создает экземпляр указанного типа, используя конструктор этого типа без параметров.</summary>
        <returns>Ссылка на вновь созданный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для доступа к закрытым типам и членам, если вызывающий объект предоставил <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав сборки, содержащей неоткрытые типы и члены, ограничен набором предоставления вызывающего объекта или подмножеством. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является объектом <see langword="RuntimeType" />.  
  
- или - 
 Тип <paramref name="type" /> является открытым универсальным типом (то есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="type" /> не может иметь значение <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- или - 
Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.  
  
- или - 
Сборка, содержащая <paramref name="type" />, является динамической сборкой, которая была создана с использованием <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Вызываемый конструктор создает исключение.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" /> — это COM-объект, но идентификатор класса, используемый для получения типа, является недопустимым, или идентифицируемый класс не зарегистрирован.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" /> не является допустимым типом.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам и членам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args)" />
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Тип создаваемого объекта.</param>
        <param name="args">Массив аргументов, число, порядок и тип которых соответствуют параметрам вызываемого конструктора. Если параметр <paramref name="args" /> предоставляет пустой массив или имеет значение <see langword="null" />, то вызывается конструктор, который не принимает никаких параметров (конструктор без параметров).</param>
        <summary>Создает экземпляр указанного типа, используя конструктор, соответствующий заданным параметрам.</summary>
        <returns>Ссылка на вновь созданный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызываемый конструктор должен быть доступен и должен предоставлять наиболее конкретное соответствие с указанным списком аргументов.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым типам, если вызывающей стороне был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав сборки, содержащей неоткрытые типы, ограничен набором предоставления вызывающего объекта или подмножеством. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> для создания объекта <xref:System.String>. Он вызывает конструктор <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> для создания экземпляра строки, содержащей десять элементов из массива символов, начиная с позиции четырнадцатого.  
  
 [!code-csharp[System.Activator.CreateInstance#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/CreateInstance5.cs#5)]
 [!code-vb[System.Activator.CreateInstance#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/CreateInstance5.vb#5)]  
  
 В следующем примере показано создание массива массивов, элементы которого являются аргументами, передаваемыми конструктору <xref:System.String>. Затем в примере каждый массив передается в <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> метод для вызова соответствующего конструктора строк.  
  
 [!code-csharp[System.Activator.CreateInstance#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstance2.cs#4)]
 [!code-vb[System.Activator.CreateInstance#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstance2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является объектом <see langword="RuntimeType" />.  
  
- или - 
 Тип <paramref name="type" /> является открытым универсальным типом (то есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="type" /> не может иметь значение <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- или - 
Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.  
  
- или - 
Сборка, содержащая <paramref name="type" />, является динамической сборкой, которая была создана с использованием <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
- или - 
Конструктор, который наилучшим образом соответствует <paramref name="args" />, имеет аргументы <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Вызываемый конструктор создает исключение.</exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.MemberAccessException" />.  
  
</para>
          </block>  
  
 Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.MissingMemberException" />.  
  
</para>
          </block>  
  
 Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" /> — это COM-объект, но идентификатор класса, используемый для получения типа, является недопустимым, или идентифицируемый класс не зарегистрирован.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" /> не является допустимым типом.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (domain As AppDomain, assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domain">Удаленный домен, в котором создан тип с именем <paramref name="typeName" />.</param>
        <param name="assemblyName">Имя сборки, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />. Если параметр <paramref name="assemblyName" /> имеет значение <see langword="null" />, поиск осуществляется в выполняющейся сборке.</param>
        <param name="typeName">Полное имя предпочтительного типа.</param>
        <summary>Создает экземпляр типа с заданным именем в указанном удаленном домене, используя для этого именованную сборку и конструктор без параметров.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Activator.CreateInstance%2A>, когда узлу требуется выполнить код в домене приложения с ограниченными разрешениями безопасности.  
  
 Для распаковки возвращаемого значения используйте <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Этот метод использует <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType>, чтобы непосредственный вызывающий объект имел полное доверие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="typeName" /> или <paramref name="domain" /> — <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Не удается создать экземпляр абстрактного типа.  
  
 - или -  
  
 Этот элемент был вызван при помощи механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.  
  
 - или -  
  
 Недопустимые имя сборки или кодовая база.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя сборки, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />. Если параметр <paramref name="assemblyName" /> имеет значение <see langword="null" />, поиск осуществляется в выполняющейся сборке.</param>
        <param name="typeName">Полное имя предпочтительного типа.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает экземпляр типа с заданным именем, используя для этого именованную сборку и конструктор без параметров.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для распаковки возвращаемого значения используйте <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для создания неоткрытых типов, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав неопубликованных типов ограничен набором предоставления вызывающего объекта или его подмножеством. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.  
  
- или - 
 <paramref name="activationAttributes" /> не является пустым массивом, а создаваемый тип не является производным от <see cref="T:System.MarshalByRefObject" />.  
  
- или - 
 <paramref name="activationAttributes" /> не является объектом <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />.  
  
Массив.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.  
  
 - или -  
  
 Недопустимые имя сборки или кодовая база.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Произошла ошибка при попытке удаленной активации в целевом объекте, указанном в <paramref name="activationAttributes" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[],System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип создаваемого объекта.</param>
        <param name="args">Массив аргументов, число, порядок и тип которых соответствуют параметрам вызываемого конструктора. Если параметр <paramref name="args" /> предоставляет пустой массив или имеет значение <see langword="null" />, то вызывается конструктор, который не принимает никаких параметров (конструктор без параметров).</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает экземпляр указанного типа, используя конструктор, соответствующий заданным параметрам.</summary>
        <returns>Ссылка на вновь созданный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызываемый конструктор должен быть доступен и должен предоставлять наиболее конкретное соответствие с указанным списком аргументов.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым типам, если вызывающей стороне был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав сборки, содержащей неоткрытые типы, ограничен набором предоставления вызывающего объекта или подмножеством. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является объектом <see langword="RuntimeType" />.  
  
- или - 
 Тип <paramref name="type" /> является открытым универсальным типом (то есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="type" /> не может иметь значение <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- или - 
Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.  
  
- или - 
 <paramref name="activationAttributes" /> не является пустым массивом, а создаваемый тип не является производным от <see cref="T:System.MarshalByRefObject" />.  
  
- или - 
Сборка, содержащая <paramref name="type" />, является динамической сборкой, которая была создана с использованием <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
- или - 
Конструктор, который наилучшим образом соответствует <paramref name="args" />, имеет аргументы <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Вызываемый конструктор создает исключение.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" /> — это COM-объект, но идентификатор класса, используемый для получения типа, является недопустимым, или идентифицируемый класс не зарегистрирован.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" /> не является допустимым типом.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип создаваемого объекта.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="type" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который использует параметры <paramref name="bindingAttr" /> и <paramref name="args" /> для поиска и идентификации конструктора <paramref name="type" />. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
        <param name="args">Массив аргументов, число, порядок и тип которых соответствуют параметрам вызываемого конструктора. Если параметр <paramref name="args" /> предоставляет пустой массив или имеет значение <see langword="null" />, то вызывается конструктор, который не принимает никаких параметров (конструктор без параметров).</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="type" />. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <summary>Создает экземпляр указанного типа, используя конструктор, соответствующий заданным параметрам.</summary>
        <returns>Ссылка на вновь созданный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызываемый конструктор должен предоставлять наиболее конкретное соответствие с указанным списком аргументов в соответствии с ограничениями указанного связывателя и атрибутов привязки.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для доступа к закрытым типам и членам, если вызывающий объект предоставил <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав сборки, содержащей неоткрытые типы и члены, ограничен набором предоставления вызывающего объекта или подмножеством. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является объектом <see langword="RuntimeType" />.  
  
- или - 
 Тип <paramref name="type" /> является открытым универсальным типом (то есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="type" /> не может иметь значение <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- или - 
Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.  
  
- или - 
Сборка, содержащая <paramref name="type" />, является динамической сборкой, которая была создана с использованием <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
- или - 
Конструктор, который наилучшим образом соответствует <paramref name="args" />, имеет аргументы <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Вызываемый конструктор создает исключение.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" /> — это объект модели COM, но идентификатор класса, используемый для получения типа, является недопустимым, или идентифицируемый класс не зарегистрирован.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" /> не является допустимым типом.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам и членам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип создаваемого объекта.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="type" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который использует параметры <paramref name="bindingAttr" /> и <paramref name="args" /> для поиска и идентификации конструктора <paramref name="type" />. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
        <param name="args">Массив аргументов, число, порядок и тип которых соответствуют параметрам вызываемого конструктора. Если параметр <paramref name="args" /> предоставляет пустой массив или имеет значение <see langword="null" />, то вызывается конструктор, который не принимает никаких параметров (конструктор без параметров).</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="type" />. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает экземпляр указанного типа, используя конструктор, соответствующий заданным параметрам.</summary>
        <returns>Ссылка на вновь созданный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызываемый конструктор должен предоставлять наиболее конкретное соответствие с указанным списком аргументов в соответствии с ограничениями указанного связывателя и атрибутов привязки.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым типам и членам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав неопубликованных типов и членов ограничен набором предоставления вызывающего объекта или его подмножеством. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является объектом <see langword="RuntimeType" />.  
  
- или - 
 Тип <paramref name="type" /> является открытым универсальным типом (то есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="type" /> не может иметь значение <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- или - 
Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.  
  
-или- 
 <paramref name="activationAttributes" /> не является пустым массивом, а создаваемый тип не является производным от <see cref="T:System.MarshalByRefObject" />.  
  
- или - 
Сборка, содержащая <paramref name="type" />, является динамической сборкой, которая была создана с использованием <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
- или - 
Конструктор, который наилучшим образом соответствует <paramref name="args" />, имеет аргументы <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Вызываемый конструктор создает исключение.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" /> — это объект модели COM, но идентификатор класса, используемый для получения типа, является недопустимым, или идентифицируемый класс не зарегистрирован.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" /> не является допустимым типом.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления свидетельства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам и членам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя сборки, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />. Если параметр <paramref name="assemblyName" /> имеет значение <see langword="null" />, поиск осуществляется в выполняющейся сборке.</param>
        <param name="typeName">Полное имя предпочтительного типа.</param>
        <param name="ignoreCase">Значение <see langword="true" /> для выполнения поиска <paramref name="typeName" /> без учета регистра; значение <see langword="false" /> для выполнения поиска с учетом регистра.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который использует параметры <paramref name="bindingAttr" /> и <paramref name="args" /> для поиска и идентификации конструктора <paramref name="typeName" />. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
        <param name="args">Массив аргументов, число, порядок и тип которых соответствуют параметрам вызываемого конструктора. Если параметр <paramref name="args" /> предоставляет пустой массив или имеет значение <see langword="null" />, то вызывается конструктор, который не принимает никаких параметров (конструктор без параметров).</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает экземпляр типа с заданным именем, используя для этого именованную сборку и конструктор, который наилучшим образом соответствует заданным параметрам.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для распаковки возвращаемого значения используйте <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для создания закрытых типов и членов, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор разрешений сборки, содержащей неоткрытые типы и члены, ограничен набором предоставления вызывающего объекта или подмножеством. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.  
  
- или - 
 <paramref name="activationAttributes" /> не является пустым массивом, а создаваемый тип не является производным от <see cref="T:System.MarshalByRefObject" />.  
  
- или - 
Конструктор, который наилучшим образом соответствует <paramref name="args" />, имеет аргументы <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.  
  
 - или -  
  
 Недопустимые имя сборки или кодовая база.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам и членам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="6" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="7" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="8" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domain">Домен, в котором создан тип с именем <paramref name="typeName" />.</param>
        <param name="assemblyName">Имя сборки, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />. Если параметр <paramref name="assemblyName" /> имеет значение <see langword="null" />, поиск осуществляется в выполняющейся сборке.</param>
        <param name="typeName">Полное имя предпочтительного типа.</param>
        <param name="ignoreCase">Значение <see langword="true" /> для выполнения поиска <paramref name="typeName" /> без учета регистра; значение <see langword="false" /> для выполнения поиска с учетом регистра.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который использует параметры <paramref name="bindingAttr" /> и <paramref name="args" /> для поиска и идентификации конструктора <paramref name="typeName" />. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
        <param name="args">Массив аргументов, число, порядок и тип которых соответствуют параметрам вызываемого конструктора. Если параметр <paramref name="args" /> предоставляет пустой массив или имеет значение <see langword="null" />, то вызывается конструктор, который не принимает никаких параметров (конструктор без параметров).</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает экземпляр типа с заданным именем в указанном удаленном домене, используя для этого именованную сборку и конструктор, который наилучшим образом соответствует заданным параметрам.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Activator.CreateInstance%2A>, когда узлу требуется выполнить код в домене приложения с ограниченными разрешениями безопасности.  
  
 Для распаковки возвращаемого значения используйте <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Этот метод использует <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType>, чтобы непосредственный вызывающий объект имел полное доверие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="domain" /> или <paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.  
  
- или - 
 <paramref name="activationAttributes" /> не является пустым массивом, а создаваемый тип не является производным от <see cref="T:System.MarshalByRefObject" />.  
  
- или - 
Конструктор, который наилучшим образом соответствует <paramref name="args" />, имеет аргументы <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.  
  
 - или -  
  
 Недопустимые имя сборки или кодовая база.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя сборки, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />. Если параметр <paramref name="assemblyName" /> имеет значение <see langword="null" />, поиск осуществляется в выполняющейся сборке.</param>
        <param name="typeName">Полное имя предпочтительного типа.</param>
        <param name="ignoreCase">Значение <see langword="true" /> для выполнения поиска <paramref name="typeName" /> без учета регистра; значение <see langword="false" /> для выполнения поиска с учетом регистра.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который использует параметры <paramref name="bindingAttr" /> и <paramref name="args" /> для поиска и идентификации конструктора <paramref name="typeName" />. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
        <param name="args">Массив аргументов, число, порядок и тип которых соответствуют параметрам вызываемого конструктора. Если параметр <paramref name="args" /> предоставляет пустой массив или имеет значение <see langword="null" />, то вызывается конструктор, который не принимает никаких параметров (конструктор без параметров).</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <param name="securityInfo">Сведения, используемые для принятия решений согласно политике безопасности и предоставления разрешений для кода.</param>
        <summary>Создает экземпляр типа с заданным именем, используя для этого именованную сборку и конструктор, который наилучшим образом соответствует заданным параметрам.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для распаковки возвращаемого значения используйте <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для создания закрытых типов и членов, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор разрешений сборки, содержащей неоткрытые типы и члены, ограничен набором предоставления вызывающего объекта или подмножеством. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.  
  
- или - 
 <paramref name="activationAttributes" /> не является пустым массивом, а создаваемый тип не является производным от <see cref="T:System.MarshalByRefObject" />.  
  
- или - 
Конструктор, который наилучшим образом соответствует <paramref name="args" />, имеет аргументы <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.  
  
 - или -  
  
 Недопустимые имя сборки или кодовая база.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам и членам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="7" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="8" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="9" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domain">Домен, в котором создан тип с именем <paramref name="typeName" />.</param>
        <param name="assemblyName">Имя сборки, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />. Если параметр <paramref name="assemblyName" /> имеет значение <see langword="null" />, поиск осуществляется в выполняющейся сборке.</param>
        <param name="typeName">Полное имя предпочтительного типа.</param>
        <param name="ignoreCase">Значение <see langword="true" /> для выполнения поиска <paramref name="typeName" /> без учета регистра; значение <see langword="false" /> для выполнения поиска с учетом регистра.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который использует параметры <paramref name="bindingAttr" /> и <paramref name="args" /> для поиска и идентификации конструктора <paramref name="typeName" />. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
        <param name="args">Массив аргументов, число, порядок и тип которых соответствуют параметрам вызываемого конструктора. Если параметр <paramref name="args" /> предоставляет пустой массив или имеет значение <see langword="null" />, то вызывается конструктор, который не принимает никаких параметров (конструктор без параметров).</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, это массив, содержащий единственный объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. Атрибут <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> указывает URL-адрес, требуемый для активации удаленного объекта.</param>
        <param name="securityAttributes">Сведения, используемые для принятия решений согласно политике безопасности и предоставления разрешений для кода.</param>
        <summary>Создает экземпляр типа с заданным именем в указанном удаленном домене, используя для этого именованную сборку и конструктор, который наилучшим образом соответствует заданным параметрам.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Activator.CreateInstance%2A>, когда узлу требуется выполнить код в домене приложения с ограниченными разрешениями безопасности.  
  
 Для распаковки возвращаемого значения используйте <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Этот метод использует <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType>, чтобы непосредственный вызывающий объект имел полное доверие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="domain" /> или <paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Тип модели COM не был получен с помощью <see cref="Overload:System.Type.GetTypeFromProgID" /> или <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Создание типов <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> и <see cref="T:System.RuntimeArgumentHandle" /> или массивов этих типов не поддерживается.  
  
- или - 
 <paramref name="activationAttributes" /> не является пустым массивом, а создаваемый тип не является производным от <see cref="T:System.MarshalByRefObject" />.  
  
- или - 
Конструктор, который наилучшим образом соответствует <paramref name="args" />, имеет аргументы <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.  
  
 - или -  
  
 Недопустимые имя сборки или кодовая база.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CreateInstance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CreateInstance&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T CreateInstance();" />
      <MemberSignature Language="F#" Value="static member CreateInstance : unit -&gt; 'T" Usage="System.Activator.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Создаваемый тип данных.</typeparam>
        <summary>Создает экземпляр типа, объявленного в указанном параметре универсального типа, с помощью конструктора без параметров.</summary>
        <returns>Ссылка на вновь созданный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activator.CreateInstance%60%601> универсальный метод используется компиляторами для реализации создания экземпляров типов, заданных параметрами типа. Например, в следующем универсальном методе реализация `new T()` (`gcnew T()` в C++) использует универсальный метод <xref:System.Activator.CreateInstance%60%601>.  
  
 [!code-cpp[System.Activation.CreateInstance~~1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cpp/remarks.cpp#1)]
 [!code-csharp[System.Activation.CreateInstance~~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cs/remarks.cs#1)]
 [!code-vb[System.Activation.CreateInstance~~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activation.createinstance~~1/vb/remarks.vb#1)]  
  
 Как правило, в коде приложения не используется универсальный метод <xref:System.Activator.CreateInstance%60%601>, поскольку тип должен быть известен во время компиляции. Если тип известен во время компиляции, можно использовать стандартный синтаксис создания экземпляра (`new` оператор в C#, `New` в Visual Basic, `gcnew` в C++). Если тип неизвестен во время компиляции, можно вызвать неуниверсальную перегрузку <xref:System.Activator.CreateInstance%2A>.  
  
 Нет перегрузок <xref:System.Activator.CreateInstance%60%601> универсального метода, принимающих списки аргументов, так как неуниверсальные перегрузки <xref:System.Activator.CreateInstance%2A> уже предоставляют разрешение конструктора с поздним связыванием.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.MissingMemberException" />.  
  
</para>
          </block>  
  
 Невозможно создать экземпляр абстрактного класса, или указанный для <typeparamref name="T" /> тип не имеет конструктора без параметров.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает экземпляр типа с заданным именем, используя для этого файл именованной сборки и конструктор, который наилучшим образом соответствует заданным параметрам.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />.</param>
        <param name="typeName">Имя предпочтительного типа.</param>
        <summary>Создает экземпляр типа с заданным именем, используя для этого файл именованной сборки и конструктор без параметров.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для распаковки возвращаемого значения используйте метод <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Сведения о других исключениях, которые могут вызываться вызванными методами, см. в разделе "исключения" в методах <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> и <xref:System.Activator.CreateInstance%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как вызвать метод <xref:System.Activator.CreateInstanceFrom%2A>. Этот пример кода является частью большого примера, приведенного для класса <xref:System.Activator>.  
  
 [!code-cpp[ActivatorX#3](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#3)]
 [!code-csharp[ActivatorX#3](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#3)]
 [!code-vb[ActivatorX#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего оператора нет необходимого разрешения <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">возможность поиска путей к каталогам и считывания их содержимого. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (domain As AppDomain, assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domain">Удаленный домен, в котором создан тип с именем <paramref name="typeName" />.</param>
        <param name="assemblyFile">Имя файла, содержащего сборку, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />.</param>
        <param name="typeName">Имя предпочтительного типа.</param>
        <summary>Создает экземпляр типа с заданным именем в указанном удаленном домене, используя для этого файл именованной сборки и конструктор без параметров.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Activator.CreateInstanceFrom%2A>, когда узлу требуется выполнить код в домене приложения с ограниченными разрешениями безопасности.  
  
 Для распаковки возвращаемого значения используйте метод <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Этот метод использует <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType>, чтобы непосредственный вызывающий объект имел полное доверие.  
  
 Сведения о других исключениях, которые могут вызываться вызванными методами, см. в разделе "исключения" в методах <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> и <xref:System.Activator.CreateInstance%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="domain" /> или <paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего оператора нет необходимого разрешения <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">возможность поиска путей к каталогам и считывания их содержимого. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />.</param>
        <param name="typeName">Имя предпочтительного типа.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает экземпляр типа с заданным именем, используя для этого файл именованной сборки и конструктор без параметров.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для распаковки возвращаемого значения используйте метод <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Сведения о других исключениях, которые могут вызываться вызванными методами, см. в разделе "исключения" в методах <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> и <xref:System.Activator.CreateInstance%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" /> не является пустым массивом, а создаваемый тип не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего оператора нет необходимого разрешения <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">возможность поиска путей к каталогам и считывания их содержимого. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />.</param>
        <param name="typeName">Имя предпочтительного типа.</param>
        <param name="ignoreCase">Значение <see langword="true" /> для выполнения поиска <paramref name="typeName" /> без учета регистра; значение <see langword="false" /> для выполнения поиска с учетом регистра.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который использует параметры <paramref name="bindingAttr" /> и <paramref name="args" /> для поиска и идентификации конструктора <paramref name="typeName" />. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
        <param name="args">Массив аргументов, число, порядок и тип которых соответствуют параметрам вызываемого конструктора. Если параметр <paramref name="args" /> предоставляет пустой массив или имеет значение <see langword="null" />, то вызывается конструктор, который не принимает никаких параметров (конструктор без параметров).</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает экземпляр типа с заданным именем, используя для этого файл именованной сборки и конструктор, который наилучшим образом соответствует заданным параметрам.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для распаковки возвращаемого значения используйте метод <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Сведения о других исключениях, которые могут вызываться вызванными методами, см. в разделе "исключения" в методах <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> и <xref:System.Activator.CreateInstance%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор не имеет необходимого разрешения <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" /> не является пустым массивом, а создаваемый тип не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">возможность поиска путей к каталогам и считывания их содержимого. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам и членам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="6" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="7" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="8" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domain">Удаленный домен, в котором создан тип с именем <paramref name="typeName" />.</param>
        <param name="assemblyFile">Имя файла, содержащего сборку, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />.</param>
        <param name="typeName">Имя предпочтительного типа.</param>
        <param name="ignoreCase">Значение <see langword="true" /> для выполнения поиска <paramref name="typeName" /> без учета регистра; значение <see langword="false" /> для выполнения поиска с учетом регистра.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который использует параметры <paramref name="bindingAttr" /> и <paramref name="args" /> для поиска и идентификации конструктора <paramref name="typeName" />. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
        <param name="args">Массив аргументов, число, порядок и тип которых соответствуют параметрам вызываемого конструктора. Если параметр <paramref name="args" /> предоставляет пустой массив или имеет значение <see langword="null" />, то вызывается конструктор, который не принимает никаких параметров (конструктор без параметров).</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает экземпляр типа с заданным именем в указанном удаленном домене, используя для этого файл именованной сборки и конструктор, который наилучшим образом соответствует заданным параметрам.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Activator.CreateInstanceFrom%2A>, когда узлу требуется выполнить код в домене приложения с ограниченными разрешениями безопасности.  
  
 Для распаковки возвращаемого значения используйте метод <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Сведения о других исключениях, которые могут вызываться вызванными методами, см. в разделах "исключения" в методах <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> и <xref:System.Activator.CreateInstance%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="domain" /> или <paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего оператора нет необходимого разрешения <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" /> не является пустым массивом, а создаваемый тип не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой.  
  
- или - 
 <paramref name="assemblyName" /> был скомпилирован для версии общеязыковой среды выполнения, которая является более поздней, чем версия, которая в настоящий момент загружена.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления свидетельства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">возможность поиска путей к каталогам и считывания их содержимого. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам и членам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />.</param>
        <param name="typeName">Имя предпочтительного типа.</param>
        <param name="ignoreCase">Значение <see langword="true" /> для выполнения поиска <paramref name="typeName" /> без учета регистра; значение <see langword="false" /> для выполнения поиска с учетом регистра.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который использует параметры <paramref name="bindingAttr" /> и <paramref name="args" /> для поиска и идентификации конструктора <paramref name="typeName" />. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
        <param name="args">Массив аргументов, число, порядок и тип которых соответствуют параметрам вызываемого конструктора. Если параметр <paramref name="args" /> предоставляет пустой массив или имеет значение <see langword="null" />, то вызывается конструктор, который не принимает никаких параметров (конструктор без параметров).</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <param name="securityInfo">Сведения, используемые для принятия решений согласно политике безопасности и предоставления разрешений для кода.</param>
        <summary>Создает экземпляр типа с заданным именем, используя для этого файл именованной сборки и конструктор, который наилучшим образом соответствует заданным параметрам.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для распаковки возвращаемого значения используйте метод <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Сведения о других исключениях, которые могут вызываться вызванными методами, см. в разделе "исключения" в методах <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> и <xref:System.Activator.CreateInstance%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор не имеет необходимого разрешения <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" /> не является пустым массивом, а создаваемый тип не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">возможность поиска путей к каталогам и считывания их содержимого. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам и членам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="7" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="8" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="9" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domain">Удаленный домен, в котором создан тип с именем <paramref name="typeName" />.</param>
        <param name="assemblyFile">Имя файла, содержащего сборку, в которой выполняется поиск типа, заданного параметром <paramref name="typeName" />.</param>
        <param name="typeName">Имя предпочтительного типа.</param>
        <param name="ignoreCase">Значение <see langword="true" /> для выполнения поиска <paramref name="typeName" /> без учета регистра; значение <see langword="false" /> для выполнения поиска с учетом регистра.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который использует параметры <paramref name="bindingAttr" /> и <paramref name="args" /> для поиска и идентификации конструктора <paramref name="typeName" />. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
        <param name="args">Массив аргументов, число, порядок и тип которых соответствуют параметрам вызываемого конструктора. Если параметр <paramref name="args" /> предоставляет пустой массив или имеет значение <see langword="null" />, то вызывается конструктор, который не принимает никаких параметров (конструктор без параметров).</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <param name="securityAttributes">Сведения, используемые для принятия решений согласно политике безопасности и предоставления разрешений для кода.</param>
        <summary>Создает экземпляр типа с заданным именем в указанном удаленном домене, используя для этого файл именованной сборки и конструктор, который наилучшим образом соответствует заданным параметрам.</summary>
        <returns>Дескриптор, оболочку которого нужно удалить, чтобы получить доступ к вновь созданному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Activator.CreateInstanceFrom%2A>, когда узлу требуется выполнить код в домене приложения с ограниченными разрешениями безопасности.  
  
 Для распаковки возвращаемого значения используйте метод <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Этот метод использует <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType>, чтобы непосредственный вызывающий объект имел полное доверие.  
  
 Сведения о других исключениях, которые могут вызываться вызванными методами, см. в разделе "исключения" в методах <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> и <xref:System.Activator.CreateInstance%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="domain" /> или <paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MemberAccessException">Невозможно создать экземпляр абстрактного класса, или этот элемент был вызван с помощь механизма позднего связывания.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Конструктор, который был вызван с помощью отражения, создал исключение.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего оператора нет необходимого разрешения <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" /> не является пустым массивом, а создаваемый тип не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой.  
  
- или - 
В данный момент загружена среда CLR версии 2.0 или более поздней. Объект <paramref name="assemblyName" /> был скомпилирован для версии среды CLR, более поздней, чем загруженная. Обратите внимание, что .NET Framework версий 2.0, 3.0 и 3.5 использует среду CLR версии 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления свидетельства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">возможность поиска путей к каталогам и считывания их содержимого. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым типам и членам независимо от набора их разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает прокси для хорошо известного объекта или веб-службы XML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string -&gt; obj" Usage="System.Activator.GetObject (type, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="url" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип хорошо известного объекта, к которому нужно подключиться.</param>
        <param name="url">URL-адрес хорошо известного объекта.</param>
        <summary>Создает прокси для хорошо известного объекта, определенного заданным типом и URL.</summary>
        <returns>Прокси, который указывает на конечную точку, используемую требуемым хорошо известным объектом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите прокси-сервер для отправки сообщений удаленному объекту. Сообщения не отправляются по сети, пока на прокси-сервере не будет вызван метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="type" /> или <paramref name="url" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="type" /> не маршалируется по ссылке и не является интерфейсом.</exception>
        <exception cref="T:System.MemberAccessException">Этот элемент был вызван при помощи механизма позднего связывания.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string * obj -&gt; obj" Usage="System.Activator.GetObject (type, url, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="url" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип хорошо известного объекта, к которому нужно подключиться.</param>
        <param name="url">URL-адрес хорошо известного объекта.</param>
        <param name="state">Данные, зависящие от канала, или значение <see langword="null" />.</param>
        <summary>Создает прокси для хорошо известного объекта, который идентифицируется по заданному типу, URL и данным канала.</summary>
        <returns>Прокси, который указывает на конечную точку, используемую требуемым хорошо известным объектом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите прокси-сервер для отправки сообщений удаленному объекту. Сообщения не отправляются по сети, пока на прокси-сервере не будет вызван метод.  
  
 Параметр `state` передает сведения в канал и передается методу <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="type" /> или <paramref name="url" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="type" /> не маршалируется по ссылке и не является интерфейсом.</exception>
        <exception cref="T:System.MemberAccessException">Этот элемент был вызван при помощи механизма позднего связывания.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Activator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Activator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Activator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="rgszNames">Переданный массив имен, которые необходимо сопоставить.</param>
        <param name="cNames">Число сопоставляемых имен.</param>
        <param name="lcid">Контекст языкового стандарта для интерпретации имен.</param>
        <param name="rgDispId">Массив, зарезервированный вызывающим оператором, в который помещаются идентификаторы, соответствующие именам.</param>
        <summary>Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetIDsOfNames`см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Activator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Возвращаемые сведения о типе.</param>
        <param name="lcid">Идентификатор языкового стандарта для сведений о типе.</param>
        <param name="ppTInfo">Объект, получающий указатель на объект с запрошенными сведениями о типе.</param>
        <summary>Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfo`см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Activator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Когда выполнение этого метода завершается, содержит указатель, по которому записано число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе. Этот параметр передается неинициализированным.</param>
        <summary>Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfoCount`см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.Invoke">
      <MemberSignature Language="C#" Value="void _Activator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Activator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Activator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Идентификатор подготовки к отправке, по которому идентифицируется член.</param>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="lcid">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</param>
        <param name="wFlags">Флаги, описывающие контекст вызова.</param>
        <param name="pDispParams">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</param>
        <param name="pVarResult">Указатель, по которому будет сохранен результат.</param>
        <param name="pExcepInfo">Указатель на структуру, содержащую сведения об исключении.</param>
        <param name="puArgErr">Индекс первого аргумента, вызвавшего ошибку.</param>
        <summary>Предоставляет доступ к открытым свойствам и методам объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::Invoke`см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
