<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata><Meta Name="ms.openlocfilehash" Value="759804e6d0c35397ab8bdd9a5ad4486f3c6c39c4" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70372551" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет сведения о привязке сборок, которые могут быть добавлены к экземпляру класса <see cref="T:System.AppDomain" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изменение свойств <xref:System.AppDomainSetup> экземпляра не влияет на существующие <xref:System.AppDomain>. Это может повлиять только на создание нового <xref:System.AppDomain>, <xref:System.AppDomain.CreateDomain%2A> когда <xref:System.AppDomainSetup> метод вызывается с экземпляром в качестве параметра.  
  
 Этот класс реализует интерфейс <xref:System.IAppDomainSetup> .  
  
> [!CAUTION]
>  Значение <xref:System.AppDomainSetup.DisallowCodeDownload%2A> свойства по умолчанию — false. Этот параметр небезопасен для служб. Чтобы защитить службы от загрузки частично доверенного кода, присвойте этому свойству значение true.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Как настроить домен приложения</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.AppDomainSetup" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.AppDomainSetup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationContext">Контекст активации, который необходимо использовать для текущего домена приложения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.AppDomainSetup" /> заданным контекстом активации для использования при активации домена приложения на основе манифеста.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект, указанный для `activationContext` , используется для создания объекта,содержащегосведения,необходимыедляактивацииновогодоменаприложения.<xref:System.Runtime.Hosting.ActivationArguments> <xref:System.ActivationContext> Доступ <xref:System.Runtime.Hosting.ActivationArguments> к этому объекту можно получить с <xref:System.AppDomainSetup.ActivationArguments%2A> помощью свойства.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationContext" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationArguments">Объект, определяющий сведения, необходимые для активации нового домена приложения на основе манифеста.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.AppDomainSetup" /> заданными аргументами контекста активации, необходимыми для активации домена приложения на основе манифеста.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для доступа к объекту `activationArguments` , указанному для, можно <xref:System.AppDomainSetup.ActivationArguments%2A> использовать свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="activationArguments" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает данные об активации домена приложения.</summary>
        <value>Объект, содержащий данные об активации домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этому свойству присвоено значение `null`, исключение не создается.  
  
 Сведения, предоставляемые <xref:System.Runtime.Hosting.ActivationArguments> объектом, поддерживают активацию на основе манифеста.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство имеет значение объекта <see cref="T:System.Runtime.Hosting.ActivationArguments" />, удостоверение приложения которого не соответствует удостоверению приложения объекта <see cref="T:System.Security.Policy.ApplicationTrust" />, возвращенного свойством <see cref="P:System.AppDomainSetup.ApplicationTrust" />. Если свойство <see cref="P:System.AppDomainSetup.ApplicationTrust" /> имеет значение <see langword="null" />, исключение не вызывается.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает делегат <see cref="T:System.AppDomainInitializer" />, представляющий метод обратного вызова, вызываемый при инициализации домена приложения.</summary>
        <value>Делегат, представляющий метод обратного вызова, вызываемый при инициализации домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы передать сведения в метод обратного вызова, назначьте <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> свойству массив строк. Массив передается в метод обратного вызова каждый раз <xref:System.AppDomain> , когда инициализируется.  
  
 Метод обратного вызова выполняется в контексте только что созданного домена приложения.  
  
   
  
## Examples  
 В следующем примере создается дочерний домен приложения `ChildDomain`с именем, <xref:System.AppDomainSetup> а также объект и свидетельство из домена приложения по умолчанию. Свойству присваивается метод `AppDomainInit`обратного вызова, который вызывается при инициализации дочернего домена. <xref:System.AppDomainSetup.AppDomainInitializer%2A> Аргументы для метода обратного вызова помещаются в массив строк, который присваивается <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> свойству. При создании дочернего домена метод обратного вызова просто выводит строки.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает аргументы, передаваемые методу обратного вызова, представленному делегатом <see cref="T:System.AppDomainInitializer" />. Этот метод обратного вызова вызывается при инициализации домена приложения.</summary>
        <value>Массив строк, передаваемый методу обратного вызова, представленному делегатом <see cref="T:System.AppDomainInitializer" />, когда метод обратного вызова вызывается при инициализации <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство, чтобы указать метод обратного вызова, который вызывается <xref:System.AppDomain> во время инициализации. <xref:System.AppDomainSetup.AppDomainInitializer%2A> <xref:System.AppDomainSetup.AppDomainInitializer%2A> Если свойство не задано, массив, назначенный этому свойству, не используется.  
  
 Метод обратного вызова выполняется в контексте только что созданного домена приложения.  
  
   
  
## Examples  
 Следующий пример кода создает дочерний домен приложения с `ChildDomain`именем, <xref:System.AppDomainSetup> используя объект и свидетельство из домена приложения по умолчанию. Свойству присваивается метод `AppDomainInit`обратного вызова, который вызывается при инициализации дочернего домена. <xref:System.AppDomainSetup.AppDomainInitializer%2A> Аргументы для метода обратного вызова помещаются в массив строк, который присваивается <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> свойству. При создании дочернего домена метод обратного вызова просто выводит строки.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает отображаемое имя сборки, предоставляющей тип диспетчера доменов приложений для доменов приложений, созданных с помощью объекта <see cref="T:System.AppDomainSetup" />.</summary>
        <value>Отображаемое имя сборки, предоставляющей <see cref="T:System.Type" /> диспетчера доменов приложений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы указать тип диспетчера домена приложения, установите и это свойство, и <xref:System.AppDomainSetup.AppDomainManagerType%2A> свойство. Если одно из этих свойств не задано, другое игнорируется.  
  
 Если тип не указан, Диспетчер доменов приложений создается из того же типа, что и родительский домен приложения (то есть домен приложения, из которого <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> вызывается метод).  
  
 При загрузке <xref:System.TypeLoadException> домена приложения создается исключение, если сборка не существует, или если сборка не содержит тип, указанный <xref:System.AppDomainSetup.AppDomainManagerType%2A> свойством. <xref:System.IO.FileLoadException>Если сборка найдена, но сведения о версии не совпадают, возникает исключение.  
  
 Чтобы задать Диспетчер доменов приложений для домена приложения по умолчанию, используйте [ \<элементы аппдомаинманажерассембли >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) и [ \<аппдомаинманажертипе >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) в [ \<разделе среды выполнения >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) . файла конфигурации приложения или использовать переменные среды, описанные в разделе <xref:System.AppDomainManager>.  
  
 Для этого компонента приложение должно иметь полное доверие. (Например, приложение, работающее на рабочем столе, имеет полное доверие.) Если приложение не имеет полного доверия, <xref:System.TypeLoadException> создается исключение.  
  
 Формат отображаемого имени <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> сборки задается свойством.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает полное имя типа, содержащего диспетчер доменов приложений для доменов приложений, созданных с помощью данного объекта <see cref="T:System.AppDomainSetup" />.</summary>
        <value>Полное имя типа, включая пространство имен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы указать тип диспетчера домена приложения, установите и это свойство, и <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> свойство. Если одно из этих свойств не задано, другое игнорируется.  
  
 Если тип не указан, Диспетчер доменов приложений создается из того же типа, что и родительский домен приложения (то есть домен приложения, из которого <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> вызывается метод).  
  
 При загрузке домена приложения создается исключение, <xref:System.TypeLoadException> если сборка <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> , заданная свойством, не содержит тип, заданный этим свойством.  
  
 Чтобы задать Диспетчер доменов приложений для домена приложения по умолчанию, используйте [ \<элементы аппдомаинманажерассембли >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) и [ \<аппдомаинманажертипе >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) в [ \<разделе среды выполнения >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) . файла конфигурации приложения или использовать переменные среды, описанные в разделе <xref:System.AppDomainManager>.  
  
 Для этого компонента приложение должно иметь полное доверие. (Например, приложение, работающее на рабочем столе, имеет полное доверие.) Если приложение не имеет полного доверия, <xref:System.TypeLoadException> создается исключение.  
  
 Формат полного имени типа задается <xref:System.Type.FullName%2A?displayProperty=nameWithType> свойством.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; }" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationBase As String" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); };" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string" Usage="System.AppDomainSetup.ApplicationBase" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя каталога, содержащего приложение.</summary>
        <value>Имя базовой папки приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовый каталог приложения — это место, где диспетчер сборок начинает проверку наличия сборок.  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A> Свойство может влиять на разрешения, предоставляемые домену приложения. Например, домен приложения, исходящий с локального компьютера, обычно получает полное доверие на основе его расположения источника. Однако если <xref:System.AppDomainSetup.ApplicationBase%2A> свойству <xref:System.AppDomain> присвоено полное имя каталога интрасети, этот <xref:System.AppDomainSetup.ApplicationBase%2A> параметр ограничит разрешения, предоставленные домену приложения, на предоставление локальной интрасети, даже если домен приложения фактически происходит с локального компьютера.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.AppDomainSetup.ApplicationBase%2A> свойство, чтобы задать расположение, в котором загрузчик сборок начинает проверку сборок для загрузки в новый домен приложения.  
  
> [!NOTE]
>  Необходимо убедиться, что указанная папка существует.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя приложения.</summary>
        <value>Имя приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано, как задать <xref:System.AppDomainSetup.ApplicationName%2A> свойство при создании нового домена приложения.  
  
 В примере создается новый домен приложения, а затем вызывается <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> метод для загрузки сборки примера в новый домен приложения и создания экземпляра `Worker` класса. Класс наследует <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> ,поэтому`TestLoad` в примере можно использовать прокси-сервер, возвращенный методом, для вызова метода. <xref:System.MarshalByRefObject> `Worker`  
  
 `TestLoad` Метод загружает указанную сборку. Необходимо либо указать допустимое полное имя сборки, либо закомментировать <xref:System.Reflection.Assembly.Load%28System.String%29> метод. `TestLoad` Метод перечисляет сборки, которые загружаются в новый домен приложения, показывая, что указанная сборка и пример сборки загружены.  
  
 В примере используется <xref:System.LoaderOptimizationAttribute> атрибут, чтобы сообщить загрузчику сборок, как приложение будет совместно использовать код в разных доменах приложений.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, содержащий сведения о безопасности и доверии.</summary>
        <value>Объект, содержащий сведения о безопасности и доверии.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется `null` <xref:System.AppDomainSetup> при создании. После изменения он не может быть сброшен на пустую ссылку.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство имеет значение объекта <see cref="T:System.Security.Policy.ApplicationTrust" />, удостоверение приложения которого не соответствует удостоверению приложения объекта <see cref="T:System.Runtime.Hosting.ActivationArguments" />, возвращенного свойством <see cref="P:System.AppDomainSetup.ActivationArguments" />. Если свойство <see cref="P:System.AppDomainSetup.ActivationArguments" /> имеет значение <see langword="null" />, исключение не вызывается.</exception>
        <exception cref="T:System.ArgumentNullException">Для свойства задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя области, определенной для приложения, где создаются теневые копии файлов.</summary>
        <value>Полный путь к каталогу и полное имя файла, соответствующие создаваемой теневой копии.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы это свойство имело воздействие, <xref:System.AppDomainSetup.ApplicationName%2A> необходимо также задать свойство. Если свойство не задано <xref:System.AppDomainSetup.CachePath%2A> , свойство игнорируется, а расположение кэша теневого копирования по умолчанию устанавливается в кэш загрузки. <xref:System.AppDomainSetup.ApplicationName%2A>  
  
 Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя файла конфигурации для домена приложения.</summary>
        <value>Имя файла конфигурации.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Файл конфигурации описывает правила поиска и данные конфигурации для домена приложения. Узел, создающий домен приложения, отвечает за предоставление этих данных, так как значимые значения изменяются от ситуации к ситуации.  
  
 Например, данные конфигурации для приложений ASP.NET хранятся для каждого приложения, сайта и компьютера, а данные конфигурации для исполняемого файла хранятся для каждого приложения, пользователя и компьютера. Только узел знает особенности данных конфигурации для определенных обстоятельств.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Схема параметров среды выполнения</related>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, выполняется ли поиск загружаемых сборок в базовой папке приложения и в папке приватных двоичных файлов.</summary>
        <value>Значение <see langword="true" />, если поиск не разрешен; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство равно `true`, значение свойстваигнорируется.<xref:System.AppDomainSetup.ApplicationBase%2A> <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> То есть ни одна сборка не проверяется в каталогах, указанных <xref:System.AppDomainSetup.ApplicationBase%2A> свойством. Кроме того, значения <xref:System.AppDomainSetup.PrivateBinPath%2A> свойства <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> и свойства игнорируются. Ни одна сборка не проверяется в каталогах, указанных <xref:System.AppDomainSetup.PrivateBinPath%2A> свойством.  
  
 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> Свойство обеспечивает дополнительный уровень управления процессом загрузки. В обычной последовательности загрузки сборок база приложения проверяется до <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> возникновения события. Однако некоторым приложениям может потребоваться загружать сборки из составного файла OLE в документе или из уникального известного расположения, не являющегося ни в глобальном кэше сборок, ни в каталогах, указанных в <xref:System.AppDomainSetup.ApplicationBase%2A> свойствах и. <xref:System.AppDomainSetup.PrivateBinPath%2A> Такие приложения могут использовать <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> свойство, чтобы избежать задержки, вызванной обычной проверкой, и избежать загрузки копий необходимой сборки, которая может находиться в обычных путях поиска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее, допускает ли домен приложения перенаправление привязки сборок.</summary>
        <value>Значение <see langword="true" />, если перенаправление сборок запрещено; значение <see langword="false" />, если оно разрешено.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> Свойство предназначено для использования службами и серверными приложениями, в которых перенаправление привязки сборок не является частью сценария приложения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, разрешена ли загрузка сборок для этого домена приложения по протоколу HTTP.</summary>
        <value>Значение<see langword="true" /> , если загрузка сборок по протоколу HTTP запрещена; значение <see langword="false" /> , если она разрешена.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowCodeDownload%2A> Свойство предназначено для использования службами и серверными приложениями, в которых Загрузка кода из интрасети или Интернета не является частью сценария приложения.  
  
> [!CAUTION]
>  Значение по умолчанию для свойства <xref:System.AppDomainSetup.DisallowCodeDownload%2A> — `false`. Этот параметр небезопасен для служб. Чтобы защитить службы от загрузки частично доверенного кода, задайте для `true`этого свойства значение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, применяется ли к домену приложения раздел [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) файла конфигурации.</summary>
        <value>Значение <see langword="true" />, если раздел <see langword="&lt;publisherPolicy&gt;" /> файла конфигурации для домена приложения игнорируется; значение <see langword="false" />, если объявленная политика издателя применяется.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> Свойство применяется к веб-приложению, которое загружается локально. Это свойство используется для предотвращения вредоносной попытки запуска небезопасного веб-приложения в безопасном режиме.  
  
 Дополнительные сведения об обходе политики издателя см. в разделе [перенаправление сборок версий](~/docs/framework/configure-apps/redirect-assembly-versions.md) . Дополнительные сведения о защищенном режиме см. в разделе "Проверка файлов конфигурации" раздела [как среда выполнения находит сборки](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает базовую папку, в которой находится папка для динамически создаваемых файлов.</summary>
        <value>Каталог, в котором расположена папка <see cref="P:System.AppDomain.DynamicDirectory" />.  

 <block subset="none" type="note"><para>  
 Возвращаемое значение этого свойства отличается от присвоенного значения.
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 Это свойство используется для задания базового каталога, в котором будет располагаться динамический каталог для нового домена приложения. Когда код в новом домене приложения загружает сборку, разрешение сборки сначала ищется в обычных путях поиска. Если сборка не найдена, она ищет в динамическом каталоге, который возвращается <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> свойством. В нем можно разместить динамические сборки, которые будут загружены и выполнены новым доменом приложения.  
  
 При назначении пути к <xref:System.AppDomainSetup.DynamicBase%2A> свойству добавляется дополнительный подкаталог. имя этого подкаталога — это хэш-код значения, присвоенного <xref:System.AppDomainSetup.ApplicationName%2A> свойству. Таким же базовым каталогом, который впоследствии возвращается этим свойством, всегда отличается от присвоенного значения.  
  
> [!IMPORTANT]
>  Присвоение значения этому свойству не приводит к созданию каталогов. Каталоги должны создаваться или проверяться с помощью кода, который их использует.  
  
 Динамический каталог — это подкаталог <xref:System.AppDomainSetup.DynamicBase%2A>. Его простое имя — это значение, возвращаемое <xref:System.AppDomainSetup.ApplicationName%2A> свойством, поэтому его форматом является*имя приложения**хэш-кода*\\ *исходного пути*\\.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.AppDomainSetup.DynamicBase%2A> свойства для задания пути проверки домена приложения при загрузке динамических сборок.  
  
 В примере создается <xref:System.AppDomainSetup> объект и <xref:System.AppDomainSetup.ApplicationName%2A> свойству присваивается значение example, а <xref:System.AppDomainSetup.DynamicBase%2A> свойству — значение "к:\динамикассемблидир". Затем в примере отображается <xref:System.AppDomainSetup.DynamicBase%2A> свойство, чтобы показать, что хэш-код имени приложения был добавлен в качестве подкаталога изначально назначенного пути.  
  
> [!NOTE]
>  Базовый каталог в этом примере должен находиться за пределами пути поиска для примера приложения. Не забудьте скомпилировать пример в другом расположении. При каждом запуске примера удалите базовый каталог и все его подкаталоги.  
  
 В примере создается новый домен приложения с помощью <xref:System.AppDomainSetup> объекта. Затем в примере создается динамический каталог, если он еще не существует. Несмотря на то, что в примере используется <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> свойство домена приложения для получения имени динамического каталога, это может быть так же легко создать каталог путем сцепления исходного пути, хэш-кода имени приложения и имя приложения.  
  
 В примере имеется `GenerateDynamicAssembly` метод, создающий сборку с именем `DynamicHelloWorld.dll` и сохраняющий ее в динамическом каталоге нового домена приложения. Динамическая сборка содержит один тип `HelloWorld`, который имеет статический метод (`Shared` метод в Visual Basic) с именем `HelloFromAD`. При вызове этого метода отображается имя домена приложения.  
  
 Класс является производным от <xref:System.MarshalByRefObject>, поэтому в примере можно создать экземпляр класса в новом домене приложения и вызвать его `Test` метод. `Example` Метод загружает динамическую сборку по отображаемому имени и вызывает статический `HelloFromAD` метод. `Test`  
  
 Можно увидеть, что поиск в динамическом каталоге выполняется после обычных путей поиска путем написания кода для сборки с именем `DynamicHelloWorld.dll` и его компиляции в том же каталоге, что и этот пример. Сборка должна иметь класс с именем `HelloWorld` и статическим методом с именем. `HelloFromAD` Этот метод не обязательно должен иметь те же функциональные возможности, что и в примере. Он может просто отобразить строку в консоли. Сборка также должна иметь <xref:System.Reflection.AssemblyVersionAttribute> атрибут, который устанавливает для его версии значение 1.0.0.0. При выполнении примера сборка, скомпилированная в текущем каталоге, обнаруживается до того, как будет выполнен поиск в динамическом каталоге.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Это свойство не может быть установлено, поскольку имя приложения в домене приложения равно <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает XML-данные конфигурации, заданные методом <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />, который переопределяет XML-данные конфигурации приложения.</summary>
        <returns>Массив, содержащий XML-данные конфигурации, заданные с помощью метода <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />, или <see langword="null" />, если метод <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> не вызывался.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Метод предоставляет способ переопределения сведений о конфигурации приложения, которое создает новый домен приложения. Сведения о файле конфигурации в `value` переопределяют сведения о файле конфигурации для приложения. Например, когда приложение example. exe создает новый домен приложения, оно может переопределить сведения о конфигурации, изначально полученные из файла example. exe. config.  
  
> [!IMPORTANT]
>  Некоторые потребители данных файла конфигурации не используют сведения, хранящиеся в <xref:System.AppDomainSetup.SetConfigurationBytes%2A> методе. Среда выполнения не применяет это. Чтобы обеспечить переопределение всех сведений о файле конфигурации в новом домене приложения, используйте <xref:System.AppDomainSetup.ConfigurationFile%2A> свойство, чтобы указать файл конфигурации. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Метод влияет на привязку сборки.  
  
 XML в `value` совпадает с XML в нормальном файле конфигурации, за исключением того, что он хранится в <xref:System.Byte> виде массива.  
  
 Чтобы получить доступ к байтам конфигурации для домена приложения, используйте <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> свойство, чтобы <xref:System.AppDomainSetup> получить объект для <xref:System.AppDomainSetup.GetConfigurationBytes%2A> домена приложения, а затем используйте метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расположение файла лицензии, связанного с этим доменом.</summary>
        <value>Имя и расположение файла лицензии.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет политику оптимизации, используемую для загрузки исполняемого файла.</summary>
        <value>Константа перечислимого типа, которая используется с атрибутом <see cref="T:System.LoaderOptimizationAttribute" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается динамическая сборка, которая сохраняется на диске, а затем с помощью <xref:System.AppDomainSetup.LoaderOptimization%2A> свойства задается политика оптимизации, используемая для загрузки сборки в домен приложения.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает список помеченных флагом <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> сборок, которые видимы коду с частичным доверием в изолированном домене приложения.</summary>
        <value>Массив частичных имен сборок, где каждое частичное имя состоит из простого имени сборки и открытого ключа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> , атрибут <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>(APTCA) можно сделать условным, задав для его свойства значение. <xref:System.Security.AllowPartiallyTrustedCallersAttribute> Сборка APTCA, помеченная как <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> , не может использоваться частично доверенным кодом, если это не разрешено ведущим приложением.  
  
 Узел изолированного домена приложения позволяет коду в домене приложения использовать сборки с условными атрибутами APTCA путем создания массива, содержащего простое имя и открытый ключ каждой сборки, и присвоение этому свойству массива. Например, элемент массива может выглядеть следующим образом: "MyAssembly, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad 0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9".  
  
> [!IMPORTANT]
>  Если вы используете подкласс <xref:System.AppDomainManager>, а сборка, определяющая его, зависит от сборок, помеченных атрибутом APTCA, необходимо включить эти сборки в список, передаваемый <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> свойству элемента <xref:System.AppDomainSetup>используется для создания доменов приложений. В противном случае сборки, помеченные атрибутом APTCA Conditional, будут отключены.  
  
> [!NOTE]
>  При отладке приложения, которое выполняется в изолированном домене приложения, некоторые <xref:System.Security.SecurityException> сообщения могут быть ложными. Например, сообщение может указывать на то, что одна из полностью доверенных сборок имеет только ограниченные разрешения, тогда как реальная причина проблемы заключается в том, что требование безопасности, превышающее набор предоставленных изолированных доменов приложений, распространяется на границу не удалось выполнить изолированный домен приложения.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает список каталогов в базовой папке приложения, в которых выполняется поиск закрытых сборок.</summary>
        <value>Список имен каталогов, разделенных точкой с запятой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Закрытые сборки развертываются в той же структуре каталогов, что и приложение. Если каталоги, указанные для <xref:System.AppDomainSetup.PrivateBinPath%2A> , не находятся <xref:System.AppDomainSetup.ApplicationBase%2A>в списке, они игнорируются.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает строковое значение, включающее <see cref="P:System.AppDomainSetup.ApplicationBase" /> в путь поиска для приложения или исключающее его из пути поиска для приложения, чтобы поиск выполнялся только в <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</summary>
        <value>Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для включения пути базовой папки приложения при поиске сборок; любое непустое строковое значение для исключения пути. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству любое строковое значение, отличное от <xref:System.String.Empty?displayProperty=nameWithType> null, включая (""), чтобы исключить путь к каталогу приложения <xref:System.AppDomainSetup.ApplicationBase%2A> , то есть — из пути поиска для приложения и для поиска сборок только в <xref:System.AppDomainSetup.PrivateBinPath%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, отключено ли кэширование интерфейсов для вызовов взаимодействия в домене приложения, так что <c>QueryInterface</c> выполняется для каждого вызова.</summary>
        <value><see langword="true" />, если кэширование интерфейсов отключено для вызовов взаимодействия в доменах приложения, созданных с текущим объектом <see cref="T:System.AppDomainSetup" />; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отключение кэширования интерфейса оказывает значительное влияние на производительность вызовов взаимодействия.  
  
 Этот член появился в [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="switches">Перечислимый набор строковых значений, задающий переключатели совместимости, или значение <see langword="null" /> для снятия существующих переключателей совместимости.</param>
        <summary>Устанавливает заданные переключатели, благодаря чему домен приложения становится совместимым с предыдущими версиями платформы .NET Framework для указанных аспектов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Основные версии .NET Framework иногда представляют критические изменения из предыдущей версии. Например, в [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] представлено небольшое количество критических изменений [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]из. <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> Используйте метод, чтобы указать, что необходимо откатить один или несколько из этих критических изменений для домена приложения, чтобы обеспечить совместимость поведения с предыдущей версией .NET Framework.  
  
 Каждый раз при вызове этого метода он заменяет существующие параметры коммутатора. Чтобы стереть параметры, укажите `null` `switches` для параметра.  
  
 Набор строковых значений, которые вы задаете для `switches` , может быть простым массивом строк, поскольку массивы <xref:System.Collections.IEnumerable> реализуют интерфейс.  
  
 В следующей таблице приведены примеры параметров совместимости, которые можно задать для восстановления поведения более ранних версий .NET Framework.  
  
|Параметр|Значение|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Управление доступом для кода (CAS) для [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включено в этом домене приложения. См. элемент NetFx40_LegacySecurityPolicy. [ &lt;&gt; ](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)|  
|"NetFx40_Legacy20SortingBehavior"|Значения сортировки строк по умолчанию [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] для включены в этом домене приложения. Для успешного восстановления прежних версий необходимо также, чтобы библиотека динамической компоновки sort00001000. dll была доступна в локальной системе. См. элемент компатсортнлсверсион. [ &lt;&gt; ](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)|  
|"NetFx40_Legacy40SortingBehavior"|Значения сортировки строк по умолчанию [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] для и Юникод 5,0 включены в этом домене приложения. Для успешного восстановления прежних версий необходимо также, чтобы библиотека динамической компоновки sort00060101. dll была доступна в локальной системе.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan>поведение [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] форматирования в этом домене приложения включено. <xref:System.TimeSpan> См [ &lt;.&gt; элемент TimeSpan_LegacyFormatMode](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) и раздел "восстановление устаревшего форматирования TimeSpan" раздела.|  
|UseRandomizedStringHashAlgorithm|Среда выполнения вычисляет хэш-коды для строк на уровне каждого приложения вместо использования единого алгоритма хэширования, который создает согласованный хэш-код между доменами приложений. См. элемент UseRandomizedStringHashAlgorithm. [ &lt;&gt; ](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/07132b9c-4a72-4710-99d7-e702405e02d4">&lt;NetFx40_LegacySecurityPolicy&gt; , элемент</related>
        <related type="Article" href="https://msdn.microsoft.com/library/782cc82e-83f7-404a-80b7-6d3061a8b6e3">&lt;Компатсортнлсверсион&gt; , элемент</related>
        <related type="Article" href="https://msdn.microsoft.com/library/865e7207-d050-4442-b574-57ea29d5e2d6">&lt;TimeSpan_LegacyFormatMode&gt; , элемент</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; , элемент</related>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Массив, содержащий XML-данные конфигурации для домена приложения.</param>
        <summary>Предоставляет XML-данные конфигурации для домена приложения, заменяя XML-данные конфигурации приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Метод предоставляет способ замены сведений о конфигурации приложения, которое создает новый домен приложения. Сведения о файле конфигурации в `value` заменяют сведения о файле конфигурации для приложения. Например, когда приложение example. exe создает новый домен приложения, оно может заменить сведения о конфигурации, изначально полученные из файла example. exe. config.  
  
> [!IMPORTANT]
>  Некоторые потребители данных файла конфигурации не используют сведения, хранящиеся в <xref:System.AppDomainSetup.SetConfigurationBytes%2A> методе. Среда выполнения не применяет это. Чтобы обеспечить замену всех сведений о файле конфигурации в новом домене приложения, используйте <xref:System.AppDomainSetup.ConfigurationFile%2A> свойство, чтобы указать файл конфигурации. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Метод влияет на привязку сборки.  
  
 XML в `value` совпадает с XML в нормальном файле конфигурации, за исключением того, что он хранится в <xref:System.Byte> виде массива.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Схема параметров среды выполнения</related>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionVersion" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionPointer" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="functionName">Имя переопределяемой функции сравнения строк.</param>
        <param name="functionVersion">Версия функции. Для [!INCLUDE[net_v45](~/includes/net-v45-md.md)] значение должно быть больше или равно 1.</param>
        <param name="functionPointer">Указатель на функцию, переопределяющую <paramref name="functionName" />.</param>
        <summary>Предоставляет среду CLR с резервной реализацией функции сравнения строк.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующие методы сравнения и сортировки строк могут быть переопределены <xref:System.AppDomainSetup.SetNativeFunction%2A> методом:  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 Дополнительные сведения об этих функциях см. в разделе [функции поддержки национальных языков](https://go.microsoft.com/fwlink/?LinkId=228134).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойство <paramref name="functionName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="functionVersion" /> не равно 1 или выше.  
  
-или- 
 Свойство <paramref name="functionPointer" /> имеет значение <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имена каталогов, содержащих сборки, для которых будут созданы теневые копии.</summary>
        <value>Список имен каталогов, разделенных точкой с запятой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если теневое копирование включено, по умолчанию используется теневое копирование всех сборок, найденных с помощью проверки. то есть в каталогах, заданных <xref:System.AppDomainSetup.PrivateBinPath%2A> свойствами и. <xref:System.AppDomainSetup.ApplicationBase%2A> Свойство позволяет зарезервировать теневое копирование сборок в каталогах, заданных параметром <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>. <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>  
  
 Если не назначить <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> строку свойству или задать для `null`этого свойства значение, то все сборки в каталогах, заданные <xref:System.AppDomainSetup.ApplicationBase%2A> свойствами и <xref:System.AppDomainSetup.PrivateBinPath%2A> , будут копироваться с помощью теневого копирования.  
  
> [!IMPORTANT]
>  Пути к каталогам не должны содержать точку с запятой, так как она является разделителем. Escape-символа для точки с запятой не существует.  
  
 Если теневое копирование действует, файлы сборки копируются в другое расположение перед загрузкой сборок. Исходный файл сборки не заблокирован, поэтому его можно обновить. Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает строку, позволяющую определить, включено ли теневое копирование.</summary>
        <value>Строковое значение true, свидетельствующее о том, что теневое копирование включено, или значение false, указывающее на то, что оно отключено.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; }" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetFrameworkName As String" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); };" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string" Usage="System.AppDomainSetup.TargetFrameworkName" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает строку, которая задает целевую версию и профиль .NET Framework для домена приложения, в формате, который может быть проанализирован конструктором <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" />.</summary>
        <value>Целевая версия и профиль платформы .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задайте это свойство, чтобы сообщить текущей версии .NET Framework о том, что домен приложения будет использоваться для загрузки и запуска сборок, скомпилированных для целевой версии и профиля. Если в текущей версии .NET Framework есть необязательные поведения, влияющие на совместимость кода, который был скомпилирован с целевой версией, он может включить или отключить эти варианты поведения, чтобы улучшить совместимость. Это может быть полезно, если приложение поддерживает надстройки, скомпилированные с несколькими версиями .NET Framework, запустив их в отдельных доменах приложений.  
  
 Для клиентских приложений значение <xref:System.AppDomainSetup.TargetFrameworkName%2A> свойства выводится <xref:System.Runtime.Versioning.TargetFrameworkAttribute> из атрибута. В [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] и более поздних версиях этот атрибут добавляется в сборку автоматически в зависимости от значения свойства **целевой платформы** проекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
