<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata><Meta Name="ms.openlocfilehash" Value="759804e6d0c35397ab8bdd9a5ad4486f3c6c39c4" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73400050" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет сведения о привязке сборок, которые могут быть добавлены в экземпляр класса <see cref="T:System.AppDomain" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изменение свойств экземпляра <xref:System.AppDomainSetup> не влияет на существующие <xref:System.AppDomain>. Это может повлиять только на создание нового <xref:System.AppDomain>, когда метод <xref:System.AppDomain.CreateDomain%2A> вызывается с экземпляром <xref:System.AppDomainSetup> в качестве параметра.  
  
 Этот класс реализует интерфейс <xref:System.IAppDomainSetup> .  
  
> [!CAUTION]
>  Значение по умолчанию для свойства <xref:System.AppDomainSetup.DisallowCodeDownload%2A> равно false. Этот параметр является ненадежным для служб. Чтобы защитить службы от загрузки частично доверенного кода, присвойте этому свойству значение true.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Как настроить домен приложения</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.AppDomainSetup" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.AppDomainSetup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationContext">Контекст активации, который необходимо использовать для текущего домена приложения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.AppDomainSetup" /> заданным контекстом активации для использования при активации домена приложения на основе манифеста.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.ActivationContext>, указанный для `activationContext`, используется для создания объекта <xref:System.Runtime.Hosting.ActivationArguments>, содержащего сведения, необходимые для активации нового домена приложения. Доступ к этому объекту <xref:System.Runtime.Hosting.ActivationArguments> можно получить с помощью свойства <xref:System.AppDomainSetup.ActivationArguments%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="activationContext" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationArguments">Объект, определяющий сведения, необходимые для активации нового домена приложения на основе манифеста.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.AppDomainSetup" /> с заданными аргументами активации, необходимыми для активации домена приложения на основе манифеста.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект, указанный для `activationArguments`, можно получить с помощью свойства <xref:System.AppDomainSetup.ActivationArguments%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="activationArguments" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает данные об активации домена приложения.</summary>
        <value>Объект, содержащий данные об активации домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этому свойству присвоено значение `null`, исключение не создается.  
  
 Сведения, предоставляемые объектом <xref:System.Runtime.Hosting.ActivationArguments>, поддерживают активацию на основе манифеста.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство имеет значение объекта <see cref="T:System.Runtime.Hosting.ActivationArguments" />, удостоверение приложения которого не соответствует удостоверению приложения объекта <see cref="T:System.Security.Policy.ApplicationTrust" />, возвращенного свойством <see cref="P:System.AppDomainSetup.ApplicationTrust" />. Если свойство <see cref="P:System.AppDomainSetup.ApplicationTrust" /> имеет значение <see langword="null" />, исключение не вызывается.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает делегат <see cref="T:System.AppDomainInitializer" />, представляющий метод обратного вызова, вызываемый при инициализации домена приложения.</summary>
        <value>Делегат, представляющий метод обратного вызова, вызываемый при инициализации домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы передать сведения в метод обратного вызова, назначьте массив строк свойству <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>. Массив передается в метод обратного вызова каждый раз при инициализации <xref:System.AppDomain>.  
  
 Метод обратного вызова выполняется в контексте только что созданного домена приложения.  
  
   
  
## Examples  
 В следующем примере создается дочерний домен приложения с именем `ChildDomain`с использованием объекта <xref:System.AppDomainSetup> и свидетельства из домена приложения по умолчанию. Свойству <xref:System.AppDomainSetup.AppDomainInitializer%2A> присваивается метод обратного вызова `AppDomainInit`, который вызывается при инициализации дочернего домена. Аргументы для метода обратного вызова помещаются в массив строк, который назначается свойству <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>. При создании дочернего домена метод обратного вызова просто выводит строки.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает аргументы, которые передаются в метод обратного вызова, представленный делегатом <see cref="T:System.AppDomainInitializer" />. Этот метод обратного вызова вызывается при инициализации домена приложения.</summary>
        <value>Массив строк, который передается методу обратного вызова, представленному делегатом <see cref="T:System.AppDomainInitializer" />, когда метод обратного вызова вызывается при инициализации <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.AppDomainSetup.AppDomainInitializer%2A>, чтобы указать метод обратного вызова, который вызывается во время инициализации <xref:System.AppDomain>. Если свойство <xref:System.AppDomainSetup.AppDomainInitializer%2A> не задано, массив, назначенный этому свойству, не используется.  
  
 Метод обратного вызова выполняется в контексте только что созданного домена приложения.  
  
   
  
## Examples  
 В следующем примере кода создается дочерний домен приложения с именем `ChildDomain`с использованием объекта <xref:System.AppDomainSetup> и свидетельства из домена приложения по умолчанию. Свойству <xref:System.AppDomainSetup.AppDomainInitializer%2A> присваивается метод обратного вызова `AppDomainInit`, который вызывается при инициализации дочернего домена. Аргументы для метода обратного вызова помещаются в массив строк, который назначается свойству <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>. При создании дочернего домена метод обратного вызова просто выводит строки.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает отображаемое имя сборки, предоставляющей тип диспетчера доменов приложений для доменов приложений, созданных с помощью объекта <see cref="T:System.AppDomainSetup" />.</summary>
        <value>Отображаемое имя сборки, предоставляющей <see cref="T:System.Type" /> диспетчера доменов приложений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы указать тип диспетчера домена приложения, установите как это свойство, так и свойство <xref:System.AppDomainSetup.AppDomainManagerType%2A>. Если одно из этих свойств не задано, другое игнорируется.  
  
 Если тип не указан, диспетчер домена приложения создается из того же типа, что и родительский домен приложения (то есть домен приложения, из которого вызывается метод <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>).  
  
 При загрузке домена приложения <xref:System.TypeLoadException> создается, если сборка не существует или если сборка не содержит тип, указанный свойством <xref:System.AppDomainSetup.AppDomainManagerType%2A>. <xref:System.IO.FileLoadException> возникает, если сборка найдена, но сведения о версии не совпадают.  
  
 Чтобы задать Диспетчер доменов приложений для домена приложения по умолчанию, используйте элементы [\<аппдомаинманажерассембли >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) и [\<аппдомаинманажертипе >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) в разделе [\<среды выполнения](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) приложения. файл конфигурации или использовать переменные среды, описанные в разделе <xref:System.AppDomainManager>.  
  
 Для этого компонента приложение должно иметь полное доверие. (Например, приложение, работающее на рабочем столе, имеет полное доверие.) Если приложение не имеет полного доверия, выдается <xref:System.TypeLoadException>.  
  
 Формат отображаемого имени сборки задается свойством <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает полное имя типа, содержащего диспетчер доменов приложений, созданных с помощью данного объекта <see cref="T:System.AppDomainSetup" />.</summary>
        <value>Полное имя типа, включая пространство имен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы указать тип диспетчера домена приложения, установите как это свойство, так и свойство <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>. Если одно из этих свойств не задано, другое игнорируется.  
  
 Если тип не указан, диспетчер домена приложения создается из того же типа, что и родительский домен приложения (то есть домен приложения, из которого вызывается метод <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>).  
  
 При загрузке домена приложения <xref:System.TypeLoadException> создается, если сборка, указанная свойством <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>, не содержит тип, указанный этим свойством.  
  
 Чтобы задать Диспетчер доменов приложений для домена приложения по умолчанию, используйте элементы [\<аппдомаинманажерассембли >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) и [\<аппдомаинманажертипе >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) в разделе [\<среды выполнения](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) приложения. файл конфигурации или использовать переменные среды, описанные в разделе <xref:System.AppDomainManager>.  
  
 Для этого компонента приложение должно иметь полное доверие. (Например, приложение, работающее на рабочем столе, имеет полное доверие.) Если приложение не имеет полного доверия, выдается <xref:System.TypeLoadException>.  
  
 Формат полного имени типа задается свойством <xref:System.Type.FullName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; }" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationBase As String" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); };" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string" Usage="System.AppDomainSetup.ApplicationBase" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя каталога, содержащего приложение.</summary>
        <value>Имя базовой папки приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовый каталог приложения — это место, где диспетчер сборок начинает проверку наличия сборок.  
  
 Свойство <xref:System.AppDomainSetup.ApplicationBase%2A> может влиять на то, какие разрешения предоставляются домену приложения. Например, домен приложения, исходящий с локального компьютера, обычно получает полное доверие на основе его расположения источника. Однако если для свойства <xref:System.AppDomainSetup.ApplicationBase%2A> этого <xref:System.AppDomain> задано полное имя каталога интрасети, то параметр <xref:System.AppDomainSetup.ApplicationBase%2A> будет ограничивать разрешения, предоставленные домену приложения для предоставления локальной интрасети, даже если фактически происходит домен приложения. с локального компьютера.  
  
   
  
## Examples  
 В следующем примере показано, как использовать свойство <xref:System.AppDomainSetup.ApplicationBase%2A>, чтобы задать расположение, в котором загрузчик сборок начинает проверку сборок для загрузки в новый домен приложения.  
  
> [!NOTE]
>  Необходимо убедиться, что указанная папка существует.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя приложения.</summary>
        <value>Имя приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано, как задать свойство <xref:System.AppDomainSetup.ApplicationName%2A> при создании нового домена приложения.  
  
 В примере создается новый домен приложения, а затем вызывается метод <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> для загрузки сборки примера в новый домен приложения и создания экземпляра класса `Worker`. Класс `Worker` наследует <xref:System.MarshalByRefObject>, поэтому в примере можно использовать прокси-сервер, возвращенный <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> для вызова метода `TestLoad`.  
  
 Метод `TestLoad` загружает указанную сборку. Необходимо либо указать допустимое полное имя сборки, либо закомментировать метод <xref:System.Reflection.Assembly.Load%28System.String%29>. Метод `TestLoad` перечисляет сборки, загруженные в новый домен приложения, показывая, что указанная сборка и пример сборки загружены.  
  
 В примере используется атрибут <xref:System.LoaderOptimizationAttribute>, чтобы сообщить загрузчику сборок, как приложение будет совместно использовать код в разных доменах приложений.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, содержащий сведения о безопасности и доверии.</summary>
        <value>Объект, содержащий сведения о безопасности и доверии.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство `null` при создании <xref:System.AppDomainSetup>. После изменения он не может быть сброшен на пустую ссылку.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство имеет значение объекта <see cref="T:System.Security.Policy.ApplicationTrust" />, удостоверение приложения которого не соответствует удостоверению приложения объекта <see cref="T:System.Runtime.Hosting.ActivationArguments" />, возвращенного свойством <see cref="P:System.AppDomainSetup.ActivationArguments" />. Если свойство <see cref="P:System.AppDomainSetup.ActivationArguments" /> имеет значение <see langword="null" />, исключение не вызывается.</exception>
        <exception cref="T:System.ArgumentNullException">Для свойства задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя области, определенной для приложения, где создаются теневые копии файлов.</summary>
        <value>Полный путь к каталогу и полное имя файла, соответствующие создаваемой теневой копии.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы это свойство действовало, также необходимо задать свойство <xref:System.AppDomainSetup.ApplicationName%2A>. Если свойство <xref:System.AppDomainSetup.ApplicationName%2A> не задано, свойство <xref:System.AppDomainSetup.CachePath%2A> игнорируется, а расположение кэша теневой копии по умолчанию устанавливается в кэш загрузки.  
  
 Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя файла конфигурации для домена приложения.</summary>
        <value>Имя файла конфигурации.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Файл конфигурации описывает правила поиска и данные конфигурации для домена приложения. Узел, создающий домен приложения, отвечает за предоставление этих данных, так как значимые значения изменяются от ситуации к ситуации.  
  
 Например, данные конфигурации для приложений ASP.NET хранятся для каждого приложения, сайта и компьютера, а данные конфигурации для исполняемого файла хранятся для каждого приложения, пользователя и компьютера. Только узел знает особенности данных конфигурации для определенных обстоятельств.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Схема параметров среды выполнения</related>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, выполняется ли поиск загружаемых сборок в базовой папке приложения и папке приватных двоичных файлов.</summary>
        <value>Значение <see langword="true" />, если проверка не разрешена. В противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> `true`, значение свойства <xref:System.AppDomainSetup.ApplicationBase%2A> игнорируется. То есть ни одна сборка не проверяется в каталогах, указанных свойством <xref:System.AppDomainSetup.ApplicationBase%2A>. Кроме того, значения свойства <xref:System.AppDomainSetup.PrivateBinPath%2A> и свойства <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> игнорируются. Ни одна сборка не проверяется в каталогах, указанных свойством <xref:System.AppDomainSetup.PrivateBinPath%2A>.  
  
 Свойство <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> обеспечивает дополнительный уровень управления процессом загрузки. В обычной последовательности загрузки сборок база приложения проверяется до возникновения события <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>. Однако некоторым приложениям может потребоваться загружать сборки из составного файла OLE в документе или из уникального известного расположения, не являющегося ни в глобальном кэше сборок, ни в каталогах, заданных свойствами <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A>. Такие приложения могут использовать свойство <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>, чтобы избежать задержки, вызванной обычной проверкой, и избежать загрузки копий необходимой сборки, которая может находиться в обычных путях поиска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, допускает ли домен приложения перенаправление привязки сборок.</summary>
        <value>Значение <see langword="true" />, если перенаправление сборок запрещено; значение <see langword="false" />, если оно разрешено.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> предназначено для использования службами и серверными приложениями, в которых перенаправление привязки сборок не является частью сценария приложения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, разрешена ли загрузка сборок для этого домена приложения по протоколу HTTP.</summary>
        <value>Значение <see langword="true" />, если загрузка сборок по протоколу HTTP запрещена; значение <see langword="false" />, если она разрешена.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.AppDomainSetup.DisallowCodeDownload%2A> предназначено для использования службами и серверными приложениями, где загрузка кода из интрасети или Интернета не является частью сценария приложения.  
  
> [!CAUTION]
>  Значение по умолчанию для свойства <xref:System.AppDomainSetup.DisallowCodeDownload%2A> — `false`. Этот параметр является ненадежным для служб. Чтобы защитить службы от загрузки частично доверенного кода, задайте для этого свойства значение `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, применяется ли к домену приложения раздел [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) файла конфигурации.</summary>
        <value>Значение <see langword="true" />, если раздел <see langword="&lt;publisherPolicy&gt;" /> файла конфигурации для домена приложения игнорируется; значение <see langword="false" />, если применяется объявленная политика издателя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> особенно применимо к веб-приложению, которое загружается локально. Это свойство используется для предотвращения вредоносной попытки запуска небезопасного веб-приложения в безопасном режиме.  
  
 Дополнительные сведения об обходе политики издателя см. в разделе [перенаправление сборок версий](~/docs/framework/configure-apps/redirect-assembly-versions.md) . Дополнительные сведения о защищенном режиме см. в разделе "Проверка файлов конфигурации" раздела [как среда выполнения находит сборки](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает базовую папку, в которой находится папка для динамически создаваемых файлов.</summary>
        <value>Каталог, в котором расположена папка <see cref="P:System.AppDomain.DynamicDirectory" />.  

 <block subset="none" type="note"><para>  
 Возвращаемое значение этого свойства отличается от присвоенного значения.
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 Это свойство используется для задания базового каталога, в котором будет располагаться динамический каталог для нового домена приложения. Когда код в новом домене приложения загружает сборку, разрешение сборки сначала ищется в обычных путях поиска. Если сборка не найдена, она ищет в динамическом каталоге, который возвращается свойством <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>. В нем можно разместить динамические сборки, которые будут загружены и выполнены новым доменом приложения.  
  
 При назначении пути к свойству <xref:System.AppDomainSetup.DynamicBase%2A> добавляется дополнительный подкаталог. имя этого подкаталога — это хэш-код значения, присвоенного свойству <xref:System.AppDomainSetup.ApplicationName%2A>. Таким же базовым каталогом, который впоследствии возвращается этим свойством, всегда отличается от присвоенного значения.  
  
> [!IMPORTANT]
>  Присвоение значения этому свойству не приводит к созданию каталогов. Каталоги должны создаваться или проверяться с помощью кода, который их использует.  
  
 Динамический каталог — это подкаталог <xref:System.AppDomainSetup.DynamicBase%2A>. Его простое имя — это значение, возвращаемое свойством <xref:System.AppDomainSetup.ApplicationName%2A>, поэтому его формат является *исходным путем*\\*хэш-кода*\\*имени приложения*.  
  
   
  
## Examples  
 В следующем примере показано использование свойства <xref:System.AppDomainSetup.DynamicBase%2A> для задания пути проверки домена приложения при загрузке динамических сборок.  
  
 В примере создается объект <xref:System.AppDomainSetup> и свойству <xref:System.AppDomainSetup.ApplicationName%2A> присваивается значение example, а свойству <xref:System.AppDomainSetup.DynamicBase%2A> — значение "К:\динамикассемблидир". Затем в примере отображается свойство <xref:System.AppDomainSetup.DynamicBase%2A>, чтобы показать, что хэш-код имени приложения добавлен в качестве подкаталога изначально назначенного пути.  
  
> [!NOTE]
>  Базовый каталог в этом примере должен находиться за пределами пути поиска для примера приложения. Не забудьте скомпилировать пример в другом расположении. При каждом запуске примера удалите базовый каталог и все его подкаталоги.  
  
 В примере создается новый домен приложения с помощью объекта <xref:System.AppDomainSetup>. Затем в примере создается динамический каталог, если он еще не существует. Несмотря на то, что в примере используется свойство <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> домена приложения для получения имени динамического каталога, это может быть так же легко, как создать каталог путем сцепления исходного пути, хэш-кода имени приложения и приложения. безымян.  
  
 В примере имеется метод `GenerateDynamicAssembly`, который создает сборку с именем `DynamicHelloWorld.dll` и сохраняет ее в динамическом каталоге нового домена приложения. Динамическая сборка содержит один тип, `HelloWorld`, имеющий статический метод (`Shared` метод в Visual Basic) с именем `HelloFromAD`. При вызове этого метода отображается имя домена приложения.  
  
 Класс `Example` является производным от <xref:System.MarshalByRefObject>, поэтому в примере можно создать экземпляр класса в новом домене приложения и вызвать его метод `Test`. Метод `Test` загружает динамическую сборку по отображаемому имени и вызывает статический метод `HelloFromAD`.  
  
 Можно увидеть, что поиск в динамическом каталоге выполняется после обычных путей поиска путем написания кода для сборки с именем `DynamicHelloWorld.dll` и компиляции его в том же каталоге, что и этот пример. Сборка должна иметь класс с именем `HelloWorld` со статическим методом с именем `HelloFromAD`. Этот метод не обязательно должен иметь те же функциональные возможности, что и в примере. Он может просто отобразить строку в консоли. Сборка также должна иметь атрибут <xref:System.Reflection.AssemblyVersionAttribute>, который задает для его версии значение 1.0.0.0. При выполнении примера сборка, скомпилированная в текущем каталоге, обнаруживается до того, как будет выполнен поиск в динамическом каталоге.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Невозможно задать это свойство, так как имя приложения в домене приложения — <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает XML-данные конфигурации, заданные методом <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />, который переопределяет XML-данные конфигурации приложения.</summary>
        <returns>Массив, содержащий XML-данные конфигурации, заданные с помощью метода <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />, или <see langword="null" />, если метод <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> не вызывался.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.AppDomainSetup.SetConfigurationBytes%2A> предоставляет способ переопределения сведений о конфигурации приложения, которое создает новый домен приложения. Сведения о файле конфигурации в `value` переопределяют сведения о файле конфигурации для приложения. Например, когда приложение example. exe создает новый домен приложения, оно может переопределить сведения о конфигурации, изначально полученные из файла example. exe. config.  
  
> [!IMPORTANT]
>  Некоторые потребители данных файла конфигурации не используют сведения, хранящиеся в методе <xref:System.AppDomainSetup.SetConfigurationBytes%2A>. Среда выполнения не применяет это. Чтобы убедиться, что все сведения о файле конфигурации переопределены в новом домене приложения, используйте свойство <xref:System.AppDomainSetup.ConfigurationFile%2A>, чтобы указать файл конфигурации. Метод <xref:System.AppDomainSetup.SetConfigurationBytes%2A> влияет на привязку сборки.  
  
 XML в `value` совпадает с XML в нормальном файле конфигурации, за исключением того, что он хранится в виде массива <xref:System.Byte>.  
  
 Чтобы получить доступ к байтам конфигурации для домена приложения, используйте свойство <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> для получения объекта <xref:System.AppDomainSetup> для домена приложения, а затем используйте метод <xref:System.AppDomainSetup.GetConfigurationBytes%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расположение файла лицензии, связанного с этим доменом.</summary>
        <value>Имя и расположение файла лицензии.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет политику оптимизации, используемую для загрузки исполняемого файла.</summary>
        <value>Константа перечисляемого типа, которая используется с <see cref="T:System.LoaderOptimizationAttribute" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается динамическая сборка, которая сохраняется на диске, а затем используется свойство <xref:System.AppDomainSetup.LoaderOptimization%2A> для задания политики оптимизации, используемой для загрузки сборки в домен приложения.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает список помеченных флагом <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> сборок, которые доступны коду с частичным доверием в изолированном домене приложения.</summary>
        <value>Массив частичных имен сборок, каждое из которых состоит из простого имени сборки и открытого ключа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], атрибут <xref:System.Security.AllowPartiallyTrustedCallersAttribute> (APTCA) можно сделать условным, задав для его свойства <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> значение <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>. Сборка APTCA, помеченная <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>, не может использоваться частично доверенным кодом, если это не разрешено ведущим приложением.  
  
 Узел изолированного домена приложения позволяет коду в домене приложения использовать сборки с условными атрибутами APTCA путем создания массива, содержащего простое имя и открытый ключ каждой сборки, и присвоение этому свойству массива. Например, элемент массива может выглядеть следующим образом: "MyAssembly, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad 0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9".  
  
> [!IMPORTANT]
>  Если вы используете подкласс <xref:System.AppDomainManager>, а сборка, определяющая его, зависит от сборок, помеченных атрибутом APTCA, необходимо включить эти сборки в список, который передается в свойство <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> <xref:System.AppDomainSetup>, которое используется для создания домены приложений. В противном случае сборки, помеченные атрибутом APTCA Conditional, будут отключены.  
  
> [!NOTE]
>  При отладке приложения, которое выполняется в изолированном домене приложения, некоторые <xref:System.Security.SecurityException> сообщения могут вести себя в заблуждение. Например, сообщение может указывать на то, что одна из полностью доверенных сборок имеет только ограниченные разрешения, тогда как реальная причина проблемы заключается в том, что требование безопасности, превышающее набор предоставленных изолированных доменов приложений, распространяется на границу не удалось выполнить изолированный домен приложения.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает список каталогов в базовой папке приложения, в которых выполняется поиск закрытых сборок.</summary>
        <value>Список имен каталогов, разделенных точкой с запятой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Закрытые сборки развертываются в той же структуре каталогов, что и приложение. Если каталоги, указанные для <xref:System.AppDomainSetup.PrivateBinPath%2A>, не находятся в <xref:System.AppDomainSetup.ApplicationBase%2A>, они игнорируются.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает строковое значение, включающее <see cref="P:System.AppDomainSetup.ApplicationBase" /> в путь поиска для приложения или исключающее его из этого пути, чтобы поиск выполнялся только в <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</summary>
        <value>Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для включения пути к базовой папке приложения при поиске сборок; любое непустое строковое значение для исключения пути. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству любое строковое значение, отличное от NULL, включая <xref:System.String.Empty?displayProperty=nameWithType> (""), чтобы исключить путь к каталогу приложения, то есть <xref:System.AppDomainSetup.ApplicationBase%2A>-из пути поиска для приложения и поиска сборок только в <xref:System.AppDomainSetup.PrivateBinPath%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, отключено ли кэширование интерфейсов для вызовов взаимодействия в домене приложения, так что <c>QueryInterface</c> выполняется для каждого вызова.</summary>
        <value><see langword="true" />, если кэширование интерфейса отключено для вызовов взаимодействия в доменах приложений, созданных с текущим объектом <see cref="T:System.AppDomainSetup" />; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отключение кэширования интерфейса оказывает значительное влияние на производительность вызовов взаимодействия.  
  
 Этот элемент появился в [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="switches">Перечислимый набор строковых значений, задающий переключатели совместимости, или значение <see langword="null" /> для снятия существующих переключателей совместимости.</param>
        <summary>Устанавливает заданные переключатели, благодаря чему домен приложения становится совместимым с предыдущими версиями платформы .NET Framework для указанных аспектов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Основные версии .NET Framework иногда представляют критические изменения из предыдущей версии. Например, [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] вводит небольшое количество критических изменений из [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]. Используйте метод <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A>, чтобы указать, что необходимо откатить один или несколько из этих критических изменений для домена приложения, чтобы обеспечить совместимость поведения с предыдущей версией .NET Framework.  
  
 Каждый раз при вызове этого метода он заменяет существующие параметры коммутатора. Чтобы удалить параметры, укажите `null` для параметра `switches`.  
  
 Набор строковых значений, предоставляемых для `switches`, может быть простым массивом строк, поскольку массивы реализуют интерфейс <xref:System.Collections.IEnumerable>.  
  
 В следующей таблице приведены примеры параметров совместимости, которые можно задать для восстановления поведения более ранних версий .NET Framework.  
  
|Переключение|Значение|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Управление доступом для кода (CAS) для [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включено в этом домене приложения. См. раздел [&lt;NetFx40_LegacySecurityPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Значения сортировки строк по умолчанию для [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включены в этом домене приложения. Для успешного восстановления прежних версий необходимо также, чтобы библиотека динамической компоновки sort00001000. dll была доступна в локальной системе. См. раздел [&lt;компатсортнлсверсион&gt; element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Значения сортировки строк по умолчанию для [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и Юникод 5,0 включены в этом домене приложения. Для успешного восстановления прежних версий необходимо также, чтобы библиотека динамической компоновки sort00060101. dll была доступна в локальной системе.|  
|"NetFx40_TimeSpanLegacyFormatMode"|поведение форматирования <xref:System.TimeSpan> для [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включено в этом домене приложения. См. раздел [&lt;TimeSpan_LegacyFormatMode&gt;](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) и "восстановление прежних версий форматирования TimeSpan" раздела <xref:System.TimeSpan>.|  
|UseRandomizedStringHashAlgorithm|Среда выполнения вычисляет хэш-коды для строк на уровне каждого приложения вместо использования единого алгоритма хэширования, который создает согласованный хэш-код между доменами приложений. См. раздел [&lt;UseRandomizedStringHashAlgorithm&gt; element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/07132b9c-4a72-4710-99d7-e702405e02d4">&lt;NetFx40_LegacySecurityPolicy&gt; элемент</related>
        <related type="Article" href="https://msdn.microsoft.com/library/782cc82e-83f7-404a-80b7-6d3061a8b6e3">&lt;Компатсортнлсверсион&gt; элемент</related>
        <related type="Article" href="https://msdn.microsoft.com/library/865e7207-d050-4442-b574-57ea29d5e2d6">&lt;TimeSpan_LegacyFormatMode&gt; элемент</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; элемент</related>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Массив, содержащий XML-данные конфигурации для домена приложения.</param>
        <summary>Предоставляет XML-данные конфигурации для домена приложения, заменяя XML-данные конфигурации приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.AppDomainSetup.SetConfigurationBytes%2A> предоставляет способ замены сведений о конфигурации приложения, которое создает новый домен приложения. Сведения о файле конфигурации в `value` заменяют сведения о файле конфигурации для приложения. Например, когда приложение example. exe создает новый домен приложения, оно может заменить сведения о конфигурации, изначально полученные из файла example. exe. config.  
  
> [!IMPORTANT]
>  Некоторые потребители данных файла конфигурации не используют сведения, хранящиеся в методе <xref:System.AppDomainSetup.SetConfigurationBytes%2A>. Среда выполнения не применяет это. Чтобы обеспечить замену всех сведений о файле конфигурации в новом домене приложения, используйте свойство <xref:System.AppDomainSetup.ConfigurationFile%2A>, чтобы указать файл конфигурации. Метод <xref:System.AppDomainSetup.SetConfigurationBytes%2A> влияет на привязку сборки.  
  
 XML в `value` совпадает с XML в нормальном файле конфигурации, за исключением того, что он хранится в виде массива <xref:System.Byte>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Схема параметров среды выполнения</related>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionVersion" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionPointer" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="functionName">Имя переопределяемой функции сравнения строк.</param>
        <param name="functionVersion">Версия функции. Для [!INCLUDE[net_v45](~/includes/net-v45-md.md)] значение должно быть больше или равно 1.</param>
        <param name="functionPointer">Указатель на функцию, переопределяющую <paramref name="functionName" />.</param>
        <summary>Предоставляет среду CLR с резервной реализацией функции сравнения строк.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующие методы сравнения и сортировки строк могут быть переопределены методом <xref:System.AppDomainSetup.SetNativeFunction%2A>:  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 Дополнительные сведения об этих функциях см. в разделе [функции поддержки национальных языков](https://go.microsoft.com/fwlink/?LinkId=228134).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойство <paramref name="functionName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="functionVersion" /> не является значением, равным или большим 1.  
  
-или- 
 Свойство <paramref name="functionPointer" /> имеет значение <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имена каталогов, содержащих сборки, для которых будут созданы теневые копии.</summary>
        <value>Список имен каталогов, разделенных точкой с запятой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если теневое копирование включено, по умолчанию используется теневое копирование всех сборок, найденных с помощью проверки. то есть в каталогах, заданных свойствами <xref:System.AppDomainSetup.PrivateBinPath%2A> и <xref:System.AppDomainSetup.ApplicationBase%2A>. Свойство <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> ограничено теневой копией сборок в каталогах, указанных в параметре <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>.  
  
 Если не присвоить строку свойству <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> или задать для этого свойства значение `null`, то все сборки в каталогах, заданные свойствами <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A>, будут копироваться с помощью теневого копирования.  
  
> [!IMPORTANT]
>  Пути к каталогам не должны содержать точку с запятой, так как она является разделителем. Escape-символа для точки с запятой не существует.  
  
 Если теневое копирование действует, файлы сборки копируются в другое расположение перед загрузкой сборок. Исходный файл сборки не заблокирован, поэтому его можно обновить. Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает строку, позволяющую определить, включено ли теневое копирование.</summary>
        <value>Строковое значение true, свидетельствующее о том, что теневое копирование включено, или значение false, указывающее на то, что оно отключено.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; }" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetFrameworkName As String" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); };" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string" Usage="System.AppDomainSetup.TargetFrameworkName" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает строку, которая определяет целевую версию и профиль .NET Framework для домена приложения в формате, который может быть проанализирован конструктором <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" />.</summary>
        <value>Целевая версия и профиль платформы .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задайте это свойство, чтобы сообщить текущей версии .NET Framework о том, что домен приложения будет использоваться для загрузки и запуска сборок, скомпилированных для целевой версии и профиля. Если в текущей версии .NET Framework есть необязательные поведения, влияющие на совместимость кода, который был скомпилирован с целевой версией, он может включить или отключить эти варианты поведения, чтобы улучшить совместимость. Это может быть полезно, если приложение поддерживает надстройки, скомпилированные с несколькими версиями .NET Framework, запустив их в отдельных доменах приложений.  
  
 Для клиентских приложений значение свойства <xref:System.AppDomainSetup.TargetFrameworkName%2A> выводится из атрибута <xref:System.Runtime.Versioning.TargetFrameworkAttribute>. В [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] и более поздних версиях этот атрибут добавляется в сборку автоматически в зависимости от значения свойства **целевой платформы** проекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
