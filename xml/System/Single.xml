<Type Name="Single" FullName="System.Single">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3758367ad4442ff2fc5fcdbbb2f7a7616fa00aac" /><Meta Name="ms.sourcegitcommit" Value="394eb46af92ad32373cd2c7855b688846886ed40" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/23/2019" /><Meta Name="ms.locfileid" Value="74424726" /></Metadata><TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет число одиночной точности с плавающей запятой.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения <xref:System.Single> представляет собой 32-разрядное число с одинарной точностью и значениями от отрицательного 3.402823 E38 до положительного 3.402823 E38, а также положительный или отрицательный нуль, <xref:System.Single.PositiveInfinity>, <xref:System.Single.NegativeInfinity>и не является числом (<xref:System.Single.NaN>). Он предназначен для представления слишком больших значений (например, расстояния между планеты или ГАЛАКСИЕС) или чрезвычайно малым (например, молекулярное масса вещества в килограммах) и часто являются неточными (например, расстояние от земли до другой солнечной системы). ). Тип <xref:System.Single> соответствует стандарту IEC 60559:1989 (IEEE 754) для бинарных арифметических операций с плавающей запятой.  
  
 В этом разделе:  
  
-   [Представление и точность с плавающей точкой](#Precision)  
  
-   [Проверка на равенство](#Equality)  
  
-   [Значения и исключения с плавающей запятой](#Exceptions)  
  
-   [Преобразование типов и единственная структура](#Conversion)  
  
-   [Функция вычислений с плавающей запятой](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType> предоставляет методы для сравнения экземпляров этого типа, преобразования значения экземпляра в строковое представление и преобразования строкового представления числа в экземпляр этого типа. Сведения о том, как коды спецификации формата управляют строковым представлением типов значений, см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md), [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md)и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Представление и точность с плавающей точкой  
 <xref:System.Single> тип данных хранит значения с плавающей запятой одиночной точности в 32-разрядном двоичном формате, как показано в следующей таблице.  
  
|Отделение|Bits|  
|----------|----------|  
|Значащим или мантисса|0-22|  
|Exponent|23-30|  
|Знак (0 = положительный, 1 = отрицательный)|31|  
  
 Точно так же, как десятичные дроби не могут точно представлять некоторые дробные значения (например, 1/3 или <xref:System.Math.PI?displayProperty=nameWithType>), двоичные дроби не могут представлять некоторые дробные значения. Например, 2/10, которая точно представляется в виде десятичной дроби 2, представляется в виде 0011111001001100 в виде двоичной дроби с шаблоном "1100", повторяющимся до бесконечности. В этом случае значение с плавающей запятой обеспечивает неточное представление числа, которое оно представляет. Выполнение дополнительных математических операций с исходным значением с плавающей запятой часто приводит к нехватке точности. Например, если сравнить результаты умножения 3 на 10 и добавить 3 в. 3 9 раз, вы увидите, что сложение выдает менее точный результат, так как включает восемь дополнительных операций, чем умножение. Обратите внимание, что такое нарушение четности очевидно только при отображении двух значений <xref:System.Single> с помощью [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md)R, которая при необходимости отображает все 9 знаков точности, поддерживаемые типом <xref:System.Single>.  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 Поскольку некоторые числа не могут быть представлены в виде дробных двоичных значений, числа с плавающей запятой могут быть приблизительными только вещественными числами.  
  
 Все числа с плавающей запятой имеют ограниченное число значащих цифр, что также определяет, насколько точное значение числа с плавающей запятой приблизительно равно вещественному числу. Значение <xref:System.Single> имеет длину до 7 десятичных разрядов точности, хотя для внутренних целей поддерживается не более 9 цифр. Это означает, что некоторые операции с плавающей запятой могут не иметь точности изменять значение с плавающей запятой. В следующем примере определяется большое значение с плавающей запятой одиночной точности, а затем в него добавляется <xref:System.Single.Epsilon?displayProperty=nameWithType> и одно из квадриллион. Однако продукт слишком мал для изменения исходного значения с плавающей запятой. Его минимальная значимая цифра состоит из тысяч, в то время как наиболее значимая цифра в продукте составляет 10<sup>– 30</sup>.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 Ограниченная точность числа с плавающей запятой имеет несколько последствий:  
  
-   Два числа с плавающей запятой, которые выглядят равными для определенной точности, могут не сравниваться, так как их наименьшие значащие цифры отличаются. В следующем примере ряд чисел добавляется вместе, а их итог сравнивается с ожидаемым итогом. Несмотря на то что два значения выглядят одинаковыми, вызов метода `Equals` указывает, что они не являются.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     Если изменить элементы форматирования в инструкции <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> с `{0}` и `{1}` на `{0:R}` и `{1:R}` для просмотра всех значащих цифр двух <xref:System.Single> значений, то ясно, что эти два значения не равны из-за потери точности во время операций сложения. В этом случае проблему можно устранить, вызвав метод <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType>, чтобы округлить значения <xref:System.Single> до нужной точности перед выполнением сравнения.  
  
-   Математическая операция OR, использующая число с плавающей запятой, может не дать одинакового результата, если используется десятичное число, так как число двоичных с плавающей запятой может не совпадать с десятичным числом. Предыдущий пример демонстрирует это, отображая результат умножения 3 на 10 и добавляя 3 в. 3 9 раз.  
  
     Если точность числовых операций с дробными значениями важна, используйте тип <xref:System.Decimal> вместо типа <xref:System.Single>. Если точность числовых операций с целочисленными значениями выходит за пределы диапазона типов <xref:System.Int64> или <xref:System.UInt64>, используйте тип <xref:System.Numerics.BigInteger>.  
  
-   Значение может не циклически передавалться, если используется число с плавающей запятой. Значение считается циклическим, если операция преобразует исходное число с плавающей запятой в другую форму, операция обратного преобразования преобразует преобразованную форму обратно в число с плавающей запятой, а окончательное число с плавающей запятой равно исходному. число с плавающей запятой. Цикл обработки может завершиться ошибкой, поскольку одна или несколько наименьших значащих цифр теряются или изменяются при преобразовании. В следующем примере три <xref:System.Single> значения преобразуются в строки и сохраняются в файле. Как видно из выходных данных, хотя значения выглядят одинаковыми, восстановленные значения не равны исходным значениям.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     В этом случае можно успешно выполнить циклический обмен значениями с помощью [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) "G9", чтобы сохранить полную точность значений <xref:System.Single>, как показано в следующем примере.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single> значения имеют меньшую точность, чем <xref:System.Double> значений. <xref:System.Single> значение, которое преобразуется в эквивалентный <xref:System.Double>, часто не равно значению <xref:System.Double> из-за различий в точности. В следующем примере результат идентичных операций деления назначается значению <xref:System.Double> и значению <xref:System.Single>. После приведения <xref:System.Single> значения к <xref:System.Double>, сравнение двух значений показывает, что они не равны.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Чтобы избежать этой проблемы, либо используйте <xref:System.Double> тип данных вместо <xref:System.Single>ного типа данных, либо используйте метод <xref:System.Math.Round%2A>, чтобы оба значения имели одинаковую точность.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Проверка на равенство  
 Чтобы считаться равными, два значения <xref:System.Single> должны представлять одинаковые значения. Однако из-за различия в точности между значениями или из-за потери точности по одному или обоим значениям значения с плавающей запятой, которые должны быть идентичными, часто оказываются неравными в связи с различиями в их минимально значащих цифрах. В результате вызовы метода <xref:System.Single.Equals%2A> для определения того, равны ли два значения, или вызовы метода <xref:System.Single.CompareTo%2A> для определения связи между двумя <xref:System.Single> значениями, часто дают непредвиденные результаты. Это очевидно в следующем примере, где два очевидных <xref:System.Single> значений могут быть неравными, так как первое значение имеет 7 цифр точности, а второе значение равно 9.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 Вычисляемые значения, которые следуют разным путям кода и управляются разными способами, часто не считаются равными. В следующем примере одно <xref:System.Single> значение равно квадратному значению, а затем вычисляется квадратный корень для восстановления исходного значения. Второй <xref:System.Single> умножается на 3,51, и в квадрате перед квадратным корнем результата делится на 3,51 для восстановления исходного значения. Несмотря на то, что два значения выглядят одинаковыми, вызов метода <xref:System.Single.Equals%28System.Single%29> указывает, что они не равны. Использование строки стандартного формата "G9" для возврата результирующей строки, отображающей все значащие цифры каждого <xref:System.Single> значения, показывает, что второе значение .0000000000001 меньше первого.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 В случаях, когда вероятность потери точности может повлиять на результат сравнения, вместо вызова метода <xref:System.Single.Equals%2A> или <xref:System.Single.CompareTo%2A> можно использовать следующие методы:  
  
-   Вызовите метод <xref:System.Math.Round%2A?displayProperty=nameWithType>, чтобы убедиться, что оба значения имеют одинаковую точность. Следующий пример изменяет предыдущий пример, чтобы использовать этот подход, чтобы два дробных значения были эквивалентными.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     Обратите внимание, что проблема точности по-прежнему применяется к округлению средних значений. Дополнительные сведения см. в описании метода <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Проверка на приблизительную равенство вместо равенства. Для этого способа необходимо определить абсолютное значение, по которому два значения могут различаться, но по-прежнему быть равными, или определить относительный объем, на который меньшее значение может отличаться от большего.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType> иногда используется в качестве абсолютной меры расстояния между двумя <xref:System.Single>ными значениями при проверке на равенство.  Однако <xref:System.Single.Epsilon?displayProperty=nameWithType> измеряет наименьшее возможное значение, которое можно добавить в <xref:System.Single>, значение которого равно нулю, или вычесть из него. Для большинства положительных и отрицательных значений <xref:System.Single> значение <xref:System.Single.Epsilon?displayProperty=nameWithType> слишком мало для обнаружения. Таким образом, за исключением нулевых значений, не рекомендуется использовать его в тестах на равенство.  
  
     В следующем примере используется второй подход для определения метода `IsApproximatelyEqual`, который проверяет относительное различие между двумя значениями. Он также отличается от результата вызовов метода `IsApproximatelyEqual` и метода <xref:System.Single.Equals%28System.Single%29>.  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Значения и исключения с плавающей запятой  
 Операции с значениями с плавающей запятой не создают исключения, в отличие от операций с целочисленными типами, которые создают исключения в случае недопустимых операций, таких как деление на ноль или переполнение.  Вместо этого в таких ситуациях результат операции с плавающей запятой равен нулю, плюс бесконечность, отрицательная бесконечность или не является числом (NaN):  
  
-   Если результат операции с плавающей запятой слишком мал для конечного формата, результат равен нулю. Это может произойти при умножении двух очень маленьких чисел с плавающей запятой, как показано в следующем примере.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   Если величина результата операции с плавающей запятой превышает диапазон формата назначения, результатом операции будет <xref:System.Single.PositiveInfinity> или <xref:System.Single.NegativeInfinity>, в зависимости от знака результата. Результатом операции, которая переполняет <xref:System.Single.MaxValue?displayProperty=nameWithType>, является <xref:System.Single.PositiveInfinity>, а результат операции, в которой переполняется <xref:System.Single.MinValue?displayProperty=nameWithType>, <xref:System.Single.NegativeInfinity>, как показано в следующем примере.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity> также результаты из деления на ноль с положительным делимым, и <xref:System.Single.NegativeInfinity> результаты деления на ноль с отрицательным делимым.  
  
-   Если операция с плавающей запятой является недопустимой, результатом операции будет <xref:System.Single.NaN>. Например, <xref:System.Single.NaN> результаты следующих операций:  
  
    -   Деление на ноль с делимым на ноль. Обратите внимание, что другие варианты деления на ноль приводят либо к <xref:System.Single.PositiveInfinity>, либо к <xref:System.Single.NegativeInfinity>.  
  
    -   Любая операция с плавающей запятой с недопустимыми входными данными. Например, попытка найти квадратный корень из отрицательного значения возвращает <xref:System.Single.NaN>.  
  
    -   Любая операция с аргументом, значение которого равно <xref:System.Single.NaN?displayProperty=nameWithType>.  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>Преобразования типов и единая структура  
 Структура <xref:System.Single> не определяет никаких явных или неявных операторов преобразования; Вместо этого преобразования реализуются компилятором.  
  
 В следующей таблице перечислены возможные преобразования значения других типов-примитивов в <xref:System.Single> значение, а также показано, является ли преобразование расширяющим или сужающим, и может ли результирующая <xref:System.Single> меньше, чем у исходного значения. значений.  
  
|Допустимо ли преобразование из|Расширяющие и узкие|Возможная потери точности|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|Нет|  
|<xref:System.Decimal>|Widening<br /><br /> Обратите C# внимание, что требуется оператор CAST.|Да. <xref:System.Decimal> поддерживает 29 десятичных разрядов точности; <xref:System.Single> поддерживает 9.|  
|<xref:System.Double>|Сужающие значения вне допустимого диапазона преобразуются в <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> или <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.|Да. <xref:System.Double> поддерживает 17 десятичных разрядов точности; <xref:System.Single> поддерживает 9.|  
|<xref:System.Int16>|Widening|Нет|  
|<xref:System.Int32>|Widening|Да. <xref:System.Int32> поддерживает 10 десятичных разрядов точности; <xref:System.Single> поддерживает 9.|  
|<xref:System.Int64>|Widening|Да. <xref:System.Int64> поддерживает 19 десятичных разрядов точности; <xref:System.Single> поддерживает 9.|  
|<xref:System.SByte>|Widening|Нет|  
|<xref:System.UInt16>|Widening|Нет|  
|<xref:System.UInt32>|Widening|Да. <xref:System.UInt32> поддерживает 10 десятичных разрядов точности; <xref:System.Single> поддерживает 9.|  
|<xref:System.UInt64>|Widening|Да. <xref:System.Int64> поддерживает 20 десятичных разрядов точности; <xref:System.Single> поддерживает 9.|  
  
 В следующем примере минимальное или максимальное значение других примитивных числовых типов преобразуется в <xref:System.Single>ое значение.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 Кроме того, <xref:System.Double> значения <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>и <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> преобразуется в <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>и <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>соответственно.  
  
 Обратите внимание, что преобразование значения некоторых числовых типов в <xref:System.Single> значение может привести к утрате точности. Как показано в примере, возможна вероятность потери точности при преобразовании значений <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt32>и <xref:System.UInt64> для <xref:System.Single> значений.  
  
 Преобразование значения <xref:System.Single> в <xref:System.Double> является расширяющим преобразованием. Преобразование может привести к утрате точности, если тип <xref:System.Double> не имеет точного представления значения <xref:System.Single>.  
  
 Преобразование значения <xref:System.Single> в значение любого типа данных-примитива, отличного от <xref:System.Double>, является узким преобразованием и требует оператора приведения (in C#) или метода преобразования (в Visual Basic). Значения, находящиеся вне диапазона целевого типа данных, определяемые свойствами `MinValue` и `MaxValue` целевого типа, ведут себя так, как показано в следующей таблице.  
  
|Тип результирующего значения|Результат|  
|-----------------|------------|  
|Любой целочисленный тип|Исключение <xref:System.OverflowException>, если преобразование выполняется в проверяемом контексте.<br /><br /> Если преобразование происходит в непроверяемом контексте (по умолчанию в C#), операция преобразования выполняется успешно, но значение переполняется.|  
|<xref:System.Decimal>|Исключение <xref:System.OverflowException>,|  
  
 Кроме того, <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>и <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> создают <xref:System.OverflowException> для преобразования в целые числа в проверяемом контексте, но при преобразовании в целые числа в непроверяемом контексте эти значения переполняются. Для преобразования в <xref:System.Decimal>они всегда создают <xref:System.OverflowException>. Для преобразования в <xref:System.Double>они преобразуются в <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>и <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>соответственно.  
  
 Обратите внимание, что при преобразовании <xref:System.Single> значения в другой числовой тип может произойти утрата точности. В случае преобразования нецелочисленных значений <xref:System.Single>, как показано в выходных данных примера, дробный компонент теряется, если <xref:System.Single> значение округляется (как в Visual Basic) или усекается (как в C#). Для преобразований в <xref:System.Decimal> значения <xref:System.Single> может не иметь точного представления в целевом типе данных.  
  
 В следующем примере число <xref:System.Single> значений преобразуется в несколько других числовых типов. Преобразования выполняются в проверяемом контексте в Visual Basic (по умолчанию) и в C# (из-за ключевого слова [checked](~/docs/csharp/language-reference/keywords/checked.md) ). Выходные данные в примере показывают результат для преобразований в проверяемом непроверяемом контексте. В Visual Basic можно выполнять преобразования в непроверенном контексте, выполнив компиляцию с помощью параметра компилятора `/removeintchecks+` и в C# , заменив инструкцию `checked`.  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 Дополнительные сведения о преобразовании числовых типов см. в разделе [Преобразование типов в](~/docs/standard/base-types/type-conversion.md) [таблицах .NET Framework и преобразования типов](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Функция вычислений с плавающей запятой  
 Структура <xref:System.Single> и связанные типы предоставляют методы для выполнения следующих категорий операций:  
  
-   **Сравнение значений**. Можно вызвать метод <xref:System.Single.Equals%2A>, чтобы определить, равны ли два значения <xref:System.Single> или метод <xref:System.Single.CompareTo%2A> для определения связи между двумя значениями.  
  
     Структура <xref:System.Single> также поддерживает полный набор операторов сравнения. Например, можно проверить на равенство или неравенство или определить, является ли одно значение больше или равно другому значению. Если один из операндов является <xref:System.Double>, <xref:System.Single> значение преобразуется в <xref:System.Double> перед выполнением сравнения. Если один из операндов является целочисленным типом, он преобразуется в <xref:System.Single> перед выполнением сравнения. Хотя это расширяющие преобразования, они могут привести к утрате точности.  
  
    > [!WARNING]
    >  Из-за различий в точности два <xref:System.Single> значения, которые должны быть равны, могут оказаться неравными, что влияет на результат сравнения. Дополнительные сведения о сравнении двух значений <xref:System.Single> см. в разделе [Проверка на равенство](#Equality) .  
  
     Для проверки этих специальных значений можно также вызвать методы <xref:System.Single.IsNaN%2A>, <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>и <xref:System.Single.IsNegativeInfinity%2A>.  
  
-   **Математические операции**. Стандартные арифметические операции, такие как сложение, вычитание, умножение и деление, реализуются компиляторами языка и инструкциями на языке CIL, а не методами <xref:System.Single>. Если другой операнд в математической операции является <xref:System.Double>, <xref:System.Single> преобразуется в <xref:System.Double> перед выполнением операции, а результат операции также является <xref:System.Double> значением. Если второй операнд является целочисленным типом, он преобразуется в <xref:System.Single> перед выполнением операции, а результат операции также является <xref:System.Single>ным значением.  
  
     Можно выполнять другие математические операции, вызывая методы `static` (`Shared` в Visual Basic) в классе <xref:System.Math?displayProperty=nameWithType>. К ним относятся дополнительные методы, обычно используемые для арифметических действий (например, <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>и <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), Geometry (например, <xref:System.Math.Cos%2A?displayProperty=nameWithType> и <xref:System.Math.Sin%2A?displayProperty=nameWithType>) и математического анализа за (например, <xref:System.Math.Log%2A?displayProperty=nameWithType>).  Во всех случаях <xref:System.Single> значение преобразуется в <xref:System.Double>.  
  
     Можно также управлять отдельными битами в <xref:System.Single>м значении. Метод <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType> возвращает свой битовый шаблон в массиве байтов.  Передав этот массив байтов в метод <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType>, можно также сохранить битовый шаблон <xref:System.Single>ого значения в 32-разрядном целом формате.  
  
-   **Округление**. Округление часто используется как метод снижения влияния различий между значениями, вызванными проблемами представления и точности с плавающей запятой. Можно округлить <xref:System.Single> значение, вызвав метод <xref:System.Math.Round%2A?displayProperty=nameWithType>. Однако обратите внимание, что <xref:System.Single> значение преобразуется в <xref:System.Double> до вызова метода, а преобразование может привести к утрате точности.  
  
-   **Форматирование**. Можно преобразовать <xref:System.Single> значение в его строковое представление, вызвав метод <xref:System.Single.ToString%2A> или функцию [составного форматирования](~/docs/standard/base-types/composite-formatting.md) . Сведения о том, как строки формата управляют строковым представлением значений с плавающей запятой, см. в разделах [стандартные строки числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md) .  
  
-   **Синтаксический анализ строк**. Можно преобразовать строковое представление значения с плавающей запятой в <xref:System.Single> значение, вызвав метод <xref:System.Single.Parse%2A> или <xref:System.Single.TryParse%2A>. Если операция синтаксического анализа завершается неудачно, метод <xref:System.Single.Parse%2A> создает исключение, в то время как метод <xref:System.Single.TryParse%2A> возвращает `false`.  
  
-   **Преобразование типов**. Структура <xref:System.Single> предоставляет явную реализацию интерфейса для интерфейса <xref:System.IConvertible>, который поддерживает преобразование между любыми двумя стандартными типами данных .NET Framework. Языковые компиляторы также поддерживают неявное преобразование значений для всех других стандартных числовых типов, за исключением преобразования <xref:System.Double> в <xref:System.Single> значения. Преобразование значения любого стандартного числового типа, отличного от <xref:System.Double> в <xref:System.Single>, является расширяющим преобразованием и не требует использования оператора приведения или метода преобразования.  
  
     Однако преобразование 32-разрядных и 64-разрядных целочисленных значений может привести к утрате точности. В следующей таблице перечислены различия в точности для 32-разрядных, 64-разрядных и <xref:System.Double> типов.  
  
    |Тип|Максимальная точность (в десятичных цифрах)|Внутренняя точность (в десятичных цифрах)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> и <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> и <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     Проблема точности чаще всего влияет на <xref:System.Single> значения, которые преобразуются в <xref:System.Double> значения. В следующем примере два значения, созданные идентичными операциями деления, не равны, так как одно из значений является значением с плавающей запятой одиночной точности, которое преобразуется в <xref:System.Double>.  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Все члены этого типа являются потокобезопасными. Члены, которые могут изменить состояние экземпляра, в действительности возвращают новый экземпляр, инициализированный новым значением. Как с любым другим типом, чтение и запись общей переменной, которая содержит экземпляр этого типа, должны быть защищены блокировкой для обеспечения потокобезопасности.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сравнивает данный экземпляр с указанным объектом или другим экземпляром <see cref="T:System.Single" /> и возвращает целое число, которое показывает, как соотносится значение данного экземпляра со значением другого экземпляра <see cref="T:System.Single" />: меньше, равняется или больше него.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Объект для сравнения или значение <see langword="null" />.</param>
        <summary>Сравнивает данный экземпляр с указанным объектом и возвращает целое число, которое показывает, является ли значение данного экземпляра меньше, больше или равно значению заданного объекта.</summary>
        <returns>Знаковое число, представляющее относительные значения этого экземпляра и параметра <paramref name="value" />.  
  
 <list type="table"><listheader><term> Возвращаемое значение 
 </term><description> Описание 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Этот экземпляр меньше параметра <paramref name="value" />.  
  
- или - 
Данный экземпляр не является числом (<see cref="F:System.Single.NaN" />), а параметр <paramref name="value" /> является.  
  
 </description></item><item><term> Нуль 
 </term><description> Этот экземпляр и параметр <paramref name="value" /> равны.  
  
- или - 
И данный экземпляр, и значение относятся к нечисловому типу (<see cref="F:System.Single.NaN" />), равны <see cref="F:System.Single.PositiveInfinity" /> или <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Этот экземпляр больше параметра <paramref name="value" />.  
  
- или - 
Данный экземпляр является числом, а параметр <paramref name="value" /> — нет (<see cref="F:System.Single.NaN" />).  
  
- или - 
 <paramref name="value" /> — <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `value` должен быть `null` или экземпляром <xref:System.Single>; в противном случае создается исключение. Любой экземпляр <xref:System.Single>, независимо от его значения, считается больше `null`.  
  
 Значения должны быть одинаковыми, чтобы считаться равными. Особенно если значения с плавающей запятой зависят от нескольких математических операций, обычно они теряют точность и их значения практически идентичны, за исключением их наименьших значащих цифр. По этой причине возвращаемое значение метода <xref:System.Single.CompareTo%2A> может показаться неудивительной в моменты времени. Например, умножение на определенное значение, за которым следует деление на одно и то же значение, должно создавать исходное значение, но в следующем примере вычисленное значение оказывается больше, чем исходное значение. Отображение всех значащих цифр двух значений с помощью [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) R означает, что вычисленное значение отличается от исходного значения в его минимально значащих цифрах. Дополнительные сведения об обработке таких сравнений см. в разделе "Примечания" метода <xref:System.Single.Equals%28System.Single%29>.  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 Этот метод реализуется для поддержки интерфейса <xref:System.IComparable>. Обратите внимание, что, хотя <xref:System.Single.NaN> не считается равным другому <xref:System.Single.NaN> (даже само по себе), интерфейс <xref:System.IComparable> требует, чтобы `A.CompareTo(A)` возвращал ноль.  
  
## <a name="precision-in-comparisons"></a>Точность в сравнениях  
 Точность чисел с плавающей запятой, превышающих задокументированную точность, зависит от реализации и версии .NET Framework. Следовательно, сравнение двух определенных чисел может измениться между версиями .NET Framework, так как точность внутреннего представления чисел может измениться.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется метод <xref:System.Single.CompareTo%2A>.  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> не является объектом <see cref="T:System.Single" />.</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : single -&gt; int&#xA;override this.CompareTo : single -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Сравниваемое число с плавающей запятой одиночной точности.</param>
        <summary>Сравнивает данный экземпляр с заданным числом одиночной точности с плавающей запятой и возвращает целое число, которое показывает, является ли значение данного экземпляра меньше, больше или равным значению заданного числа одиночной точности с плавающей запятой.</summary>
        <returns>Знаковое число, представляющее относительные значения этого экземпляра и параметра <paramref name="value" />.  
  
 <list type="table"><listheader><term> Возвращаемое значение 
 </term><description> Описание 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Этот экземпляр меньше параметра <paramref name="value" />.  
  
- или - 
Данный экземпляр не является числом (<see cref="F:System.Single.NaN" />), а параметр <paramref name="value" /> является.  
  
 </description></item><item><term> Нуль 
 </term><description> Этот экземпляр и параметр <paramref name="value" /> равны.  
  
- или - 
И этот экземпляр, и параметр <paramref name="value" /> не являются числами (<see cref="F:System.Single.NaN" />), равны <see cref="F:System.Single.PositiveInfinity" /> или <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Этот экземпляр больше параметра <paramref name="value" />.  
  
- или - 
Данный экземпляр является числом, а параметр <paramref name="value" /> — нет (<see cref="F:System.Single.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значения должны быть одинаковыми, чтобы считаться равными. Обычно значения с плавающей запятой теряют точность и почти идентичны, за исключением наименее значащих цифр, особенно в тех случаях, когда значения зависят от нескольких математических операций. По этой причине возвращаемое значение метода <xref:System.Single.CompareTo%2A> в некоторых случаях может показаться неудивительной. Например, умножение любого значения, за которым следует деление на одно и то же значение, должно привести к изначальному значению. Однако в следующем примере вычисленное значение оказывается больше, чем исходное значение. Отображение всех значащих цифр двух значений с помощью [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) R означает, что вычисленное значение отличается от исходного значения в его минимально значащих цифрах. Дополнительные сведения об обработке таких сравнений см. в разделе "Примечания" метода <xref:System.Single.Equals%28System.Single%29>.  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 Этот метод реализует интерфейс <xref:System.IComparable%601?displayProperty=nameWithType> и работает немного лучше, чем метод <xref:System.Single.CompareTo%2A?displayProperty=nameWithType>, поскольку ему не нужно преобразовывать параметр `value` в объект.  
  
 Обратите внимание, что, несмотря на то, что объект со значением <xref:System.Single.NaN> не считается равным другому объекту, значение которого равно <xref:System.Single.NaN> (даже само свойство), интерфейс <xref:System.IComparable%601> требует, чтобы `A.CompareTo(A)` возвращал ноль.  
  
## <a name="widening-conversions"></a>расширяющие преобразования  
 В зависимости от языка программирования может быть возможным написание кода <xref:System.Single.CompareTo%2A> метода, где тип параметра имеет меньше разрядов (более узкий), чем тип экземпляра. Это возможно, поскольку некоторые языки программирования выполняют неявное расширяющее преобразование, которое представляет параметр как тип с количеством битов в качестве экземпляра.  
  
 Например, предположим, что тип экземпляра <xref:System.Single>, а тип параметра — <xref:System.Int32>. Компилятор Microsoft C# создает инструкции для представления значения параметра как объекта <xref:System.Single>, а затем создает метод <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType>, который сравнивает значения экземпляра и расширенное представление параметра.  
  
 Обратитесь к документации по языку программирования, чтобы определить, выполняет ли компилятор неявное расширяющее преобразование числовых типов. Дополнительные сведения см. в разделе [таблицы преобразования типов](~/docs/standard/base-types/conversion-tables.md) .  
  
## <a name="precision-in-comparisons"></a>Точность в сравнениях  
 Точность чисел с плавающей запятой, превышающих задокументированную точность, зависит от реализации и версии .NET Framework. Следовательно, сравнение двух определенных чисел может измениться между версиями .NET Framework, так как точность внутреннего представления чисел может измениться.  
  
   
  
## Examples  
 В следующем примере кода показаны универсальные и неуниверсальные версии метода <xref:System.Single.CompareTo%2A> для нескольких ссылочных типов.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : single" Usage="System.single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>Представляет наименьшее положительное значение <see cref="T:System.Single" /> больше нуля. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства <xref:System.Single.Epsilon> отражает наименьшее положительное значение <xref:System.Single>, значимое в числовых операциях или сравнениях, если значение экземпляра <xref:System.Single> равно нулю. Например, следующий код показывает, что ноль и <xref:System.Single.Epsilon> считаются неравными значениями, тогда как нулевые и половинные значения <xref:System.Single.Epsilon> считаются равными.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 Точнее, формат с плавающей запятой одиночной точности состоит из знака, 23-разрядной мантисса или значащим и 8-разрядного показателя степени. Как показано в следующем примере, ноль имеет показатель степени-126 и мантисса 0. <xref:System.Single.Epsilon> имеет показатель-126 и мантисса 1. Это означает, что <xref:System.Single.Epsilon?displayProperty=nameWithType> — наименьшее положительное <xref:System.Single> значение больше нуля и представляющее наименьшее возможное значение и наименьшее возможное приращение для <xref:System.Single>, степень которого составляет-126.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 Однако свойство <xref:System.Single.Epsilon> не является общей мерой точности типа <xref:System.Single>. Он применяется только к <xref:System.Single>ным экземплярам, имеющим нулевое значение.  
  
> [!NOTE]
>  Значение свойства <xref:System.Single.Epsilon> не эквивалентно компьютеру Эпсилон, который представляет верхнюю границу относительных ошибок из-за округления в арифметических операциях с плавающей запятой.  
  
 Значение этой константы равно 1.4 e-45.  
  
 Два невероятных эквивалентных числа с плавающей запятой могут не сравниваться, так как они имеют различия в крайне значащих цифрах. Например, C# выражение `(float)1/3 == (float)0.33333`не сравнивает равенство, так как операция деления в левой части имеет максимальную точность, а константа в правой части является точной только до указанных цифр. Если вы создаете пользовательский алгоритм, определяющий, могут ли два числа с плавающей запятой считаться равными, необходимо использовать значение, превышающее <xref:System.Single.Epsilon>ную константу, чтобы установить допустимое абсолютное поле разности для этих двух значений. равномерно. (Как правило, это поле разности больше, чем <xref:System.Single.Epsilon>.)  
  
## <a name="platform-notes"></a>Примечания к платформе  
 В системах ARM значение константы <xref:System.Single.Epsilon> слишком мало для обнаружения, поэтому оно равно нулю. Вместо этого можно определить альтернативное значение Эпсилон, равное 1.175494351 E-38.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, указывающее, представляют ли два экземпляра <see cref="T:System.Single" /> одно и то же значение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для сравнения с данным экземпляром.</param>
        <summary>Возвращает значение, показывающее, равен ли данный экземпляр заданному объекту.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="obj" /> является экземпляром типа <see cref="T:System.Single" /> и равен значению данного экземпляра; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Single.Equals%2A> следует использовать с осторожностью, так как два неравных значения могут быть не равны из-за разной точности этих двух значений. В следующем примере сообщается, что <xref:System.Single> значение. 3333 и <xref:System.Single>, возвращаемые делением 1 на 3, не равны.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 Вместо сравнения на равенство, одним из рекомендуемых способов является определение приемлемого поля разности между двумя значениями (например, .01% одного из значений). Если абсолютное значение разницы между двумя значениями меньше или равно этому полю, разница, скорее всего, будет обусловлена различиями в точности и, следовательно, значения, скорее всего, будут равны. В следующем примере этот метод используется для сравнения значений. 33333 и 1/3, что два <xref:System.Single>ных значения, которые были найдены в предыдущем примере кода, не равны.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 В этом случае значения равны.  
  
> [!NOTE]
>  Поскольку <xref:System.Single.Epsilon> определяет минимальное выражение положительного значения, чей диапазон близок к нулю, поле разности должно быть больше <xref:System.Single.Epsilon>. Обычно это число больше <xref:System.Single.Epsilon>.  
  
 Точность чисел с плавающей запятой, превышающих задокументированную точность, зависит от реализации и версии .NET Framework. Следовательно, сравнение двух определенных чисел может измениться между версиями .NET Framework, так как точность внутреннего представления чисел может измениться.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется метод <xref:System.Single.Equals%2A>.  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Разрешение перегрузки компилятора может учитывать очевидную разницу в поведении двух перегрузок метода <see cref="M:System.Single.Equals(System.Object)" />. Если неявное преобразование между аргументом <paramref name="obj" /> и <see cref="T:System.Single" /> определено и аргумент не типизирован как <see cref="T:System.Object" />, компиляторы могут выполнить неявное преобразование и вызвать метод <see cref="M:System.Single.Equals(System.Single)" />. В противном случае они вызывают метод <see cref="M:System.Single.Equals(System.Object)" />, который всегда возвращает <see langword="false" />, если его <paramref name="obj" /> аргумент не является <see cref="T:System.Single" /> значением. В следующем примере показано различие в поведении между двумя перегрузками метода. В случае всех примитивных числовых типов, кроме <see cref="T:System.Double" /> в Visual Basic и за исключением <see cref="T:System.Decimal" /> и <see cref="T:System.Double" /> в C#, первое сравнение возвращает <see langword="true" />, так как компилятор автоматически выполняет расширяющее преобразование и вызывает <see cref="M:System.Single.Equals(System.Single)" /> , в то время как второе сравнение возвращает <see langword="false" />, так как компилятор вызывает метод <see cref="M:System.Single.Equals(System.Object)" />.  
  
[! код-CSharp[System. Single. Equals # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! код-VB[System. Single. Equals # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : single -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для сравнения с данным экземпляром.</param>
        <summary>Возвращает значение, позволяющее определить, представляют ли этот экземпляр и заданный объект <see cref="T:System.Single" /> одно и то же значение.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="obj" /> равно данному экземпляру; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует интерфейс <xref:System.IEquatable%601?displayProperty=nameWithType> и работает немного лучше, чем <xref:System.Single.Equals%2A>, поскольку ему не нужно преобразовывать параметр `obj` в объект.  
  
## <a name="widening-conversions"></a>расширяющие преобразования  
 В зависимости от языка программирования может быть возможным написание кода <xref:System.Single.Equals%2A> метода, где тип параметра имеет меньше разрядов (более узкий), чем тип экземпляра. Это возможно, поскольку некоторые языки программирования выполняют неявное расширяющее преобразование, которое представляет параметр как тип с количеством битов в качестве экземпляра.  
  
 Например, предположим, что тип экземпляра <xref:System.Single>, а тип параметра — <xref:System.Int32>. Компилятор Microsoft C# создает инструкции для представления значения параметра как объекта <xref:System.Single>, а затем создает метод <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType>, который сравнивает значения экземпляра и расширенное представление параметра.  
  
 Обратитесь к документации по языку программирования, чтобы определить, выполняет ли компилятор неявное расширяющее преобразование числовых типов. Дополнительные сведения см. в разделе [таблицы преобразования типов](~/docs/standard/base-types/conversion-tables.md) .  
  
## <a name="precision-in-comparisons"></a>Точность в сравнениях  
 Метод <xref:System.Single.Equals%2A> следует использовать с осторожностью, так как два вероятно эквивалентных значения могут быть неравными из-за разной точности этих двух значений. В следующем примере сообщается, что <xref:System.Single> значение. 3333 и <xref:System.Single>, возвращаемые делением 1 на 3, не равны.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 Одна методика сравнения, которая позволяет избежать проблем, связанных с сравнением на равенство, заключается в определении приемлемого поля разности между двумя значениями (например, .01% одного из значений). Если абсолютное значение разницы между двумя значениями меньше или равно этому полю, разница, скорее всего, будет результатом различий в точности, поэтому значения, скорее всего, будут равны. В следующем примере этот метод используется для сравнения значений. 33333 и 1/3, которые являются двумя <xref:System.Single> значениями, которые в предыдущем примере кода не совпадают.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 В этом случае значения равны.  
  
> [!NOTE]
>  Поскольку <xref:System.Single.Epsilon> определяет минимальное выражение положительного значения, чей диапазон близок к нулю, поле разности должно быть больше <xref:System.Single.Epsilon>. Обычно это число больше <xref:System.Single.Epsilon>. По этой причине рекомендуется не использовать <xref:System.Double.Epsilon> при сравнении <xref:System.Double> значений на равенство.  
  
 Вторая методика, которая позволяет избежать проблем, связанных с сравнением на равенство, заключается в сравнении различий между двумя числами с плавающей запятой и определенным абсолютным значением. Если разность меньше или равна этому абсолютному значению, числа равны. Если оно больше, числа не равны. Одним из способов сделать это является произвольное выделение абсолютного значения. Однако это проблематично, поскольку приемлемое поле разности зависит от величины <xref:System.Single> значений. Второй способ использует преимущества функции проектирования в формате с плавающей запятой: разница между компонентами мантисса в целочисленных представлениях двух значений с плавающей запятой указывает количество возможных значений с плавающей запятой, которые разделяют два значения. Например, разница между 0,0 и <xref:System.Single.Epsilon> равна 1, поскольку <xref:System.Single.Epsilon> является наименьшим значением, которое может быть представлено при работе с <xref:System.Single>, значение которого равно нулю. В следующем примере этот метод используется для сравнения значений. 33333 и 1/3, которые являются двумя <xref:System.Double> значениями, которые в предыдущем примере кода с <xref:System.Single.Equals%28System.Single%29>ным методом не совпадают. Обратите внимание, что в примере используются методы <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> и <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> для преобразования значения с плавающей запятой одиночной точности в целочисленное представление.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 Точность чисел с плавающей запятой, превышающих задокументированную точность, зависит от реализации и версии .NET Framework. Следовательно, сравнение двух чисел может привести к различным результатам в зависимости от версии .NET Framework, так как точность внутреннего представления чисел может измениться.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Разрешение перегрузки компилятора может учитывать очевидную разницу в поведении двух перегрузок метода <see cref="M:System.Single.Equals(System.Object)" />. Если неявное преобразование между аргументом <paramref name="obj" /> и <see cref="T:System.Single" /> определено и аргумент не типизирован как <see cref="T:System.Object" />, компиляторы могут выполнить неявное преобразование и вызвать метод <see cref="M:System.Single.Equals(System.Single)" />. В противном случае они вызывают метод <see cref="M:System.Single.Equals(System.Object)" />, который всегда возвращает <see langword="false" />, если его <paramref name="obj" /> аргумент не является <see cref="T:System.Single" /> значением. В следующем примере показано различие в поведении между двумя перегрузками метода. В случае всех примитивных числовых типов, кроме <see cref="T:System.Double" /> в Visual Basic и за исключением <see cref="T:System.Decimal" /> и <see cref="T:System.Double" /> в C#, первое сравнение возвращает <see langword="true" />, так как компилятор автоматически выполняет расширяющее преобразование и вызывает <see cref="M:System.Single.Equals(System.Single)" /> , в то время как второе сравнение возвращает <see langword="false" />, так как компилятор вызывает метод <see cref="M:System.Single.Equals(System.Object)" />.  
  
[! код-CSharp[System. Single. Equals # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! код-VB[System. Single. Equals # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="single.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код данного экземпляра.</summary>
        <returns>Хэш-код в виде 32-битовым целым числом со знаком.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="single.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.TypeCode" /> для типа значения <see cref="T:System.Single" />.</summary>
        <returns>Константа перечислимого типа, <see cref="F:System.TypeCode.Single" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberSignature Language="F#" Value="static member IsFinite : single -&gt; bool" Usage="System.single.IsFinite f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Определяет, является ли указанное значение конечным (нулевым, поднормальным или нормальным).</summary>
        <returns>Значение <see langword="true" />, если указанное значение является конечным (нулевым, поднормальным или нормальным); в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : single -&gt; bool" Usage="System.single.IsInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Возвращает значение, позволяющее определить, равно ли данное число плюс или минус бесконечности.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="f" /> равен значению <see cref="F:System.Single.PositiveInfinity" /> или <see cref="F:System.Single.NegativeInfinity" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой возвращают <xref:System.Single.PositiveInfinity> или <xref:System.Single.NegativeInfinity>, чтобы сообщить о состоянии переполнения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется метод <xref:System.Single.IsInfinity%2A>.  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberSignature Language="F#" Value="static member IsNaN : single -&gt; bool" Usage="System.single.IsNaN f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Возвращает значение, показывающее, что указанное значение не является числом (<see cref="F:System.Single.NaN" />).</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="f" /> относится к нечисловому типу (<see cref="F:System.Single.NaN" />); в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой возвращают <xref:System.Single.NaN> для сигнализации о том, что результат операции не определен. Например, деление 0,0 на 0,0 приводит к <xref:System.Single.NaN>.  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A> возвращает `false`, если <xref:System.Single> значение <xref:System.Single.PositiveInfinity> или <xref:System.Single.NegativeInfinity>. Чтобы проверить эти значения, используйте методы <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>и <xref:System.Single.IsNegativeInfinity%2A>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется метод <xref:System.Single.IsNaN%2A>.  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegative : single -&gt; bool" Usage="System.single.IsNegative f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Определяет, является ли заданное значение отрицательным.</summary>
        <returns>Значение <see langword="true" />, если отрицательное; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : single -&gt; bool" Usage="System.single.IsNegativeInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Возвращает значение, позволяющее определить, равно ли данное число минус бесконечности.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="f" /> равно значению <see cref="F:System.Single.NegativeInfinity" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой возвращают <xref:System.Single.NegativeInfinity>, чтобы сообщить о состоянии переполнения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется метод <xref:System.Single.IsNegativeInfinity%2A>.  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsNormal : single -&gt; bool" Usage="System.single.IsNormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Определяет, является ли заданное значение нормальным.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="f" /> является нормальным; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : single -&gt; bool" Usage="System.single.IsPositiveInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Возвращает значение, показывающее, равно ли данное число плюс бесконечности.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="f" /> равно значению <see cref="F:System.Single.PositiveInfinity" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой возвращают <xref:System.Single.PositiveInfinity>, чтобы сообщить о состоянии переполнения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется метод <xref:System.Single.IsPositiveInfinity%2A>.  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : single -&gt; bool" Usage="System.single.IsSubnormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Определяет, является ли заданное значение поднормальным.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="f" /> является поднормальным; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : single" Usage="System.single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>Представляет наибольшее возможное значение типа <see cref="T:System.Single" />. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы является положительным 3.40282347 E + 38.  
  
 Результат операции, которая превышает <xref:System.Single.MaxValue?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>. В следующем примере <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> результаты операций сложения, умножения и возведения в степень, когда результат превысит <xref:System.Single.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 В следующем примере кода показана <xref:System.Single.MaxValue> константа.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : single" Usage="System.single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>Представляет минимально допустимое значение типа <see cref="T:System.Single" />. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы отрицательно 3.402823 E38.  
  
 Результатом операции, которая меньше <xref:System.Single.MinValue?displayProperty=nameWithType>, является <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. В следующем примере <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> результаты операций вычитания и умножения, если результат меньше <xref:System.Single.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 В следующем примере кода показана <xref:System.Single.MinValue> константа.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : single" Usage="System.single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Представляет нечисловое значение (<see langword="NaN" />). Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод или оператор возвращает <xref:System.Single.NaN>, если результат операции не определен. Например, результат деления нуля на ноль <xref:System.Single.NaN>, как показано в следующем примере. (Однако обратите внимание, что деление ненулевого числа на ноль возвращает либо <xref:System.Single.PositiveInfinity>, либо <xref:System.Single.NegativeInfinity>в зависимости от знака делителя.)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 Кроме того, вызов метода со значением <xref:System.Single.NaN> или операцией с <xref:System.Single.NaN> значением возвращает <xref:System.Single.NaN>, как показано в следующем примере.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 Используйте метод <xref:System.Single.IsNaN%2A>, чтобы определить, является ли значение нечисловым. В общем случае <xref:System.Single> операторы нельзя использовать для сравнения <xref:System.Single.NaN?displayProperty=nameWithType> с другими значениями <xref:System.Single>, хотя методы сравнения (такие как <xref:System.Single.Equals%2A> и <xref:System.Single.CompareTo%2A>) могут быть. В следующем примере показано различие в поведении между операторами сравнения <xref:System.Single> и методами.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 В следующем примере показана <xref:System.Single.NaN> константа.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : single" Usage="System.single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Представляет минус бесконечность. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы является результатом деления отрицательного числа на ноль.  
  
 Эта константа возвращается, если результат операции меньше <xref:System.Single.MinValue>.  
  
 Используйте <xref:System.Single.IsNegativeInfinity%2A>, чтобы определить, является ли значение отрицательной бесконечностью.  
  
   
  
## Examples  
 В следующем примере кода показана <xref:System.Single.NegativeInfinity> константа.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : single * single -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, равны ли два заданных значения <see cref="T:System.Single" />.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> равны; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Single.op_Equality%2A> определяет оператор равенства для <xref:System.Single> значений.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : single * single -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Single" /> больше другого заданного значения <see cref="T:System.Single" />.</summary>
        <returns><see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Single.op_GreaterThan%2A> определяет операцию оператора "больше чем" для <xref:System.Single> значений.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : single * single -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Single" /> больше или равно другому заданному значению <see cref="T:System.Single" />.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> больше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Single.op_GreaterThanOrEqual%2A> определяет операцию оператора "больше или равно" для <xref:System.Single> значений.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : single * single -&gt; bool" Usage="System.single.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, не равны ли два заданных значения <see cref="T:System.Single" />.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> не равны друг другу; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Single.op_Inequality%2A> определяет оператор неравенства для <xref:System.Single> значений.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : single * single -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Single" /> меньше другого заданного значения <see cref="T:System.Single" />.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше значения <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Single.op_LessThan%2A> определяет операцию оператора "меньше чем" для <xref:System.Single> значений.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : single * single -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Single" /> меньше или равно другому заданному значению <see cref="T:System.Single" />.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Single.op_LessThanOrEqual%2A> определяет операцию оператора "меньше или равно" для <xref:System.Single> значений.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует строковое представление числа в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; single" Usage="System.single.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <summary>Преобразует строковое представление числа в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `s` может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>или строку в формате текущего языка и региональных параметров:  
  
 [*WS*] [*Sign*] [*целочисленные цифры*[*,*]] *целочисленные цифры*[*.* [*дробные цифры*]] [e [*знак*]*экспоненциальные цифры*] [*WS*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Последовательность символов пробела.|  
|*sign*|Знак отрицательного знака или знак плюс. Допустимые знаки знака определяются <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> свойствами текущего языка и региональных параметров. Можно использовать только ведущий знак.|  
|*целые числа*|Последовательность цифр от 0 до 9, указывающих целую часть числа. Выполнение *целочисленных цифр* может быть разделено символом разделителя групп. Например, в некоторых культурах запятая (,) разделяет группы тысяч. Элемент с *целочисленными цифрами* может отсутствовать, если строка содержит элемент *дробной разрядности* .|  
|*,*|Символ разделителя тысяч, зависящий от языка и региональных параметров.|  
|*.*|Символ десятичной запятой, зависящий от языка и региональных параметров.|  
|*Дробные разряды*|Последовательность цифр от 0 до 9, которая указывает дробную часть числа.|  
|E|Символ "e" или "E", указывающий, что значение представлено в экспоненциальной (экспоненциальной) нотации.|  
|*экспоненциальные цифры*|Последовательность цифр от 0 до 9, указывающая показатель степени.|  
  
 Параметр `s` интерпретируется с помощью сочетания флагов <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> и <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>. Это означает, что пробелы и разделители групп разрядов разрешены, а символы валют — нет. Чтобы явно определить элементы (например, символы валют, разделители тысяч и пробелы), которые могут присутствовать в `s`, используйте перегрузку метода <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>.  
  
 Параметр `s` анализируется с помощью сведений о форматировании в объекте <xref:System.Globalization.NumberFormatInfo>, который инициализируется для текущего языка и региональных параметров системы. Для получения дополнительной информации см. <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Чтобы выполнить синтаксический анализ строки с использованием сведений о форматировании конкретного языка и региональных параметров, используйте метод <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> или <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>.  
  
Обычно при передаче метода <xref:System.Single.Parse%2A> строку, созданную путем вызова метода <xref:System.Single.ToString%2A>, возвращается исходное значение <xref:System.Single>. Однако из-за потери точности значения могут не совпадать.  

Если `s` выходит за пределы диапазона <xref:System.Single> типа данных, метод создает <xref:System.OverflowException> в .NET Framework и .NET Core 2,2 и более ранних версиях. В .NET Core 3,0 и более поздних версиях он возвращает <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, если `s` меньше, чем <xref:System.Single.MinValue?displayProperty=nameWithType>, и <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, если `s` больше <xref:System.Single.MaxValue?displayProperty=nameWithType>.

Если в параметре `s` в ходе операции синтаксического анализа встречается разделитель, а применимые разделители денежных единиц или десятичного числа и групп совпадают, то операция синтаксического анализа предполагает, что разделитель является десятичным разделителем, а не разделителем групп. Дополнительные сведения о разделителях см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
## Examples  
 В следующем примере используется метод <xref:System.Single.Parse%28System.String%29> для преобразования массива строк в эквивалентные <xref:System.Single> значения.  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> не представляет число в допустимом формате.</exception>
        <exception cref="T:System.OverflowException">Только .NET Framework и .NET Core 2.2 и более ранние версии: <paramref name="s" /> представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Синтаксический анализ числовых строк в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; single" Usage="System.single.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="style">Побитовое сочетание значений перечисления, обозначающих элементы стиля, которые могут быть представлены в параметре <paramref name="s" />. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Преобразует строковое представление числа в указанном стиле в эквивалентное ему число одиночной точности с плавающей запятой.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `style` определяет элементы стиля (такие как пробелы, разделители групп разрядов и символы валют), допустимые в параметре `s` для выполнения операции синтаксического анализа. Он должен представлять собой сочетание битовых флагов из перечисления <xref:System.Globalization.NumberStyles>. Следующие элементы <xref:System.Globalization.NumberStyles> не поддерживаются:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Параметр `s` может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>текущего языка и региональных параметров. В зависимости от значения `style`оно также может принимать форму:  
  
 [*WS*] [*$*] [*Sign*] [*целочисленные цифры*[*,*]] *целочисленные цифры*[*.* [*дробные цифры*]] [E [*знак*]*экспоненциальные цифры*] [*WS*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
 *ws*  
 Последовательность пробельных символов. Пробелы могут присутствовать в начале `s` если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> и может находиться в конце `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.  
  
 $  
 Символ валюты, зависящий от языка и региональных параметров. Его расположение в строке определяется свойствами <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> текущего языка и региональных параметров. Символ валюты текущего языка и региональных параметров может отображаться в `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>.  
  
 *sign*  
 Знак отрицательного знака (-) или знак плюс (+). Знак может располагаться в начале `s` если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> и может находиться в конце `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>. Круглые скобки можно использовать в `s`, чтобы указать отрицательное значение, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>.  
  
 *целые числа*  
 Последовательность цифр от 0 до 9, указывающих целую часть числа. Элемент с *целочисленными цифрами* может отсутствовать, если строка содержит элемент *дробной разрядности* .  
  
 ,  
 Разделитель групп, зависящий от языка и региональных параметров. Символ разделителя групп текущего языка и региональных параметров может отображаться в `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>  
  
 .  
 Символ десятичной запятой, зависящий от языка и региональных параметров. Символ десятичной запятой текущего языка и региональных параметров может присутствовать в `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>.  
  
 *Дробные разряды*  
 Последовательность цифр от 0 до 9, которая указывает дробную часть числа. Дробные цифры могут присутствовать в `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>.  
  
 E  
 Символ "e" или "E", указывающий, что значение представлено в экспоненциальной (экспоненциальной) нотации. Параметр `value` может представлять число в экспоненциальной нотации, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>.  
  
 *экспоненциальные цифры*  
 Последовательность цифр от 0 до 9, указывающая показатель степени.  
  
> [!NOTE]
> Все завершающие символы NUL (U + 0000) в `s` игнорируются операцией синтаксического анализа независимо от значения аргумента `style`.

 Строка с цифрами (которая соответствует стилю <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>) всегда будет успешно проанализирована, если она находится в диапазоне типа <xref:System.Single>. Остальные <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> элементы управления, которые могут присутствовать, но не обязательно должны присутствовать, во входной строке. В следующей таблице показано, как отдельные флаги <xref:System.Globalization.NumberStyles> влияют на элементы, которые могут присутствовать в `s`.  
  
|Значение NumberStyles|Элементы, разрешенные в `s` в дополнение к цифрам|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Только элемент с *целыми цифрами* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Элементы десятичной запятой (*.*) и *дробные разряды* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Символ "e" или "E", который указывает на экспоненциальную нотацию. Этот флаг сам по себе поддерживает значения в виде *цифр*E*цифр*. Дополнительные флаги необходимы для успешного анализа строк с такими элементами, как знаки плюса или минуса и символы десятичной запятой.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Элемент *WS* в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Элемент *WS* в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Элемент *Sign* в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Элемент *Sign* в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Элемент *Sign* в виде круглых скобок, охватывающих числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Элемент разделителя тысяч (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Элемент Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Все элементы. Однако `s` не может представлять шестнадцатеричное число или число в экспоненциальной нотации.|  
|<xref:System.Globalization.NumberStyles.Float>|Элемент *WS* в начале или конце `s`, *знак* в начале `s`и символ десятичной запятой (.). Параметр `s` может также использовать экспоненциальную нотацию.|  
|<xref:System.Globalization.NumberStyles.Number>|Элементы `ws`, `sign`, разделителей тысяч (,) и десятичной запятой (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Все элементы. Однако `s` не может представлять шестнадцатеричное число.|  
  
 Некоторые примеры `s`: "100", "-123 456 789", "123,45 e + 6", "+ 500", "5e2", "3,1416", "600.", "-. 123" и "-Infinity".  
  
 Параметр `s` анализируется с помощью сведений о форматировании в объекте <xref:System.Globalization.NumberFormatInfo>, который инициализируется для текущего языка и региональных параметров системы. Чтобы указать язык и региональные параметры, сведения о форматировании которых используются для операции синтаксического анализа, вызовите перегрузку <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>.  
  
 Обычно при передаче метода <xref:System.Single.Parse%2A> строку, созданную путем вызова метода <xref:System.Single.ToString%2A>, возвращается исходное значение <xref:System.Single>. Однако из-за потери точности значения могут не совпадать.  

Если `s` выходит за пределы диапазона <xref:System.Single> типа данных, метод создает <xref:System.OverflowException> в .NET Framework и .NET Core 2,2 и более ранних версиях. В .NET Core 3,0 и более поздних версиях он возвращает <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, если `s` меньше, чем <xref:System.Single.MinValue?displayProperty=nameWithType>, и <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, если `s` больше <xref:System.Single.MaxValue?displayProperty=nameWithType>.

Если в параметре `s` в ходе операции синтаксического анализа встречается разделитель, а применимые разделители денежных единиц или десятичного числа и групп совпадают, то операция синтаксического анализа предполагает, что разделитель является десятичным разделителем, а не разделителем групп. Дополнительные сведения о разделителях см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  

## Examples  
 В следующем примере используется метод <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> для анализа строкового представления значений <xref:System.Single>. В примере используются сведения о форматировании для языка и региональных параметров en-US.  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> не является числом в допустимом формате.</exception>
        <exception cref="T:System.OverflowException">.NET Framework и .NET Core 2.2 и более ранние версии: <paramref name="s" /> представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  
  
- или - 
 <paramref name="style" /> включает значение <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Синтаксический анализ числовых строк в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; single" Usage="System.single.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <paramref name="s" /> в зависимости от языка и региональных параметров.</param>
        <summary>Преобразует строковое представление числа, записанное в формате, соответствующем определенному языку и региональным параметрам, в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка обычно используется для преобразования текста, который может быть отформатирован различными способами, в значение <xref:System.Single>. Например, можно использовать для преобразования текста, вводимых пользователем, в текстовое поле HTML в числовое значение.  
  
 Параметр `s` интерпретируется с помощью сочетания флагов <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> и <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>. Параметр `s` может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>или <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> для языка и региональных параметров, заданных параметром `provider`, или может содержать строку в формате:  
  
 [*WS*] [*Sign*] *целочисленные цифры*[*.* [*дробные цифры*]] [E [*знак*]*экспоненциальные цифры*] [*WS*]  
  
 Необязательные элементы заключены в квадратные скобки ([и]). Элементы, содержащие термин "цифры", состоят из ряда числовых символов в диапазоне от 0 до 9.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Последовательность пробельных символов.|  
|*sign*|Знак отрицательного знака (-) или знак плюс (+).|  
|*целые числа*|Последовательность цифр от 0 до 9, указывающих целую часть числа. Выполнение *целочисленных цифр* может быть разделено символом разделителя групп. Например, в некоторых культурах запятая (,) разделяет группы тысяч. Элемент с *целочисленными цифрами* может отсутствовать, если строка содержит элемент *дробной разрядности* .|  
|.|Символ десятичной запятой, зависящий от языка и региональных параметров.|  
|*Дробные разряды*|Последовательность цифр от 0 до 9, которая указывает дробную часть числа.|  
|E|Символ "e" или "E", указывающий, что значение представлено в экспоненциальной (экспоненциальной) нотации.|  
|*экспоненциальные цифры*|Последовательность цифр от 0 до 9, указывающая показатель степени.|  
  
 Дополнительные сведения о числовых форматах см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md) .  
  
 Параметр `provider` является реализацией <xref:System.IFormatProvider>, метод <xref:System.IFormatProvider.GetFormat%2A> возвращает объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами. При вызове метода <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> вызывается метод <xref:System.IFormatProvider.GetFormat%2A> параметра `provider` и передает ему объект <xref:System.Type>, представляющий тип <xref:System.Globalization.NumberFormatInfo>. Затем метод <xref:System.IFormatProvider.GetFormat%2A> возвращает объект <xref:System.Globalization.NumberFormatInfo>, который предоставляет сведения о формате параметра `s`. Существует три способа использования параметра `provider` для предоставления сведений о пользовательском форматировании операции синтаксического анализа:  
  
-   Можно передать объект <xref:System.Globalization.CultureInfo>, представляющий язык и региональные параметры, которые предоставляют сведения о форматировании. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> метод возвращает объект <xref:System.Globalization.NumberFormatInfo>, который предоставляет сведения о форматировании числовых значений для этого языка и региональных параметров.  
  
-   Можно передать фактический объект <xref:System.Globalization.NumberFormatInfo>, который предоставляет сведения о форматировании чисел. (Его реализация <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам себя.)  
  
-   Можно передать пользовательский объект, реализующий <xref:System.IFormatProvider>. Его <xref:System.IFormatProvider.GetFormat%2A> метод создает экземпляр и возвращает объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения о форматировании.  
  
 Если `provider` имеет `null` или не удается получить <xref:System.Globalization.NumberFormatInfo>, используется информация о форматировании для текущего языка и региональных параметров системы.  

Если `s` выходит за пределы диапазона <xref:System.Single> типа данных, метод создает <xref:System.OverflowException> в .NET Framework и .NET Core 2,2 и более ранних версиях. В .NET Core 3,0 и более поздних версиях он возвращает <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, если `s` меньше, чем <xref:System.Single.MinValue?displayProperty=nameWithType>, и <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, если `s` больше <xref:System.Single.MaxValue?displayProperty=nameWithType>. 

Если в параметре `s` в ходе операции синтаксического анализа встречается разделитель, а применимые разделители денежных единиц или десятичного числа и групп совпадают, то операция синтаксического анализа предполагает, что разделитель является десятичным разделителем, а не разделителем групп. Дополнительные сведения о разделителях см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
Некоторые примеры `s`: "100", "-123 456 789", "123,45 e + 6", "+ 500", "5e2", "3,1416", "600.", "-. 123" и "-Infinity".  

## Examples  
 В следующем примере показан обработчик событий нажатия кнопки в веб-форме. Для определения языкового стандарта пользователя используется массив, возвращенный свойством <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType>. Затем он создает объект <xref:System.Globalization.CultureInfo>, соответствующий этому языку. Объект <xref:System.Globalization.NumberFormatInfo>, принадлежащий этому объекту <xref:System.Globalization.CultureInfo>, затем передается методу <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> для преобразования входных данных пользователя в значение <xref:System.Single>.  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> не представляет число в допустимом формате.</exception>
        <exception cref="T:System.OverflowException">Только .NET Framework и .NET Core 2.2 и более ранние версии: <paramref name="s" /> представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Синтаксический анализ числовых строк в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Single" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">Диапазон символов, содержащий преобразуемое число.</param>
        <param name="style">Побитовое сочетание значений перечисления, обозначающих элементы стиля, которые могут присутствовать в параметре <paramref name="s" />.  Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <paramref name="s" /> в зависимости от языка и региональных параметров.</param>
        <summary>Преобразует диапазон символов, содержащий строковое представление числа в указанном стиле и с использованием формата, соответствующего данному языку и региональным параметрам, в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

Если `s` выходит за пределы диапазона <xref:System.Single> типа данных, метод возвращает <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, если `s` меньше <xref:System.Single.MinValue?displayProperty=nameWithType> и <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> если `s` больше <xref:System.Single.MaxValue?displayProperty=nameWithType>.

         ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Параметр <paramref name="s" /> не представляет числовое значение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  
  
- или - 
<paramref name="style" /> является значением <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="style">Побитовое сочетание значений перечисления, обозначающих элементы стиля, которые могут быть представлены в параметре <paramref name="s" />. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <paramref name="s" /> в зависимости от языка и региональных параметров.</param>
        <summary>Преобразует строковое представление числа в указанном стиле и с использованием формата, соответствующего данному языку и региональным параметрам, в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `style` определяет элементы стиля (такие как пробелы, разделители групп разрядов и символы валют), допустимые в параметре `s` для выполнения операции синтаксического анализа. Он должен представлять собой сочетание битовых флагов из перечисления <xref:System.Globalization.NumberStyles>. Следующие элементы <xref:System.Globalization.NumberStyles> не поддерживаются:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Параметр `s` может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>или <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> для языка и региональных параметров, заданных `provider`. В зависимости от значения `style`оно также может принимать форму:  
  
 [*WS*] [*$*] [*Sign*] [*целые числа*] *целочисленные цифры*[. [ *дробные цифры*]] [E [*знак*]*экспоненциальные цифры*] [*WS*]  
  
 Элементы, заключенные в квадратные скобки ([и]), являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Последовательность пробельных символов. Пробелы могут присутствовать в начале `s` если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> и может находиться в конце `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.|  
|$|Символ валюты, зависящий от языка и региональных параметров. Его расположение в строке определяется свойствами <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> текущего языка и региональных параметров. Символ валюты текущего языка и региональных параметров может отображаться в `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>.|  
|*sign*|Знак отрицательного знака (-) или знак плюс (+). Знак может располагаться в начале `s` если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> и может находиться в конце `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>. Круглые скобки можно использовать в `s`, чтобы указать отрицательное значение, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>.|  
|*целые числа*|Последовательность цифр от 0 до 9, указывающих целую часть числа. Элемент с *целочисленными цифрами* может отсутствовать, если строка содержит элемент *дробной разрядности* .|  
|,|Разделитель групп, зависящий от языка и региональных параметров. Символ разделителя групп текущего языка и региональных параметров может отображаться в `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>|  
|.|Символ десятичной запятой, зависящий от языка и региональных параметров. Символ десятичной запятой текущего языка и региональных параметров может присутствовать в `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>.|  
|*Дробные разряды*|Последовательность цифр от 0 до 9, которая указывает дробную часть числа. Дробные цифры могут присутствовать в `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>.|  
|E|Символ "e" или "E", указывающий, что значение представлено в экспоненциальной (экспоненциальной) нотации. Параметр `s` может представлять число в экспоненциальной нотации, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>.|  
|*экспоненциальные цифры*|Последовательность цифр от 0 до 9, указывающая показатель степени.|  
  
> [!NOTE]
> Все завершающие символы NUL (U + 0000) в `s` игнорируются операцией синтаксического анализа независимо от значения аргумента `style`.

 Строка с цифрами (которая соответствует стилю <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>) всегда будет успешно проанализирована, если она находится в диапазоне типа <xref:System.Single>. Остальные <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> элементы управления, которые могут присутствовать, но не обязательно должны присутствовать, во входной строке. В следующей таблице показано, как отдельные флаги <xref:System.Globalization.NumberStyles> влияют на элементы, которые могут присутствовать в `s`.  
  
|Значение NumberStyles|Элементы, разрешенные в `s` в дополнение к цифрам|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Только элемент с *целыми цифрами* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Элементы десятичной запятой (*.*) и *дробные разряды* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Символ "e" или "E", который указывает на экспоненциальную нотацию. Этот флаг сам по себе поддерживает значения в виде *цифр*E*цифр*. Дополнительные флаги необходимы для успешного анализа строк с такими элементами, как знаки плюса или минуса и символы десятичной запятой.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Элемент *WS* в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Элемент *WS* в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Элемент *Sign* в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Элемент *Sign* в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Элемент *Sign* в виде круглых скобок, охватывающих числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Элемент разделителя тысяч (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Элемент Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Все элементы. Однако `s` не может представлять шестнадцатеричное число или число в экспоненциальной нотации.|  
|<xref:System.Globalization.NumberStyles.Float>|Элемент *WS* в начале или конце `s`, *знак* в начале `s`и символ десятичной запятой (.). Параметр `s` может также использовать экспоненциальную нотацию.|  
|<xref:System.Globalization.NumberStyles.Number>|Элементы `ws`, `sign`, разделителей тысяч (,) и десятичной запятой (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Все элементы. Однако `s` не может представлять шестнадцатеричное число.|  
  
 Параметр `provider` является реализацией <xref:System.IFormatProvider>. Его <xref:System.IFormatProvider.GetFormat%2A> метод возвращает объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения о формате `value`в зависимости от языка и региональных параметров. Как правило, `provider` может быть одним из следующих:  
  
-   Объект <xref:System.Globalization.CultureInfo>, представляющий язык и региональные параметры, которые предоставляют сведения о форматировании чисел. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> метод возвращает объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения о форматировании чисел.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения о форматировании. (Его реализация <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам себя.)  
  
-   Пользовательский объект, реализующий <xref:System.IFormatProvider> и использующий метод <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> для создания экземпляра и возврата объекта <xref:System.Globalization.NumberFormatInfo>, предоставляющего сведения о форматировании.  
  
Если `provider` `null`, используется объект <xref:System.Globalization.NumberFormatInfo> для текущего языка и региональных параметров.  

Если `s` выходит за пределы диапазона <xref:System.Single> типа данных, метод создает <xref:System.OverflowException> в .NET Framework и .NET Core 2,2 и более ранних версиях. В .NET Core 3,0 и более поздних версиях он возвращает <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, если `s` меньше, чем <xref:System.Single.MinValue?displayProperty=nameWithType>, и <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, если `s` больше <xref:System.Single.MaxValue?displayProperty=nameWithType>.

Если в параметре `s` в ходе операции синтаксического анализа встречается разделитель, а применимые разделители денежных единиц или десятичного числа и групп совпадают, то операция синтаксического анализа предполагает, что разделитель является десятичным разделителем, а не разделителем групп. Дополнительные сведения о разделителях см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  

## Examples  
 В следующем примере кода используется метод <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> для анализа строковых представлений значений <xref:System.Single>. Каждая строка в массиве анализируется с помощью соглашений о форматировании en-US, nl-NL и пользовательского языка и региональных параметров. Пользовательский язык и региональные параметры определяют символ разделителя группы в качестве символа подчеркивания ("_") и размера группы как два.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Параметр <paramref name="s" /> не представляет числовое значение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  
  
- или - 
 <paramref name="style" /> является значением <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException">.NET Framework и .NET Core 2.2 и более ранние версии: <paramref name="s" /> представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Синтаксический анализ числовых строк в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : single" Usage="System.single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Представляет плюс бесконечность. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы является результатом деления положительного числа на ноль.  
  
 Эта константа возвращается, если результат операции больше <xref:System.Single.MaxValue>.  
  
 Используйте <xref:System.Single.IsPositiveInfinity%2A>, чтобы определить, является ли значение положительным бесконечностью.  
  
   
  
## Examples  
 В следующем примере кода показана <xref:System.Single.PositiveInfinity> константа.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" />, если значение текущего экземпляра не равно нулю; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Данное преобразование не поддерживается. При попытке использовать этот метод выбрасывается исключение <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Данное преобразование не поддерживается. Возвращаемое значение отсутствует.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Во всех случаях.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Данное преобразование не поддерживается. При попытке использовать этот метод выбрасывается исключение <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Данное преобразование не поддерживается. Возвращаемое значение отсутствует.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Во всех случаях.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, не измененное.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип, к которому необходимо привести это значение <see cref="T:System.Single" />.</param>
        <param name="provider">Объект, предоставляющий сведения о формате возвращаемого значения.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется вызывать метод `static` (`Shared` в Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразовывает числовое значение данного экземпляра в эквивалентное ему строковое представление.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="single.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразовывает числовое значение данного экземпляра в эквивалентное ему строковое представление.</summary>
        <returns>Строковое представление значения этого экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Single.ToString> форматирует значение <xref:System.Single> в формате по умолчанию ("G" или "общий") текущего языка и региональных параметров. Если необходимо указать другой формат или язык и региональные параметры, используйте другие перегрузки метода <xref:System.Single.ToString%2A> следующим образом:  
  
|Использование формата|Для языка и региональных параметров|Использование перегрузки|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию ("G")|Конкретный язык и региональные параметры|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Конкретный формат|Культура по умолчанию (текущий)|<xref:System.Single.ToString%28System.String%29>|  
|Конкретный формат|Конкретный язык и региональные параметры|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>или строкой формы:  
  
 [знак] целочисленные цифры [. [ дробные цифры]] [e [знак] экспоненциальные цифры]  
  
 Необязательные элементы заключены в квадратные скобки ([и]). Элементы, содержащие термин "цифры", состоят из ряда числовых символов в диапазоне от 0 до 9. В следующей таблице перечислены все элементы.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*sign*|Знак отрицательного или положительного знака.|  
|*целые числа*|Последовательность цифр, указывающих целую часть числа. Целочисленные цифры могут отсутствовать, если есть дробные разряды.|  
|'.'|Символ десятичной запятой, зависящий от языка и региональных параметров.|  
|*Дробные разряды*|Последовательность цифр, указывающая дробную часть числа.|  
|&|Символ нижнего регистра "e", указывающий экспоненциальную (экспоненциальную) нотацию.|  
|*экспоненциальные цифры*|Последовательность цифр, указывающая показатель степени.|  
  
 Примеры возвращаемых значений: "100", "-123 456 789", "123,45 e + 6", "500", "3,1416", "600", "-0,123" и "-Infinity".  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования:  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Single.ToString%2A?displayProperty=nameWithType> по умолчанию для отображения строкового представления числа <xref:System.Single> значений.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 В следующем примере кода показано использование метода <xref:System.Single.Parse%28System.String%29> вместе с методом <xref:System.Single.ToString>.  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="single.ToString provider" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <summary>Преобразует числовое значение данного экземпляра в эквивалентное ему строковое представление с использованием указанных сведений об особенностях форматирования для данного языка и региональных параметров.</summary>
        <returns>Строковое представление значения данного экземпляра, определяемое параметром <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Single.ToString%28System.IFormatProvider%29> форматирует значение <xref:System.Single> в формате по умолчанию ("G" или "общий") указанного языка и региональных параметров. Если необходимо указать другой формат или текущий язык и региональные параметры, используйте другие перегрузки метода <xref:System.Single.ToString%2A> следующим образом:  
  
|Использование формата|Для языка и региональных параметров|Использование перегрузки|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию ("G")|Культура по умолчанию (текущий)|<xref:System.Single.ToString>|  
|Конкретный формат|Культура по умолчанию (текущий)|<xref:System.Single.ToString%28System.String%29>|  
|Конкретный формат|Конкретный язык и региональные параметры|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>или строкой формы:  
  
 [знак] целочисленные цифры [. [ дробные цифры]] [e [знак] экспоненциальные цифры]  
  
 Необязательные элементы заключены в квадратные скобки ([и]). Элементы, содержащие термин "цифры", состоят из ряда числовых символов в диапазоне от 0 до 9. В следующей таблице перечислены все элементы.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|sign|Знак отрицательного или положительного знака.|  
|целые числа|Последовательность цифр, указывающих целую часть числа. Целочисленные цифры могут отсутствовать, если есть дробные разряды.|  
|'.'|Символ десятичной запятой, зависящий от языка и региональных параметров.|  
|Дробные разряды|Последовательность цифр, указывающая дробную часть числа.|  
|&|Символ нижнего регистра "e", указывающий экспоненциальную (экспоненциальную) нотацию.|  
|экспоненциальные цифры|Последовательность цифр, указывающая показатель степени.|  
  
 Примеры возвращаемых значений: "100", "-123 456 789", "123,45 e + 6", "500", "3,1416", "600", "-0,123" и "-Infinity".  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования:  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Параметр `provider` является реализацией <xref:System.IFormatProvider>, метод <xref:System.IFormatProvider.GetFormat%2A> возвращает объект <xref:System.Globalization.NumberFormatInfo>. Как правило, `provider` является объектом <xref:System.Globalization.CultureInfo> или <xref:System.Globalization.NumberFormatInfo>. Параметр `provider` предоставляет сведения о языке и региональных параметрах, используемые при форматировании. Если `provider` `null`, возвращаемое значение форматируется с использованием <xref:System.Globalization.NumberFormatInfo> данных для текущего языка и региональных параметров.  
  
 Чтобы преобразовать <xref:System.Single> значение в строковое представление с помощью указанного языка и региональных параметров и определенной строки формата, вызовите метод <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано строковое представление двух <xref:System.Single> значений с помощью <xref:System.Globalization.CultureInfo> объектов, представляющих несколько различных языков и региональных параметров.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="single.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Строка числового формата.</param>
        <summary>Преобразует числовое значение данного экземпляра в эквивалентное строковое представление с использованием указанного формата.</summary>
        <returns>Строковое представление значения данного экземпляра, определяемое параметром <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Single.ToString%28System.String%29> форматирует <xref:System.Single> значение в указанном формате с использованием правил текущего языка и региональных параметров. Если вы хотите использовать формат по умолчанию ("G" или "общий") или указать другой язык и региональные параметры, используйте другие перегрузки метода <xref:System.Single.ToString%2A> следующим образом:  
  
|Использование формата|Для языка и региональных параметров|Использование перегрузки|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию ("G")|Культура по умолчанию (текущий)|<xref:System.Single.ToString>|  
|Формат по умолчанию ("G")|Конкретный язык и региональные параметры|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Конкретный формат|Конкретный язык и региональные параметры|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>или строковым представлением значения текущего экземпляра, как указано в `format`.  
  
 Параметр `format` может быть любым допустимым описателем стандартного числового формата, за исключением D и X, а также любого сочетания настраиваемых описателей числового формата. Если параметр format имеет `null` или является пустой строкой, возвращаемое значение форматируется с помощью описателя общего числового формата ("G").  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования:  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 По умолчанию возвращаемое значение содержит только 7 цифр точности, хотя для внутренних целей поддерживается не более 9 цифр. Если значение этого экземпляра превышает 7 цифр, <xref:System.Single.ToString%28System.String%29> возвращает <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> или <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> вместо ожидаемого числа. Если требуется дополнительная точность, укажите `format` со спецификацией формата "G9", которая всегда возвращает 9 разрядов точности, или "R", который возвращает 7 цифр, если число может быть представлено только с такой точностью или 9 цифрами, если число может быть представлено только с помощью Максимальная точность.  
  
   
  
## Examples  
 В следующем примере определяется числовое значение и форматируется как денежное значение с помощью строки стандартного числового формата "C", а в качестве числового значения для трех десятичных разрядов используется строка стандартного числового формата "N". Строки результатов форматируются с помощью соглашений языка и региональных параметров en-US. Дополнительные сведения о строках числового формата см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 В следующем примере показано несколько значений <xref:System.Single>, используя каждый из поддерживаемых стандартных описателей числового формата вместе с двумя строками настраиваемого числового формата. Одна из этих строк настраиваемого формата показывает, как заполнять <xref:System.Single> значение начальными нулями. При преобразовании числовых значений в строки в примере используются соглашения о форматировании для языка и региональных параметров en-US.  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Практическое руководство. Добавление к числу начальных нулей.</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="single.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Строка числового формата.</param>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <summary>Преобразует числовое значение данного экземпляра в эквивалентное ему строковое представление с использованием указанного формата и сведений об особенностях форматирования для данного языка и региональных параметров.</summary>
        <returns>Строковое представление значения данного экземпляра, определяемое параметрами <paramref name="format" /> и <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29> форматирует значение <xref:System.Single> в указанном формате указанного языка и региональных параметров. Если вы хотите использовать формат по умолчанию или параметры языка и региональных параметров, используйте другие перегрузки метода <xref:System.Single.ToString%2A> следующим образом:  
  
|Использование формата|Для языка и региональных параметров|Использование перегрузки|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию ("G")|Культура по умолчанию (текущий)|<xref:System.Single.ToString>|  
|Формат по умолчанию ("G")|Конкретный язык и региональные параметры|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Конкретный формат|Культура по умолчанию (текущий)|<xref:System.Single.ToString%28System.String%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>или строковым представлением значения текущего экземпляра, как указано в `format`.  
  
 Параметр `format` может быть любым допустимым описателем стандартного числового формата, за исключением D и X, а также любого сочетания настраиваемых описателей числового формата. Если `format` является `null` или пустой строкой, возвращаемое значение для этого экземпляра форматируется с помощью описателя общего числового формата ("G").  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования:  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Параметр `provider` является реализацией <xref:System.IFormatProvider>, метод <xref:System.IFormatProvider.GetFormat%2A> возвращает объект <xref:System.Globalization.NumberFormatInfo>. Как правило, `provider` является объектом <xref:System.Globalization.CultureInfo> или <xref:System.Globalization.NumberFormatInfo>. Параметр `provider` предоставляет сведения о языке и региональных параметрах, используемые при форматировании. Если `provider` `null`, возвращаемое значение форматируется с помощью объекта <xref:System.Globalization.NumberFormatInfo> для текущего языка и региональных параметров.  
  
 По умолчанию возвращаемое значение содержит только 7 цифр точности, хотя для внутренних целей поддерживается не более 9 цифр. Если значение этого экземпляра превышает 7 цифр, <xref:System.Single.ToString%2A> возвращает <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> или <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> вместо ожидаемого числа. Если требуется дополнительная точность, укажите `format` со спецификацией формата "G9", которая всегда возвращает 9 разрядов точности, или "R", который возвращает 7 цифр, если число может быть представлено только с такой точностью или 9 цифрами, если число может быть представлено только с помощью Максимальная точность.  
  
   
  
## Examples  
 В следующем примере выводится <xref:System.Single> значение с использованием каждого из поддерживаемых стандартных описателей числового формата для нескольких различных языков и региональных параметров.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Практическое руководство. Добавление к числу начальных нулей.</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="single.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">При возврате из этого метода значение этого экземпляра форматируется как диапазон символов.</param>
        <param name="charsWritten">При возврате из этого метода отображается число символов, записанных в <paramref name="destination" />.</param>
        <param name="format">Диапазон, содержащий символы, представляющие стандартную или настраиваемую строку формата, которая определяет допустимый формат для <paramref name="destination" />.</param>
        <param name="provider">Необязательный объект, предоставляющий сведения о форматировании с учетом определенного языка и региональных параметров для <paramref name="destination" />.</param>
        <summary>Пытается форматировать значение текущего экземпляра числа с плавающей запятой в указанный диапазон символов.</summary>
        <returns>Значение <see langword="true" />, если форматирование выполнено успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует строковое представление числа в эквивалентное ему число с плавающей запятой одиночной точности. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <altmember cref="Overload:System.Single.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * single -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">&gt;Диапазон символов, содержащий строковое представление числа, которое нужно преобразовать.</param>
        <param name="result">&gt;При возврате этот метод содержит число одиночной точности с плавающей запятой, эквивалентное параметру <paramref name="s" />, если преобразование завершилось успешно, или ноль, если оно завершилось неудачно. Преобразование не удается выполнить, если параметр <paramref name="s" /> имеет значение <see langword="null" /> или пуст или не является числом в допустимом формате. Если <parmref name="s" /> является допустимым числом меньше <see cref="F:System.Single.MinValue" />, <paramref name="result" /> имеет значение <see cref="F:System.Single.NegativeInfinity" />. Если <parmref name="s" /> является допустимым числом больше <see cref="F:System.Single.MaxValue" />, <paramref name="result" /> имеет значение <see cref="F:System.Single.PositiveInfinity" />. Этот параметр передается неинициализированным; любое значение, первоначально предоставленное в <paramref name="result" />, будет перезаписано.</param>
        <summary>Преобразует строковое представление числа в диапазоне символов в эквивалентное ему число одиночной точности с плавающей запятой. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="s" /> успешно преобразован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * single -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Строка, представляющая преобразуемое число.</param>
        <param name="result">Когда этот метод возвращает значение, оно содержит эквивалент числового значения или символа, содержащегося в параметре <paramref name="s" />, представленный в виде числа с плавающей запятой одиночной точности, если преобразование прошло успешно, или нуль, если произошел сбой преобразования. Преобразование не удается выполнить, если параметр <paramref name="s" /> имеет значение <see langword="null" /> или <see cref="F:System.String.Empty" /> или не является числом в допустимом формате. Сбой происходит в .NET Framework и .NET Core 2.2 и более ранних версиях, если <paramref name="s" /> представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />. Этот параметр передается неинициализированным; любое значение, первоначально предоставленное в <paramref name="result" />, будет перезаписано.</param>
        <summary>Преобразует строковое представление числа в эквивалентное ему число с плавающей запятой одиночной точности. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="s" /> успешно преобразован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отличается от метода <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType>, возвращая логическое значение, которое указывает, была ли операция анализа успешной, а не возвращать проанализированное числовое значение. Это устраняет необходимость использования обработки исключений для проверки <xref:System.FormatException> в случае, если `s` недопустим и не может быть успешно проанализирован.  
  
 Параметр `s` может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (сравнение строк учитывает регистр) или строку в форме:  
  
 Протокол писать [целые числа,] целые цифры [. [ дробные цифры]] [e [знак] экспоненциальные цифры] [ws]  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Последовательность пробельных символов.|  
|*sign*|Знак отрицательного или положительного знака.|  
|*целые числа*|Последовательность числовых символов в диапазоне от 0 до 9, которые указывают целую часть числа. Целочисленные цифры могут отсутствовать, если есть дробные разряды.|  
|*,*|Символ разделителя группы, зависящий от языка и региональных параметров.|  
|*.*|Символ десятичной запятой, зависящий от языка и региональных параметров.|  
|*Дробные разряды*|Последовательность числовых символов в диапазоне от 0 до 9, которые указывают дробную часть числа.|  
|*E*|Прописная или строчная буква "e", которая указывает на экспоненциальную (экспоненциальную) нотацию.|  
|*экспоненциальные цифры*|Последовательность числовых символов в диапазоне от 0 до 9, задающих показатель степени.|  
  
 Параметр `s` интерпретируется с помощью сочетания флагов <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> и <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>. Это означает, что пробелы и разделители групп разрядов разрешены, а символы валют — нет. Чтобы явно определить элементы (например, символы валют, разделители тысяч и пробелы), которые могут присутствовать в `s`, используйте перегрузку метода <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29>.  
  
 Параметр `s` анализируется с помощью сведений о форматировании в объекте <xref:System.Globalization.NumberFormatInfo>, который инициализируется для текущего языка и региональных параметров системы. Для получения дополнительной информации см. <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Чтобы выполнить синтаксический анализ строки, используя сведения о форматировании некоторых других указанных региональных параметров, используйте перегрузку метода <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29>.  
  
 Обычно при передаче метода <xref:System.Single.TryParse%2A?displayProperty=nameWithType> строку, созданную путем вызова метода <xref:System.Single.ToString%2A?displayProperty=nameWithType>, возвращается исходное значение <xref:System.Single>. Однако из-за потери точности значения могут не совпадать.  

Если `s` выходит за пределы диапазона <xref:System.Single> типа данных, метод возвращает `false` для .NET Framework и .NET Core 2,2 и более ранних версий. В .NET Core 3,0 и более поздних версиях он возвращает <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, если `s` меньше, чем <xref:System.Single.MinValue?displayProperty=nameWithType>, и <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, если `s` больше <xref:System.Single.MaxValue?displayProperty=nameWithType>.

Если в параметре `s` в ходе операции синтаксического анализа встречается разделитель, а применимые разделители денежных единиц или десятичного числа и групп совпадают, то операция синтаксического анализа предполагает, что разделитель является десятичным разделителем, а не разделителем групп. Дополнительные сведения о разделителях см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29> для преобразования строковых представлений числовых значений в <xref:System.Single> значения. Предполагается, что en-US является текущим языком и региональными параметрами.  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Синтаксический анализ числовых строк в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * single -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">Диапазон символов только для чтения, содержащий преобразуемое число. Диапазон интерпретируется с использованием стиля, указанного в <paramref name="style" /></param>
        <param name="style">Побитовая комбинация значений перечисления, которая показывает разрешенный формат параметра <paramref name="s" />. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <paramref name="s" /> в зависимости от языка и региональных параметров.</param>
        <param name="result">Когда этот метод возвращает значение, оно содержит эквивалент числового значения или символа, содержащегося в параметре <paramref name="s" />, представленный в виде числа с плавающей запятой одиночной точности, если преобразование прошло успешно, или нуль, если произошел сбой преобразования. Преобразование завершается неудачно, если параметр <paramref name="s" /> имеет значение <see langword="null" /> или <see cref="F:System.String.Empty" />, не является значением в формате, совместимом с параметром <paramref name="style" />, представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />, либо если <paramref name="style" /> не является допустимой комбинацией перечисленных констант <see cref="T:System.Globalization.NumberStyles" />. Этот параметр передается неинициализированным; любое значение, первоначально предоставленное в <paramref name="result" />, будет перезаписано.</param>
        <summary>Преобразует представление диапазона числа в указанном стиле и с использованием формата, соответствующего данному языку и региональным параметрам, в эквивалентное ему число с плавающей запятой одиночной точности. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="s" /> успешно преобразован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * single -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Строка, представляющая преобразуемое число.</param>
        <param name="style">Побитовая комбинация значений перечисления, которая показывает разрешенный формат параметра <paramref name="s" />. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <paramref name="s" /> в зависимости от языка и региональных параметров.</param>
        <param name="result">Когда этот метод возвращает значение, оно содержит эквивалент числового значения или символа, содержащегося в параметре <paramref name="s" />, представленный в виде числа с плавающей запятой одиночной точности, если преобразование прошло успешно, или нуль, если произошел сбой преобразования. Преобразование завершается неудачно, если параметр <paramref name="s" /> имеет значение <see langword="null" /> или <see cref="F:System.String.Empty" />, не является значением в формате, совместимом с параметром <paramref name="style" /> или если <paramref name="style" /> не является допустимой комбинацией перечисленных констант <see cref="T:System.Globalization.NumberStyles" />. Сбой происходит в .NET Framework или .NET Core 2.2 и более ранних версиях, если <paramref name="s" /> представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />. Этот параметр передается неинициализированным; любое значение, первоначально предоставленное в <paramref name="result" />, будет перезаписано.</param>
        <summary>Преобразует строковое представление числа в указанном стиле и с использованием формата, соответствующего данному языку и региональным параметрам, в эквивалентное ему число с плавающей запятой одиночной точности. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="s" /> успешно преобразован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отличается от метода <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>, возвращая логическое значение, которое указывает, была ли операция анализа успешной, а не возвращать проанализированное числовое значение. Это устраняет необходимость использования обработки исключений для проверки <xref:System.FormatException> в случае, если `s` недопустим и не может быть успешно проанализирован.  
  
 Параметр `style` определяет допустимый формат параметра `s` для выполнения операции синтаксического анализа. Он должен представлять собой сочетание битовых флагов из перечисления <xref:System.Globalization.NumberStyles>. Следующие элементы <xref:System.Globalization.NumberStyles> не поддерживаются:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Параметр `s` может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A><xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> для языка и региональных параметров, указанных `provider`. Кроме того, в зависимости от значения `style`параметр `s` может включать следующие элементы:  
  
 Протокол [$] писать [целые числа,] целочисленные цифры [. дробные цифры] [e [знак] экспоненциальные цифры] [ws]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Необязательный пробел. Пробелы могут находиться в начале `s` если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>. Он может находиться в конце `s` если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.|  
|*$*|Символ валюты, зависящий от языка и региональных параметров. Его расположение в строке определяется свойствами <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> или <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> объекта <xref:System.Globalization.NumberFormatInfo>, возвращаемого методом <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> параметра `provider`. Символ валюты может отображаться в `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>.|  
|*sign*|Необязательный знак. Знак может располагаться в начале `s` если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> и может находиться в конце `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>. Круглые скобки можно использовать в `s`, чтобы указать отрицательное значение, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>.|  
|*целые числа*|Последовательность цифр от 0 до 9, указывающих целую часть числа. Целочисленные цифры могут отсутствовать, если есть дробные разряды.|  
|*,*|Символ разделителя тысяч, зависящий от языка и региональных параметров. Символ разделителя тысяч текущего языка и региональных параметров может отображаться в `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>.|  
|*.*|Символ десятичной запятой, зависящий от языка и региональных параметров. Символ десятичной запятой текущего языка и региональных параметров может присутствовать в `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>.|  
|*Дробные разряды*|Последовательность цифр от 0 до 9, которая указывает дробную часть числа. Дробные цифры могут присутствовать в `s`, если `style` включает флаг <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>.|  
|*e*|Символ e или E, указывающий, что `s` может представлять число с помощью экспоненциальной нотации. Параметр `s` может представлять число в экспоненциальной нотации, если style включает флаг <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>.|  
|*экспоненциальные цифры*|Последовательность цифр от 0 до 9, указывающая показатель степени.|  
  
> [!NOTE]
> Все завершающие символы NUL (U + 0000) в `s` игнорируются операцией синтаксического анализа независимо от значения аргумента `style`.

 Строка с цифрами (которая соответствует стилю <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>) всегда будет успешно проанализирована, если она находится в диапазоне типа <xref:System.Single>. Остальные <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> элементы управления, которые могут быть, но не обязательно присутствовать во входной строке. В следующей таблице показано, как отдельные флаги <xref:System.Globalization.NumberStyles> влияют на элементы, которые могут присутствовать в `s`.  
  
|Значение NumberStyles|Элементы, разрешенные в s в дополнение к цифрам|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Только элемент с *целыми цифрами* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Языковой элемент *.* и *дробные разрядные* элементы.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Параметр `s` может также использовать экспоненциальную нотацию. Этот флаг сам по себе поддерживает значения в виде*экспоненциальных*разрядов E- *цифр*. Дополнительные флаги необходимы для успешного анализа строк в экспоненциальной нотации с такими элементами, как положительные или отрицательные знаки и символы десятичной запятой.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Элемент *WS* в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Элемент *WS* в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Элемент *Sign* в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Элемент *Sign* в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Элемент *Sign* в виде круглых скобок, охватывающих числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Элемент *,* .|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Элемент *$* .|  
|<xref:System.Globalization.NumberStyles.Currency>|Все. Параметр `s` не может представлять шестнадцатеричное число или число в экспоненциальной нотации.|  
|<xref:System.Globalization.NumberStyles.Float>|Элемент *WS* в начале или в конце `s`, *знак* в начале `s`и *.* знак. Параметр `s` может также использовать экспоненциальную нотацию.|  
|<xref:System.Globalization.NumberStyles.Number>|Элементы `ws`, `sign`, разделителей тысяч (*,)* и десятичной запятой (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Все стили, кроме `s`, не могут представлять шестнадцатеричное число.|  
  
 Параметр `provider` является реализацией <xref:System.IFormatProvider>, метод <xref:System.IFormatProvider.GetFormat%2A> возвращает объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами. При вызове метода <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> вызывается метод <xref:System.IFormatProvider.GetFormat%2A> параметра `provider` и передает ему объект <xref:System.Type>, представляющий тип <xref:System.Globalization.NumberFormatInfo>. Затем метод <xref:System.IFormatProvider.GetFormat%2A> возвращает объект <xref:System.Globalization.NumberFormatInfo>, который предоставляет сведения о формате параметра `s`. Существует три способа использования параметра `provider` для предоставления сведений о пользовательском форматировании операции синтаксического анализа:  
  
-   Можно передать объект <xref:System.Globalization.CultureInfo>, представляющий язык и региональные параметры, которые предоставляют сведения о форматировании. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> метод возвращает объект <xref:System.Globalization.NumberFormatInfo>, который предоставляет сведения о форматировании числовых значений для этого языка и региональных параметров.  
  
-   Можно передать фактический объект <xref:System.Globalization.NumberFormatInfo>, который предоставляет сведения о форматировании чисел. (Его реализация <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам себя.)  
  
-   Можно передать пользовательский объект, реализующий <xref:System.IFormatProvider>. Его <xref:System.IFormatProvider.GetFormat%2A> метод создает экземпляр и возвращает объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения о форматировании.  
  
 Если `provider` `null`, то форматирование `s` интерпретируется на основе объекта <xref:System.Globalization.NumberFormatInfo> текущего языка и региональных параметров.  

Если `s` выходит за пределы диапазона <xref:System.Single> типа данных, метод создает <xref:System.OverflowException> в .NET Framework и .NET Core 2,2 и более ранних версиях. В .NET Core 3,0 и более поздних версиях он возвращает <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, если `s` меньше, чем <xref:System.Single.MinValue?displayProperty=nameWithType>, и <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, если `s` больше <xref:System.Single.MaxValue?displayProperty=nameWithType>.

 Если в параметре `s` в ходе операции синтаксического анализа встречается разделитель, а применимые разделители денежных единиц или десятичного числа и групп совпадают, то операция синтаксического анализа предполагает, что разделитель является десятичным разделителем, а не разделителем групп. Дополнительные сведения о разделителях см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
 
## Examples  
 В следующем примере показано использование метода <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType> для анализа строкового представления чисел, имеющих определенный стиль и отформатированных с использованием соглашений определенного языка и региональных параметров.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  
  
- или - 
 Значение параметра <paramref name="style" /> равно значению <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Синтаксический анализ числовых строк в .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
