<Type Name="Single" FullName="System.Single">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8e85f1c716db939453f4c282f59f5bee435b5009" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70372271" /></Metadata><TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет число одиночной точности с плавающей запятой.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения представляет собой 32-разрядное число с одинарной точностью и значениями от отрицательного 3.402823 E38 до положительного 3.402823 E38, а также положительного или отрицательного <xref:System.Single.NegativeInfinity>нуля, <xref:System.Single.PositiveInfinity>,, а не<xref:System.Single.NaN>числа (). <xref:System.Single> Он предназначен для представления слишком больших значений (например, расстояния между планеты или ГАЛАКСИЕС) или чрезвычайно малым (например, молекулярное масса вещества в килограммах) и часто являются неточными (например, расстояние от земли до другой солнечной системы). ). <xref:System.Single> Тип соответствует стандарту IEC 60559:1989 (IEEE 754) для бинарной арифметики с плавающей запятой.  
  
 В этом разделе:  
  
-   [Представление и точность с плавающей точкой](#Precision)  
  
-   [Проверка на равенство](#Equality)  
  
-   [Значения и исключения с плавающей запятой](#Exceptions)  
  
-   [Преобразование типов и единственная структура](#Conversion)  
  
-   [Функция вычислений с плавающей запятой](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType>предоставляет методы для сравнения экземпляров этого типа, преобразования значения экземпляра в строковое представление и преобразования строкового представления числа в экземпляр этого типа. Сведения о том, как коды спецификации формата управляют строковым представлением типов значений, см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md), [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md)и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Представление и точность с плавающей точкой  
 Тип <xref:System.Single> данных хранит значения с плавающей запятой одиночной точности в 32-разрядном двоичном формате, как показано в следующей таблице.  
  
|Отделение|Bits|  
|----------|----------|  
|Значащим или мантисса|0-22|  
|Числа|23-30|  
|Знак (0 = положительный, 1 = отрицательный)|31|  
  
 Точно так же, как десятичные дроби не могут точно представлять некоторые дробные значения (например <xref:System.Math.PI?displayProperty=nameWithType>, 1/3 или), двоичные дроби не могут представлять некоторые дробные значения. Например, 2/10, которая точно представляется в виде десятичной дроби 2, представляется в виде 0011111001001100 в виде двоичной дроби с шаблоном "1100", повторяющимся до бесконечности. В этом случае значение с плавающей запятой обеспечивает неточное представление числа, которое оно представляет. Выполнение дополнительных математических операций с исходным значением с плавающей запятой часто приводит к нехватке точности. Например, если сравнить результаты умножения 3 на 10 и добавить 3 в. 3 9 раз, вы увидите, что сложение выдает менее точный результат, так как включает восемь дополнительных операций, чем умножение. Обратите внимание, что такое нарушение четности очевидно только при отображении <xref:System.Single> двух значений с помощью [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md)R, которая при необходимости отображает все 9 знаков <xref:System.Single> точности, поддерживаемые типом.  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 Поскольку некоторые числа не могут быть представлены в виде дробных двоичных значений, числа с плавающей запятой могут быть приблизительными только вещественными числами.  
  
 Все числа с плавающей запятой имеют ограниченное число значащих цифр, что также определяет, насколько точное значение числа с плавающей запятой приблизительно равно вещественному числу. <xref:System.Single> Значение имеет длину до 7 десятичных разрядов, хотя для внутренних целей поддерживается не более 9 цифр. Это означает, что некоторые операции с плавающей запятой могут не иметь точности изменять значение с плавающей запятой. В следующем примере определяется большое значение с плавающей запятой одиночной точности, а затем к нему добавляется <xref:System.Single.Epsilon?displayProperty=nameWithType> и один квадриллион. Однако продукт слишком мал для изменения исходного значения с плавающей запятой. Его минимальная значимая цифра состоит из тысяч, в то время как наиболее значимая цифра в продукте составляет 10<sup>– 30</sup>.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 Ограниченная точность числа с плавающей запятой имеет несколько последствий:  
  
-   Два числа с плавающей запятой, которые выглядят равными для определенной точности, могут не сравниваться, так как их наименьшие значащие цифры отличаются. В следующем примере ряд чисел добавляется вместе, а их итог сравнивается с ожидаемым итогом. Хотя два значения выглядят одинаково, вызов `Equals` метода указывает, что они не являются.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     Если <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> изменить элементы форматирования в инструкции с `{0}` и `{1}` на `{0:R}` и `{1:R}` , чтобы отобразить все значащие цифры двух <xref:System.Single> значений, то ясно, что эти два значения не равны, так как потери точности во время операций сложения. В этом случае проблему можно устранить, вызвав <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> метод, чтобы <xref:System.Single> округлить значения до нужной точности перед выполнением сравнения.  
  
-   Математическая операция OR, использующая число с плавающей запятой, может не дать одинакового результата, если используется десятичное число, так как число двоичных с плавающей запятой может не совпадать с десятичным числом. Предыдущий пример демонстрирует это, отображая результат умножения 3 на 10 и добавляя 3 в. 3 9 раз.  
  
     Если точность числовых операций с дробными значениями важна, используйте <xref:System.Decimal> тип вместо <xref:System.Single> типа. Если точность числовых операций с целочисленными значениями вне диапазона <xref:System.Int64> типов или <xref:System.UInt64> важна, используйте <xref:System.Numerics.BigInteger> тип.  
  
-   Значение может не циклически передавалться, если используется число с плавающей запятой. Значение считается циклическим, если операция преобразует исходное число с плавающей запятой в другую форму, операция обратного преобразования преобразует преобразованную форму обратно в число с плавающей запятой, а окончательное число с плавающей запятой равно исходному. число с плавающей запятой. Цикл обработки может завершиться ошибкой, поскольку одна или несколько наименьших значащих цифр теряются или изменяются при преобразовании. В следующем примере три <xref:System.Single> значения преобразуются в строки и сохраняются в файле. Как видно из выходных данных, хотя значения выглядят одинаковыми, восстановленные значения не равны исходным значениям.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     В этом случае можно успешно выполнить циклический обмен значениями, используя [стандартную строку числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) "G9" для сохранения полной точности <xref:System.Single> значений, как показано в следующем примере.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single>значения имеют меньшую точность <xref:System.Double> , чем значения. Значение, которое преобразуется в эквивалентный <xref:System.Double> , <xref:System.Double> часто не равно значению из-за различий в точности. <xref:System.Single> В следующем примере результат идентичных операций деления присваивается <xref:System.Double> значению <xref:System.Single> и значению. После приведения <xref:System.Double>значенияктипу, сравнение двух значений показывает, что они не равны. <xref:System.Single>  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Чтобы избежать этой проблемы, либо используйте <xref:System.Double> тип данных вместо <xref:System.Single> <xref:System.Math.Round%2A> типа данных, либо используйте метод, чтобы оба значения имели одинаковую точность.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Проверка на равенство  
 Чтобы считаться равными, <xref:System.Single> два значения должны представлять одинаковые значения. Однако из-за различия в точности между значениями или из-за потери точности по одному или обоим значениям значения с плавающей запятой, которые должны быть идентичными, часто оказываются неравными в связи с различиями в их минимально значащих цифрах. В результате вызовы <xref:System.Single.Equals%2A> метода для определения того, равны ли два значения, или вызовы <xref:System.Single.CompareTo%2A> метода для определения связи между двумя <xref:System.Single> значениями, часто дают непредвиденные результаты. Это очевидно в следующем примере, где два <xref:System.Single> очевидных значения могут быть неравными, так как первое значение имеет 7 цифр точности, а второе значение равно 9.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 Вычисляемые значения, которые следуют разным путям кода и управляются разными способами, часто не считаются равными. В следующем примере одно <xref:System.Single> значение помещается в квадрат, а затем вычисляется квадратный корень для восстановления исходного значения. Вторая <xref:System.Single> умножается на 3,51 и в квадрате, прежде чем квадратный корень результата делится на 3,51 для восстановления исходного значения. Несмотря на то, что два значения выглядят одинаковыми, вызов <xref:System.Single.Equals%28System.Single%29> метода указывает, что они не равны. Использование строки стандартного формата "G9" для возврата результирующей строки, отображающей все значащие цифры каждого <xref:System.Single> значения, показывает, что второе значение .0000000000001 меньше первого.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 В случаях, когда вероятность потери точности может повлиять на результат сравнения, вместо вызова <xref:System.Single.Equals%2A> метода или <xref:System.Single.CompareTo%2A> можно использовать следующие методы:  
  
-   Вызовите <xref:System.Math.Round%2A?displayProperty=nameWithType> метод, чтобы убедиться, что оба значения имеют одинаковую точность. Следующий пример изменяет предыдущий пример, чтобы использовать этот подход, чтобы два дробных значения были эквивалентными.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     Обратите внимание, что проблема точности по-прежнему применяется к округлению средних значений. Дополнительные сведения см. в описании метода <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Проверка на приблизительную равенство вместо равенства. Для этого способа необходимо определить абсолютное значение, по которому два значения могут различаться, но по-прежнему быть равными, или определить относительный объем, на который меньшее значение может отличаться от большего.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType>иногда используется в качестве абсолютной меры расстояния между двумя <xref:System.Single> значениями при проверке на равенство.  Однако измеряет наименьшее возможное значение, которое можно добавить или вычесть из <xref:System.Single> , значение которого равно нулю. <xref:System.Single.Epsilon?displayProperty=nameWithType> Для большинства положительных и <xref:System.Single> отрицательных значений <xref:System.Single.Epsilon?displayProperty=nameWithType> значение слишком мало для обнаружения. Таким образом, за исключением нулевых значений, не рекомендуется использовать его в тестах на равенство.  
  
     В следующем примере используется второй подход для определения `IsApproximatelyEqual` метода, который проверяет относительное различие между двумя значениями. Он также отличается от результата вызовов `IsApproximatelyEqual` метода <xref:System.Single.Equals%28System.Single%29> и метода.  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Значения и исключения с плавающей запятой  
 Операции с значениями с плавающей запятой не создают исключения, в отличие от операций с целочисленными типами, которые создают исключения в случае недопустимых операций, таких как деление на ноль или переполнение.  Вместо этого в таких ситуациях результат операции с плавающей запятой равен нулю, плюс бесконечность, отрицательная бесконечность или не является числом (NaN):  
  
-   Если результат операции с плавающей запятой слишком мал для конечного формата, результат равен нулю. Это может произойти при умножении двух очень маленьких чисел с плавающей запятой, как показано в следующем примере.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   Если величина результата операции с плавающей запятой превышает диапазон формата назначения, результатом операции будет <xref:System.Single.PositiveInfinity> или <xref:System.Single.NegativeInfinity>, в зависимости от знака результата. Результатом <xref:System.Single.MaxValue?displayProperty=nameWithType> операции, которая переполняется, является <xref:System.Single.PositiveInfinity>, а результатом <xref:System.Single.MinValue?displayProperty=nameWithType> операции, которая переполняется, является <xref:System.Single.NegativeInfinity>, как показано в следующем примере.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity>также результаты из деления на ноль с положительным делимым и <xref:System.Single.NegativeInfinity> результатом деления на ноль с отрицательным делимым.  
  
-   Если операция с плавающей запятой является недопустимой, результатом операции будет <xref:System.Single.NaN>. Например, <xref:System.Single.NaN> результаты выполнения следующих операций:  
  
    -   Деление на ноль с делимым на ноль. Обратите внимание, что другие варианты деления на ноль приводят <xref:System.Single.NegativeInfinity>к одному <xref:System.Single.PositiveInfinity> или.  
  
    -   Любая операция с плавающей запятой с недопустимыми входными данными. Например, при попытке найти квадратный корень из отрицательного значения возвращается <xref:System.Single.NaN>значение.  
  
    -   Любая операция с аргументом, значение которого <xref:System.Single.NaN?displayProperty=nameWithType>равно.  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>Преобразования типов и единая структура  
 В <xref:System.Single> структуре не определены явные или неявные операторы преобразования. вместо этого преобразования реализуются компилятором.  
  
 В следующей таблице перечислены возможные преобразования значения других примитивных числовых типов в <xref:System.Single> значение, а также указывает, является ли преобразование расширяющим или сужающим, и может ли результат <xref:System.Single> иметь меньшую точность, чем исходное значение.  
  
|Допустимо ли преобразование из|Расширяющие и узкие|Возможная потери точности|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|Нет|  
|<xref:System.Decimal>|Widening<br /><br /> Обратите C# внимание, что требуется оператор CAST.|Да. <xref:System.Decimal>поддерживает 29 десятичных разрядов точности; <xref:System.Single> поддерживает 9.|  
|<xref:System.Double>|Сужающие значения вне диапазона преобразуются в <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> или. <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|Да. <xref:System.Double>поддерживает 17 десятичных разрядов точности; <xref:System.Single> поддерживает 9.|  
|<xref:System.Int16>|Widening|Нет|  
|<xref:System.Int32>|Widening|Да. <xref:System.Int32>поддерживает 10 десятичных разрядов точности; <xref:System.Single> поддерживает 9.|  
|<xref:System.Int64>|Widening|Да. <xref:System.Int64>поддерживает 19 десятичных разрядов точности; <xref:System.Single> поддерживает 9.|  
|<xref:System.SByte>|Widening|Нет|  
|<xref:System.UInt16>|Widening|Нет|  
|<xref:System.UInt32>|Widening|Да. <xref:System.UInt32>поддерживает 10 десятичных разрядов точности; <xref:System.Single> поддерживает 9.|  
|<xref:System.UInt64>|Widening|Да. <xref:System.Int64>поддерживает 20 десятичных разрядов точности; <xref:System.Single> поддерживает 9.|  
  
 В следующем примере минимальное или максимальное значение других примитивных числовых типов преобразуется в <xref:System.Single> значение.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 Кроме <xref:System.Double> того, <xref:System.Double.NaN?displayProperty=nameWithType> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>значения, и <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> переполняются<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>в, и соответственно. <xref:System.Single.NaN?displayProperty=nameWithType> <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>  
  
 Обратите внимание, что преобразование значения некоторых числовых типов в <xref:System.Single> значение может привести к утрате точности. Как показано в <xref:System.Decimal>примере, возможна утрата точности при преобразовании значений <xref:System.Int32>, <xref:System.Double> <xref:System.Int64> <xref:System.UInt32>,,, и <xref:System.UInt64> в <xref:System.Single> значения.  
  
 Преобразование <xref:System.Single> значения<xref:System.Double> в является расширяющим преобразованием. Преобразование может привести к утрате точности, если <xref:System.Double> тип не имеет точного представления <xref:System.Single> значения.  
  
 Преобразование <xref:System.Single> значения в значение любого типа данных-примитива, отличного от, <xref:System.Double> представляет собой понижающие преобразования и требует оператора приведения (in C#) или метода преобразования (в Visual Basic). Значения, находящиеся за пределами диапазона целевого типа данных, определяемые свойствами `MinValue` и `MaxValue` свойств целевого типа, ведут себя так, как показано в следующей таблице.  
  
|Тип результирующего значения|Результат|  
|-----------------|------------|  
|Любой целочисленный тип|<xref:System.OverflowException> Исключение, если преобразование происходит в проверяемом контексте.<br /><br /> Если преобразование происходит в непроверяемом контексте (по умолчанию в C#), операция преобразования выполняется успешно, но значение переполняется.|  
|<xref:System.Decimal>|<xref:System.OverflowException> Исключение,|  
  
 Кроме <xref:System.Single.NaN?displayProperty=nameWithType> того<xref:System.Single.PositiveInfinity?displayProperty=nameWithType> <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> ,, и вызывают для преобразования в целые числа в проверяемом контексте, но эти значения переполняются при преобразовании в целые числа в непроверяемом контексте. <xref:System.OverflowException> Для преобразований <xref:System.Decimal>они всегда <xref:System.OverflowException>создают исключение. Для преобразований <xref:System.Double>они преобразуют в <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>и <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>соответственно.  
  
 Обратите внимание, что при преобразовании <xref:System.Single> значения в другой числовой тип может произойти утрата точности. В случае преобразования нецелочисленных <xref:System.Single> значений, как показано в выходных данных примера, дробный компонент теряется, <xref:System.Single> если значение округляется (как в Visual Basic) или усекается (как в C#). Для преобразований <xref:System.Decimal> в значения <xref:System.Single> значение может не иметь точного представления в целевом типе данных.  
  
 В следующем примере число <xref:System.Single> значений преобразуется в несколько других числовых типов. Преобразования выполняются в проверяемом контексте в Visual Basic (по умолчанию) и в C# (из-за ключевого слова [checked](~/docs/csharp/language-reference/keywords/checked.md) ). Выходные данные в примере показывают результат для преобразований в проверяемом непроверяемом контексте. Можно выполнять преобразования в непроверенном контексте в Visual Basic путем компиляции с `/removeintchecks+` переключателем компилятора и в C# , заменив `checked` инструкцию.  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 Дополнительные сведения о преобразовании числовых типов см. в разделе [Преобразование типов в](~/docs/standard/base-types/type-conversion.md) [таблицах .NET Framework и преобразования типов](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Функция вычислений с плавающей запятой  
 <xref:System.Single> Структура и связанные типы предоставляют методы для выполнения следующих категорий операций:  
  
-   **Сравнение значений**. Можно вызвать <xref:System.Single.Equals%2A> метод, чтобы определить, равны ли <xref:System.Single> два значения, или <xref:System.Single.CompareTo%2A> метод для определения связи между двумя значениями.  
  
     <xref:System.Single> Структура также поддерживает полный набор операторов сравнения. Например, можно проверить на равенство или неравенство или определить, является ли одно значение больше или равно другому значению. Если один из операндов — <xref:System.Double> <xref:System.Single> , <xref:System.Double> значение преобразуется в перед выполнением сравнения. Если один из операндов является целочисленным типом, <xref:System.Single> перед выполнением сравнения он преобразуется в. Хотя это расширяющие преобразования, они могут привести к утрате точности.  
  
    > [!WARNING]
    >  Из-за различий в точности <xref:System.Single> два значения, которые должны быть равны, могут быть неравными, что влияет на результат сравнения. Дополнительные сведения о сравнении двух <xref:System.Single> значений см. в разделе [Проверка на равенство](#Equality) .  
  
     Для проверки этих специальных значений <xref:System.Single.IsNaN%2A>можно <xref:System.Single.IsInfinity%2A>также вызвать методы <xref:System.Single.IsNegativeInfinity%2A> ,, <xref:System.Single.IsPositiveInfinity%2A>и.  
  
-   **Математические операции**. Распространенные арифметические операции, такие как сложение, вычитание, умножение и деление, реализуются компиляторами языка и инструкциями на языке CIL, а не <xref:System.Single> методами. Если другой операнд в <xref:System.Double>математической операции — <xref:System.Single> , <xref:System.Double> перед выполнением операции преобразуется в, а результатом операции также <xref:System.Double> является значение. Если другой операнд является целочисленным типом, он преобразуется <xref:System.Single> в перед выполнением операции, а результат операции <xref:System.Single> также является значением.  
  
     Можно выполнять другие математические операции, `static` вызывая`Shared` методы (в <xref:System.Math?displayProperty=nameWithType> Visual Basic) в классе. К ним относятся дополнительные методы, обычно используемые для арифметических <xref:System.Math.Abs%2A?displayProperty=nameWithType>операций <xref:System.Math.Sign%2A?displayProperty=nameWithType>(например <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>,, и), Geometry <xref:System.Math.Cos%2A?displayProperty=nameWithType> ( <xref:System.Math.Sin%2A?displayProperty=nameWithType>например, и) и математического анализа за ( <xref:System.Math.Log%2A?displayProperty=nameWithType>например,).  Во всех случаях <xref:System.Single> значение преобразуется <xref:System.Double>в.  
  
     Можно также манипулировать отдельными битами <xref:System.Single> значения. <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType> Метод возвращает свой битовый шаблон в массиве байтов.  Передавая этот массив <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> байтов в метод, можно также <xref:System.Single> сохранить битовый шаблон значения в 32-битовом целом формате.  
  
-   **Округление**. Округление часто используется как метод снижения влияния различий между значениями, вызванными проблемами представления и точности с плавающей запятой. Можно округлить <xref:System.Single> значение, <xref:System.Math.Round%2A?displayProperty=nameWithType> вызвав метод. Однако обратите внимание, <xref:System.Single> что значение преобразуется <xref:System.Double> в перед вызовом метода, а преобразование может привести к утрате точности.  
  
-   **Форматирование**. <xref:System.Single> Значение можно преобразовать в строковое представление, <xref:System.Single.ToString%2A> вызвав метод или воспользовавшись функцией [составного форматирования](~/docs/standard/base-types/composite-formatting.md) . Сведения о том, как строки формата управляют строковым представлением значений с плавающей запятой, см. в разделах [стандартные строки числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md) .  
  
-   **Синтаксический анализ строк**. Можно преобразовать строковое представление значения с плавающей запятой в <xref:System.Single> значение, <xref:System.Single.Parse%2A> вызвав метод или <xref:System.Single.TryParse%2A> . Если операция синтаксического анализа завершается <xref:System.Single.Parse%2A> неудачно, метод создает исключение, <xref:System.Single.TryParse%2A> в то `false`время как метод возвращает.  
  
-   **Преобразование типов**. Структура предоставляет явную реализацию интерфейса <xref:System.IConvertible> для интерфейса, который поддерживает преобразование между любыми двумя стандартными .NET Frameworkными типами данных. <xref:System.Single> Языковые компиляторы также поддерживают неявное преобразование значений для всех других стандартных числовых типов, за исключением преобразования <xref:System.Double> в <xref:System.Single> значения. Преобразование значения любого стандартного числового типа, отличного от, <xref:System.Double> <xref:System.Single> в, является расширяющим преобразованием и не требует использования оператора приведения или метода преобразования.  
  
     Однако преобразование 32-разрядных и 64-разрядных целочисленных значений может привести к утрате точности. В следующей таблице перечислены различия в точности для 32-разрядных, 64-разрядных и <xref:System.Double> типов:  
  
    |Тип|Максимальная точность (в десятичных цифрах)|Внутренняя точность (в десятичных цифрах)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> и <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> и <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     Проблема точности чаще всего влияет <xref:System.Single> на значения, которые преобразуются в <xref:System.Double> значения. В следующем примере два значения, созданные идентичными операциями деления, не равны, так как одно из значений является значением с плавающей запятой одиночной точности, которое преобразуется <xref:System.Double>в.  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Все члены этого типа являются потокобезопасными. Члены, которые могут изменить состояние экземпляра, в действительности возвращают новый экземпляр, инициализированный новым значением. Как с любым другим типом, чтение и запись общей переменной, которая содержит экземпляр этого типа, должны быть защищены блокировкой для обеспечения потокобезопасности.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сравнивает данный экземпляр с указанным объектом или другим экземпляром <see cref="T:System.Single" /> и возвращает целое число, которое показывает, как соотносится значение данного экземпляра со значением другого экземпляра <see cref="T:System.Single" />: меньше, равняется или больше него.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Объект для сравнения или значение <see langword="null" />.</param>
        <summary>Сравнивает данный экземпляр с указанным объектом и возвращает целое число, которое показывает, является ли значение данного экземпляра меньше, больше или равно значению заданного объекта.</summary>
        <returns>Знаковое число, представляющее относительные значения этого экземпляра и параметра <paramref name="value" />.  
  
 <list type="table"><listheader><term> Возвращаемое значение 
 </term><description> Описание 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Этот экземпляр меньше параметра <paramref name="value" />.  
  
- или - 
Данный экземпляр не является числом (<see cref="F:System.Single.NaN" />), а параметр <paramref name="value" /> является.  
  
 </description></item><item><term> Нуль 
 </term><description> Этот экземпляр и параметр <paramref name="value" /> равны.  
  
-или- 
И данный экземпляр, и значение относятся к нечисловому типу (<see cref="F:System.Single.NaN" />), равны <see cref="F:System.Single.PositiveInfinity" /> или <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Этот экземпляр больше параметра <paramref name="value" />.  
  
- или - 
Данный экземпляр является числом, а параметр <paramref name="value" /> — нет (<see cref="F:System.Single.NaN" />).  
  
- или - 
 Свойство <paramref name="value" /> имеет значение <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр должен быть `null` или экземпляром <xref:System.Single>; в противном случае создается исключение. `value` Любой экземпляр <xref:System.Single>, независимо от его значения, считается `null`больше.  
  
 Значения должны быть одинаковыми, чтобы считаться равными. Особенно если значения с плавающей запятой зависят от нескольких математических операций, обычно они теряют точность и их значения практически идентичны, за исключением их наименьших значащих цифр. Из-за этого возвращаемое значение <xref:System.Single.CompareTo%2A> метода может показаться неудивительным в моменты времени. Например, умножение на определенное значение, за которым следует деление на одно и то же значение, должно создавать исходное значение, но в следующем примере вычисленное значение оказывается больше, чем исходное значение. Отображение всех значащих цифр двух значений с помощью [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) R означает, что вычисленное значение отличается от исходного значения в его минимально значащих цифрах. Дополнительные сведения об обработке таких сравнений см. в разделе <xref:System.Single.Equals%28System.Single%29> "Примечания" метода.  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 Этот метод реализован для поддержки <xref:System.IComparable> интерфейса. Обратите внимание, что <xref:System.Single.NaN> , хотя не считается равным другому <xref:System.Single.NaN> ( <xref:System.IComparable> даже самому), интерфейс требует, `A.CompareTo(A)` чтобы возвращал ноль.  
  
## <a name="precision-in-comparisons"></a>Точность в сравнениях  
 Точность чисел с плавающей запятой, превышающих задокументированную точность, зависит от реализации и версии .NET Framework. Следовательно, сравнение двух определенных чисел может измениться между версиями .NET Framework, так как точность внутреннего представления чисел может измениться.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется <xref:System.Single.CompareTo%2A> метод.  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> не является объектом <see cref="T:System.Single" />.</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : single -&gt; int&#xA;override this.CompareTo : single -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Сравниваемое число с плавающей запятой одиночной точности.</param>
        <summary>Сравнивает данный экземпляр с заданным числом одиночной точности с плавающей запятой и возвращает целое число, которое показывает, является ли значение данного экземпляра меньше, больше или равным значению заданного числа одиночной точности с плавающей запятой.</summary>
        <returns>Знаковое число, представляющее относительные значения этого экземпляра и параметра <paramref name="value" />.  
  
 <list type="table"><listheader><term> Возвращаемое значение 
 </term><description> Описание 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Этот экземпляр меньше параметра <paramref name="value" />.  
  
- или - 
Данный экземпляр не является числом (<see cref="F:System.Single.NaN" />), а параметр <paramref name="value" /> является.  
  
 </description></item><item><term> Нуль 
 </term><description> Этот экземпляр и параметр <paramref name="value" /> равны.  
  
-или- 
И этот экземпляр, и параметр <paramref name="value" /> не являются числами (<see cref="F:System.Single.NaN" />), равны <see cref="F:System.Single.PositiveInfinity" /> или <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Этот экземпляр больше параметра <paramref name="value" />.  
  
- или - 
Данный экземпляр является числом, а параметр <paramref name="value" /> — нет (<see cref="F:System.Single.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значения должны быть одинаковыми, чтобы считаться равными. Обычно значения с плавающей запятой теряют точность и почти идентичны, за исключением наименее значащих цифр, особенно в тех случаях, когда значения зависят от нескольких математических операций. По этой причине возвращаемое значение <xref:System.Single.CompareTo%2A> метода иногда может показаться неожиданным. Например, умножение любого значения, за которым следует деление на одно и то же значение, должно привести к изначальному значению. Однако в следующем примере вычисленное значение оказывается больше, чем исходное значение. Отображение всех значащих цифр двух значений с помощью [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) R означает, что вычисленное значение отличается от исходного значения в его минимально значащих цифрах. Дополнительные сведения об обработке таких сравнений см. в разделе <xref:System.Single.Equals%28System.Single%29> "Примечания" метода.  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 Этот метод реализует <xref:System.IComparable%601?displayProperty=nameWithType> интерфейс и работает немного лучше, чем метод <xref:System.Single.CompareTo%2A?displayProperty=nameWithType> , поскольку ему `value` не нужно преобразовывать параметр в объект.  
  
 Обратите внимание, что, хотя объект, <xref:System.Single.NaN> значение которого не считается другим объектом, значение которого равно <xref:System.Single.NaN> ( <xref:System.IComparable%601> даже само собой), интерфейс требует, `A.CompareTo(A)` чтобы возвращал ноль.  
  
## <a name="widening-conversions"></a>расширяющие преобразования  
 В зависимости от языка программирования может быть возможным <xref:System.Single.CompareTo%2A> написание метода, где тип параметра имеет меньше разрядов (является более узким), чем тип экземпляра. Это возможно, поскольку некоторые языки программирования выполняют неявное расширяющее преобразование, которое представляет параметр как тип с количеством битов в качестве экземпляра.  
  
 Например, предположим, что тип экземпляра — <xref:System.Single> , а тип параметра — <xref:System.Int32>. Компилятор Microsoft C# создает инструкции для представления значения параметра в виде <xref:System.Single> объекта <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType> , а затем создает метод, который сравнивает значения экземпляра и расширенное представление параметра.  
  
 Обратитесь к документации по языку программирования, чтобы определить, выполняет ли компилятор неявное расширяющее преобразование числовых типов. Дополнительные сведения см. в разделе [таблицы преобразования типов](~/docs/standard/base-types/conversion-tables.md) .  
  
## <a name="precision-in-comparisons"></a>Точность в сравнениях  
 Точность чисел с плавающей запятой, превышающих задокументированную точность, зависит от реализации и версии .NET Framework. Следовательно, сравнение двух определенных чисел может измениться между версиями .NET Framework, так как точность внутреннего представления чисел может измениться.  
  
   
  
## Examples  
 В следующем примере кода показаны универсальные и неуниверсальные версии <xref:System.Single.CompareTo%2A> метода для нескольких ссылочных типов.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : single" Usage="System.single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>Представляет наименьшее положительное значение <see cref="T:System.Single" /> больше нуля. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение <xref:System.Single.Epsilon> свойства отражает наименьшее положительное <xref:System.Single> значение, значимое в числовых операциях или сравнениях, <xref:System.Single> если значение экземпляра равно нулю. Например, следующий код показывает, что ноль и <xref:System.Single.Epsilon> считаются неравными значениями, тогда как ноль и половина <xref:System.Single.Epsilon> значения считаются равными.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 Точнее, формат с плавающей запятой одиночной точности состоит из знака, 23-разрядной мантисса или значащим и 8-разрядного показателя степени. Как показано в следующем примере, ноль имеет показатель степени-126 и мантисса 0. <xref:System.Single.Epsilon>имеет показатель степени-126 и мантисса 1. Это означает, <xref:System.Single.Epsilon?displayProperty=nameWithType> что является наименьшим <xref:System.Single> положительным значением больше нуля и представляет наименьшее возможное значение и наименьшее возможное приращение для, <xref:System.Single> степень которого равна-126.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 Однако свойство не является общей мерой точности <xref:System.Single> типа. оно применяется только к <xref:System.Single> экземплярам, имеющим нулевое значение. <xref:System.Single.Epsilon>  
  
> [!NOTE]
>  Значение <xref:System.Single.Epsilon> свойства не эквивалентно компьютеру Эпсилон, который представляет верхнюю границу относительных ошибок из-за округления в арифметических операциях с плавающей запятой.  
  
 Значение этой константы равно 1.4 e-45.  
  
 Два невероятных эквивалентных числа с плавающей запятой могут не сравниваться, так как они имеют различия в крайне значащих цифрах. Например, C# выражение `(float)1/3 == (float)0.33333`не сравнивает равенство, поскольку операция деления в левой части имеет максимальную точность, а константа в правой части является точной только для указанных цифр. При создании пользовательского алгоритма, определяющего, можно ли считать два числа с плавающей запятой равными, необходимо использовать значение, большее, чем <xref:System.Single.Epsilon> константа, чтобы установить допустимое абсолютное поле разности для двух значений. считается равным. (Как правило, это поле разности имеет много раз больше <xref:System.Single.Epsilon>, чем.)  
  
## <a name="platform-notes"></a>Примечания к платформе  
 В системах ARM значение <xref:System.Single.Epsilon> константы слишком мало для обнаружения, поэтому оно равно нулю. Вместо этого можно определить альтернативное значение Эпсилон, равное 1.175494351 E-38.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, указывающее, представляют ли два экземпляра <see cref="T:System.Single" /> одно и то же значение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для сравнения с данным экземпляром.</param>
        <summary>Возвращает значение, показывающее, равен ли данный экземпляр заданному объекту.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="obj" /> является экземпляром типа <see cref="T:System.Single" /> и равен значению данного экземпляра; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот <xref:System.Single.Equals%2A> метод следует использовать с осторожностью, поскольку два неравенства значения могут быть неравными из-за разной точности этих двух значений. В следующем примере сообщается, <xref:System.Single> что значение. 3333 <xref:System.Single> и возвращенное делением 1 на 3 не равны.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 Вместо сравнения на равенство, одним из рекомендуемых способов является определение приемлемого поля разности между двумя значениями (например, .01% одного из значений). Если абсолютное значение разницы между двумя значениями меньше или равно этому полю, разница, скорее всего, будет обусловлена различиями в точности и, следовательно, значения, скорее всего, будут равны. В следующем примере этот метод используется для сравнения. 33333 и 1/3, два <xref:System.Single> значения которых в предыдущем примере кода не совпадают.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 В этом случае значения равны.  
  
> [!NOTE]
>  Поскольку <xref:System.Single.Epsilon> определяет минимальное выражение положительного значения, чей диапазон близок к нулю, поле разности должно быть <xref:System.Single.Epsilon>больше. Как правило, это множество раз больше, <xref:System.Single.Epsilon>чем.  
  
 Точность чисел с плавающей запятой, превышающих задокументированную точность, зависит от реализации и версии .NET Framework. Следовательно, сравнение двух определенных чисел может измениться между версиями .NET Framework, так как точность внутреннего представления чисел может измениться.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется <xref:System.Single.Equals%2A> метод.  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Разрешение перегрузки компилятора может учитывать очевидную разницу в поведении двух <see cref="M:System.Single.Equals(System.Object)" /> перегрузок метода. Если неявное преобразование между <paramref name="obj" /> <see cref="T:System.Single" /> аргументом и определено и аргумент не типизирован как <see cref="T:System.Object" />, компиляторы <see cref="M:System.Single.Equals(System.Single)" /> могут выполнить неявное преобразование и вызвать метод. В противном случае они <see cref="M:System.Single.Equals(System.Object)" /> вызывают метод, который всегда <see langword="false" /> возвращает, <paramref name="obj" /> если <see cref="T:System.Single" /> его аргумент не является значением. В следующем примере показано различие в поведении между двумя перегрузками метода. В случае со всеми примитивными числовыми типами, <see cref="T:System.Double" /> за исключением в Visual Basic <see cref="T:System.Decimal" /> и <see cref="T:System.Double" /> за C#исключением и в, <see langword="true" /> первое сравнение возвращается, так как компилятор автоматически выполняет расширяющее преобразование. и вызывает <see cref="M:System.Single.Equals(System.Single)" /> метод, а второе сравнение возвращает <see langword="false" /> , <see cref="M:System.Single.Equals(System.Object)" /> так как компилятор вызывает метод.  
  
[! код-CSharp[System. Single. Equals # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! код-VB[System. Single. Equals # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : single -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для сравнения с данным экземпляром.</param>
        <summary>Возвращает значение, позволяющее определить, представляют ли этот экземпляр и заданный объект <see cref="T:System.Single" /> одно и то же значение.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="obj" /> равно данному экземпляру; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует <xref:System.IEquatable%601?displayProperty=nameWithType> интерфейс и работает немного лучше, чем <xref:System.Single.Equals%2A> потому, что `obj` не требуется преобразовывать параметр в объект.  
  
## <a name="widening-conversions"></a>расширяющие преобразования  
 В зависимости от языка программирования может быть возможным <xref:System.Single.Equals%2A> написание метода, в котором тип параметра имеет меньше разрядов (является более узким), чем тип экземпляра. Это возможно, поскольку некоторые языки программирования выполняют неявное расширяющее преобразование, которое представляет параметр как тип с количеством битов в качестве экземпляра.  
  
 Например, предположим, что тип экземпляра — <xref:System.Single> , а тип параметра — <xref:System.Int32>. Компилятор Microsoft C# создает инструкции для представления значения параметра в виде <xref:System.Single> объекта, <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType> а затем создает метод, который сравнивает значения экземпляра и расширенное представление параметра.  
  
 Обратитесь к документации по языку программирования, чтобы определить, выполняет ли компилятор неявное расширяющее преобразование числовых типов. Дополнительные сведения см. в разделе [таблицы преобразования типов](~/docs/standard/base-types/conversion-tables.md) .  
  
## <a name="precision-in-comparisons"></a>Точность в сравнениях  
 <xref:System.Single.Equals%2A> Метод следует использовать с осторожностью, так как два незначащих значения могут быть неравными из-за разной точности этих двух значений. В следующем примере сообщается, <xref:System.Single> что значение. 3333 <xref:System.Single> и возвращенное делением 1 на 3 не равны.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 Одна методика сравнения, которая позволяет избежать проблем, связанных с сравнением на равенство, заключается в определении приемлемого поля разности между двумя значениями (например, .01% одного из значений). Если абсолютное значение разницы между двумя значениями меньше или равно этому полю, разница, скорее всего, будет результатом различий в точности, поэтому значения, скорее всего, будут равны. В следующем примере этот метод используется для сравнения значений. 33333 и 1/3, которые представляют собой <xref:System.Single> два значения, которые в предыдущем примере кода не совпадают.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 В этом случае значения равны.  
  
> [!NOTE]
>  Поскольку <xref:System.Single.Epsilon> определяет минимальное выражение положительного значения, чей диапазон близок к нулю, поле разности должно быть <xref:System.Single.Epsilon>больше. Как правило, это множество раз больше, <xref:System.Single.Epsilon>чем. Поэтому рекомендуется не использовать <xref:System.Double.Epsilon> при сравнении <xref:System.Double> значений на равенство.  
  
 Вторая методика, которая позволяет избежать проблем, связанных с сравнением на равенство, заключается в сравнении различий между двумя числами с плавающей запятой и определенным абсолютным значением. Если разность меньше или равна этому абсолютному значению, числа равны. Если оно больше, числа не равны. Одним из способов сделать это является произвольное выделение абсолютного значения. Однако это проблематично, поскольку приемлемое поле разности зависит от величины <xref:System.Single> значений. Второй способ использует преимущества функции проектирования в формате с плавающей запятой: Разница между компонентами мантисса в целочисленных представлениях двух значений с плавающей запятой указывает на количество возможных значений с плавающей запятой, разделяющих эти два значения. Например, разница между 0,0 и <xref:System.Single.Epsilon> равно 1, поскольку <xref:System.Single.Epsilon> — это наименьшее значение, которое может быть представлено при работе <xref:System.Single> с, значение которого равно нулю. В следующем примере этот метод используется для сравнения значений. 33333 и 1/3, которые являются двумя <xref:System.Double> значениями, приведенными в предыдущем примере кода <xref:System.Single.Equals%28System.Single%29> с методом, не равным. Обратите внимание, что в <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> примере <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> используются методы и для преобразования значения с плавающей запятой одиночной точности в целочисленное представление.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 Точность чисел с плавающей запятой, превышающих задокументированную точность, зависит от реализации и версии .NET Framework. Следовательно, сравнение двух чисел может привести к различным результатам в зависимости от версии .NET Framework, так как точность внутреннего представления чисел может измениться.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Разрешение перегрузки компилятора может учитывать очевидную разницу в поведении двух <see cref="M:System.Single.Equals(System.Object)" /> перегрузок метода. Если неявное преобразование между <paramref name="obj" /> <see cref="T:System.Single" /> аргументом и определено и аргумент не типизирован как <see cref="T:System.Object" />, компиляторы <see cref="M:System.Single.Equals(System.Single)" /> могут выполнить неявное преобразование и вызвать метод. В противном случае они <see cref="M:System.Single.Equals(System.Object)" /> вызывают метод, который всегда <see langword="false" /> возвращает, <paramref name="obj" /> если <see cref="T:System.Single" /> его аргумент не является значением. В следующем примере показано различие в поведении между двумя перегрузками метода. В случае со всеми примитивными числовыми типами, <see cref="T:System.Double" /> за исключением в Visual Basic <see cref="T:System.Decimal" /> и <see cref="T:System.Double" /> за C#исключением и в, <see langword="true" /> первое сравнение возвращается, так как компилятор автоматически выполняет расширяющее преобразование. и вызывает <see cref="M:System.Single.Equals(System.Single)" /> метод, а второе сравнение возвращает <see langword="false" /> , <see cref="M:System.Single.Equals(System.Object)" /> так как компилятор вызывает метод.  
  
[! код-CSharp[System. Single. Equals # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! код-VB[System. Single. Equals # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="single.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код данного экземпляра.</summary>
        <returns>Хэш-код в виде 32-битовым целым числом со знаком.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="single.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.TypeCode" /> для типа значения <see cref="T:System.Single" />.</summary>
        <returns>Константа перечислимого типа, <see cref="F:System.TypeCode.Single" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberSignature Language="F#" Value="static member IsFinite : single -&gt; bool" Usage="System.single.IsFinite f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Определяет, является ли указанное значение конечным (нулевым, поднормальным или нормальным).</summary>
        <returns>Значение <see langword="true" />, если указанное значение является конечным (нулевым, поднормальным или нормальным); в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : single -&gt; bool" Usage="System.single.IsInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Возвращает значение, позволяющее определить, равно ли данное число плюс или минус бесконечности.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="f" /> равен значению <see cref="F:System.Single.PositiveInfinity" /> или <see cref="F:System.Single.NegativeInfinity" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой <xref:System.Single.PositiveInfinity> возвращают или <xref:System.Single.NegativeInfinity> сообщают о состоянии переполнения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется <xref:System.Single.IsInfinity%2A> метод.  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberSignature Language="F#" Value="static member IsNaN : single -&gt; bool" Usage="System.single.IsNaN f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Возвращает значение, показывающее, что указанное значение не является числом (<see cref="F:System.Single.NaN" />).</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="f" /> относится к нечисловому типу (<see cref="F:System.Single.NaN" />); в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой <xref:System.Single.NaN> возвращают сигнал о том, что результат операции не определен. Например, деление 0,0 на 0,0 приводит <xref:System.Single.NaN>к.  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A>Возвращает `false` <xref:System.Single.PositiveInfinity> , <xref:System.Single> если значение равно либо <xref:System.Single.NegativeInfinity>. Чтобы проверить эти значения, используйте <xref:System.Single.IsInfinity%2A>методы, <xref:System.Single.IsPositiveInfinity%2A>и <xref:System.Single.IsNegativeInfinity%2A> .  
  
   
  
## Examples  
 В следующем примере кода демонстрируется <xref:System.Single.IsNaN%2A> метод.  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegative : single -&gt; bool" Usage="System.single.IsNegative f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Определяет, является ли заданное значение отрицательным.</summary>
        <returns>Значение <see langword="true" />, если отрицательное; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : single -&gt; bool" Usage="System.single.IsNegativeInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Возвращает значение, позволяющее определить, равно ли данное число минус бесконечности.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="f" /> равно значению <see cref="F:System.Single.NegativeInfinity" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой <xref:System.Single.NegativeInfinity> возвращают, чтобы сообщить о состоянии переполнения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется <xref:System.Single.IsNegativeInfinity%2A> метод.  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsNormal : single -&gt; bool" Usage="System.single.IsNormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Определяет, является ли заданное значение нормальным.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="f" /> является нормальным; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : single -&gt; bool" Usage="System.single.IsPositiveInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Возвращает значение, показывающее, равно ли данное число плюс бесконечности.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="f" /> равно значению <see cref="F:System.Single.PositiveInfinity" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой <xref:System.Single.PositiveInfinity> возвращают, чтобы сообщить о состоянии переполнения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется <xref:System.Single.IsPositiveInfinity%2A> метод.  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : single -&gt; bool" Usage="System.single.IsSubnormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="f">Число одиночной точности с плавающей запятой.</param>
        <summary>Определяет, является ли заданное значение поднормальным.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="f" /> является поднормальным; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : single" Usage="System.single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>Представляет наибольшее возможное значение типа <see cref="T:System.Single" />. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы является положительным 3.40282347 E + 38.  
  
 Результат операции, которая превышает <xref:System.Single.MaxValue?displayProperty=nameWithType> значение, равно. <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> В следующем примере <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> результаты операций сложения, умножения и возведения в степень возводятся в случае <xref:System.Single.MaxValue?displayProperty=nameWithType>превышения результата.  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 В следующем примере кода показана <xref:System.Single.MaxValue> константа.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : single" Usage="System.single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>Представляет минимально допустимое значение типа <see cref="T:System.Single" />. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы отрицательно 3.402823 E38.  
  
 Результат операции меньше, чем <xref:System.Single.MinValue?displayProperty=nameWithType>. <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> В следующем примере результаты операций <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> вычитания и умножения выполняются, если результат <xref:System.Single.MinValue?displayProperty=nameWithType>меньше.  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 В следующем примере кода показана <xref:System.Single.MinValue> константа.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : single" Usage="System.single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Представляет нечисловое значение (<see langword="NaN" />). Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод или оператор возвращает <xref:System.Single.NaN> , когда результат операции не определен. Например, результат деления нуля на ноль равен <xref:System.Single.NaN>, как показано в следующем примере. (Однако обратите внимание, что деление ненулевого числа на ноль <xref:System.Single.PositiveInfinity> возвращает <xref:System.Single.NegativeInfinity>либо или, в зависимости от знака делителя.)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 Кроме того, вызов метода со <xref:System.Single.NaN> значением или операцией <xref:System.Single.NaN> со значением возвращается <xref:System.Single.NaN>, как показано в следующем примере.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 <xref:System.Single.IsNaN%2A> Используйте метод, чтобы определить, является ли значение нечисловым. Как правило, <xref:System.Single> операторы нельзя использовать для сравнения <xref:System.Single.NaN?displayProperty=nameWithType> с другими <xref:System.Single> значениями, хотя методы сравнения (такие как <xref:System.Single.Equals%2A> и <xref:System.Single.CompareTo%2A>) могут быть. В следующем примере показано различие в поведении между <xref:System.Single> операторами сравнения и методами.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 В следующем примере показана <xref:System.Single.NaN> константа.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : single" Usage="System.single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Представляет минус бесконечность. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы является результатом деления отрицательного числа на ноль.  
  
 Эта константа возвращается, если результат операции меньше <xref:System.Single.MinValue>.  
  
 Используйте <xref:System.Single.IsNegativeInfinity%2A> , чтобы определить, является ли значение отрицательной бесконечностью.  
  
   
  
## Examples  
 В следующем примере кода показана <xref:System.Single.NegativeInfinity> константа.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : single * single -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, равны ли два заданных значения <see cref="T:System.Single" />.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> равны; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод определяет оператор равенства для <xref:System.Single> значений. <xref:System.Single.op_Equality%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : single * single -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Single" /> больше другого заданного значения <see cref="T:System.Single" />.</summary>
        <returns><see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод определяет операцию оператора "больше" для <xref:System.Single> значений. <xref:System.Single.op_GreaterThan%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : single * single -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Single" /> больше или равно другому заданному значению <see cref="T:System.Single" />.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> больше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод определяет операцию оператора "больше или равно" для <xref:System.Single> значений. <xref:System.Single.op_GreaterThanOrEqual%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : single * single -&gt; bool" Usage="System.single.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, не равны ли два заданных значения <see cref="T:System.Single" />.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> не равны друг другу; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод определяет оператор неравенства для <xref:System.Single> значений. <xref:System.Single.op_Inequality%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : single * single -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Single" /> меньше другого заданного значения <see cref="T:System.Single" />.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше значения <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод определяет операцию оператора "меньше чем" для <xref:System.Single> значений. <xref:System.Single.op_LessThan%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : single * single -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Single" /> меньше или равно другому заданному значению <see cref="T:System.Single" />.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод определяет операцию оператора "меньше или равно" для <xref:System.Single> значений. <xref:System.Single.op_LessThanOrEqual%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует строковое представление числа в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; single" Usage="System.single.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <summary>Преобразует строковое представление числа в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр может содержать строку в формате <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, или в текущем языке и региональных параметрах: `s`  
  
 [*WS*] [*Sign*] [*целочисленные цифры*[*,*]] *целые числа* [*.* [*дробные цифры*]] [e [*знак*]*экспоненциальные цифры*] [*WS*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Последовательность символов пробела.|  
|*sign*|Знак отрицательного знака или знак плюс. Допустимые символы знака определяются <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> свойствами и <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> текущего языка и региональных параметров. Можно использовать только ведущий знак.|  
|*целые числа*|Последовательность цифр от 0 до 9, указывающих целую часть числа. Выполнение *целочисленных цифр* может быть разделено символом разделителя групп. Например, в некоторых культурах запятая (,) разделяет группы тысяч. Элемент с *целочисленными цифрами* может отсутствовать, если строка содержит элемент *дробной разрядности* .|  
|*,*|Символ разделителя тысяч, зависящий от языка и региональных параметров.|  
|*.*|Символ десятичной запятой, зависящий от языка и региональных параметров.|  
|*Дробные разряды*|Последовательность цифр от 0 до 9, которая указывает дробную часть числа.|  
|E|Символ "e" или "E", указывающий, что значение представлено в экспоненциальной (экспоненциальной) нотации.|  
|*экспоненциальные цифры*|Последовательность цифр от 0 до 9, указывающая показатель степени.|  
  
 Параметр интерпретируется с помощью сочетания <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> флагов и <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>. `s` Это означает, что пробелы и разделители групп разрядов разрешены, а символы валют — нет. Чтобы явно определить элементы (например, символы валют, разделители тысяч и пробелы), которые могут присутствовать в `s`, <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> используйте перегрузку метода.  
  
 Параметр анализируется с помощью сведений о форматировании <xref:System.Globalization.NumberFormatInfo> в объекте, инициализированном для текущего языка и региональных параметров системы. `s` Для получения дополнительной информации см. <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Чтобы выполнить синтаксический анализ строки с использованием сведений о форматировании определенного языка и региональных <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> параметров <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> , используйте метод или.  
  
 Обычно, если передать <xref:System.Single.Parse%2A> методу строку, созданную путем <xref:System.Single.ToString%2A> вызова метода, возвращается исходное <xref:System.Single> значение. Однако из-за потери точности значения могут не совпадать.  
  
 Если в `s` параметре во время операции синтаксического анализа встречается разделитель, а применимые разделители денежных единиц или десятичного числа и групп совпадают, то операция синтаксического анализа предполагает, что разделитель является десятичным разделителем, а не группой. двоеточи. <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>Дополнительные сведения о разделителях см. <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>в разделе <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>,, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере <xref:System.Single.Parse%28System.String%29> метод используется для преобразования массива строк в эквивалентные <xref:System.Single> значения.  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> не представляет число в допустимом формате.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> представляет число, которое меньше значения <see cref="F:System.Single.MinValue" /> или больше значения <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Синтаксический анализ числовых строк в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; single" Usage="System.single.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="style">Побитовое сочетание значений перечисления, обозначающих элементы стиля, которые могут быть представлены в параметре <paramref name="s" />. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Преобразует строковое представление числа в указанном стиле в эквивалентное ему число одиночной точности с плавающей запятой.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр определяет элементы стиля (такие как пробелы, разделители групп разрядов и символы валют), допустимые `s` в параметре для выполнения операции синтаксического анализа. `style` Он должен представлять собой сочетание битовых флагов из <xref:System.Globalization.NumberStyles> перечисления. Следующие <xref:System.Globalization.NumberStyles> члены не поддерживаются:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Параметр может содержать текущий <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>язык и региональные параметры, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>. `s` В зависимости от значения `style`, оно также может принимать форму:  
  
 [*WS*] [*$*] [*Sign*] [*целая-разрядная*[*,*]]*целая-разрядная*[*.* [*дробные цифры*]] [E [*знак*]*экспоненциальные цифры*] [*WS*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
 *ws*  
 Последовательность пробельных символов. Пробел может `s` присутствовать в начале, если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> флаг, `s` и может <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> находиться в конце, если `style` включает флаг.  
  
 $  
 Символ валюты, зависящий от языка и региональных параметров. Его расположение в строке определяется <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> свойствами и <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> текущего языка и региональных параметров. Символ валюты текущего языка и региональных параметров может отображаться `s` в `style` , если <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> включает флаг.  
  
 *sign*  
 Знак отрицательного знака (-) или знак плюс (+). Знак может `s` присутствовать в начале, если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> флаг, `s` и может <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> находиться в конце, если `style` включает флаг. Круглые скобки могут использоваться в `s` , чтобы указать отрицательное значение `style` , если <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> включает флаг.  
  
 *целые числа*  
 Последовательность цифр от 0 до 9, указывающих целую часть числа. Элемент с *целочисленными цифрами* может отсутствовать, если строка содержит элемент *дробной разрядности* .  
  
 ,  
 Разделитель групп, зависящий от языка и региональных параметров. Символ разделителя групп текущего языка и региональных параметров может отображаться `s` в `style` , если <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> включает флаг  
  
 .  
 Символ десятичной запятой, зависящий от языка и региональных параметров. Символ десятичной запятой текущего языка и региональных параметров может `s` присутствовать в <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> , если `style` включает флаг.  
  
 *Дробные разряды*  
 Последовательность цифр от 0 до 9, которая указывает дробную часть числа. Дробные цифры могут присутствовать `s` в `style` , <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> если включает флаг.  
  
 E  
 Символ "e" или "E", указывающий, что значение представлено в экспоненциальной (экспоненциальной) нотации. Параметр может представлять число в экспоненциальной нотации, `style` <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> если включает флаг. `value`  
  
 *экспоненциальные цифры*  
 Последовательность цифр от 0 до 9, указывающая показатель степени.  
  
> [!NOTE]
> Все завершающие символы NUL (U + 0000) в `s` игнорируются операцией синтаксического анализа, независимо от значения `style` аргумента.

 Строка с цифрами (которая соответствует <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> стилю) всегда будет успешно проанализирована. Остальные <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> элементы управляют элементами управления, которые могут присутствовать, но не обязательно должны присутствовать во входной строке. В следующей таблице показано, как <xref:System.Globalization.NumberStyles> отдельные флаги влияют на элементы, которые могут `s`присутствовать в.  
  
|Значение NumberStyles|Элементы, разрешенные в `s` в дополнение к цифрам|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Только элемент с *целыми цифрами* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Элементы десятичной запятой (*.*) и *дробные разряды* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Символ "e" или "E", который указывает на экспоненциальную нотацию. Этот флаг сам по себе поддерживает значения в виде *цифр*E*цифр*. Дополнительные флаги необходимы для успешного анализа строк с такими элементами, как знаки плюса или минуса и символы десятичной запятой.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Элемент *WS* в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Элемент *WS* в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Элемент *Sign* в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Элемент *Sign* в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Элемент *Sign* в виде круглых скобок, охватывающих числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Элемент разделителя тысяч (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Элемент Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Все элементы. `s` Однако не может представлять шестнадцатеричное число или число в экспоненциальной нотации.|  
|<xref:System.Globalization.NumberStyles.Float>|Элемент *WS* в начале или конце `s`, ** `s`знак в начале и символ десятичной запятой (.). `s` Параметр также может использовать экспоненциальную нотацию.|  
|<xref:System.Globalization.NumberStyles.Number>|Элементы `ws` ,`sign`, тысячные разделители (,) и десятичные точки (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Все элементы. `s` Однако не может представлять шестнадцатеричное число.|  
  
 Примеры `s` : "100", "-123 456 789", "123,45 e + 6", "+ 500", "5e2", "3,1416", "600.", "-. 123" и "-Infinity".  
  
 Параметр анализируется с помощью сведений о форматировании <xref:System.Globalization.NumberFormatInfo> в объекте, инициализированном для текущего языка и региональных параметров системы. `s` Чтобы указать язык и региональные параметры, сведения о форматировании которых используются для операции синтаксического анализа, вызовите <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> перегрузку.  
  
 Обычно, если передать <xref:System.Single.Parse%2A> методу строку, созданную путем <xref:System.Single.ToString%2A> вызова метода, возвращается исходное <xref:System.Single> значение. Однако из-за потери точности значения могут не совпадать.  
  
 Если в `s` параметре во время операции синтаксического анализа встречается разделитель, а применимые разделители денежных единиц или десятичного числа и групп совпадают, то операция синтаксического анализа предполагает, что разделитель является десятичным разделителем, а не группой. двоеточи. <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>Дополнительные сведения о разделителях см. <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>в разделе <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>,, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> метод используется для синтаксического анализа строковых <xref:System.Single> представлений значений. В примере используются сведения о форматировании для языка и региональных параметров en-US.  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> не является числом в допустимом формате.</exception>
        <exception cref="T:System.OverflowException">Параметр <paramref name="s" /> представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  
  
- или - 
 <paramref name="style" /> включает значение <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Синтаксический анализ числовых строк в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; single" Usage="System.single.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <paramref name="s" /> в зависимости от языка и региональных параметров.</param>
        <summary>Преобразует строковое представление числа, записанное в формате, соответствующем определенному языку и региональным параметрам, в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка обычно используется для преобразования текста, который может быть отформатирован различными способами <xref:System.Single> , в значение. Например, можно использовать для преобразования текста, вводимых пользователем, в текстовое поле HTML в числовое значение.  
  
 Параметр интерпретируется с помощью сочетания <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> флагов и <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>. `s` <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> `provider`Параметр может содержать ,<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> или<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> для языка и региональных параметров, заданных параметром, или может содержать строку в формате: `s`  
  
 [*WS*] [*Sign*] *целые числа* [*.* [*дробные цифры*]] [E [*знак*]*экспоненциальные цифры*] [*WS*]  
  
 Необязательные элементы заключены в квадратные скобки ([и]). Элементы, содержащие термин "цифры", состоят из ряда числовых символов в диапазоне от 0 до 9.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Последовательность пробельных символов.|  
|*sign*|Знак отрицательного знака (-) или знак плюс (+).|  
|*целые числа*|Последовательность цифр от 0 до 9, указывающих целую часть числа. Выполнение *целочисленных цифр* может быть разделено символом разделителя групп. Например, в некоторых культурах запятая (,) разделяет группы тысяч. Элемент с *целочисленными цифрами* может отсутствовать, если строка содержит элемент *дробной разрядности* .|  
|.|Символ десятичной запятой, зависящий от языка и региональных параметров.|  
|*Дробные разряды*|Последовательность цифр от 0 до 9, которая указывает дробную часть числа.|  
|E|Символ "e" или "E", указывающий, что значение представлено в экспоненциальной (экспоненциальной) нотации.|  
|*экспоненциальные цифры*|Последовательность цифр от 0 до 9, указывающая показатель степени.|  
  
 Дополнительные сведения о числовых форматах см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md) .  
  
 Параметр — это <xref:System.IFormatProvider.GetFormat%2A>реализация, метод которой возвращает объект,предоставляющийсведенияобособенностяхформатирования,связанныхсязыкомирегиональнымипараметрами.<xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider> `provider` <xref:System.Type> `provider` <xref:System.IFormatProvider.GetFormat%2A> При вызове метода он вызывает метод параметра<xref:System.Globalization.NumberFormatInfo> и передает ему объект, представляющий тип. <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> Затем метод возвращает объект, предоставляющий сведения `s` о формате параметра. <xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider.GetFormat%2A> Существует три способа использования `provider` параметра для предоставления сведений о пользовательском форматировании операции синтаксического анализа:  
  
-   Можно передать <xref:System.Globalization.CultureInfo> объект, представляющий язык и региональные параметры, которые предоставляют сведения о форматировании. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> метод<xref:System.Globalization.NumberFormatInfo> возвращает объект, предоставляющий сведения о форматировании числовых значений для этого языка и региональных параметров.  
  
-   Можно передать фактический <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании чисел. (Его реализация <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам себя.)  
  
-   Можно передать пользовательский объект, реализующий интерфейс <xref:System.IFormatProvider>. Его <xref:System.IFormatProvider.GetFormat%2A> метод создает экземпляр и <xref:System.Globalization.NumberFormatInfo> возвращает объект, предоставляющий сведения о форматировании.  
  
 Если `provider` параметр `null` имеет значение <xref:System.Globalization.NumberFormatInfo> или не может быть получен, используются сведения о форматировании для текущего языка и региональных параметров системы.  
  
 Если в `s` параметре во время операции синтаксического анализа встречается разделитель, а применимые разделители денежных единиц или десятичного числа и групп совпадают, то операция синтаксического анализа предполагает, что разделитель является десятичным разделителем, а не группой. двоеточи. <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>Дополнительные сведения о разделителях см. <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>в разделе <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>,, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
 Примеры `s` : "100", "-123 456 789", "123,45 e + 6", "+ 500", "5e2", "3,1416", "600.", "-. 123" и "-Infinity".  
  
   
  
## Examples  
 В следующем примере показан обработчик событий нажатия кнопки в веб-форме. Он использует массив, возвращаемый <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> свойством, чтобы определить языковой стандарт пользователя. Затем создается экземпляр <xref:System.Globalization.CultureInfo> объекта, соответствующий этому языковому стандарту. Затем объект, принадлежащий этому <xref:System.Globalization.CultureInfo> объекту, передается <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> методу <xref:System.Single> для преобразования входных данных пользователя в значение. <xref:System.Globalization.NumberFormatInfo>  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> не представляет число в допустимом формате.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> представляет число, которое меньше значения <see cref="F:System.Single.MinValue" /> или больше значения <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Синтаксический анализ числовых строк в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Single" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="style">Побитовое сочетание значений перечисления, обозначающих элементы стиля, которые могут быть представлены в параметре <paramref name="s" />. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <paramref name="s" /> в зависимости от языка и региональных параметров.</param>
        <summary>Преобразует строковое представление числа в указанном стиле и с использованием формата, соответствующего данному языку и региональным параметрам, в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр определяет элементы стиля (такие как пробелы, разделители групп разрядов и символы валют), допустимые `s` в параметре для выполнения операции синтаксического анализа. `style` Он должен представлять собой сочетание битовых флагов из <xref:System.Globalization.NumberStyles> перечисления. Следующие <xref:System.Globalization.NumberStyles> члены не поддерживаются:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>Параметр может содержать, `provider`или дляязыкаирегиональныхпараметров,заданныхпараметром.<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> `s` В зависимости от значения `style`, оно также может принимать форму:  
  
 [*WS*] [*$*] [*знак*] [*цифры целой и дробной*части],*целая-цифры*[. [ *дробные цифры*]] [E [*знак*]*экспоненциальные цифры*] [*WS*]  
  
 Элементы, заключенные в квадратные скобки ([и]), являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Последовательность пробельных символов. Пробел может `s` присутствовать в начале, если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> флаг, `s` и может <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> находиться в конце, если `style` включает флаг.|  
|$|Символ валюты, зависящий от языка и региональных параметров. Его расположение в строке определяется <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> свойствами и <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> текущего языка и региональных параметров. Символ валюты текущего языка и региональных параметров может отображаться `s` в `style` , если <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> включает флаг.|  
|*sign*|Знак отрицательного знака (-) или знак плюс (+). Знак может `s` присутствовать в начале, если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> флаг, `s` и может <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> находиться в конце, если `style` включает флаг. Круглые скобки могут использоваться в `s` , чтобы указать отрицательное значение `style` , если <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> включает флаг.|  
|*целые числа*|Последовательность цифр от 0 до 9, указывающих целую часть числа. Элемент с *целочисленными цифрами* может отсутствовать, если строка содержит элемент *дробной разрядности* .|  
|,|Разделитель групп, зависящий от языка и региональных параметров. Символ разделителя групп текущего языка и региональных параметров может отображаться `s` в `style` , если <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> включает флаг|  
|.|Символ десятичной запятой, зависящий от языка и региональных параметров. Символ десятичной запятой текущего языка и региональных параметров может `s` присутствовать в <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> , если `style` включает флаг.|  
|*Дробные разряды*|Последовательность цифр от 0 до 9, которая указывает дробную часть числа. Дробные цифры могут присутствовать `s` в `style` , <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> если включает флаг.|  
|E|Символ "e" или "E", указывающий, что значение представлено в экспоненциальной (экспоненциальной) нотации. Параметр может представлять число в экспоненциальной нотации, `style` <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> если включает флаг. `s`|  
|*экспоненциальные цифры*|Последовательность цифр от 0 до 9, указывающая показатель степени.|  
  
> [!NOTE]
> Все завершающие символы NUL (U + 0000) в `s` игнорируются операцией синтаксического анализа, независимо от значения `style` аргумента.

 Строка с цифрами (которая соответствует <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> стилю) всегда будет успешно проанализирована. Остальные <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> элементы управляют элементами управления, которые могут присутствовать, но не обязательно должны присутствовать во входной строке. В следующей таблице показано, как <xref:System.Globalization.NumberStyles> отдельные флаги влияют на элементы, которые могут `s`присутствовать в.  
  
|Значение NumberStyles|Элементы, разрешенные в `s` в дополнение к цифрам|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Только элемент с *целыми цифрами* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Элементы десятичной запятой (*.*) и *дробные разряды* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Символ "e" или "E", который указывает на экспоненциальную нотацию. Этот флаг сам по себе поддерживает значения в виде *цифр*E*цифр*. Дополнительные флаги необходимы для успешного анализа строк с такими элементами, как знаки плюса или минуса и символы десятичной запятой.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Элемент *WS* в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Элемент *WS* в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Элемент *Sign* в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Элемент *Sign* в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Элемент *Sign* в виде круглых скобок, охватывающих числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Элемент разделителя тысяч (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Элемент Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Все элементы. `s` Однако не может представлять шестнадцатеричное число или число в экспоненциальной нотации.|  
|<xref:System.Globalization.NumberStyles.Float>|Элемент *WS* в начале или конце `s`, ** `s`знак в начале и символ десятичной запятой (.). `s` Параметр также может использовать экспоненциальную нотацию.|  
|<xref:System.Globalization.NumberStyles.Number>|Элементы `ws` ,`sign`, тысячные разделители (,) и десятичные точки (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Все элементы. `s` Однако не может представлять шестнадцатеричное число.|  
  
 `provider` Параметр<xref:System.IFormatProvider> является реализацией. Его <xref:System.IFormatProvider.GetFormat%2A> метод `value`возвращает объект, предоставляющий сведения о формате для определенного языка и региональных параметров. <xref:System.Globalization.NumberFormatInfo> Как правило `provider` , может принимать одно из следующих действий:  
  
-   <xref:System.Globalization.CultureInfo> Объект, представляющий язык и региональные параметры, которые предоставляют сведения о форматировании чисел. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> метод<xref:System.Globalization.NumberFormatInfo> возвращает объект, предоставляющий сведения о форматировании чисел.  
  
-   <xref:System.Globalization.NumberFormatInfo> Объект, предоставляющий сведения о форматировании. (Его реализация <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам себя.)  
  
-   Пользовательский объект, реализующий <xref:System.IFormatProvider> интерфейс и <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> использующий метод для <xref:System.Globalization.NumberFormatInfo> создания экземпляра и возврата объекта, предоставляющего сведения о форматировании.  
  
 Если `provider` параметр `null`имеет значение <xref:System.Globalization.NumberFormatInfo> , используется объект для текущего языка и региональных параметров.  
  
 Если в `s` параметре во время операции синтаксического анализа встречается разделитель, а применимые разделители денежных единиц или десятичного числа и групп совпадают, то операция синтаксического анализа предполагает, что разделитель является десятичным разделителем, а не группой. двоеточи. <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>Дополнительные сведения о разделителях см. <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>в разделе <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>,, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> метод используется для синтаксического анализа строковых <xref:System.Single> представлений значений. Каждая строка в массиве анализируется с помощью соглашений о форматировании en-US, nl-NL и пользовательского языка и региональных параметров. Пользовательский язык и региональные параметры определяют символ разделителя группы в качестве символа подчеркивания ("_") и размера группы как два.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Параметр <paramref name="s" /> не представляет числовое значение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  
  
- или - 
 <paramref name="style" /> является значением <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException">Параметр <paramref name="s" /> представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Синтаксический анализ числовых строк в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : single" Usage="System.single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Представляет плюс бесконечность. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы является результатом деления положительного числа на ноль.  
  
 Эта константа возвращается, если результат операции больше <xref:System.Single.MaxValue>.  
  
 Используйте <xref:System.Single.IsPositiveInfinity%2A> , чтобы определить, является ли значение положительным бесконечностью.  
  
   
  
## Examples  
 В следующем примере кода показана <xref:System.Single.PositiveInfinity> константа.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" />, если значение текущего экземпляра не равно нулю; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType> вызов метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType> вызов метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Данное преобразование не поддерживается. При попытке использовать этот метод выбрасывается исключение <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Данное преобразование не поддерживается. Возвращаемое значение отсутствует.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Во всех случаях.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Данное преобразование не поддерживается. При попытке использовать этот метод выбрасывается исключение <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Данное преобразование не поддерживается. Возвращаемое значение отсутствует.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Во всех случаях.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType> вызов метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType> вызов метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType> вызов метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType> вызов метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType> вызов метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType> вызов метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, не измененное.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип, к которому необходимо привести это значение <see cref="T:System.Single" />.</param>
        <param name="provider">Объект, предоставляющий сведения о формате возвращаемого значения.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является `static` вызов`Shared` метода (в <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType> вызов метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType> вызов метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType> вызов метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразовывает числовое значение данного экземпляра в эквивалентное ему строковое представление.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="single.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразовывает числовое значение данного экземпляра в эквивалентное ему строковое представление.</summary>
        <returns>Строковое представление значения этого экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString> Метод<xref:System.Single> форматирует значение в формате по умолчанию ("G" или "общий") текущего языка и региональных параметров. Если необходимо указать другой формат или язык и региональные параметры, используйте другие перегрузки <xref:System.Single.ToString%2A> метода следующим образом:  
  
|Использование формата|Для языка и региональных параметров|Использование перегрузки|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию ("G")|Конкретный язык и региональные параметры|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Конкретный формат|Культура по умолчанию (текущий)|<xref:System.Single.ToString%28System.String%29>|  
|Конкретный формат|Конкретный язык и региональные параметры|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>или строкой вида:  
  
 [знак] целочисленные цифры [. [ дробные цифры]] [e [знак] экспоненциальные цифры]  
  
 Необязательные элементы заключены в квадратные скобки ([и]). Элементы, содержащие термин "цифры", состоят из ряда числовых символов в диапазоне от 0 до 9. В следующей таблице перечислены все элементы.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*sign*|Знак отрицательного или положительного знака.|  
|*целые числа*|Последовательность цифр, указывающих целую часть числа. Целочисленные цифры могут отсутствовать, если есть дробные разряды.|  
|'.'|Символ десятичной запятой, зависящий от языка и региональных параметров.|  
|*Дробные разряды*|Последовательность цифр, указывающая дробную часть числа.|  
|&|Символ нижнего регистра "e", указывающий экспоненциальную (экспоненциальную) нотацию.|  
|*экспоненциальные цифры*|Последовательность цифр, указывающая показатель степени.|  
  
 Примеры возвращаемых значений: "100", "-123 456 789", "123,45 e + 6", "500", "3,1416", "600", "-0,123" и "-Infinity".  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования:  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере используется метод по <xref:System.Single.ToString%2A?displayProperty=nameWithType> умолчанию для отображения строкового представления <xref:System.Single> количества значений.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 В следующем примере кода показано использование <xref:System.Single.Parse%28System.String%29> метода вместе <xref:System.Single.ToString> с методом.  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="single.ToString provider" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <summary>Преобразует числовое значение данного экземпляра в эквивалентное ему строковое представление с использованием указанных сведений об особенностях форматирования для данного языка и региональных параметров.</summary>
        <returns>Строковое представление значения данного экземпляра, определяемое параметром <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.IFormatProvider%29> Метод<xref:System.Single> форматирует значение в формате по умолчанию ("G" или "общий") указанного языка и региональных параметров. Если необходимо указать другой формат или текущий язык и региональные параметры, используйте другие перегрузки <xref:System.Single.ToString%2A> метода следующим образом:  
  
|Использование формата|Для языка и региональных параметров|Использование перегрузки|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию ("G")|Культура по умолчанию (текущий)|<xref:System.Single.ToString>|  
|Конкретный формат|Культура по умолчанию (текущий)|<xref:System.Single.ToString%28System.String%29>|  
|Конкретный формат|Конкретный язык и региональные параметры|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>или строкой вида:  
  
 [знак] целочисленные цифры [. [ дробные цифры]] [e [знак] экспоненциальные цифры]  
  
 Необязательные элементы заключены в квадратные скобки ([и]). Элементы, содержащие термин "цифры", состоят из ряда числовых символов в диапазоне от 0 до 9. В следующей таблице перечислены все элементы.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|sign|Знак отрицательного или положительного знака.|  
|целые числа|Последовательность цифр, указывающих целую часть числа. Целочисленные цифры могут отсутствовать, если есть дробные разряды.|  
|'.'|Символ десятичной запятой, зависящий от языка и региональных параметров.|  
|Дробные разряды|Последовательность цифр, указывающая дробную часть числа.|  
|&|Символ нижнего регистра "e", указывающий экспоненциальную (экспоненциальную) нотацию.|  
|экспоненциальные цифры|Последовательность цифр, указывающая показатель степени.|  
  
 Примеры возвращаемых значений: "100", "-123 456 789", "123,45 e + 6", "500", "3,1416", "600", "-0,123" и "-Infinity".  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования:  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Параметр — это <xref:System.IFormatProvider.GetFormat%2A>реализация, метод которой возвращает объект.<xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider> `provider` Как правило `provider` , <xref:System.Globalization.CultureInfo> является объектом или <xref:System.Globalization.NumberFormatInfo> объектом. Параметр `provider` предоставляет сведения о языке и региональных параметрах, используемые при форматировании. Если `provider` параметр `null` имеет<xref:System.Globalization.NumberFormatInfo> значение, возвращаемые значения форматируются с использованием данных для текущего языка и региональных параметров.  
  
 Чтобы преобразовать <xref:System.Single> значение в строковое представление с помощью указанного языка и региональных параметров и определенной строки формата, <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> вызовите метод.  
  
   
  
## Examples  
 В следующем примере показано строковое представление двух <xref:System.Single> значений с помощью <xref:System.Globalization.CultureInfo> объектов, представляющих различные языки и региональные параметры.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="single.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Строка числового формата.</param>
        <summary>Преобразует числовое значение данного экземпляра в эквивалентное строковое представление с использованием указанного формата.</summary>
        <returns>Строковое представление значения данного экземпляра, определяемое параметром <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.String%29> Метод<xref:System.Single> форматирует значение в указанном формате, используя правила текущего языка и региональных параметров. Если вы хотите использовать формат по умолчанию ("G" или "общий") или указать другой язык и региональные параметры, используйте другие перегрузки <xref:System.Single.ToString%2A> метода следующим образом:  
  
|Использование формата|Для языка и региональных параметров|Использование перегрузки|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию ("G")|Культура по умолчанию (текущий)|<xref:System.Single.ToString>|  
|Формат по умолчанию ("G")|Конкретный язык и региональные параметры|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Конкретный формат|Конкретный язык и региональные параметры|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>или строковым представлением значения текущего экземпляра, как указано в `format`.  
  
 `format` Параметр может быть любым допустимым описателем стандартного числового формата, за исключением D и X, а также любого сочетания настраиваемых описателей числового формата. Если параметр format `null` имеет значение или является пустой строкой, то возвращаемый результат форматируется с помощью описателя общего числового формата ("G").  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования:  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 По умолчанию возвращаемое значение содержит только 7 цифр точности, хотя для внутренних целей поддерживается не более 9 цифр. Если значение этого экземпляра превышает 7 цифр, <xref:System.Single.ToString%28System.String%29> возвращает <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> или <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> вместо ожидаемого числа. Если требуется дополнительная точность, укажите `format` с помощью спецификации формата "G9", которая всегда возвращает 9 разрядов точности, или "R", который возвращает 7 цифр, если число может быть представлено в точности или 9 цифр, если число может быть представлено только с максимальной точностью.  
  
   
  
## Examples  
 В следующем примере определяется числовое значение и форматируется как денежное значение с помощью строки стандартного числового формата "C", а в качестве числового значения для трех десятичных разрядов используется строка стандартного числового формата "N". Строки результатов форматируются с помощью соглашений языка и региональных параметров en-US. Дополнительные сведения о строках числового формата см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 В следующем примере показано несколько <xref:System.Single> значений, использующих каждый из поддерживаемых стандартных описателей числового формата вместе с двумя строками настраиваемого числового формата. Одна из этих строк настраиваемого формата показывает, как заполнить <xref:System.Single> значение начальными нулями. При преобразовании числовых значений в строки в примере используются соглашения о форматировании для языка и региональных параметров en-US.  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Практическое руководство. Добавление к числу начальных нулей.</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="single.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Строка числового формата.</param>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <summary>Преобразует числовое значение данного экземпляра в эквивалентное ему строковое представление с использованием указанного формата и сведений об особенностях форматирования для данного языка и региональных параметров.</summary>
        <returns>Строковое представление значения данного экземпляра, определяемое параметрами <paramref name="format" /> и <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29> Метод<xref:System.Single> форматирует значение в указанном формате указанного языка и региональных параметров. Если вы хотите использовать формат по умолчанию или параметры языка и региональных параметров, используйте другие перегрузки <xref:System.Single.ToString%2A> метода следующим образом:  
  
|Использование формата|Для языка и региональных параметров|Использование перегрузки|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию ("G")|Культура по умолчанию (текущий)|<xref:System.Single.ToString>|  
|Формат по умолчанию ("G")|Конкретный язык и региональные параметры|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Конкретный формат|Культура по умолчанию (текущий)|<xref:System.Single.ToString%28System.String%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>или строковым представлением значения текущего экземпляра, как указано в `format`.  
  
 `format` Параметр может быть любым допустимым описателем стандартного числового формата, за исключением D и X, а также любого сочетания настраиваемых описателей числового формата. Если `format` параметр `null` имеет значение или является пустой строкой, то возвращаемые значения для этого экземпляра форматируются с помощью описателя общего числового формата ("G").  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования:  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Параметр — это <xref:System.IFormatProvider.GetFormat%2A>реализация, метод которой возвращает объект.<xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider> `provider` Как правило `provider` , <xref:System.Globalization.CultureInfo> является объектом или <xref:System.Globalization.NumberFormatInfo> объектом. Параметр `provider` предоставляет сведения о языке и региональных параметрах, используемые при форматировании. Если `provider` параметр `null` имеет<xref:System.Globalization.NumberFormatInfo> значение, возвращаемое значения форматируется с помощью объекта для текущего языка и региональных параметров.  
  
 По умолчанию возвращаемое значение содержит только 7 цифр точности, хотя для внутренних целей поддерживается не более 9 цифр. Если значение этого экземпляра превышает 7 цифр, <xref:System.Single.ToString%2A> возвращает <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> или <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> вместо ожидаемого числа. Если требуется дополнительная точность, укажите `format` с помощью спецификации формата "G9", которая всегда возвращает 9 разрядов точности, или "R", который возвращает 7 цифр, если число может быть представлено в точности или 9 цифр, если число может быть представлено только с максимальной точностью.  
  
   
  
## Examples  
 В следующем примере отображается <xref:System.Single> значение с использованием каждого из поддерживаемых стандартных описателей числового формата для нескольких различных языков и региональных параметров.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Практическое руководство. Добавление к числу начальных нулей.</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="single.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует строковое представление числа в эквивалентное ему число с плавающей запятой одиночной точности. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <altmember cref="Overload:System.Single.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * single -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * single -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Строка, представляющая преобразуемое число.</param>
        <param name="result">Когда этот метод возвращает значение, оно содержит эквивалент числового значения или символа, содержащегося в параметре <paramref name="s" />, представленный в виде числа с плавающей запятой одиночной точности, если преобразование прошло успешно, или нуль, если произошел сбой преобразования. Преобразование завершается сбоем, если значение параметра <paramref name="s" /> равно <see langword="null" /> или <see cref="F:System.String.Empty" />, не является числом допустимого формата или представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />. Этот параметр передается неинициализированным; любое значение, первоначально предоставленное в <paramref name="result" />, будет перезаписано.</param>
        <summary>Преобразует строковое представление числа в эквивалентное ему число с плавающей запятой одиночной точности. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="s" /> успешно преобразован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отличается от <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType> метода путем возвращения логического значения, которое указывает, завершилась ли операция синтаксического анализа, а не возвращать проанализированное числовое значение. Это исключает необходимость использования обработки исключений для проверки <xref:System.FormatException> в случае, `s` если событие является недопустимым и его невозможно успешно проанализировать.  
  
 Параметр может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> ,<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (сравнение строк учитывает регистр) или строку в формате: `s`  
  
 Протокол писать [целые числа,] целые цифры [. [ дробные цифры]] [e [знак] экспоненциальные цифры] [ws]  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Последовательность пробельных символов.|  
|*sign*|Знак отрицательного или положительного знака.|  
|*целые числа*|Последовательность числовых символов в диапазоне от 0 до 9, которые указывают целую часть числа. Целочисленные цифры могут отсутствовать, если есть дробные разряды.|  
|*,*|Символ разделителя группы, зависящий от языка и региональных параметров.|  
|*.*|Символ десятичной запятой, зависящий от языка и региональных параметров.|  
|*Дробные разряды*|Последовательность числовых символов в диапазоне от 0 до 9, которые указывают дробную часть числа.|  
|*E*|Прописная или строчная буква "e", которая указывает на экспоненциальную (экспоненциальную) нотацию.|  
|*экспоненциальные цифры*|Последовательность числовых символов в диапазоне от 0 до 9, задающих показатель степени.|  
  
 Параметр интерпретируется с помощью сочетания <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> флагов и <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>. `s` Это означает, что пробелы и разделители групп разрядов разрешены, а символы валют — нет. Чтобы явно определить элементы (например, символы валют, разделители тысяч и пробелы), которые могут присутствовать в `s`, <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> используйте перегрузку метода.  
  
 Параметр анализируется с помощью сведений о форматировании <xref:System.Globalization.NumberFormatInfo> в объекте, инициализированном для текущего языка и региональных параметров системы. `s` Для получения дополнительной информации см. <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Чтобы выполнить синтаксический анализ строки, используя сведения о форматировании некоторых других указанных региональных <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> параметров, используйте перегрузку метода.  
  
 Обычно, если передать <xref:System.Single.TryParse%2A?displayProperty=nameWithType> методу строку, созданную путем <xref:System.Single.ToString%2A?displayProperty=nameWithType> вызова метода, возвращается исходное <xref:System.Single> значение. Однако из-за потери точности значения могут не совпадать.  
  
 Если в `s` параметре во время операции синтаксического анализа встречается разделитель, а применимые разделители денежных единиц или десятичного числа и групп совпадают, то операция синтаксического анализа предполагает, что разделитель является десятичным разделителем, а не группой. двоеточи. <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>Дополнительные сведения о разделителях см. <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>в разделе <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>,, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29> метод используется для преобразования строковых представлений числовых значений в <xref:System.Single> значения. Предполагается, что en-US является текущим языком и региональными параметрами.  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Синтаксический анализ числовых строк в .NET</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * single -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * single -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Строка, представляющая преобразуемое число.</param>
        <param name="style">Побитовая комбинация значений перечисления, которая показывает разрешенный формат параметра <paramref name="s" />. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <paramref name="s" /> в зависимости от языка и региональных параметров.</param>
        <param name="result">Когда этот метод возвращает значение, оно содержит эквивалент числового значения или символа, содержащегося в параметре <paramref name="s" />, представленный в виде числа с плавающей запятой одиночной точности, если преобразование прошло успешно, или нуль, если произошел сбой преобразования. Преобразование завершается неудачно, если параметр <paramref name="s" /> имеет значение <see langword="null" /> или <see cref="F:System.String.Empty" />, не является значением в формате, совместимом с параметром <paramref name="style" />, представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />, либо если <paramref name="style" /> не является допустимой комбинацией перечисленных констант <see cref="T:System.Globalization.NumberStyles" />. Этот параметр передается неинициализированным; любое значение, первоначально предоставленное в <paramref name="result" />, будет перезаписано.</param>
        <summary>Преобразует строковое представление числа в указанном стиле и с использованием формата, соответствующего данному языку и региональным параметрам, в эквивалентное ему число с плавающей запятой одиночной точности. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="s" /> успешно преобразован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отличается от <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> метода путем возвращения логического значения, которое указывает, завершилась ли операция синтаксического анализа, а не возвращать проанализированное числовое значение. Это исключает необходимость использования обработки исключений для проверки <xref:System.FormatException> в случае, `s` если событие является недопустимым и его невозможно успешно проанализировать.  
  
 Параметр определяет допустимый формат `s` параметра для выполнения операции синтаксического анализа. `style` Он должен представлять собой сочетание битовых флагов из <xref:System.Globalization.NumberStyles> перечисления. Следующие <xref:System.Globalization.NumberStyles> члены не поддерживаются:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>Параметр может содержать, `provider`, дляязыкаирегиональныхпараметров,указанныхв<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>. `s` Кроме того, в зависимости от значения `style` `s` параметр может включать следующие элементы:  
  
 Протокол [$] писать [целые числа,] целочисленные цифры [. дробные цифры] [e [знак] экспоненциальные цифры] [ws]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Необязательный пробел. Пробелы могут присутствовать в начале `s` , если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> флаг. Он может находиться в конце `s` , если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> флаг.|  
|*$*|Символ валюты, зависящий от языка и региональных параметров. Его <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> расположение в строке определяется свойствами <xref:System.Globalization.NumberFormatInfo> или <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> объекта, возвращаемыми <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> методом `provider` параметра. Символ валюты может отображаться в `s` , <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> если `style` включает флаг.|  
|*sign*|Необязательный знак. Знак может `s` присутствовать в начале, если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> флаг, `s` и может <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> находиться в конце, если `style` включает флаг. Круглые скобки могут использоваться в `s` , чтобы указать отрицательное значение `style` , если <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> включает флаг.|  
|*целые числа*|Последовательность цифр от 0 до 9, указывающих целую часть числа. Целочисленные цифры могут отсутствовать, если есть дробные разряды.|  
|*,*|Символ разделителя тысяч, зависящий от языка и региональных параметров. Символ разделителя тысяч текущего языка и региональных параметров может отображаться `s` в `style` , если <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> включает флаг.|  
|*.*|Символ десятичной запятой, зависящий от языка и региональных параметров. Символ десятичной запятой текущего языка и региональных параметров может `s` присутствовать в <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> , если `style` включает флаг.|  
|*Дробные разряды*|Последовательность цифр от 0 до 9, которая указывает дробную часть числа. Дробные цифры могут присутствовать `s` в `style` , <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> если включает флаг.|  
|*e*|Символ e или e, который указывает, что `s` может представлять число, используя экспоненциальную нотацию. Параметр может представлять число в экспоненциальной нотации, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> если стиль включает флаг. `s`|  
|*экспоненциальные цифры*|Последовательность цифр от 0 до 9, указывающая показатель степени.|  
  
> [!NOTE]
> Все завершающие символы NUL (U + 0000) в `s` игнорируются операцией синтаксического анализа, независимо от значения `style` аргумента.

 Строка с цифрами (которая соответствует <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> стилю) всегда будет успешно проанализирована. Остальные <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> элементы управляют элементами, которые могут быть, но не обязательно присутствовать во входной строке. В следующей таблице показано, как <xref:System.Globalization.NumberStyles> отдельные флаги влияют на элементы, которые могут `s`присутствовать в.  
  
|Значение NumberStyles|Элементы, разрешенные в s в дополнение к цифрам|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Только элемент с *целыми цифрами* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Языковой элемент *.* и *дробные разрядные* элементы.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s` Параметр также может использовать экспоненциальную нотацию. Этот флаг сам по себе поддерживает значения в виде*экспоненциальных*разрядов E- *цифр*. Дополнительные флаги необходимы для успешного анализа строк в экспоненциальной нотации с такими элементами, как положительные или отрицательные знаки и символы десятичной запятой.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Элемент *WS* в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Элемент *WS* в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Элемент *Sign* в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Элемент *Sign* в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Элемент *Sign* в виде круглых скобок, охватывающих числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Элемент *,* .|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|*$* Элемент.|  
|<xref:System.Globalization.NumberStyles.Currency>|Все. `s` Параметр не может представлять шестнадцатеричное число или число в экспоненциальной нотации.|  
|<xref:System.Globalization.NumberStyles.Float>|Элемент *WS* в начале или конце `s` `s`, *знак* в начале и *.* знак. `s` Параметр также может использовать экспоненциальную нотацию.|  
|<xref:System.Globalization.NumberStyles.Number>|Элементы `ws` ,`sign`, тысячные разделители (*,)* и десятичные точки (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Все стили, кроме `s` , не могут представлять шестнадцатеричное число.|  
  
 Параметр — это <xref:System.IFormatProvider.GetFormat%2A>реализация, метод которой возвращает объект,предоставляющийсведенияобособенностяхформатирования,связанныхсязыкомирегиональнымипараметрами.<xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider> `provider` <xref:System.Type> `provider` <xref:System.IFormatProvider.GetFormat%2A> При вызове метода он вызывает метод параметра<xref:System.Globalization.NumberFormatInfo> и передает ему объект, представляющий тип. <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> Затем метод возвращает объект, предоставляющий сведения `s` о формате параметра. <xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider.GetFormat%2A> Существует три способа использования `provider` параметра для предоставления сведений о пользовательском форматировании операции синтаксического анализа:  
  
-   Можно передать <xref:System.Globalization.CultureInfo> объект, представляющий язык и региональные параметры, которые предоставляют сведения о форматировании. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> метод<xref:System.Globalization.NumberFormatInfo> возвращает объект, предоставляющий сведения о форматировании числовых значений для этого языка и региональных параметров.  
  
-   Можно передать фактический <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании чисел. (Его реализация <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам себя.)  
  
-   Можно передать пользовательский объект, реализующий интерфейс <xref:System.IFormatProvider>. Его <xref:System.IFormatProvider.GetFormat%2A> метод создает экземпляр и <xref:System.Globalization.NumberFormatInfo> возвращает объект, предоставляющий сведения о форматировании.  
  
 Если `provider` имеет `null`значение, форматирование `s` интерпретируется на основе <xref:System.Globalization.NumberFormatInfo> объекта текущего языка и региональных параметров.  
  
 Если в `s` параметре во время операции синтаксического анализа встречается разделитель, а применимые разделители денежных единиц или десятичного числа и групп совпадают, то операция синтаксического анализа предполагает, что разделитель является десятичным разделителем, а не группой. двоеточи. <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>Дополнительные сведения о разделителях см. <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>в разделе <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>,, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType> метода для синтаксического анализа строкового представления чисел с определенным стилем и форматирования с использованием соглашений определенного языка и региональных параметров.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  
  
-или- 
 Значение параметра <paramref name="style" /> равно значению <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Синтаксический анализ числовых строк в .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
