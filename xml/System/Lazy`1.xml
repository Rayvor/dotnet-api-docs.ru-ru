<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5db16a3e2e391e606bff8cafb5a24c5c3f82c143" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68398327" /></Metadata><TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">тип объекта, который неактивно инициализируется.</typeparam>
    <summary>Обеспечивает поддержку неактивной инициализации.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте отложенную инициализацию, чтобы отложить создание большого или ресурсоемкиго объекта или выполнение ресурсоемких задач, особенно если такое создание или выполнение может не произойти в течение всего времени существования программы.  
  
 Чтобы подготовиться к отложенной инициализации, создайте экземпляр <xref:System.Lazy%601>. Аргумент типа создаваемого <xref:System.Lazy%601> объекта указывает тип объекта, который требуется инициализировать отложенно. Конструктор, используемый для создания <xref:System.Lazy%601> объекта, определяет характеристики инициализации. Отложенная инициализация производится при первом обращении к свойству <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>.  
  
 В большинстве случаев выбор конструктора зависит от ответов на два вопроса:  
  
-   Будет ли доступ к объекту с отложенной инициализацией осуществляться из более чем одного потока? Если да, то <xref:System.Lazy%601> объект может создать его в любом потоке. Можно использовать один из простых конструкторов, поведением по умолчанию которых является создание потокобезопасного <xref:System.Lazy%601> объекта, чтобы создавался только один экземпляр объекта с отложенным созданием экземпляров, независимо от того, сколько потоков пытается получить к нему доступ. Чтобы создать <xref:System.Lazy%601> объект, который не является потокобезопасным, необходимо использовать конструктор, который позволяет указать отсутствие потокобезопасности.  
  
    > [!CAUTION]
    >  Обеспечение безопасности <xref:System.Lazy%601> объектного потока не защищает объект с отложенной инициализацией. Если несколько потоков могут получить доступ к объекту с отложенной инициализацией, необходимо сделать его свойства и методы надежными для многопоточного доступа.  
  
-   Если отложенная инициализация требует большого объема кода или если у отложенно инициализированного объекта есть конструктор без параметров, который выполняет все необходимые действия и не создает исключения? Если необходимо написать код инициализации или необходимо обработать исключения, используйте один из конструкторов, которые принимают фабричный метод. Напишите код инициализации в фабричном методе.  
  
 В следующей таблице показано, какой конструктор выбрать в зависимости от этих двух факторов.  
  
|Доступ к объекту будет осуществляться|Если код инициализации не требуется (конструктор без параметров), используйте|Если требуется код инициализации, используйте|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Несколько потоков|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Один поток|<xref:System.Lazy%601.%23ctor%28System.Boolean%29>с `isThreadSafe`параметром. `false`|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>с `isThreadSafe`параметром. `false`|  
  
 Для указания фабричного метода можно использовать лямбда-выражение. Это позволяет хранить весь код инициализации в одном месте. Лямбда-выражение фиксирует контекст, включая любые аргументы, передаваемые в конструктор отложенно инициализированного объекта.  
  
 **Кэширование исключений** При использовании фабричных методов исключения кэшируются. Это значит, что если метод фабрики создает исключение при первом обращении потока к <xref:System.Lazy%601.Value%2A> свойству <xref:System.Lazy%601> объекта, то то же самое исключение возникает при каждой последующей попытке. Это гарантирует, что каждый вызов <xref:System.Lazy%601.Value%2A> свойства приведет к одному и тому же результату и избежать незначительных ошибок, которые могут возникать, если разные потоки получают разные результаты. Он <xref:System.Lazy%601> означает фактическое `T` значение, которое в противном случае было бы инициализировано в более ранней точке, обычно во время запуска. Сбой в более ранней точке обычно является неустранимой. Если есть вероятность возможного сбоя, рекомендуется создать логику повторных попыток в подпрограммы инициализации (в данном случае — фабричном методе), точно так же, как если бы вы не использовали отложенную инициализацию.  
  
 **Альтернатива блокировке** В некоторых ситуациях может возникнуть необходимость избежать издержек, обусловленных <xref:System.Lazy%601> поведением блокировки по умолчанию объекта. В редких ситуациях возможны взаимоблокировки. В таких случаях можно использовать <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> конструктор или <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> и указать <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Это позволяет <xref:System.Lazy%601> объекту создать копию отложенно инициализированного объекта в каждом из нескольких потоков, если потоки <xref:System.Lazy%601.Value%2A> вызывают свойство одновременно. <xref:System.Lazy%601> Объект гарантирует, что все потоки будут использовать один и тот же экземпляр объекта с отложенной инициализацией и отбрасывают неиспользуемые экземпляры. Таким образом, стоимость снижения затрат на блокировку заключается в том, что программа может иногда создавать и удалять дополнительные копии дорогостоящего объекта. В большинстве случаев это маловероятно. Примеры для <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> конструкторов и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> демонстрируют это поведение.  
  
> [!IMPORTANT]
>  При указании <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>исключения никогда не кэшируются, даже если указан фабричный метод.  
  
 **Эквивалентные конструкторы** В дополнение к включению использования <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> конструкторы и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> могут дублировать функциональность других конструкторов. В следующей таблице приведены значения параметров, которые создают эквивалентное поведение.  
  
|Создание <xref:System.Lazy%601> объекта, который|Для конструкторов, имеющих `LazyThreadSafetyMode` `mode` параметр, задайте для `mode` значение|Для конструкторов, имеющих логический `isThreadSafe` параметр, задайте для значение `isThreadSafe`|Для конструкторов без параметров безопасности потока|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Полностью потокобезопасный; использует блокировку, чтобы гарантировать, что только один поток инициализирует значение.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Все такие конструкторы являются полностью потокобезопасными.|  
|Не является потокобезопасным.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Неприменимо.|  
|Полностью потокобезопасный; потоки, которые инициализируют значение.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Неприменимо.|Неприменимо.|  
  
 **Другие возможности** Сведения об использовании <xref:System.Lazy%601> с полями static потока или в качестве резервного хранилища для свойств см. в разделе [Отложенная инициализация](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Lazy%601> класса для обеспечения отложенной инициализации с доступом из нескольких потоков.  
  
> [!NOTE]
>  В примере используется <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> конструктор. Также демонстрируется использование конструктора (с <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> `true` указанием для `isThreadSafe`) и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> конструктора (с указанием <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`). Чтобы переключиться на другой конструктор, просто измените конструкторы, которые заносятся в комментарий.  
>   
>  Пример, демонстрирующий кэширование исключений с помощью тех же конструкторов, см <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> . в разделе Конструктор.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Четыре ключевых раздела кода иллюстрируют создание инициализатора, фабричный метод, фактическую инициализацию и конструктор `LargeObject` класса, который отображает сообщение при создании объекта. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 Метод Factory показывает создание объекта с заполнительом для дальнейшей инициализации:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Обратите внимание, что первые два раздела кода можно объединить с помощью лямбда-функции, как показано ниже:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 В этом примере приостанавливается, чтобы указать, что неопределенный период может пройти до возникновения отложенной инициализации. При нажатии клавиши **Ввод** в примере создаются и запускаются три потока. Метод, используемый всеми тремя потоками, <xref:System.Lazy%601.Value%2A> вызывает свойство. `ThreadProc` В первый раз происходит `LargeObject` создание экземпляра:  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Конструктор `LargeObject` класса, который включает последний ключевой раздел кода, отображает сообщение и записывает идентификатор инициализации потока. Выходные данные программы отображаются в конце полного листинга кода.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>По умолчанию все открытые и защищенные члены <see cref="T:System.Lazy`1" /> класса являются потокобезопасными и могут использоваться одновременно из нескольких потоков. Эти гарантии безопасности потоков могут быть удалены дополнительно и для каждого экземпляра с помощью параметров для конструкторов типа.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />. При неактивной инициализации используется конструктор целевого типа без параметров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр, созданный с помощью этого конструктора, может использоваться одновременно из нескольких потоков.  
  
 В <xref:System.Lazy%601> экземпляре, инициализированном с помощью этого конструктора, используется <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>режим потокобезопасности. Режим безопасности потока описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляр.  
  
 <xref:System.Lazy%601> Экземпляр, созданный с помощью этого конструктора, не кэширует исключения. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого конструктора. Также показано использование конструктора (с <xref:System.Lazy%601.%23ctor%28System.Boolean%29> указанием `true` для `isThreadSafe`) и <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> конструктора (с указанием <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`). Чтобы переключиться на другой конструктор, просто измените конструкторы, которые заносятся в комментарий.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Двумя ключевыми строками кода в этом примере являются создание инициализатора и фактическая инициализация. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 В примере создаются и запускаются три потока, которые блокируют <xref:System.Threading.ManualResetEvent> объект, чтобы в примере можно было освободить все потоки одновременно. Метод, используемый всеми тремя потоками, <xref:System.Lazy%601.Value%2A> вызывает свойство для получения `LargeObject` экземпляра: `ThreadProc`  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 Класс обеспечивает блокировку, поэтому только одному потоку разрешено `LargeObject` создавать экземпляр. <xref:System.Lazy%601> В примере показано, что все остальные потоки получают один и тот же экземпляр.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">Значение <see langword="true" />, если необходимо разрешить параллельное использование этого экземпляра несколькими потоками; значение <see langword="false" />, если необходимо разрешить одновременное использование этого экземпляра только одним потоком.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />. При неактивной инициализации используются конструктор целевого типа без параметров и заданный режим инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режим <xref:System.Lazy%601> потокобезопасности экземпляра, который инициализируется с помощью этого конструктора, равен <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> , если `isThreadSafe` имеет `true`значение; в противном случае используется <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>режим. Режим безопасности потока описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляр. Чтобы указать <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> режим, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> используйте конструктор или <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> .  
  
 <xref:System.Lazy%601> Экземпляр, созданный с помощью этого конструктора, не кэширует исключения. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого конструктора для создания отложенного инициализатора, который не является потокобезопасным, для сценариев, в которых весь доступ к объекту с отложенной инициализацией происходит в том же потоке. Также демонстрируется использование конструктора (с <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> указанием <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`. Чтобы переключиться на другой конструктор, просто измените конструктор с комментарием.  
  
> [!NOTE]
>  Код, демонстрирующий использование этого конструктора в многопоточных сценариях (с указанием `true` для `isThreadSafe`), <xref:System.Lazy%601.%23ctor> см. в примере для конструктора.  
  
 В примере определяется `LargeObject` класс, который будет инициализирован неактивно. В методе в примере <xref:System.Lazy%601> создается экземпляр, а затем приостанавливается. `Main` При нажатии клавиши **Ввод** выполняется доступ к <xref:System.Lazy%601.Value%2A> свойству <xref:System.Lazy%601> экземпляра, что приводит к инициализации. Конструктор `LargeObject` класса отображает сообщение консоли.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Делегат, вызываемый для получения неактивно инициализированного значения, когда оно требуется.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />. При неактивной инициализации используется заданная функция инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр, созданный с помощью этого конструктора, может использоваться одновременно из нескольких потоков.  
  
 В <xref:System.Lazy%601> экземпляре, инициализированном с помощью этого конструктора, используется <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>режим потокобезопасности. Режим безопасности потока описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляр.  
  
 Исключения, создаваемые `valueFactory` , кэшируются. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого конструктора для обеспечения отложенной инициализации с кэшированием исключений. Также демонстрируется использование конструктора (с <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> `true` указанием для `isThreadSafe`) и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> конструктора (с указанием <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`). Чтобы переключиться на другой конструктор, просто измените конструкторы, которые заносятся в комментарий.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Три ключевых раздела кода иллюстрируют создание инициализатора, фактическую инициализацию и конструктор `LargeObject` класса, который демонстрирует кэширование исключений. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 В примере создаются и запускаются три потока. Метод, используемый всеми тремя потоками, <xref:System.Lazy%601.Value%2A> вызывает свойство для получения `LargeObject` экземпляра: `ThreadProc`  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 В конструкторе `LargeObject` класса третий ключевой раздел кода создает исключение при первом `LargeObject` создании экземпляра, но затем позволяет создать экземпляр:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 При выполнении этого примера первый поток, пытающийся создать экземпляр `LargeObject` , завершается ошибкой, и перехватывается исключение. Вы можете ожидать, что следующий поток будет успешно создавать экземпляр, но <xref:System.Lazy%601> объект кэширует исключение. Из-за этого все три потока создают исключение.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="valueFactory" /> имеет значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mode">Одно из значений перечисления, задающее потокобезопасный режим.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />, который использует конструктор <paramref name="T" /> без параметров и заданный потокобезопасный режим.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режим <xref:System.Lazy%601> потокобезопасности экземпляра описывает поведение, когда несколько потоков пытаются <xref:System.Lazy%601> инициализировать экземпляр.  
  
 <xref:System.Lazy%601> Экземпляр, созданный с помощью этого конструктора, не кэширует исключения. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого конструктора для создания отложенного инициализатора, который позволяет нескольким потокам неактивно создавать объект. Несколько потоков могут успешно создавать экземпляры, но все потоки используют экземпляр, который был создан первым.  
  
> [!NOTE]
>  Пример, демонстрирующий использование этого конструктора в сценариях с одним потоком (с указанием <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`), см. в <xref:System.Lazy%601.%23ctor%28System.Boolean%29> разделе Конструктор. Пример, демонстрирующий использование этого конструктора для предоставления блокировки вместо состояний гонки в многопоточных сценариях (с указанием <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`), см. в <xref:System.Lazy%601.%23ctor> разделе Конструктор.  
  
 В этом примере определяется `LargeObject` класс, который будет инициализирован в пассивном режиме с помощью любого из нескольких потоков. Три ключевых раздела кода иллюстрируют создание инициализатора, фактическую инициализацию, а также конструктор и метод завершения `LargeObject` класса. В начале `Main` метода в примере <xref:System.Lazy%601> создается объект, `LargeObject`выполняющий отложенную инициализацию:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 В примере создаются и запускаются три потока, которые блокируют <xref:System.Threading.ManualResetEvent> объект, чтобы в примере можно было освободить все потоки одновременно. В методе, который используется всеми тремя потоками, <xref:System.Lazy%601.Value%2A> вызов свойства создает `LargeObject` экземпляр: `ThreadProc`  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Поскольку конструктор для <xref:System.Lazy%601> указанного <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>экземпляра, всем трем потокам разрешено создавать `LargeObject` экземпляры. В этом примере показано, как отобразить сообщения консоли в конструкторе и в методе завершения `LargeObject` класса:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 <xref:System.Lazy%601> Однако объект гарантирует, что все потоки используют только один экземпляр. Выходные данные в примере показывают, что все три потока используют один и тот же экземпляр, а также показывают, что другие экземпляры могут быть освобождены при сборке мусора.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Предварительно инициализированное значение для использования.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />, использующий предварительно инициализированное заданное значение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
Экземпляр, созданный с помощью этого конструктора, может использоваться несколькими потоками одновременно.
]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Делегат, вызываемый для получения неактивно инициализированного значения, когда оно требуется.</param>
        <param name="isThreadSafe">Значение <see langword="true" />, если необходимо разрешить параллельное использование этого экземпляра несколькими потоками; значение <see langword="false" />, если необходимо разрешить одновременное использование этого экземпляра только одним потоком.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />. При неактивной инициализации используются заданные функция и режим инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режим <xref:System.Lazy%601> потокобезопасности экземпляра, который инициализируется с помощью этого конструктора, равен <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> , если `isThreadSafe` имеет `true`значение; в противном случае используется <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>режим. Режим безопасности потока описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляр.  
  
 Чтобы указать <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> режим, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> используйте конструктор или <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> .  
  
 Исключения, создаваемые `valueFactory` , кэшируются. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого конструктора для обеспечения отложенной инициализации с кэшированием исключений в сценарии с одним потоком. Также демонстрируется использование конструктора (с <xref:System.Lazy%601.%23ctor%2A> указанием <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`). Чтобы переключиться на этот конструктор, просто измените конструктор с комментарием.  
  
> [!NOTE]
>  Код, демонстрирующий использование этого конструктора в многопоточных сценариях (с указанием `true` для `isThreadSafe`), <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> см. в примере для конструктора.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Три ключевых раздела кода иллюстрируют создание инициализатора, фактическую инициализацию и конструктор `LargeObject` класса, который демонстрирует кэширование исключений. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 В вызове конструктора `isThreadSafe` параметр имеет `false`значение, поэтому <xref:System.Lazy%601> не является потокобезопасным. Так как он не является потокобезопасным, пример вызывает <xref:System.Lazy%601.Value%2A> свойство три раза в том же потоке:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 В конструкторе `LargeObject` класса третий ключевой раздел кода создает исключение при первом `LargeObject` создании экземпляра, но затем позволяет создать экземпляр:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 При выполнении этого примера первая попытка создать экземпляр `LargeObject` завершается ошибкой и перехвачено исключение. Можно ожидать, что следующая попытки будет выполнена успешно, но <xref:System.Lazy%601> объект кэширует исключение. Из-за этого все три попытки вызовут исключение.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="valueFactory" /> имеет значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Делегат, вызываемый для получения неактивно инициализированного значения, когда оно требуется.</param>
        <param name="mode">Одно из значений перечисления, задающее потокобезопасный режим.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />, который использует заданную функцию инициализации и потокобезопасный режим.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режим <xref:System.Lazy%601> потокобезопасности экземпляра описывает поведение, когда несколько потоков пытаются <xref:System.Lazy%601> инициализировать экземпляр.  
  
 Исключения, создаваемые `valueFactory` , кэшируются, если `mode` не <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>имеет параметр. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого конструктора для создания отложенного инициализатора, который позволяет нескольким потокам неактивно создавать объект. Несколько потоков могут успешно создавать экземпляры, но все потоки используют экземпляр, который был создан первым. Кроме того, в примере показано, что исключения никогда не кэшируются при <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>указании, даже если инициализация выполняется функцией, а не с помощью конструктора без параметров для типа с отложенным созданием.  
  
> [!NOTE]
>  Пример, демонстрирующий использование этого конструктора в сценариях с одним потоком (с указанием <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`), см. в <xref:System.Lazy%601.%23ctor%28System.Boolean%29> разделе Конструктор. Пример, демонстрирующий использование этого конструктора для предоставления блокировки вместо состояний гонки в многопоточных сценариях (с указанием <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`), см. в <xref:System.Lazy%601.%23ctor> разделе Конструктор.  
  
 В этом примере определяется `LargeObject` класс, который будет инициализирован в пассивном режиме с помощью любого из нескольких потоков. Четыре ключевых раздела кода иллюстрируют создание инициализатора, фактическую инициализацию, функцию инициализации, а также конструктор и метод завершения `LargeObject` класса. В начале `Main` метода в примере <xref:System.Lazy%601> создается объект, `LargeObject`выполняющий отложенную инициализацию:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 Для выполнения инициализации отложенный инициализатор использует функцию. В этом случае требуется функция, поскольку для `LargeObject` класса не существует конструктора без параметров.  
  
 В примере создаются и запускаются три потока, которые блокируют <xref:System.Threading.ManualResetEvent> объект, чтобы в примере можно было освободить все потоки одновременно. В методе, который используется всеми тремя потоками, <xref:System.Lazy%601.Value%2A> вызов свойства создает `LargeObject` экземпляр: `ThreadProc`  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 В третьем ключевом разделе кода вызывается функция отложенной инициализации для создания `LargeObject` экземпляра. Функция создает исключение при первом вызове:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 При любом другом <xref:System.Threading.LazyThreadSafetyMode> параметре будет кэшироваться необработанное исключение в функции инициализации. <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> Однако подавляет кэширование исключений. В выходных данных примера показано, что последующая попытка инициализации объекта завершается с ошибкой.  
  
> [!NOTE]
>  Сообщение об исключении обычно появляется после сообщений о том, что другие потоки успешно инициализируют объект. Это обусловлено задержкой, вызванной созданием и перехватом исключения.  
  
 Поскольку конструктор для <xref:System.Lazy%601> указанного <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>экземпляра, всем трем потокам разрешено создавать `LargeObject` экземпляры. В этом примере показано, как отобразить сообщения консоли в конструкторе и в методе завершения `LargeObject` класса:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 <xref:System.Lazy%601> Объект гарантирует, что все потоки используют только один экземпляр (за исключением потока, в котором функция инициализации создает исключение). Это показано в выходных данных примера.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> — <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, было ли создано значение для данного экземпляра <see cref="T:System.Lazy`1" />.</summary>
        <value>Значение <see langword="true" />, если для данного экземпляра <see cref="T:System.Lazy`1" /> было создано значение; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для <xref:System.Lazy%601> экземпляра используется отложенная инициализация, это может привести либо к созданию значения, либо к вызываемому исключению. При возникновении исключения последующее поведение <xref:System.Lazy%601> экземпляра зависит от того, действует ли кэширование исключений. <xref:System.Lazy%601> Если экземпляр был создан с помощью конструктора, не определяющего функцию инициализации, то кэширование исключений не действует. Последующая попытка инициализации <xref:System.Lazy%601> может быть успешной, и после успешной <xref:System.Lazy%601.IsValueCreated%2A> инициализации свойство возвращает `true`значение. Если экземпляр был создан с помощью функции инициализации (заданной `valueFactory` параметром <xref:System.Lazy%601> конструктора), то кэширование исключений управляется режимом потокобезопасности. <xref:System.Lazy%601>  
  
-   Если задан <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> режим или <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, то <xref:System.Lazy%601> второй шанс инициализировать экземпляр не существует. Если исключение возникает и не обработано в функции инициализации, это исключение кэшируется и вызывается повторно при последующих обращениях к <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> свойству. При возникновении исключения значение не создается, поэтому в таких случаях <xref:System.Lazy%601.IsValueCreated%2A> возвращается. `false`  
  
-   Если режим равен <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, первый поток, который завершил выполнение функции инициализации (или конструктора без параметров), создает значение <xref:System.Lazy%601> для экземпляра. Если функция инициализации создает исключение в одном потоке, другие потоки по-прежнему могут пытаться инициализировать <xref:System.Lazy%601> экземпляр. До создания <xref:System.Lazy%601.IsValueCreated%2A> значения свойство возвращает `false`значение.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает и возвращает строковое представление свойства <see cref="P:System.Lazy`1.Value" /> данного экземпляра.</summary>
        <returns>Результат вызова метода <see cref="M:System.Object.ToString" /> для свойства <see cref="P:System.Lazy`1.Value" /> данного экземпляра, если это значение было создано (то есть если свойство <see cref="P:System.Lazy`1.IsValueCreated" /> возвращает значение <see langword="true" />). В противном случае возвращается строка, указывающая, что значение не было создано.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода не вызывает инициализацию.  
  
 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> `null` `valueFactory` <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>Свойство может быть `null` после отложенной инициализации, если метод фабрики, указанный для параметра конструктора, или, возвращает. <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Значение свойства <see cref="P:System.Lazy`1.Value" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает неактивно инициализированное значение текущего экземпляра <see cref="T:System.Lazy`1" />.</summary>
        <value>Неактивно инициализированное значение текущего экземпляра <see cref="T:System.Lazy`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство имеет `false`значение, доступ к <xref:System.Lazy%601.Value%2A> свойству вызывает принудительную инициализацию. <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType>  
  
 <xref:System.Lazy%601.Value%2A> Помимо перечисленных исключений, свойство может вызывать любое необработанное исключение, выдаваемое методом фабрики, который был передан `valueFactory` параметру <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, или <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> Конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Экземпляр <see cref="T:System.Lazy`1" /> инициализируется для использования конструктора без параметров, имеющего тип с отложенной инициализацией, а разрешения для доступа к конструктору отсутствуют.</exception>
        <exception cref="T:System.MissingMemberException">Экземпляр <see cref="T:System.Lazy`1" /> инициализируется для использования конструктора без параметров, имеющего тип с отложенной инициализацией, и данный тип не имеет открытого конструктора без параметров.</exception>
        <exception cref="T:System.InvalidOperationException">Функция инициализации в данном экземпляре пытается получить доступ к <see cref="P:System.Lazy`1.Value" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
  </Members>
</Type>