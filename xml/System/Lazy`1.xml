<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="df266a91358ad146e1c18d873159ac0475dd9b5d" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75040702" /></Metadata><TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Тип объекта с отложенной инициализацией.</typeparam>
    <summary>Обеспечивает поддержку отложенной инициализации.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте отложенную инициализацию, чтобы отложить создание большого или ресурсоемкиго объекта или выполнение ресурсоемких задач, особенно если такое создание или выполнение может не произойти в течение всего времени существования программы.  
  
 Чтобы подготовиться к отложенной инициализации, создайте экземпляр <xref:System.Lazy%601>. Аргумент типа создаваемого объекта <xref:System.Lazy%601> указывает тип объекта, который требуется инициализировать отложенно. Конструктор, используемый для создания объекта <xref:System.Lazy%601>, определяет характеристики инициализации. Отложенная инициализация производится при первом обращении к свойству <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>.  
  
 В большинстве случаев выбор конструктора зависит от ответов на два вопроса:  
  
-   Будет ли доступ к объекту с отложенной инициализацией осуществляться из более чем одного потока? В этом случае объект <xref:System.Lazy%601> может создать его в любом потоке. Можно использовать один из простых конструкторов, поведение по умолчанию которого — создать потокобезопасный объект <xref:System.Lazy%601>, чтобы создавался только один экземпляр объекта с отложенным созданием экземпляров, независимо от того, сколько потоков пытается получить к нему доступ. Чтобы создать объект <xref:System.Lazy%601>, который не является потокобезопасным, необходимо использовать конструктор, который позволяет указать отсутствие потокобезопасности.  
  
    > [!CAUTION]
    >  Обеспечение безопасного потокового объекта <xref:System.Lazy%601> не защищает объект с отложенной инициализацией. Если несколько потоков могут получить доступ к объекту с отложенной инициализацией, необходимо сделать его свойства и методы надежными для многопоточного доступа.  
  
-   Если отложенная инициализация требует большого объема кода или если у отложенно инициализированного объекта есть конструктор без параметров, который выполняет все необходимые действия и не создает исключения? Если необходимо написать код инициализации или необходимо обработать исключения, используйте один из конструкторов, которые принимают фабричный метод. Напишите код инициализации в фабричном методе.  
  
 В следующей таблице показано, какой конструктор выбрать в зависимости от этих двух факторов.  
  
|Доступ к объекту будет осуществляться|Если код инициализации не требуется (конструктор без параметров), используйте|Если требуется код инициализации, используйте|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Несколько потоков|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Один поток|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> `isThreadSafe` задано значение `false`.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> `isThreadSafe` задано значение `false`.|  
  
 Для указания фабричного метода можно использовать лямбда-выражение. Это позволяет хранить весь код инициализации в одном месте. Лямбда-выражение фиксирует контекст, включая любые аргументы, передаваемые в конструктор отложенно инициализированного объекта.  
  
 **Кэширование исключений** При использовании фабричных методов исключения кэшируются. То есть, если метод фабрики создает исключение при первом попытке потока получить доступ к свойству <xref:System.Lazy%601.Value%2A> объекта <xref:System.Lazy%601>, то при каждой последующей попытке возникает исключение. Это гарантирует, что каждый вызов свойства <xref:System.Lazy%601.Value%2A> приведет к одному и тому же результату и избежать незначительных ошибок, которые могут возникать, если разные потоки получают разные результаты. <xref:System.Lazy%601> означает фактическое `T`, которое в противном случае было бы инициализировано в более ранней точке, обычно во время запуска. Сбой в более ранней точке обычно является неустранимой. Если есть вероятность возможного сбоя, рекомендуется создать логику повторных попыток в подпрограммы инициализации (в данном случае — фабричном методе), точно так же, как если бы вы не использовали отложенную инициализацию.  
  
 **Альтернатива блокировке** В некоторых ситуациях может возникнуть необходимость избежать издержек, возникающих в работе блокировки по умолчанию для объекта <xref:System.Lazy%601>. В редких ситуациях возможны взаимоблокировки. В таких случаях можно использовать конструктор <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> или <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> и указать <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Это позволяет объекту <xref:System.Lazy%601> создавать копию объекта с отложенной инициализацией в каждом из нескольких потоков, если потоки вызывают свойство <xref:System.Lazy%601.Value%2A> одновременно. Объект <xref:System.Lazy%601> гарантирует, что все потоки будут использовать один и тот же экземпляр объекта с отложенной инициализацией и отбрасывают неиспользуемые экземпляры. Таким образом, стоимость снижения затрат на блокировку заключается в том, что программа может иногда создавать и удалять дополнительные копии дорогостоящего объекта. В большинстве случаев это маловероятно. Примеры для конструкторов <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> демонстрируют это поведение.  
  
> [!IMPORTANT]
>  При указании <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>исключения никогда не кэшируются, даже если указан фабричный метод.  
  
 **Эквивалентные конструкторы** Помимо использования <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, конструкторы <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> могут дублировать функциональность других конструкторов. В следующей таблице приведены значения параметров, которые создают эквивалентное поведение.  
  
|Создание объекта <xref:System.Lazy%601>, который|Для конструкторов, имеющих параметр `LazyThreadSafetyMode` `mode`, задайте для `mode` значение.|Для конструкторов, имеющих логический параметр `isThreadSafe`, установите `isThreadSafe` в значение|Для конструкторов без параметров безопасности потока|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Полностью потокобезопасный; использует блокировку, чтобы гарантировать, что только один поток инициализирует значение.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Все такие конструкторы являются полностью потокобезопасными.|  
|Не является потокобезопасным.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Неприменимо.|  
|Полностью потокобезопасный; потоки, которые инициализируют значение.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Неприменимо.|Неприменимо.|  
  
 **Другие возможности** Сведения об использовании <xref:System.Lazy%601> с полями static потока или в качестве резервного хранилища для свойств см. в разделе [Отложенная инициализация](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 В следующем примере показано использование класса <xref:System.Lazy%601> для обеспечения отложенной инициализации с доступом из нескольких потоков.  
  
> [!NOTE]
>  В примере используется конструктор <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>. Также демонстрируется использование конструктора <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> (указание `true` для `isThreadSafe`) и конструктора <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> (с указанием <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`). Чтобы переключиться на другой конструктор, просто измените конструкторы, которые заносятся в комментарий.  
>   
>  Пример, демонстрирующий кэширование исключений с помощью тех же конструкторов, см. в разделе Конструктор <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Четыре ключевых раздела кода иллюстрируют создание инициализатора, фабричный метод, фактическую инициализацию и конструктор класса `LargeObject`, который отображает сообщение при создании объекта. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 Метод Factory показывает создание объекта с заполнительом для дальнейшей инициализации:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Обратите внимание, что первые два раздела кода можно объединить с помощью лямбда-функции, как показано ниже:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 В этом примере приостанавливается, чтобы указать, что неопределенный период может пройти до возникновения отложенной инициализации. При нажатии клавиши **Ввод** в примере создаются и запускаются три потока. Метод `ThreadProc`, используемый всеми тремя потоками, вызывает свойство <xref:System.Lazy%601.Value%2A>. В первый раз создается экземпляр `LargeObject`.  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Конструктор класса `LargeObject`, который включает последний ключевой раздел кода, отображает сообщение и записывает идентификатор инициализации потока. Выходные данные программы отображаются в конце полного листинга кода.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>По умолчанию все открытые и защищенные члены класса <see cref="T:System.Lazy`1" /> являются потокобезопасными и могут использоваться одновременно из нескольких потоков. Эти гарантии безопасности потоков могут быть удалены дополнительно и для каждого экземпляра с помощью параметров для конструкторов типа.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.Lazy`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.Lazy`1" />. При неактивной инициализации используется конструктор целевого типа без параметров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр, созданный с помощью этого конструктора, может использоваться одновременно из нескольких потоков.  
  
 Режим потокобезопасности экземпляра <xref:System.Lazy%601>, который инициализируется с помощью этого конструктора, <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Режим безопасности потока описывает поведение, когда несколько потоков пытаются инициализировать экземпляр <xref:System.Lazy%601>.  
  
 Экземпляр <xref:System.Lazy%601>, созданный с помощью этого конструктора, не кэширует исключения. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого конструктора. Также показано использование конструктора <xref:System.Lazy%601.%23ctor%28System.Boolean%29> (указание `true` для `isThreadSafe`) и конструктора <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> (с указанием <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`). Чтобы переключиться на другой конструктор, просто измените конструкторы, которые заносятся в комментарий.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Двумя ключевыми строками кода в этом примере являются создание инициализатора и фактическая инициализация. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 В примере создаются и запускаются три потока, которые блокируют объект <xref:System.Threading.ManualResetEvent>, чтобы в примере можно было освободить все потоки одновременно. Метод `ThreadProc`, используемый всеми тремя потоками, вызывает свойство <xref:System.Lazy%601.Value%2A> для получения экземпляра `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 Класс <xref:System.Lazy%601> обеспечивает блокировку, поэтому только одному потоку разрешено создавать экземпляр `LargeObject`. В примере показано, что все остальные потоки получают один и тот же экземпляр.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">Значение <see langword="true" />, чтобы сделать этот экземпляр доступным для одновременного использования несколькими потоками; значение <see langword="false" />, чтобы экземпляр мог использоваться только одним потоком.</param>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.Lazy`1" />. При неактивной инициализации используются конструктор целевого типа без параметров и заданный режим инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режим потокобезопасности экземпляра <xref:System.Lazy%601>, который инициализируется с помощью этого конструктора, <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>, если `isThreadSafe` `true`. в противном случае режим — <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Режим безопасности потока описывает поведение, когда несколько потоков пытаются инициализировать экземпляр <xref:System.Lazy%601>. Чтобы указать режим <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, используйте конструктор <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> или <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>.  
  
 Экземпляр <xref:System.Lazy%601>, созданный с помощью этого конструктора, не кэширует исключения. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого конструктора для создания отложенного инициализатора, который не является потокобезопасным, для сценариев, в которых весь доступ к объекту с отложенной инициализацией происходит в том же потоке. Также демонстрируется использование конструктора <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> (с указанием <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`. Чтобы переключиться на другой конструктор, просто измените конструктор с комментарием.  
  
> [!NOTE]
>  Код, демонстрирующий использование этого конструктора в многопоточных сценариях (с указанием `true` для `isThreadSafe`), см. в примере для конструктора <xref:System.Lazy%601.%23ctor>.  
  
 В примере определяется класс `LargeObject`, который будет инициализирован неактивно. В методе `Main` в примере создается экземпляр <xref:System.Lazy%601>, а затем приостанавливается. При нажатии клавиши **Ввод** в примере выполняется доступ к свойству <xref:System.Lazy%601.Value%2A> экземпляра <xref:System.Lazy%601>, что приводит к инициализации. Конструктор класса `LargeObject` отображает сообщение консоли.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Делегат, вызываемый для создания значения с отложенной инициализацией при необходимости.</param>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.Lazy`1" />. Когда происходит отложенная инициализация, используется заданная функция инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр, созданный с помощью этого конструктора, может использоваться одновременно из нескольких потоков.  
  
 Режим потокобезопасности экземпляра <xref:System.Lazy%601>, который инициализируется с помощью этого конструктора, <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Режим безопасности потока описывает поведение, когда несколько потоков пытаются инициализировать экземпляр <xref:System.Lazy%601>.  
  
 Исключения, вызываемые `valueFactory`, кэшируются. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого конструктора для обеспечения отложенной инициализации с кэшированием исключений. Также демонстрируется использование конструктора <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> (указание `true` для `isThreadSafe`) и конструктора <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> (с указанием <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`). Чтобы переключиться на другой конструктор, просто измените конструкторы, которые заносятся в комментарий.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Три ключевых раздела кода иллюстрируют создание инициализатора, фактическую инициализацию и конструктор класса `LargeObject`, который демонстрирует кэширование исключений. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 В примере создаются и запускаются три потока. Метод `ThreadProc`, используемый всеми тремя потоками, вызывает свойство <xref:System.Lazy%601.Value%2A> для получения экземпляра `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 В конструкторе класса `LargeObject` третий ключевой раздел кода создает исключение при первом создании экземпляра `LargeObject`, но затем позволяет создать экземпляр.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 При выполнении этого примера первый поток, пытающийся создать экземпляр `LargeObject`, завершается ошибкой, и перехватывается исключение. Вы можете ожидать, что следующий поток будет успешно создавать экземпляр, но объект <xref:System.Lazy%601> кэширует исключение. Из-за этого все три потока создают исключение.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="valueFactory" /> имеет значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mode">Одно из значений перечисления, задающее потокобезопасный режим.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />, который использует конструктор <paramref name="T" /> без параметров и заданный потокобезопасный режим.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режим безопасности потока <xref:System.Lazy%601> экземпляра описывает поведение, когда несколько потоков пытаются инициализировать экземпляр <xref:System.Lazy%601>.  
  
 Экземпляр <xref:System.Lazy%601>, созданный с помощью этого конструктора, не кэширует исключения. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого конструктора для создания отложенного инициализатора, который позволяет нескольким потокам неактивно создавать объект. Несколько потоков могут успешно создавать экземпляры, но все потоки используют экземпляр, который был создан первым.  
  
> [!NOTE]
>  Пример, демонстрирующий использование этого конструктора в сценариях с одним потоком (с указанием <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`), см. в разделе Конструктор <xref:System.Lazy%601.%23ctor%28System.Boolean%29>. Пример, демонстрирующий использование этого конструктора для предоставления блокировки вместо конкуренции в многопоточных сценариях (с указанием <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`), см. в разделе Конструктор <xref:System.Lazy%601.%23ctor>.  
  
 В примере определяется класс `LargeObject`, который будет инициализирован в пассивном режиме с помощью любого из нескольких потоков. Три ключевых раздела кода иллюстрируют создание инициализатора, фактическую инициализацию, а также конструктор и метод завершения класса `LargeObject`. В начале метода `Main` в примере создается объект <xref:System.Lazy%601>, который выполняет отложенную инициализацию `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 В примере создаются и запускаются три потока, которые блокируют объект <xref:System.Threading.ManualResetEvent>, чтобы в примере можно было освободить все потоки одновременно. В методе `ThreadProc`, который используется всеми тремя потоками, вызов свойства <xref:System.Lazy%601.Value%2A> создает экземпляр `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Поскольку конструктор для экземпляра <xref:System.Lazy%601> указан <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, всем трем потокам разрешено создавать экземпляры `LargeObject`. В этом примере показано, как отобразить сообщения консоли в конструкторе и в методе завершения класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Однако объект <xref:System.Lazy%601> гарантирует, что все потоки используют только один экземпляр. Выходные данные в примере показывают, что все три потока используют один и тот же экземпляр, а также показывают, что другие экземпляры могут быть освобождены при сборке мусора.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">Предварительно инициализированное значение для использования.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />, использующий предварительно инициализированное заданное значение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
Экземпляр, созданный с помощью этого конструктора, может использоваться несколькими потоками одновременно.
]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Делегат, вызываемый для создания значения с отложенной инициализацией при необходимости.</param>
        <param name="isThreadSafe">Значение <see langword="true" />, чтобы сделать этот экземпляр доступным для одновременного использования несколькими потоками; значение <see langword="false" />, чтобы этот экземпляр мог использоваться только одним потоком в каждый момент времени.</param>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.Lazy`1" />. Когда происходит отложенная инициализация, используются заданные функция инициализации и режим инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режим потокобезопасности экземпляра <xref:System.Lazy%601>, который инициализируется с помощью этого конструктора, <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>, если `isThreadSafe` `true`. в противном случае режим — <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Режим безопасности потока описывает поведение, когда несколько потоков пытаются инициализировать экземпляр <xref:System.Lazy%601>.  
  
 Чтобы указать режим <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, используйте конструктор <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> или <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>.  
  
 Исключения, вызываемые `valueFactory`, кэшируются. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого конструктора для обеспечения отложенной инициализации с кэшированием исключений в сценарии с одним потоком. Также демонстрируется использование конструктора <xref:System.Lazy%601.%23ctor%2A> (с указанием <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`). Чтобы переключиться на этот конструктор, просто измените конструктор с комментарием.  
  
> [!NOTE]
>  Код, демонстрирующий использование этого конструктора в многопоточных сценариях (с указанием `true` для `isThreadSafe`), см. в примере для конструктора <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Три ключевых раздела кода иллюстрируют создание инициализатора, фактическую инициализацию и конструктор класса `LargeObject`, который демонстрирует кэширование исключений. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 В вызове конструктора параметр `isThreadSafe` `false`, поэтому <xref:System.Lazy%601> не является потокобезопасным. Так как он не является потокобезопасным, пример вызывает свойство <xref:System.Lazy%601.Value%2A> три раза в одном потоке:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 В конструкторе класса `LargeObject` третий ключевой раздел кода создает исключение при первом создании экземпляра `LargeObject`, но затем позволяет создать экземпляр.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 При выполнении примера первая попытка создания экземпляра `LargeObject` завершается ошибкой, а исключение перехватывается. Можно ожидать, что следующая попытки будет выполнена успешно, но объект <xref:System.Lazy%601> кэширует исключение. Из-за этого все три попытки вызовут исключение.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="valueFactory" /> имеет значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Делегат, вызываемый для создания значения с отложенной инициализацией при необходимости.</param>
        <param name="mode">Одно из значений перечисления, задающее потокобезопасный режим.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />, который использует заданную функцию инициализации и потокобезопасный режим.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режим безопасности потока <xref:System.Lazy%601> экземпляра описывает поведение, когда несколько потоков пытаются инициализировать экземпляр <xref:System.Lazy%601>.  
  
 Исключения, вызываемые `valueFactory`, кэшируются, если только `mode` не <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование этого конструктора для создания отложенного инициализатора, который позволяет нескольким потокам неактивно создавать объект. Несколько потоков могут успешно создавать экземпляры, но все потоки используют экземпляр, который был создан первым. Кроме того, в примере показано, что исключения никогда не кэшируются при указании <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, даже если инициализация выполняется функцией, а не с помощью конструктора без параметров типа, созданного с отложенным созданием.  
  
> [!NOTE]
>  Пример, демонстрирующий использование этого конструктора в сценариях с одним потоком (с указанием <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`), см. в разделе Конструктор <xref:System.Lazy%601.%23ctor%28System.Boolean%29>. Пример, демонстрирующий использование этого конструктора для предоставления блокировки вместо конкуренции в многопоточных сценариях (с указанием <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`), см. в разделе Конструктор <xref:System.Lazy%601.%23ctor>.  
  
 В примере определяется класс `LargeObject`, который будет инициализирован в пассивном режиме с помощью любого из нескольких потоков. Четыре ключевых раздела кода иллюстрируют создание инициализатора, фактическую инициализацию, функцию инициализации, а также конструктор и метод завершения класса `LargeObject`. В начале метода `Main` в примере создается объект <xref:System.Lazy%601>, который выполняет отложенную инициализацию `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 Для выполнения инициализации отложенный инициализатор использует функцию. В этом случае требуется функция, поскольку отсутствует конструктор без параметров для класса `LargeObject`.  
  
 В примере создаются и запускаются три потока, которые блокируют объект <xref:System.Threading.ManualResetEvent>, чтобы в примере можно было освободить все потоки одновременно. В методе `ThreadProc`, который используется всеми тремя потоками, вызов свойства <xref:System.Lazy%601.Value%2A> создает экземпляр `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 В третьем разделе кода вызывается функция отложенной инициализации для создания экземпляра `LargeObject`. Функция создает исключение при первом вызове:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 При любом другом параметре <xref:System.Threading.LazyThreadSafetyMode> будет кэшироваться необработанное исключение в функции инициализации. Однако <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> подавляет кэширование исключений. В выходных данных примера показано, что последующая попытка инициализации объекта завершается с ошибкой.  
  
> [!NOTE]
>  Сообщение об исключении обычно появляется после сообщений о том, что другие потоки успешно инициализируют объект. Это обусловлено задержкой, вызванной созданием и перехватом исключения.  
  
 Поскольку конструктор для экземпляра <xref:System.Lazy%601> указан <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, всем трем потокам разрешено создавать экземпляры `LargeObject`. В этом примере показано, как отобразить сообщения консоли в конструкторе и в методе завершения класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 Объект <xref:System.Lazy%601> гарантирует, что все потоки используют только один экземпляр (за исключением потока, в котором функция инициализации создает исключение). Это показано в выходных данных примера.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="valueFactory" /> имеет значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое показывает, создано ли значение для этого экземпляра <see cref="T:System.Lazy`1" />.</summary>
        <value>Значение <see langword="true" />, если значение создано для этого экземпляра <see cref="T:System.Lazy`1" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если отложенная инициализация выполняется для экземпляра <xref:System.Lazy%601>, это может привести к созданию либо значения, либо вызываемого исключения. При возникновении исключения последующее поведение экземпляра <xref:System.Lazy%601> зависит от того, действует ли кэширование исключений. Если экземпляр <xref:System.Lazy%601> был создан с помощью конструктора, не определяющего функцию инициализации, то кэширование исключений не действует. Последующая попытка инициализации <xref:System.Lazy%601> может быть успешной, и после успешной инициализации свойство <xref:System.Lazy%601.IsValueCreated%2A> возвращает `true`. Если <xref:System.Lazy%601> экземпляр был создан с помощью функции инициализации (заданной параметром `valueFactory` конструктора <xref:System.Lazy%601>), то кэширование исключений управляется режимом потокобезопасности.  
  
-   Если режим — <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> или <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, то второй шанс инициализировать экземпляр <xref:System.Lazy%601> не существует. Если исключение возникает и не обработано в функции инициализации, это исключение кэшируется и вызывается повторно при последующих обращениях к свойству <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>. При возникновении исключения значение не создается, поэтому в таких случаях <xref:System.Lazy%601.IsValueCreated%2A> возвращает `false`.  
  
-   Если режим <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, то первый поток, который завершил выполнение функции инициализации (или конструктора без параметров), создает значение для экземпляра <xref:System.Lazy%601>. Если функция инициализации создает исключение в одном потоке, другие потоки по-прежнему могут пытаться инициализировать экземпляр <xref:System.Lazy%601>. Пока значение не будет создано, свойство <xref:System.Lazy%601.IsValueCreated%2A> возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает и возвращает строковое представление свойства <see cref="P:System.Lazy`1.Value" /> для данного экземпляра.</summary>
        <returns>Результат вызова метода <see cref="M:System.Object.ToString" /> для свойства <see cref="P:System.Lazy`1.Value" /> данного экземпляра, если значение создано (то есть если свойство <see cref="P:System.Lazy`1.IsValueCreated" /> возвращает <see langword="true" />). В противном случае строка, указывающая, что значение не создано.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода не вызывает инициализацию.  
  
 Свойство <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> может быть `null` после отложенной инициализации, если метод фабрики, указанный для параметра `valueFactory` <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>или конструктора <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>, возвращает `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Значение свойства <see cref="P:System.Lazy`1.Value" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение с отложенной инициализацией текущего экземпляра <see cref="T:System.Lazy`1" />.</summary>
        <value>Значение с отложенной инициализацией текущего экземпляра <see cref="T:System.Lazy`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> `false`, то доступ к свойству <xref:System.Lazy%601.Value%2A> вызывает принудительную инициализацию.  
  
 В дополнение к перечисленным исключениям свойство <xref:System.Lazy%601.Value%2A> может вызывать любое необработанное исключение, выдаваемое методом фабрики, который был передан в параметр `valueFactory` конструктора <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>или <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Экземпляр <see cref="T:System.Lazy`1" /> инициализируется для использования конструктора без параметров, имеющего тип с отложенной инициализацией, а разрешения для доступа к конструктору отсутствуют.</exception>
        <exception cref="T:System.MissingMemberException">Экземпляр <see cref="T:System.Lazy`1" /> инициализируется для использования конструктора без параметров, имеющего тип с отложенной инициализацией, и данный тип не имеет открытого конструктора без параметров.</exception>
        <exception cref="T:System.InvalidOperationException">Функция инициализации пытается получить доступ к <see cref="P:System.Lazy`1.Value" /> в данном экземпляре.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
  </Members>
</Type>
