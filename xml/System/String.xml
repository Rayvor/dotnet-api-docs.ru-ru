<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e2aa2433b61fdc394c1602ac791d097d70525c99" /><Meta Name="ms.sourcegitcommit" Value="2b0967e04b047f6709322418d97215dfcef6a938" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/20/2019" /><Meta Name="ms.locfileid" Value="74237840" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет текст как последовательность из частей кода UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Строка — это последовательная коллекция символов, используемая для представления текста. Объект <xref:System.String> — это последовательная коллекция <xref:System.Char?displayProperty=nameWithType> объектов, представляющих строку. Объект <xref:System.Char?displayProperty=nameWithType> соответствует блоку кода UTF-16. Значение объекта <xref:System.String> — это содержимое последовательной коллекции объектов <xref:System.Char?displayProperty=nameWithType>, которое является неизменяемым (т. е. оно доступно только для чтения). Дополнительные сведения о неизменности строк см. в разделе неизменяемость [и класс StringBuilder](#Immutability) далее в этом разделе. Максимальный размер объекта <xref:System.String> в памяти составляет 2 ГБ или около 1 000 000 000 символов.  
  
[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 Содержание  
  
 [Создание экземпляра объекта String](#Instantiation)   
 [Объекты char и символы юникода](#Characters)   
 [Строки и стандарт юникода](#Unicode)   
 [Строки и внедренные символы null](#EmbeddedNulls)   
 [Строки и индексы](#Indexes)   
 Пустые [строки и пустые строки](#Nulls)   
 [Неизменность и класс StringBuilder](#Immutability)   
 [Порядковые номера и операции с учетом языка и региональных параметров](#CultureSensitive)   
 [Нормализация](#Normalization)   
 [Строковые операции по категориям](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Создание экземпляра объекта String  
 Создать экземпляр объекта <xref:System.String> можно следующими способами.  
  
-   Путем присвоения строкового литерала переменной <xref:System.String>. Это наиболее часто используемый метод создания строки. В следующем примере используется присваивание для создания нескольких строк. Обратите внимание C#, что в, поскольку обратная косая черта (\\) является escape-символом, литералы в строке должны быть экранированы или вся строка должна быть@-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Путем вызова конструктора <xref:System.String> класса. В следующем примере создаются экземпляры строк путем вызова нескольких конструкторов классов. Обратите внимание, что некоторые конструкторы содержат указатели на массивы символов или байтовые массивы со знаком в качестве параметров. Visual Basic не поддерживает вызовы этих конструкторов. Подробные сведения о <xref:System.String> конструкторах см. в разделе Сводка по конструктору <xref:System.String.%23ctor%2A>.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   С помощью оператора объединения строк (+ in C# и & или + в Visual Basic) для создания одной строки из любого сочетания <xref:System.String> экземпляров и строковых литералов. В следующем примере показано использование оператора объединения строк.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Путем извлечения свойства или вызова метода, который возвращает строку. В следующем примере методы класса <xref:System.String> используются для извлечения подстроки из более длинной строки.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   Путем вызова метода форматирования для преобразования значения или объекта в строковое представление. В следующем примере функция [составного форматирования](~/docs/standard/base-types/composite-formatting.md) используется для встраивания строкового представления двух объектов в строку.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Объекты char и символы Юникода  
 Каждый символ в строке определяется скалярным значением Юникода, также называемым кодовой точкой Юникода или порядковым (числовым) значением символа Юникода. Каждая кодовая точка кодируется с помощью кодировки UTF-16, а числовое значение каждого элемента кодировки представлено <xref:System.Char> объектом.  
  
> [!NOTE]
>  Обратите внимание, что, поскольку экземпляр <xref:System.String> состоит из последовательной коллекции единиц кода UTF-16, можно создать объект <xref:System.String>, который не является правильно сформированной строкой в Юникоде. Например, можно создать строку с младшим суррогатом без соответствующего старшего символа-заместителя. Хотя некоторые методы, такие как методы кодирования и декодирования объектов в пространстве имен <xref:System.Text>, могут выполнять проверки, чтобы гарантировать, что строки имеют правильный формат, <xref:System.String> члены класса не гарантируют правильность формата строки.  
  
 Один объект <xref:System.Char> обычно представляет одну кодовую точку; то есть числовое значение <xref:System.Char> равно кодовой точке. Например, кодовая точка для символа «a» — это U + 0061. Однако кодовая точка может требовать более одного закодированного элемента (более одного объекта <xref:System.Char>). Стандарт Unicode определяет два типа символов, которые соответствуют нескольким <xref:System.Char> объектам: графемес, и дополнительные кодовые точки Юникода, соответствующие символам в дополнительных плоскостях Юникода.  
  
-   Графеме представляется базовым символом, за которым следует один или несколько Объединенных символов. Например, символ ä представлен объектом <xref:System.Char>, код которого равен U + 0061, за которым следует объект <xref:System.Char>, чей код находится в U + 0308. Этот символ также может быть определен одним объектом <xref:System.Char>, имеющим кодовую точку U + 00E4. Как показано в следующем примере, сравнение с учетом языка и региональных параметров на равенство означает, что эти два представления равны, хотя обычное порядковое сравнение не имеет значения. Однако если две строки нормализованы, порядковое сравнение также указывает на то, что они равны. (Дополнительные сведения об нормализации строк см. в разделе [нормализация](#Normalization) .)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Дополнительная кодовая точка Юникода (суррогатная пара) представлена объектом <xref:System.Char>, код которого является старшим суррогатом, за которым следует объект <xref:System.Char>, позиция кода которого является младшим суррогатом. Единицы кода старших суррогатов находятся в диапазоне от U + D800 до U + DBFF. Единицы кода младших суррогатов находятся в диапазоне от U + DC00 до U + DFFF. Суррогатные пары используются для представления символов в 16 дополнительных плоскостях Юникода. В следующем примере создается суррогатный символ, который передается методу <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType>, чтобы определить, является ли он суррогатной парой.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Строки и стандарт Unicode  
 Символы в строке представлены блоками кода в кодировке UTF-16, которые соответствуют значениям <xref:System.Char>.  
  
 Каждый символ в строке имеет связанную с ним категорию символов Юникода, которая представлена в .NET с помощью перечисления <xref:System.Globalization.UnicodeCategory>. Категория символа или суррогатной пары может быть определена путем вызова метода <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>.  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 Кроме того, .NET поддерживает сравнение строк и сортировку на основе стандарта Unicode. В версиях .NET Framework с помощью [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].NET Framework хранит собственную таблицу строковых данных. Это также относится к версиям .NET Framework, начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], работающего в Windows 7. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], выполняющегося в Windows 8 и более поздних версиях операционной системы, среда выполнения делегирует операции сравнения строк и сортировки операционной системе. В .NET Core сведения о сравнении строк и сортировке предоставляются [международными компонентами для библиотек Юникода](http://site.icu-project.org/) . В следующей таблице перечислены версии .NET и версии стандарта Unicode, на которых основаны сравнение и сортировка символов.  
  
|Версия .NET|Версия стандарта Юникод|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Стандарт Юникод, версия 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2,0|[Стандарт Юникод, версия 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Стандарт Юникод, версия 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Стандарт Юникод, версия 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] и более поздних версий в Windows 7|[Стандарт Юникод, версия 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] и более поздние версии в операционных системах Windows 8 и более поздних версий Windows|[Стандарт Юникод, версия 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET Core (все версии)|Зависит от версии стандарта Юникода, поддерживаемой базовой операционной системой.|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Строки и внедренные символы NULL  
 В .NET объект <xref:System.String> может включать в себя внедренные символы NULL, которые учитываются как часть длины строки. Однако на некоторых языках, таких как C и C++, символ NULL обозначает конец строки. Он не считается частью строки и не учитывается как часть длины строки. Это означает, что следующие распространенные предположения о том, C++ что c и программисты или библиотеки C++ , написанные на языке c или, могут быть связаны со строками, не обязательно являются допустимыми при применении к <xref:System.String> объектам:  
  
-   Значение, возвращаемое функциями `strlen` или `wcslen`, не обязательно равно <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   Строка, созданная функциями `strcpy_s` или `wcscpy_s`, не обязательно совпадает со строкой, созданной методом <xref:System.String.Copy%2A?displayProperty=nameWithType>.  
  
 Следует убедиться, что в машинном C++ коде C и код, создающий экземпляры <xref:System.String> объекты, и код, передаваемый <xref:System.String> объектов через вызов неуправляемого кода, не предполагается, что символ NULL обозначает конец строки.  
  
 Внедренные символы NULL в строке также обрабатываются по-разному при сортировке строки (или сравнении) и при поиске строки. Символы NULL игнорируются при выполнении сравнений с учетом языка и региональных параметров между двумя строками, включая сравнения с использованием инвариантного языка и региональных параметров. Они рассматриваются только для порядковых сравнений с порядковыми номерами или без учета регистра. С другой стороны, внедренные символы NULL всегда учитываются при поиске строки с такими методами, как <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>и <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Строки и индексы  
 Индекс — это позиция объекта <xref:System.Char> (а не символа Юникода) в <xref:System.String>. Индекс — это неотрицательное, отсчитываемое от нуля число, которое начинается от первой позиции в строке, что равно нулевой позиции индекса. Ряд методов поиска, таких как <xref:System.String.IndexOf%2A> и <xref:System.String.LastIndexOf%2A>, возвращают индекс символа или подстроки в экземпляре строки.  
  
 Свойство <xref:System.String.Chars%2A> позволяет получать доступ к отдельным объектам <xref:System.Char> по их позиции индекса в строке. Поскольку свойство <xref:System.String.Chars%2A> является свойством по умолчанию (в Visual Basic) или индексатором (в C#), можно получить доступ к отдельным объектам <xref:System.Char> в строке, используя следующий код. Этот код выполняет поиск пробелов или знаков препинания в строке, чтобы определить, сколько слов содержит строка.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Поскольку класс <xref:System.String> реализует интерфейс <xref:System.Collections.IEnumerable>, можно также выполнить итерацию по <xref:System.Char>ным объектам в строке с помощью конструкции `foreach`, как показано в следующем примере.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Последовательные значения индекса могут не соответствовать последовательным символам Юникода, так как символ Юникода может быть закодирован как более одного <xref:System.Char> объекта. В частности, строка может содержать многосимвольные единицы текста, сформированные базовым символом, за которым следует один или несколько Объединенных символов или суррогатных пар. Для работы с символами Юникода вместо <xref:System.Char> объектов используйте классы <xref:System.Globalization.StringInfo?displayProperty=nameWithType> и <xref:System.Globalization.TextElementEnumerator>. В следующем примере показана разница между кодом, который работает с <xref:System.Char>ными объектами, и кодом, который работает с символами Юникода. Он сравнивает количество символов или текстовых элементов в каждом слове предложения. Строка содержит две последовательности базового символа, за которыми следует несамостоятельный символ.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 Этот пример работает с текстовыми элементами с помощью метода <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> и класса <xref:System.Globalization.TextElementEnumerator> для перечисления всех текстовых элементов в строке. Можно также извлечь массив, содержащий начальный индекс каждого текстового элемента, вызвав метод <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType>.  
  
 Дополнительные сведения о работе с единицами текста, а не отдельными <xref:System.Char> значениями, см. в разделе класс <xref:System.Globalization.StringInfo>.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Пустые строки и пустые строки  
 Строка, которая была объявлена, но ей не было присвоено значение, — `null`. При попытке вызова методов для этой строки создается <xref:System.NullReferenceException>. Строка со значением NULL отличается от пустой строки, которая представляет собой строку со значением "" или <xref:System.String.Empty?displayProperty=nameWithType>. В некоторых случаях передача пустой строки или пустой строки в качестве аргумента в вызове метода вызывает исключение. Например, передача строки со значением NULL в метод <xref:System.Int32.Parse%2A?displayProperty=nameWithType> создает исключение <xref:System.ArgumentNullException>и передает пустую строку, выдает <xref:System.FormatException>. В других случаях аргумент метода может быть строкой null или пустой строкой. Например, если вы предоставляете реализацию <xref:System.IFormattable> для класса, вам нужно равенство строки null и пустой строки с описателем общего формата ("G").  
  
 Класс <xref:System.String> включает следующие два удобных метода, которые позволяют проверить, является ли строка `null` или пустой:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, указывающее, является ли строка `null` или равна <xref:System.String.Empty?displayProperty=nameWithType>. Этот метод исключает необходимость использования следующего кода:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, который указывает, является ли строка `null`ной, равной <xref:System.String.Empty?displayProperty=nameWithType>или состоит только из пробельных символов. Этот метод исключает необходимость использования следующего кода:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 В следующем примере используется метод <xref:System.String.IsNullOrEmpty%2A> в реализации <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> пользовательского класса `Temperature`. Метод поддерживает строки формата "G", "C", "F" и "K". Если пустая строка формата или строка формата со значением `null` передается в метод, его значение изменяется на строку формата "G".  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Неизменность и класс StringBuilder  
 Объект <xref:System.String> называется неизменяемым (только для чтения), так как его значение нельзя изменить после его создания. Методы, которые выглядят для изменения объекта <xref:System.String>, фактически возвращают новый объект <xref:System.String>, содержащий изменение.  
  
 Так как строки являются неизменяемыми, подпрограммы обработки строк, выполняющие повторяющиеся добавления или удаления, которые представляют собой одну строку, могут значительно преноситься к производительности. Например, в следующем коде генератор случайных чисел используется для создания строки с 1000 символами в диапазоне от 0x0001 до 0x052F. Несмотря на то, что код использует объединение строк для добавления нового символа к существующей строке с именем `str`, он на самом деле создает новый объект <xref:System.String> для каждой операции объединения.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Класс <xref:System.Text.StringBuilder> можно использовать вместо класса <xref:System.String> для операций, которые делают несколько изменений в значении строки. В отличие от экземпляров класса <xref:System.String> <xref:System.Text.StringBuilder> объекты являются изменяемыми. При сцеплении, добавлении или удалении подстрок из строки операции выполняются в одной строке. Завершив изменение значения объекта <xref:System.Text.StringBuilder>, можно вызвать его метод <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>, чтобы преобразовать его в строку. Следующий пример заменяет <xref:System.String>, использованный в предыдущем примере, для сцепления 1000 случайных символов в диапазоне в 0x052F с объектом <xref:System.Text.StringBuilder>.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Порядковые и зависящие от языка и региональных параметров операции  
 Члены класса <xref:System.String> выполняют операции с порядковым номером или с учетом языка и региональных параметров (лингвистические) для объекта <xref:System.String>. Порядковые операции выполняются с числовым значением каждого объекта <xref:System.Char>. Операция с учетом языка и региональных параметров действует на значение объекта <xref:System.String> и принимает учетные данные, относящиеся к языку и региональным параметрам, а также правилам сортировки, форматирования и анализа. Операции с учетом языка и региональных параметров выполняются в контексте явно объявленного языка и региональных параметров или неявного текущего языка и региональных параметров. Два вида операций могут давать значительные результаты, если они выполняются в одной и той же строке.  
  
.NET также поддерживает лингвистические строковые операции без учета языка и региональных параметров, используя инвариантный язык и региональные параметры (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), которые слабо основаны на параметрах языка и региональных параметров английского языка, независимо от региона. В отличие от других параметров <xref:System.Globalization.CultureInfo?displayProperty=nameWithType>, параметры инвариантных региональных параметров гарантированно остаются согласованными на одном компьютере, от системы до системы и в разных версиях .NET. Инвариантный язык и региональные параметры можно рассматривать как разновидности черного прямоугольника, что обеспечивает стабильность сравнений строк и упорядочения во всех культурах.  
  
> [!IMPORTANT]
>  Если приложение принимает решение о безопасности символьного идентификатора, такого как имя файла или именованный канал, или о сохраненных данных, таких как текстовые данные в XML-файле, операция должна использовать порядковое сравнение вместо сравнения с учетом языка и региональных параметров. Это связано с тем, что сравнение с учетом языка и региональных параметров может дать разные результаты в зависимости от языка и региональных параметров, в то время как порядковое сравнение зависит только от двоичного значения сравниваемых символов.  
  
> [!IMPORTANT]
>  Большинство методов, выполняющих строковые операции, включают в себя перегрузку с параметром типа <xref:System.StringComparison>, который позволяет указать, выполняет ли метод порядковый номер или операцию с учетом языка и региональных параметров. В общем случае следует вызывать эту перегрузку, чтобы сделать вызов метода открытым. Рекомендации и рекомендации по использованию строковых и языковых параметров в строках см. в разделе рекомендации [по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 Операции по [регистру](#casing), [синтаксическому анализу, форматированию](#parsing), [сортировке и](#comparison) [проверке на равенство](#equality) могут быть либо порядковыми, либо с учетом языка и региональных параметров. В следующих разделах рассматриваются все категории операций.  
  
> [!TIP]
>  Следует всегда вызывать перегрузку метода, которая делает цель вызова метода понятной. Например, вместо вызова метода <xref:System.String.Compare%28System.String%2CSystem.String%29> для выполнения сравнения двух строк с учетом языка и региональных параметров с помощью правил текущего языка и региональных параметров следует вызвать метод <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> со значением <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> для аргумента `comparisonType`. Дополнительные сведения см. в разделе [Рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  

Можно скачать [таблицы коэффициентов сортировки](https://www.microsoft.com/download/details.aspx?id=10921) — набор текстовых файлов, которые содержат сведения о весовых коэффициентах символов, используемых в операциях сортировки и сравнения для операционных систем Windows, а также [таблицу параметров сортировки по умолчанию для элементов Юникод](https://www.unicode.org/Public/UCA/latest/allkeys.txt) — таблицу весовых коэффициентов сортировки для Linux и macOS.

<a name="casing"></a>   
### <a name="casing"></a>Различает  
 Правила учета регистра определяют способ изменения регистра символов Юникода. Например, от нижнего регистра до верхнего. Часто операция с регистром выполняется перед сравнением строк. Например, строка может быть преобразована в верхний регистр, чтобы ее можно было сравнить с другой строкой в верхнем регистре. Символы в строке можно преобразовать в нижний регистр, вызвав метод <xref:System.String.ToLower%2A> или <xref:System.String.ToLowerInvariant%2A>, а также преобразовать их в верхний регистр, вызвав метод <xref:System.String.ToUpper%2A> или <xref:System.String.ToUpperInvariant%2A>. Кроме того, можно использовать метод <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> для преобразования строки в вариант заголовка.  

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]  
  
 Операции с регистром могут основываться на правилах текущего языка и региональных параметров, указанной культуре или инвариантном языке и региональных параметрах. Поскольку сопоставления вариантов могут различаться в зависимости от используемого языка и региональных параметров, результат операций с регистром может различаться в зависимости от языка и региональных параметров. Фактические различия в регистре имеют три вида:  
  
-   Различия в сопоставлении регистра для Латинской ПРОПИСной буквы I (U + 0049), Латинская СТРОЧная буква I (U + 0069), Латинская ПРОПИСная БУКВа I с ТОЧКОЙ выше (U + 0130) и Латинской маленькой БУКВой I без точки I (U + 0131). В языках и региональных параметрах tr-TR (Турецкая (Турция)) и AZ-ЛАТН-AZ (Азербайджан, Latin), а также в нейтральных культурах TR, AZ и AZ-ЛАТН, буква в нижнем регистре, эквивалентная Латинской Латинской БУКВе i, — это буква i, прописная строчная буква i ЛАТИНСКАЯ ПРОПИСНАЯ БУКВА I С ТОЧКОЙ ВЫШЕ. Во всех других культурах, включая инвариантный язык и региональные параметры, Латинская СТРОЧная буква I и Латинская ПРОПИСная БУКВа I, строчные и прописные буквы I.  
  
     В следующем примере показано, как сравнение строк, предназначенное для предотвращения доступа к файловой системе, может завершиться ошибкой, если оно зависит от сравнения регистра с учетом языка и региональных параметров. (Должны использоваться соглашения о регистрах инвариантного языка и региональных параметров.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Различия в сопоставлениях вариантов между инвариантными и другими языками и региональными параметрами. В таких случаях использование правил регистра инвариантного языка и региональных параметров для замены символа на верхний или нижний регистр возвращает один и тот же символ. Для всех других языков и региональных параметров возвращается другой символ. Некоторые из затронутых символов перечислены в следующей таблице.  
  
    |Знак|Если изменено на|Возвращает|  
    |---------------|-------------------|-------------|  
    |ЗНАК МИКРОНА (U + 00B5)|Прописные буквы|ГРЕЧЕСКАЯ ПРОПИСНАЯ БУКВА MU (U +-39C)|  
    |ЛАТИНСКАЯ ПРОПИСНАЯ БУКВА I С ТОЧКОЙ ВЫШЕ (U + 0130)|Строчные буквы|ЛАТИНСКАЯ СТРОЧНАЯ БУКВА I (U + 0069)|  
    |ЛАТИНСКАЯ СТРОЧНАЯ БУКВА I БЕЗ ТОЧКИ (U + 0131)|Прописные буквы|ЛАТИНСКАЯ ПРОПИСНАЯ БУКВА I (U + 0049)|  
    |ЛАТИНСКАЯ СТРОЧНАЯ БУКВА S (U + 017F)|Прописные буквы|ЛАТИНСКАЯ ПРОПИСНАЯ БУКВА S (U + 0053)|  
    |ЛАТИНСКАЯ ПРОПИСНАЯ БУКВА D С МАЛЫМ ПИСЬМОМ Z С КЭРОНА (U + 01C5)|Строчные буквы|ЛАТИНСКАЯ СТРОЧНАЯ БУКВА DZ С КЭРОНА (U + 01C6)|  
    |СОЧЕТАНИЕ ГРЕЧЕСКОГО ИПОЖЕГРАММЕНИ (U + 0345)|Прописные буквы|ГРЕЧЕСКАЯ ПРОПИСНАЯ БУКВА ЙОТА (U + 0399)|  
  
-   Различия в сопоставлении регистров двух букв в разных регистрах в диапазоне символов ASCII. В большинстве языков и региональных параметров пара, состоящую из двух букв, эквивалентна паре из двух букв в верхнем или нижнем регистре. Это не верно для следующих двух пар символов в следующих культурах, так как в каждом случае они сравниваются с графом раскрутки:  
  
    -   "lJ" и "nJ" в культуре hr-HR (Хорватский (Хорватия)).  
  
    -   "cH" в культурах cs-CZ (чешский (Чешская Республика)) и SK-SK (Словацкий (Словакия)).  
  
    -   "aA" в культуре da-DK (Датский (Дания)).  
  
    -   "cS", "dZ", "Дзс", "Россия", "sZ", "tY" и "zS" в культуре hu-HU (Венгерский (Венгрия)).  
  
    -   "cH" и "lL" в культуре es-ES_tradnl (Испанский (Испания, традиционная сортировка)).  
  
    -   "cH", "n", "kH", "nG" "nH", "pH", "qU", "tH" и "tR" в культуре vi-VN (вьетнамский (Вьетнам)).  
  
     Однако нередко возникает ситуация, при которой сравнение этих пар с учетом языка и региональных параметров создает проблемы, поскольку эти пары редко встречаются в фиксированных строках или идентификаторах.  
  
 В следующем примере показаны некоторые различия в правилах использования регистров между языками и региональными параметрами при преобразовании строк в верхний регистр.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>Синтаксический анализ и форматирование  
 Форматирование и синтаксический анализ являются обратными операциями. Правила форматирования определяют способ преобразования значения, например даты и времени или числа, в строковое представление, а правила анализа определяют, как преобразовать строковое представление в значение, например дату и время. Правила форматирования и анализа зависят от региональных соглашений. В следующем примере показана неоднозначность, которая может возникнуть при интерпретации строки даты, зависящей от языка и региональных параметров. Без знания соглашений о культуре, которая использовалась для создания строки даты, невозможно определить, что 03/01/2011, 3/1/2011 и 01/03/2011 представляют 3 января, 2011 или 1 марта, 2011.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 Аналогично, как показано в следующем примере, одна строка может формировать разные даты в зависимости от языка и региональных параметров, соглашения об использовании которых используются в операции синтаксического анализа.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Сравнение строк и сортировка  
 Соглашения для сравнения и сортировки строк различаются в зависимости от языка и региональных параметров. Например, порядок сортировки может быть основан на фонетическом или визуальном представлении символов. В восточно-азиатских языках символы сортируются по штриху и радикалу иероглифов. Сортировка также зависит от языков заказов и культур, используемых для алфавита. Например, датский язык содержит символ "Æ", который сортируется после "Z" в алфавите. Кроме того, в сравнениях можно учитывать регистр или без учета регистра, а в некоторых случаях правила учета регистра также отличаются языком и региональными параметрами. Порядковое сравнение, с другой стороны, использует кодовые точки Юникода отдельных символов в строке при сравнении и сортировке строк.  
  
 Правила сортировки определяют алфавитный порядок символов Юникода и порядок сравнения двух строк. Например, метод <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> сравнивает две строки на основе параметра <xref:System.StringComparison>. Если значение параметра равно <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, метод выполняет лингвистическое сравнение, в котором используются соглашения текущего языка и региональных параметров. Если значение параметра равно <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, метод выполняет порядковое сравнение. Следовательно, как показано в следующем примере, если текущий язык и региональные параметры — Английский (США), первый вызов метода <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> (с использованием сравнения с учетом языка и региональных параметров) считает, что "a" меньше, чем "A", а второй вызов того же метода (используя порядковое сравнение). рассматривает "a" больше чем "A".  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET поддерживает правила сортировки по словам, строкам и порядковым номерам:  
  
-   Сортировка по словам выполняет сравнение строк, зависящих от языка и региональных параметров, с некоторыми небуквенно определенными символами Юникода, которым могут быть назначены специальные весовые коэффициенты. Например, для дефиса (-) может быть назначен очень малый вес, чтобы «Coop» и «Co-Op» появились рядом друг с другом в отсортированном списке. Список методов <xref:System.String>, сравнивающих две строки с помощью правил сортировки Word, см. в разделе [строковые операции по категориям](#ByCategory) .  
  
-   Строка сортировки также выполняет сравнение с учетом языка и региональных параметров. Он похож на сортировку по словам, за исключением того, что в нем нет особых случаев, и все символы, отличные от буквенно-цифровых, перед всеми алфавитно-цифровыми символами Юникода. Две строки можно сравнить с помощью правил сортировки строк, вызвав <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> перегрузок метода, которые имеют параметр `options`, которому предоставлено значение <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>. Обратите внимание, что это единственный метод, предоставляемый .NET для сравнения двух строк с помощью правил сортировки строк.  
  
-   Сортировка по порядковому номеру сравнивает строки на основе числового значения каждого объекта <xref:System.Char> в строке. Порядковое сравнение автоматически учитывает регистр, поскольку версии символа в нижнем и верхнем регистре имеют разные кодовые точки. Однако если регистр не важен, можно указать порядковое сравнение, которое игнорирует регистр. Это эквивалентно преобразованию строки в верхний регистр с помощью инвариантного языка и региональных параметров, а затем выполняется порядковое сравнение результата. Список методов <xref:System.String>, сравнивающих две строки с помощью правил сортировки по порядковому номеру, см. в разделе [строковые операции по категориям](#ByCategory) .  
  
 Сравнение с учетом языка и региональных параметров — это любое сравнение, явно или неявно использующее объект <xref:System.Globalization.CultureInfo>, включая инвариантный язык и региональные параметры, заданные свойством <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>. Неявным языком и региональными параметрами является текущий язык и региональные параметры, определяемые свойствами <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> и <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>. Существует существенная разновидность порядка сортировки букв (то есть символов, для которых свойство <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> возвращает `true`) между языками и региональными параметрами. Можно указать сравнение с учетом языка и региональных параметров, которое использует соглашения для определенного языка и региональных параметров, предоставляя объект <xref:System.Globalization.CultureInfo> для метода сравнения строк, такого как <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. Можно указать сравнение с учетом языка и региональных параметров, которое использует соглашения текущего языка и региональных параметров, предоставив <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>или любой элемент перечисления <xref:System.Globalization.CompareOptions>, кроме <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> или <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>, в соответствующую перегрузку метода <xref:System.String.Compare%2A>. Сравнение с учетом языка и региональных параметров обычно подходит для сортировки, а порядковое сравнение — нет. Порядковое сравнение, как правило, подходит для определения того, равны ли две строки (то есть для определения удостоверения), а сравнение с учетом языка и региональных параметров — нет.  
  
 В следующем примере показано различие между сравнением с учетом языка и региональных параметров и порядковыми сравнениями. В примере оцениваются три строки: "Apple", "Æбле" и "Аебле" с использованием сравнения по порядковому номеру и соглашений для языков и региональных параметров da-DK и EN-US (каждый из которых является культурой по умолчанию на момент вызова метода <xref:System.String.Compare%2A>). Поскольку датский язык обрабатывает символ "Æ" как отдельную букву и сортирует его после "Z" в алфавите, строка "Æбле" больше, чем "Apple". Однако "Æбле" не считается эквивалентом "Аебле", поэтому "Æбле" также больше, чем "Аебле". Культура en-US не включает букву "Æ", но интерпретирует ее как эквивалентную "AE", что объясняет, почему "Æбле" меньше "Apple", но равно "Аебле". Порядковое сравнение, с другой стороны, считает "Apple" менее "Æбле", а "Æбле" — большим, чем "Аебле".  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Используйте следующие общие рекомендации для выбора соответствующего метода сортировки или сравнения строк:  
  
-   Если нужно, чтобы строки упорядочивались на основе языка и региональных параметров пользователя, их следует упорядочить на основе правил текущего языка и региональных параметров. Если язык и региональные параметры пользователя изменятся, порядок сортировки строк также изменится соответствующим образом. Например, приложение тезауруса должно всегда сортировать слова в зависимости от языка и региональных параметров пользователя.  
  
-   Если требуется упорядочить строки на основе соглашений определенного языка и региональных параметров, следует упорядочить их, предоставив объект <xref:System.Globalization.CultureInfo>, представляющий этот язык и региональные параметры, в метод сравнения. Например, в приложении, предназначенном для изучения учащихся определенного языка, необходимо упорядочить строки на основе соглашений одного из культур, говорящих на этом языке.  
  
-   Если необходимо, чтобы порядок строк оставался неизменным в разных культурах, следует упорядочить их на основе соглашений инвариантного языка и региональных параметров или использовать порядковое сравнение. Например, порядковый номер сортировки используется для организации имен файлов, процессов, мьютексов или именованных каналов.  
  
-   Для сравнения, включающего решение по обеспечению безопасности (например, допустимость имени пользователя), следует всегда выполнять порядковый номер проверки на равенство, вызывая перегрузку метода <xref:System.String.Equals%2A>.  
  
> [!NOTE]
>  Правила сортировки и учета регистра, учитывающие язык и региональные параметры, которые используются при сравнении строк, зависят от версии .NET. В .NET Framework 4,5 и более поздних версиях, работающих в операционной системе [!INCLUDE[win8](~/includes/win8-md.md)], сортировка, регистр, нормализация и символьная информация в Юникоде соответствует стандарту Unicode 6,0. В других операционных системах Windows она соответствует стандарту Unicode 5,0. В .NET Core это зависит от версии стандарта Юникода, поддерживаемого базовой операционной системой. 
  
 Дополнительные сведения о правилах сортировки по словам, строкам и порядковым номерам см. в <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> разделе. Дополнительные рекомендации по использованию каждого правила см. в разделе рекомендации [для использования строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 Обычно методы сравнения строк, такие как <xref:System.String.Compare%2A>, не вызываются напрямую для определения порядка сортировки строк. Вместо этого методы сравнения вызываются методами сортировки, такими как <xref:System.Array.Sort%2A?displayProperty=nameWithType> или <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. В следующем примере выполняются четыре различные операции сортировки (Сортировка по словам с использованием текущего языка и региональных параметров, сортировка по словам и сортировка строк с использованием инвариантного языка и региональных параметров) без явного вызова метода сравнения строк. Несмотря на то, что они указывают тип используемого сравнения. Обратите внимание, что каждый тип сортировки создает уникальный порядок строк в своем массиве.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  На внутреннем языке .NET использует ключи сортировки для поддержки сравнения строк с учетом языка и региональных параметров. Каждому символу в строке присваивается несколько категорий весовых коэффициентов сортировки, включая буквенные, прописные и диакритические знаки. Ключ сортировки, представленный классом <xref:System.Globalization.SortKey>, предоставляет репозиторий этих весов для конкретной строки. Если приложение выполняет большое количество операций поиска или сортировки на одном наборе строк, можно повысить его производительность, создав и сохранив ключи сортировки для всех используемых строк. Если требуется операция сортировки или сравнения, вместо строк используются ключи сортировки. Дополнительные сведения см. в описании класса <xref:System.Globalization.SortKey>.  
  
 Если не указать соглашение о сравнении строк, то методы сортировки, такие как <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>, выполняют сортировку строк с учетом языка и региональных параметров, учитывающих регистр. В следующем примере показано, как изменение текущего языка и региональных параметров влияет на порядок сортировки строк в массиве. Он создает массив из трех строк. Во-первых, он устанавливает для свойства `System.Threading.Thread.CurrentThread.CurrentCulture` значение en-US и вызывает метод <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>. Итоговый порядок сортировки основан на соглашениях сортировки для языка и региональных параметров "Английский (США)". Далее в примере свойству `System.Threading.Thread.CurrentThread.CurrentCulture` присваивается значение da-DK и снова вызывается метод <xref:System.Array.Sort%2A?displayProperty=nameWithType>. Обратите внимание, что итоговый порядок сортировки отличается от результатов en-US, так как он использует соглашения о сортировке для датского языка (Дания).  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Если основной целью в сравнении строк является определение того, равны ли они, следует вызвать метод <xref:System.String.Equals%2A?displayProperty=nameWithType>. Как правило, для выполнения порядкового сравнения следует использовать <xref:System.String.Equals%2A>. Метод <xref:System.String.Compare%2A?displayProperty=nameWithType> предназначен в основном для сортировки строк.  
  
 Методы поиска строк, такие как <xref:System.String.StartsWith%2A?displayProperty=nameWithType> и <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, также могут выполнять сравнение строк с учетом языка и региональных параметров или порядковыми номерами. В следующем примере показаны различия между порядковыми сравнениями и сравнением с учетом языка и региональных параметров с помощью метода <xref:System.String.IndexOf%2A>. Поиск с учетом языка и региональных параметров, в котором текущий язык и региональные параметры — Английский (США) считает подстроку "OE" соответствующей лигатурой ":". Поскольку мягкий дефис (U + 00AD) является символом нулевой ширины, Поиск рассматривает мягкий дефис как эквивалентный <xref:System.String.Empty?displayProperty=nameWithtype> и находит совпадение в начале строки. С другой стороны, порядковый поиск не находит совпадений в любом случае.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Поиск строк  
 Методы поиска строк, такие как <xref:System.String.StartsWith%2A?displayProperty=nameWithType> и <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, также могут выполнять сравнение строк с учетом языка и региональных параметров или порядковыми номерами для определения того, найден ли в указанной строке символ или подстрока.  
  
 Методы поиска в классе <xref:System.String>, которые выполняют поиск отдельных символов, таких как метод <xref:System.String.IndexOf%2A>, или один из набора символов, например метод <xref:System.String.IndexOfAny%2A>, выполняет порядковый поиск по порядковому номеру. Чтобы выполнить поиск символа с учетом языка и региональных параметров, необходимо вызвать метод <xref:System.Globalization.CompareInfo>, например <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> или <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Обратите внимание, что результаты поиска символа с использованием порядкового номера и сравнения с учетом языка и региональных параметров могут быть очень разными. Например, Поиск предопределенного символа Юникода, такого как лигатура "Æ" (U + 00C6), может соответствовать любому вхождению его компонентов в правильной последовательности, например "AE" (U + 041U + 0045), в зависимости от языка и региональных параметров. В следующем примере показано различие между методами <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> и <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> при поиске отдельного символа. Лигатура "æ" (U + 00E6) находится в строке "аэрофотосъемки" при использовании соглашений языка и региональных параметров en-US, но не при использовании соглашений для языка и региональных параметров da-DK или при выполнении порядкового сравнения.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 С другой стороны, <xref:System.String> методы класса, которые выполняют поиск строки, а не символа, выполняет поиск с учетом языка и региональных параметров, если параметры поиска не задаются явно параметром типа <xref:System.StringComparison>. Единственным исключением является <xref:System.String.Contains%2A>, которое выполняет порядковый поиск.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Проверка на равенство  
 Используйте метод <xref:System.String.Compare%2A?displayProperty=nameWithType> для определения связи двух строк в порядке сортировки. Как правило, это операция с учетом языка и региональных параметров. Напротив, вызовите метод <xref:System.String.Equals%2A?displayProperty=nameWithType> для проверки на равенство. Так как проверка на равенство обычно сравнивает введенные пользователем данные с определенной известной строкой, например с допустимым именем пользователя, паролем или путем файловой системы, обычно это порядковая операция.  
  
> [!WARNING]
>  Для проверки на равенство можно вызвать метод <xref:System.String.Compare%2A?displayProperty=nameWithType> и определить, является ли возвращаемое значение нулевым. Однако этот подход не рекомендуется. Чтобы определить, равны ли две строки, следует вызвать одну из перегрузок метода <xref:System.String.Equals%2A?displayProperty=nameWithType>. Предпочтительной перегруженной версией является метод <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> экземпляра или статический метод <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>, поскольку оба метода включают параметр <xref:System.StringComparison?displayProperty=nameWithType>, который явно указывает тип сравнения.  
  
 В следующем примере показана опасность выполнения сравнения с учетом языка и региональных параметров на равенство, если вместо этого используется порядковый номер. В этом случае цель кода заключается в запрете доступа к файловой системе с URL-адресов, которые начинаются с "FILE://" или "file://", путем сравнения начала URL-адреса со строкой "FILE://" без учета регистра. Однако если сравнение с учетом языка и региональных параметров выполняется с использованием турецкого (Турция) языка и региональных параметров по URL-адресу, который начинается с "file://", сравнение на равенство завершается неудачей, так как прописная буква "i" в верхнем регистре имеет букву "i", а не "I". В результате доступ к файловой системе непреднамеренно разрешен. С другой стороны, если выполняется порядковое сравнение, сравнение на равенство выполняется, а доступ к файловой системе запрещается.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Нормализация  
 Некоторые символы Юникода имеют несколько представлений. Например, любая из следующих кодовых позиций может представлять букву «ắ»:  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U+0061 U+0306 U+0301  
  
 Несколько представлений для одного символа усложняют поиск, сортировку, сопоставление и другие строковые операции.  
  
 Стандарт Unicode определяет процесс, называемый нормализацией, который возвращает одно двоичное представление символа Юникода для любого из его эквивалентов в двоичном представлении. Нормализация может использовать несколько алгоритмов, называемых формами нормализации, которые следуют различным правилам. .NET поддерживает формы нормализации Юникода C, D, KC и KD. Если строки нормализованы для одной и той же формы нормализации, их можно сравнить с помощью сравнения по порядковому номеру.  
  
 Порядковое сравнение — это двоичное сравнение скалярного значения Юникода для соответствующих <xref:System.Char> объектов в каждой строке. Класс <xref:System.String> включает ряд методов, которые могут выполнять порядковое сравнение, включая следующие:  
  
-   Любая перегрузка методов <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>и <xref:System.String.LastIndexOf%2A>, которые включают параметр <xref:System.StringComparison>. Метод выполняет порядковое сравнение, если для этого параметра указано значение <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> или <xref:System.StringComparison.OrdinalIgnoreCase>.  
  
-   Перегрузки метода <xref:System.String.CompareOrdinal%2A>.  
  
-   Методы, использующие порядковое сравнение по умолчанию, такие как <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>и <xref:System.String.Split%2A>.  
  
-   Методы, которые выполняют поиск <xref:System.Char>ного значения или для элементов в массиве <xref:System.Char> в экземпляре строки. К таким методам относятся <xref:System.String.IndexOf%28System.Char%29> и <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 Можно определить, нормализована ли строка до формы нормализации C путем вызова метода <xref:System.String.IsNormalized?displayProperty=nameWithType>, или же можно вызвать метод <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType>, чтобы определить, является ли строка нормализованной для заданной формы нормализации. Можно также вызвать метод <xref:System.String.Normalize?displayProperty=nameWithType> для преобразования строки в форму нормализации C или вызвать метод <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> для преобразования строки в заданную форму нормализации. Пошаговые инструкции по нормализации и сравнению строк см. в разделе методы <xref:System.String.Normalize> и <xref:System.String.Normalize%28System.Text.NormalizationForm%29>.  
  
 В следующем простом примере показана нормализация строк. Он определяет букву "ố" тремя различными способами в трех разных строках и использует порядковое сравнение для проверки на равенство, чтобы определить, что каждая строка отличается от других двух строк. Затем каждая строка преобразуется в поддерживаемые формы нормализации и снова выполняет порядковое сравнение каждой строки в заданной форме нормализации. В каждом случае второй тест на равенство показывает, что строки равны.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Дополнительные сведения о формах нормализации и нормализации см. в разделе <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, а также в [стандартном приложении юникод #15: формы нормализации Юникода](https://unicode.org/reports/tr15/) и [часто задаваемые вопросы о нормализации](https://www.unicode.org/faq/normalization.html) на веб-сайте Unicode.org.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Строковые операции по категориям  
 Класс <xref:System.String> предоставляет элементы для сравнения строк, проверки строк на равенство, поиска символов или подстрок в строке, изменения строки, извлечения подстрок из строки, объединения строк, форматирования значений, копирования строки и нормализации строки.  
  
### <a name="comparing-strings"></a>Сравнение строк  
 Можно сравнить строки, чтобы определить их относительное расположение в порядке сортировки, используя следующие методы <xref:System.String>:  
  
-   <xref:System.String.Compare%2A> возвращает целое число, указывающее связь одной строки со второй строкой в порядке сортировки.  
  
-   <xref:System.String.CompareOrdinal%2A> возвращает целое число, которое указывает на связь одной строки со второй строкой на основе сравнения кодовых позиций.  
  
-   <xref:System.String.CompareTo%2A> возвращает целое число, указывающее связь текущего экземпляра строки со второй строкой в порядке сортировки. Метод <xref:System.String.CompareTo%28System.String%29> предоставляет реализации <xref:System.IComparable> и <xref:System.IComparable%601> для класса <xref:System.String>.  
  
### <a name="testing-strings-for-equality"></a>Проверка строк на равенство  
 Чтобы определить, равны ли две строки, вызовите метод <xref:System.String.Equals%2A>. <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> экземпляра и статические <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> перегрузки позволяют указать, учитывается ли сравнение с учетом языка и региональных параметров или порядковым номером, а также учитывается ли регистр. Большинство тестов на равенство являются порядковыми, а сравнения на равенство, определяющие доступ к системному ресурсу (например, к объекту файловой системы), всегда должны быть порядковыми.  
  
### <a name="finding-characters-in-a-string"></a>Поиск символов в строке  
 Класс <xref:System.String> включает два вида методов поиска:  
  
-   Методы, возвращающие <xref:System.Boolean> значение, указывающее, содержится ли конкретная подстрока в экземпляре строки. К ним относятся методы <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>и <xref:System.String.StartsWith%2A>.  
  
-   Методы, указывающие начальную точку подстроки в экземпляре строки. К ним относятся методы <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>и <xref:System.String.LastIndexOfAny%2A>.  
  
> [!WARNING]
>  Если требуется найти в строке определенный шаблон, а не конкретную подстроку, следует использовать регулярные выражения. Дополнительные сведения см. в разделе [регулярные выражения .NET](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Изменение строки  
 Класс <xref:System.String> содержит следующие методы, которые приводят к изменению значения строки:  
  
-   <xref:System.String.Insert%2A> вставляет строку в текущий экземпляр <xref:System.String>.  
  
-   <xref:System.String.PadLeft%2A> вставляет одно или несколько вхождений указанного символа в начале строки.  
  
-   <xref:System.String.PadRight%2A> вставляет одно или несколько вхождений указанного символа в конце строки.  
  
-   <xref:System.String.Remove%2A> удаляет подстроку из текущего экземпляра <xref:System.String>.  
  
-   <xref:System.String.Replace%2A> заменяет подстроку другой подстрокой в текущем экземпляре <xref:System.String>.  
  
-   <xref:System.String.ToLower%2A> и <xref:System.String.ToLowerInvariant%2A> преобразуют все символы в строке в нижний регистр.  
  
-   <xref:System.String.ToUpper%2A> и <xref:System.String.ToUpperInvariant%2A> преобразовать все символы в строке в верхний регистр.  
  
-   <xref:System.String.Trim%2A> удаляет все вхождения символа из начала и конца строки.  
  
-   <xref:System.String.TrimEnd%2A> удаляет все вхождения символа из конца строки.  
  
-   <xref:System.String.TrimStart%2A> удаляет все вхождения символа из начала строки.  
  
> [!IMPORTANT]
>  Все методы изменения строк возвращают новый объект <xref:System.String>. Они не изменяют значение текущего экземпляра.  
  
### <a name="extracting-substrings-from-a-string"></a>Извлечение подстрок из строки  
 Метод <xref:System.String.Split%2A?displayProperty=nameWithType> разделяет одну строку на несколько строк. Перегрузки метода позволяют указать несколько разделителей, определить максимальное количество подстрок, извлекаемых методом, а также определить, включаются ли пустые строки (которые происходят при смежности разделителей) в возвращаемые строки.  
  
### <a name="combining-strings"></a>Объединение строк  
 Для сцепления строк можно использовать следующие методы <xref:System.String>.  
  
-   <xref:System.String.Concat%2A> объединяет одну или несколько подстрок в одну строку.  
  
-   <xref:System.String.Join%2A> объединяет одну или несколько подстрок в один элемент и добавляет разделитель между каждой подстрокой.  
  
### <a name="formatting-values"></a>Форматирование значений  
 Метод <xref:System.String.Format%2A?displayProperty=nameWithType> использует функцию составного форматирования для замены одного или нескольких заполнителей в строке строковым представлением некоторого объекта или значения. Метод <xref:System.String.Format%2A> часто используется для следующих задач:  
  
-   Встраивание строкового представления числового значения в строку.  
  
-   Встраивание строкового представления значения даты и времени в строку.  
  
-   Встраивание строкового представления значения перечисления в строку.  
  
-   Чтобы внедрить строковое представление некоторого объекта, поддерживающего интерфейс <xref:System.IFormattable> в строке.  
  
-   Выровнять по правому краю или по левому краю подстроку в поле в более длинной строке.  
  
 Подробные сведения об операциях форматирования и примерах см. в разделе Сводка по перегрузке <xref:System.String.Format%2A>.  
  
### <a name="copying-a-string"></a>Копирование строки  
 Чтобы создать копию строки, можно вызвать следующие методы <xref:System.String>:  
  
-   <xref:System.String.Clone%2A> возвращает ссылку на существующий объект <xref:System.String>.  
  
-   <xref:System.String.Copy%2A> создает копию существующей строки.  
  
-   <xref:System.String.CopyTo%2A> копирует часть строки в массив символов.  
  
### <a name="normalizing-a-string"></a>Нормализация строки  
 В Юникоде один символ может иметь несколько кодовых точек. Нормализация преобразует эти эквивалентные символы в одно и то же двоичное представление. Метод <xref:System.String.Normalize%2A?displayProperty=nameWithType> выполняет нормализацию, а метод <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> определяет, является ли строка нормализованной.  
  
 Дополнительные сведения и пример см. в разделе [нормализация](#Normalization) ранее в этом разделе.  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/download/details.aspx?id=10921">Сортировка таблиц веса для операционных систем Windows</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">Таблица элементов параметров сортировки Юникода по умолчанию для Linux и macOS</related>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Рекомендации по использованию строк в .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Содержание  
  
   [синтаксиса перегруженного конструктора](#Syntax)  
   [параметров](#Params)  
 [Исключения](#Exceptions)   
 [Какой метод следует вызывать?](#Tasks)   
 [Создание строк](#Creating_Strings)   
 [Обработка повторяющихся строк](#Repetitive)   
 Примеры создания экземпляров строк:   
 [Использование присваивания строк](#Ctor1_Example)  
 [Использование массива символов](#Ctor2_Example)  
 [Использование части массива символов и повторение одного символа](#Ctor3_Example)  
 [Использование указателя на массив символов](#Ctor4_Example)  
 [Использование указателя и диапазона массива](#Ctor5_Example)  
 [Использование указателя на массив байтов со знаком](#Ctor6_Example)  
[Сведения о версии](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Синтаксис перегруженного конструктора  
 Конструкторы строк делятся на две категории: без параметров указателя и с параметрами указателя. Конструкторы, использующие указатели, не являются CLS-совместимыми. Кроме того, Visual Basic не поддерживает использование указателей и C# требует кода, который использует указатели для выполнения в ненадежном контексте. Дополнительные сведения см. в разделе [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Дополнительные рекомендации по выбору перегрузки см. в разделе [метод, который я вызываю?](#Tasks)  
  
 `String(Char[] value)`  
 Инициализирует новый экземпляр значением, указанным в массиве символов Юникода. Этот конструктор копирует символы Юникода ([Пример](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Инициализирует новый экземпляр значением, указанным в массиве символов Юникода, начальной позицией символа в этом массиве и длиной ([Пример](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Инициализирует новый экземпляр со значением, указанным в указанном символе Юникода, повторяемым указанное число раз ([например](#Ctor3_Example),).  
  
 `String(char* value)`  
 **(Не совместимо с CLS)** Инициализирует новый экземпляр значением, указанным указателем на массив символов Юникода, заканчивающийся нулевым символом (U + 0000 или ' \ 0 '). ([Пример](#Ctor4_Example)).  
  
 Разрешение: <xref:System.Security.SecurityCriticalAttribute>, для немедленного вызывающего объекта требуется полное доверие. Этот член не может использоваться частично доверенным или прозрачным кодом.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Не совместимо с CLS)** Инициализирует новый экземпляр значением, указанным указателем на массив символов Юникода, начальной позицией символа в этом массиве и длиной. Конструктор копирует символы Юникода из `value`, начиная с индекса `startIndex` и заканчивая индексом `startIndex` + `length`-1 ([Пример](#Ctor5_Example)).  
  
 Разрешение: <xref:System.Security.SecurityCriticalAttribute>, для немедленного вызывающего объекта требуется полное доверие. Этот член не может использоваться частично доверенным или прозрачным кодом.  
  
 `String(SByte* value)`  
 **(Не совместимо с CLS)** Инициализирует новый экземпляр значением, указанным указателем на массив 8-разрядных целых чисел со знаком. Предполагается, что массив представляет собой строку, закодированную с помощью текущей системной кодовой страницы (то есть кодировка, заданная <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Конструктор обрабатывает символы из `value`, начиная с расположения, заданного указателем, до тех пор, пока не будет достигнут символ null ([например](#Ctor6_Example),).  
  
 Разрешение: <xref:System.Security.SecurityCriticalAttribute>, для немедленного вызывающего объекта требуется полное доверие. Этот член не может использоваться частично доверенным или прозрачным кодом.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Не совместимо с CLS)** Инициализирует новый экземпляр значением, указанным указателем на массив 8-разрядных целых чисел со знаком, начальную точку в этом массиве и длину.  Предполагается, что массив представляет собой строку, закодированную с помощью текущей системной кодовой страницы (то есть кодировка, заданная <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Конструктор обрабатывает символы из значения, начиная с `startIndex` и заканчивая `startIndex` + `length`-1 ([Пример](#Ctor6_Example)).  
  
 Разрешение: <xref:System.Security.SecurityCriticalAttribute>, для немедленного вызывающего объекта требуется полное доверие. Этот член не может использоваться частично доверенным или прозрачным кодом.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Не совместимо с CLS)** Инициализирует новый экземпляр значением, указанным указателем на массив 8-разрядных целых чисел со знаком, начальную точку в пределах этого массива, длину и объект <xref:System.Text.Encoding>.  
  
 Разрешение: <xref:System.Security.SecurityCriticalAttribute>, для немедленного вызывающего объекта требуется полное доверие. Этот член не может использоваться частично доверенным или прозрачным кодом.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Параметры  
 Ниже приведен полный список параметров, используемых конструкторами <xref:System.String>, не включающими параметр указателя. Параметры, используемые каждой перегрузкой, см. в описании приведенного выше синтаксиса перегрузки.  
  
|Параметр|Тип|Описание|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Массив знаков Юникода.|  
|`c`|<xref:System.Char>|Знак Юникода.|  
|`startIndex`|<xref:System.Int32>|Начальная позиции в `value` первого символа в новой строке.<br /><br /> Значение по умолчанию: 0|  
|`length`|<xref:System.Int32>|Число символов в `value`, включаемых в новую строку.<br /><br /> Значение по умолчанию: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|Количество повторений `c` символов в новой строке. Если `count` равен нулю, значение нового объекта будет <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Ниже приведен полный список параметров, используемых конструкторами <xref:System.String>, которые включают параметр указателя. Параметры, используемые каждой перегрузкой, см. в описании приведенного выше синтаксиса перегрузки.  
  
|Параметр|Тип|Описание|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> - или -<br /><br /> <xref:System.SByte>\*|Указатель на массив символов Юникода, заканчивающийся нулем, или массив 8-разрядных целых чисел со знаком. Если `value` имеет `null` или пустой массив, значение новой строки будет <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|Индекс элемента массива, который определяет первый символ в новой строке.<br /><br /> Значение по умолчанию: 0|  
|`length`|<xref:System.Int32>|Число элементов массива, используемых для создания новой строки. Если значение length равно нулю, конструктор создает строку со значением <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Значение по умолчанию: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Объект, указывающий способ кодирования `value` массива.<br /><br /> Значение по умолчанию: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>или Текущая кодовая страница ANSI системы|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Исключения  
 Ниже приведен список исключений, создаваемых конструкторами, которые не включают параметры указателя.  
  
|Исключение|Условие|Кем создано|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` — `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`или `count` меньше нуля.<br /><br /> - или -<br /><br /> Сумма `startIndex` и `length` больше, чем число элементов в `value`.<br /><br /> - или -<br /><br /> Значение параметра `count` меньше нуля.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Ниже приведен список исключений, создаваемых конструкторами, которые включают в себя параметры-указатели.  
  
|Исключение|Условие|Кем создано|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` указывает массив, содержащий недопустимый символ Юникода.<br /><br /> - или -<br /><br /> `value` или `value` + `startIndex` указывает адрес, размер которого меньше 64 КБ.<br /><br /> - или -<br /><br /> Не удалось инициализировать новый экземпляр <xref:System.String> из `value` массива байтов, так как `value` не использует кодировку кодовой страницы по умолчанию.|Все конструкторы с указателями.|  
|<xref:System.ArgumentNullException>|Параметр `value` имеет значение null.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|Текущий процесс не имеет доступа на чтение ко всем рассматриваемым символам.<br /><br /> - или -<br /><br /> `startIndex` или `length` меньше нуля, `value` + `startIndex` приводит к переполнению указателя, или текущий процесс не имеет доступа на чтение ко всем адресуемым символам.<br /><br /> - или -<br /><br /> Длина новой строки слишком велика для выделения.|Все конструкторы с указателями.|  
|<xref:System.AccessViolationException>|`value`или `value` + `startIndex` + `length`-1, указывает недопустимый адрес.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Какой метод следует вызывать?  
  
|Кому|Вызов или использование|  
|--------|-----------------|  
|Создайте строку.|Присваивание из строкового литерала или существующей строки ([Пример](#Ctor1_Example))|  
|Создать строку из целого массива символов.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([Пример](#Ctor2_Example))|  
|Создать строку из части массива символов.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([Пример](#Ctor3_Example))|  
|Создайте строку, которая повторяет один и тот же символ несколько раз.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([Пример](#Ctor3_Example))|  
|Создать строку из указателя на массив символов в Юникоде или расширенную кодировку.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Создание строки из части массива символов Юникода или расширенного символа с помощью указателя.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Создайте строку из C++ `char` массива.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> - или -<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Создайте строку из символов ASCII.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Создание строк  
 Наиболее часто используемый способ создания строк программным способом — это простое присваивание, как показано в [этом примере](#Ctor1_Example). Класс <xref:System.String> также включает четыре типа перегрузок конструктора, которые позволяют создавать строки из следующих значений:  
  
-   Из массива символов (массива символов в кодировке UTF-16). Можно создать новый объект <xref:System.String> из символов во всем массиве или в его части. Конструктор <xref:System.String.%23ctor%28System.Char%5B%5D%29> копирует все символы в массиве в новую строку. Конструктор <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> копирует символы из `startIndex` индекса в индекс `startIndex` + `length`-1 в новую строку. Если `length` равен нулю, значение новой строки будет <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Если код многократно создает строки с одинаковым значением, можно повысить производительность приложения с помощью альтернативного способа создания строк. Дополнительные сведения см. в разделе [Обработка повторяющихся строк](#Repetitive).  
  
-   Из одного символа, дублирующего ноль, один или более раз с помощью конструктора <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>. Если `count` равен нулю, значение новой строки будет <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Из указателя на массив символов, заканчивающийся нулем, с помощью конструктора <xref:System.String.%23ctor%28System.Char%2A%29> или <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>. Для инициализации строки можно использовать либо весь массив, либо указанный диапазон. Конструктор копирует последовательность символов Юникода, начиная с указанного указателя, или из указанного указателя, а также `startIndex` и продолжается до конца массива или для `length` символов. Если `value` является пустым указателем или `length` равен нулю, конструктор создает строку, значение которой равно <xref:System.String.Empty?displayProperty=nameWithType>. Если операция копирования продолжается до конца массива, а массив не завершается нулем, поведение конструктора зависит от системы. Такое условие может вызвать нарушение прав доступа.  
  
     Если массив содержит любые внедренные символы NULL (U + 0000 или ' \ 0 ') и вызывается перегрузка <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>, то экземпляр строки содержит `length` символы, включая любые внедренные значения NULL. В следующем примере показано, что происходит, когда в метод <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> передается указатель на массив из 10 элементов, включающий в себя два символа null. Поскольку адрес — это начало массива, и все элементы массива должны быть добавлены в строку, конструктор создает экземпляр строки с десятью символами, включая два встроенных значения NULL. С другой стороны, если один и тот же массив передается конструктору <xref:System.String.%23ctor%28System.Char%2A%29>, результатом является строка из четырех символов, которая не включает первый символ null.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     Массив должен содержать символы Юникода. В C++это означает, что массив символов должен быть определен как управляемый тип <xref:System.Char>[] или неуправляемый тип`wchar_t`[].  
  
     Если вызывается перегрузка <xref:System.String.%23ctor%28System.Char%2A%29> и массив не завершается нулем или если вызвана перегрузка <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> и `startIndex` + `length`-1 включает диапазон, который находится за пределами памяти, выделенной для последовательности символов поведение конструктора зависит от системы, и может возникнуть нарушение прав доступа. Кроме того, на процессоре Intel Itanium вызовы конструктора <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> могут вызвать исключение <xref:System.DataMisalignedException>. Если это происходит, вызовите <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>.  
  
-   Из указателя на массив байтов со знаком. Для инициализации строки можно использовать либо весь массив, либо указанный диапазон. Последовательность байтов может интерпретироваться с помощью кодировки кодовой страницы по умолчанию, или в вызове конструктора можно указать кодировку. Если конструктор пытается создать экземпляр строки из целого массива, не заканчивающегося нулем, или диапазон массива `value` + `startIndex` `value` + `startIndex` + `length`-1 находится за пределами памяти При выделении для массива поведение этого конструктора зависит от системы, и может возникнуть нарушение прав доступа.  
  
     Три конструктора, включающие массив байтов со знаком в качестве параметра, предназначены в первую очередь для преобразования C++ `char` массива в строку, как показано в следующем примере:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Если массив содержит любые символы NULL ("\ 0") или байты, значение которых равно 0 и вызывается перегрузка <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>, то экземпляр строки содержит `length` символов, включая любые внедренные значения NULL. В следующем примере показано, что происходит, когда в метод <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> передается указатель на массив из 10 элементов, включающий в себя два символа null. Поскольку адрес — это начало массива, и все элементы массива должны быть добавлены в строку, конструктор создает экземпляр строки с десятью символами, включая два встроенных значения NULL. С другой стороны, если один и тот же массив передается конструктору <xref:System.String.%23ctor%28System.SByte%2A%29>, результатом является строка из четырех символов, которая не включает первый символ null.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Поскольку конструкторы <xref:System.String.%23ctor%28System.SByte%2A%29> и <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> интерпретирует `value` с помощью кодовой страницы ANSI по умолчанию, вызов этих конструкторов с одинаковыми массивами байтов может привести к созданию строк, имеющих разные значения в разных системах.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Обработка повторяющихся строк  
 Приложения, которые анализируют или декодируются потоки текста, часто используют конструктор <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> или метод <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> для преобразования последовательностей символов в строку. Повторное создание новых строк с одинаковым значением вместо создания и повторного использования одной строки приводит к нерасходованию памяти. Если вы, вероятно, создадите одинаковое строковое значение повторно, вызвав конструктор <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, даже если вы не понимаете, что такое идентичные строковые значения, можно использовать таблицу уточняющих запросов.  
  
 Например, предположим, что вы читаете и анализируете поток символов из файла, содержащего XML-теги и атрибуты. При синтаксическом анализе потока происходит многократное возникновение определенных токенов (т. е. последовательностей символов, имеющих символьное значение). Маркеры, эквивалентные строкам "0", "1", "true" и "false", скорее всего, часто встречаются в потоке XML.  
  
 Вместо преобразования каждого токена в новую строку можно создать объект <xref:System.Xml.NameTable?displayProperty=nameWithType> для хранения часто встречающихся строк. Объект <xref:System.Xml.NameTable> повышает производительность, поскольку он извлекает сохраненные строки без выделения временной памяти. При возникновении маркера используйте метод <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> для получения маркера из таблицы. Если маркер существует, метод возвращает соответствующую строку. Если маркер не существует, используйте метод <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>, чтобы вставить маркер в таблицу и получить соответствующую строку.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Пример 1. использование присваивания строк  
 В следующем примере создается новая строка путем присвоения ей строкового литерала. Он создает вторую строку, присваивая ей значение первой строки. Это два наиболее распространенных способа создания нового объекта <xref:System.String>.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Пример 2. Использование массива символов  
 В следующем примере показано, как создать новый объект <xref:System.String> из массива символов.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Пример 3. использование части массива символов и повторение одного символа  
 В следующем примере показано, как создать новый объект <xref:System.String> из части массива символов и как создать новый объект <xref:System.String>, содержащий несколько вхождений одного символа.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Пример 4. Использование указателя на массив символов  
 В следующем примере показано, как создать новый объект <xref:System.String> из указателя на массив символов. C# Пример должен быть скомпилирован с помощью параметра компилятора `/unsafe`.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Пример 5. Создание экземпляра строки из указателя и диапазона массива  
 В следующем примере изучаются элементы массива символов для точки или восклицательного знака. Если он найден, то он создает экземпляр строки из символов в массиве, предшествующих символу пунктуации. В противном случае она создает экземпляр строки со всем содержимым массива. C# Пример должен быть скомпилирован с помощью параметра компилятора `/unsafe`.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Пример 6. Создание экземпляра строки из указателя на массив байтов со знаком  
 В следующем примере показано, как можно создать экземпляр класса <xref:System.String> с помощью конструктора <xref:System.String.%23ctor%28System.SByte%2A%29>.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Сведения о версии  
 .NET Framework  
 Все перегрузки поддерживаются в: 4,5, 4, 3,5, 3,0, 2,0, 1,1, 1,0  
  
 .NET Framework (клиентский профиль)  
 Все перегрузки поддерживаются в: 4, 3,5 с пакетом обновления 1 (SP1)  
  
 Переносимая библиотека классов  
 Поддерживаются все перегрузки без параметра <xref:System.SByte>`*`  
  
 Приложения .NET для Магазина Windows  
 В Windows 8 поддерживаются все перегрузки без параметра <xref:System.SByte>`*`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на строку знаков в кодировке Юникод, завершающуюся нулевым значением.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, определенным указателем на массив знаков Юникода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и подробные сведения об использовании этих и других перегрузок конструктора `String` см. в разделе Сводка по конструктору <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий процесс не имеет доступа на чтение ко всем рассматриваемым символам.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> указывает массив, содержащий недопустимый символ Юникода, или <paramref name="value" /> определяет адрес меньше 64 000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Массив знаков Юникода.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> символами Юникода, заданными в виде массива символов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и подробные сведения об использовании этих и других перегрузок конструктора `String` см. в разделе Сводка по конструктору <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Доступный только для чтения диапазон символов Юникода.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> символами Юникода, заданными в виде доступного только для чтения диапазона.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на массив 8-разрядных целых чисел со знаком, завершающийся нулевым значением. Целые числа интерпретируются с использованием текущей системы кодировки страницы системным кодом (то есть, кодировки, заданной <see cref="P:System.Text.Encoding.Default" />).</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, определенным указателем на массив 8-разрядных целых чисел со знаком.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и подробные сведения об использовании этих и других перегрузок конструктора `String` см. в разделе Сводка по конструктору <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Не удалось инициализировать новый экземпляр <see cref="T:System.String" /> с помощью <paramref name="value" />, если предполагается, что <paramref name="value" /> представлен в кодировке ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина новой инициализируемой строки, определяемая символом, завершающимся нулевым значением <paramref name="value" />, слишком велика для выделения.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" /> указывает недопустимый адрес.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Знак Юникода.</param>
        <param name="count">Количество повторов <paramref name="c" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, полученным путем повторения заданного знака Юникода указанное число раз.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и подробные сведения об использовании этих и других перегрузок конструктора `String` см. в разделе Сводка по конструктору <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="count" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на массив знаков Юникода.</param>
        <param name="startIndex">Начальная позиция в <paramref name="value" />.</param>
        <param name="length">Используемое количество знаков в <paramref name="value" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, которое определяется заданным указателем на массив знаков Юникода, начальной позицией знака в этом массиве и длиной.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и подробные сведения об использовании этих и других перегрузок конструктора `String` см. в разделе Сводка по конструктору <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> или <paramref name="length" /> меньше нуля, <paramref name="value" /> + <paramref name="startIndex" /> приводит к переполнению указателя, или текущий процесс не имеет доступа на чтение ко всем адресуемым символам.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> указывает массив, содержащий недопустимый символ Юникода, или <paramref name="value" /> + <paramref name="startIndex" /> определяет адрес меньше 64 000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Массив знаков Юникода.</param>
        <param name="startIndex">Начальная позиция в <paramref name="value" />.</param>
        <param name="length">Используемое количество знаков в <paramref name="value" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, заданным массивом знаков Юникода, начальной позицией знака в пределах данного массива и длиной.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и подробные сведения об использовании этих и других перегрузок конструктора `String` см. в разделе Сводка по конструктору <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.  
  
- или - 
Сумма <paramref name="startIndex" /> и <paramref name="length" /> больше, чем число элементов в <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на массив 8-разрядных целых чисел со знаком. Целые числа интерпретируются с использованием текущей системы кодировки страницы системным кодом (то есть, кодировки, заданной <see cref="P:System.Text.Encoding.Default" />).</param>
        <param name="startIndex">Начальная позиция в <paramref name="value" />.</param>
        <param name="length">Используемое количество знаков в <paramref name="value" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, определяемым заданным указателем на массив 8-разрядных целых чисел со знаком, начальной позицией в пределах массива и длиной.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и подробные сведения об использовании этих и других перегрузок конструктора `String` см. в разделе Сводка по конструктору <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.  
  
- или - 
Адрес, указанный значениями <paramref name="value" /> + <paramref name="startIndex" />, слишком велик для текущей платформы, то есть при вычислении адреса произошло переполнение.  
  
- или - 
Длина новой инициализируемой строки слишком велика для выделения.</exception>
        <exception cref="T:System.ArgumentException">Адрес, указанный значениями <paramref name="value" /> + <paramref name="startIndex" />, меньше 64 000.  
  
- или - 
Не удалось инициализировать новый экземпляр <see cref="T:System.String" /> с помощью <paramref name="value" />, исходя из предположения, что значение <paramref name="value" /> представлено в кодировке ANSI.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> и <paramref name="length" /> совместно определяют недопустимый адрес.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на массив 8-разрядных целых чисел со знаком.</param>
        <param name="startIndex">Начальная позиция в <paramref name="value" />.</param>
        <param name="length">Используемое количество знаков в <paramref name="value" />.</param>
        <param name="enc">Объект, определяющий способ кодировки массива, на который указывает параметр <paramref name="value" />. Если значением параметра <paramref name="enc" /> является <see langword="null" />, предполагается кодировка ANSI.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, определенным заданным указателем на массив 8-разрядных целых чисел со знаком, начальной позицией в пределах этого массива, длиной и объектом <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и подробные сведения об использовании этих и других перегрузок конструктора `String` см. в разделе Сводка по конструктору <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.  
  
- или - 
Адрес, указанный значениями <paramref name="value" /> + <paramref name="startIndex" />, слишком велик для текущей платформы, то есть при вычислении адреса произошло переполнение.  
  
- или - 
Длина новой инициализируемой строки слишком велика для выделения.</exception>
        <exception cref="T:System.ArgumentException">Адрес, указанный значениями <paramref name="value" /> + <paramref name="startIndex" />, меньше 64 000.  
  
- или - 
Не удалось инициализировать новый экземпляр <see cref="T:System.String" /> с помощью <paramref name="value" />, если предполагается, что <paramref name="value" /> представлен в кодировке <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> и <paramref name="length" /> совместно определяют недопустимый адрес.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в текущей строке.</param>
        <summary>Возвращает объект <see cref="T:System.Char" /> в указанной позиции в текущем объекте <see cref="T:System.String" />.</summary>
        <value>Объект в позиции <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `index` отсчитывается от нуля.  
  
 Это свойство возвращает объект <xref:System.Char> в позиции, указанной параметром `index`. Однако символ Юникода может быть представлен более чем одним <xref:System.Char>. Используйте класс <xref:System.Globalization.StringInfo?displayProperty=nameWithType> для работы с символами Юникода вместо <xref:System.Char> объектов. Дополнительные сведения см. в подразделе "объекты char и символы Юникода" раздела Общие сведения о классе <xref:System.String>.  
  
 В C#свойство <xref:System.String.Chars%2A> является индексатором. В Visual Basic это свойство класса <xref:System.String> по умолчанию. К каждому объекту <xref:System.Char> в строке можно получить доступ с помощью следующего кода.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 В следующем примере показано, как можно использовать этот индексатор в процедуре для проверки строки.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Значение <paramref name="index" /> больше или равно длине данного объекта или меньше нуля.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ссылку на данный экземпляр класса <see cref="T:System.String" />.</summary>
        <returns>Этот экземпляр <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемое значение не является независимой копией этого экземпляра; Это просто другое представление одних и тех же данных. Используйте метод <xref:System.String.Copy%2A> или <xref:System.String.CopyTo%2A>, чтобы создать отдельный объект <xref:System.String> с тем же значением, что и у данного экземпляра.  
  
 Поскольку метод <xref:System.String.Clone%2A> просто возвращает существующий экземпляр строки, существует небольшая причина вызова этого метода напрямую.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сравнивает два указанных объекта <see cref="T:System.String" /> и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все перегрузки метода <xref:System.String.Compare%2A> возвращают 32-разрядное целое число со знаком, выражающее лексическое соотношение двух сравниваемых значений.  
  
|Значение|Условие|  
|-----------|---------------|  
|Меньше нуля|Первая подстрока предшествует второй подстроке в порядке сортировки.|  
|Нуль|Подстроки появляются в той же позиции в порядке сортировки, или параметр `length` равен нулю.|  
|Больше нуля|Первая подстрока соответствует второй подстроке в порядке сортировки.|  
  
> [!WARNING]
>  Везде, где это возможно, следует вызывать перегрузку метода <xref:System.String.Compare%2A>, который включает параметр <xref:System.StringComparison>. Дополнительные сведения см. в разделе [Рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Рекомендации по использованию строк в .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Первая сравниваемая строка.</param>
        <param name="strB">Вторая сравниваемая строка.</param>
        <summary>Сравнивает два указанных объекта <see cref="T:System.String" /> и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description><paramref name="strA" /> предшествует <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="strA" /> занимает ту же позицию в порядке сортировки, что и объект <paramref name="strB" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description><paramref name="strA" /> следует за <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При сравнении используется текущий язык и региональные параметры, чтобы получить сведения о языке и региональных параметрах, такие как правила учета регистра и алфавитный порядок отдельных символов. Например, язык и региональные параметры могут указывать, что определенные сочетания символов обрабатываются как один символ, а прописные и строчные буквы сравниваются определенным образом, или порядок сортировки символа зависит от символов, предшествующих или Следуйте указаниям.  
  
 Сравнение выполняется с помощью правил сортировки Word. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  При сравнении строк следует вызвать метод <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>, для которого требуется явно указать тип сравнения строк, используемый методом. Дополнительные сведения см. в разделе [Рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 Можно `null`один или оба сравниваемых значения. По определению любая строка, включая пустую строку (""), сравнивается больше, чем пустая ссылка; два пустых ссылки сравнивают равными друг другу.  
  
 Сравнение завершается при обнаружении неравенства или при сравнении обеих строк. Однако если две строки в сравнении равны концу одной строки, а другая строка содержит оставшиеся символы, то строка с оставшимися символами считается больше. Возвращаемое значение является результатом последнего выполненного сравнения.  
  
 Непредвиденные результаты могут возникать, если сравнение зависит от правил регистров, зависящих от языка и региональных параметров. Например, в турецком языке в следующем примере выдаются неверные результаты, поскольку в файловой системе в турецком языке не используются лингвистические правила регистров букв «i» в файле «file».  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Сравните имя пути с "File" с помощью порядкового сравнения. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.String.Compare%28System.String%2CSystem.String%29> для сравнения трех наборов строк.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 В следующем примере класс `ReverseStringComparer` демонстрирует, как можно вычислить две строки с помощью метода <xref:System.String.Compare%2A>.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. Метод <see cref="M:System.String.Compare(System.String,System.String)" /> не учитывает такие символы при выполнении сравнения с учетом языка и региональных параметров. Например, если следующий код выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, сравнение "Animal", учитывающее язык и региональные параметры, с "Ani-недействительностью" (с использованием мягкого дефиса или U + 00AD) указывает на то, что две строки эквивалентны.  
  
[! код-CSharp[System. String. Compare # 21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [! код-VB[System. String. Compare # 21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
Чтобы распознать игнорируемые символы в сравнении строк, вызовите метод <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> и укажите для параметра `comparisonType` значение либо <see cref="F:System.Globalization.CompareOptions.Ordinal" />, либо <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Первая сравниваемая строка.</param>
        <param name="strB">Вторая сравниваемая строка.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при сравнении; в противном случае — значение <see langword="false" />.</param>
        <summary>Сравнивает два указанных объекта <see cref="T:System.String" /> (с учетом или без учета регистра) и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description><paramref name="strA" /> предшествует <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="strA" /> занимает ту же позицию в порядке сортировки, что и объект <paramref name="strB" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description><paramref name="strA" /> следует за <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При сравнении используется текущий язык и региональные параметры, чтобы получить сведения о языке и региональных параметрах, такие как правила учета регистра и алфавитный порядок отдельных символов. Например, язык и региональные параметры могут указывать, что определенные сочетания символов обрабатываются как один символ, а прописные и строчные буквы сравниваются определенным образом, или порядок сортировки символа зависит от символов, предшествующих или Следуйте указаниям.  
  
 Сравнение выполняется с помощью правил сортировки Word. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  При сравнении строк следует вызвать метод <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>, для которого требуется явно указать тип сравнения строк, используемый методом. Дополнительные сведения см. в разделе [Рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 Можно `null`один или оба сравниваемых значения. По определению любая строка, включая пустую строку (""), сравнивается больше, чем пустая ссылка; два пустых ссылки сравнивают равными друг другу.  
  
 Сравнение завершается при обнаружении неравенства или при сравнении обеих строк. Однако если две строки в сравнении равны концу одной строки, а другая строка содержит оставшиеся символы, то строка с оставшимися символами считается больше. Возвращаемое значение является результатом последнего выполненного сравнения.  
  
 Непредвиденные результаты могут возникать, если сравнение зависит от правил регистров, зависящих от языка и региональных параметров. Например, в турецком языке в следующем примере выдаются неверные результаты, поскольку в файловой системе в турецком языке не используются лингвистические правила регистров букв «i» в файле «file».  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Сравните имя пути с "File" с помощью порядкового сравнения. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 В следующем примере показано, что метод <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> эквивалентен использованию <xref:System.String.ToUpper%2A> или <xref:System.String.ToLower%2A> при сравнении строк.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. Метод <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> не учитывает такие символы при выполнении сравнения с учетом языка и региональных параметров. Например, если следующий код выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, с учетом языка и региональных параметров, без учета регистра для «Animal» с «Ani-недействительностью» (с использованием мягкого дефиса или U + 00AD), указывает, что эти две строки эквивалентны.  
  
[! код-CSharp[System. String. Compare # 22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [! код-VB[System. String. Compare # 22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
Чтобы распознать игнорируемые символы в сравнении строк, вызовите метод <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> и укажите для параметра <paramref name="comparisonType" /> значение либо <see cref="F:System.Globalization.CompareOptions.Ordinal" />, либо <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Первая сравниваемая строка.</param>
        <param name="strB">Вторая сравниваемая строка.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее используемые при сравнении правила.</param>
        <summary>Сравнивает два указанных объекта <see cref="T:System.String" /> с использованием заданных правил и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description><paramref name="strA" /> предшествует <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="strA" /> занимает ту же позицию в порядке сортировки, что и объект <paramref name="strB" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description><paramref name="strA" /> следует за <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `comparisonType` указывает, должно ли сравнение использовать текущий или инвариантный язык и региональные параметры, учитывать или игнорировать регистр сравниваемых значений либо использовать правила сортировки в формате Word (с учетом языка и региональных параметров) или по порядковому номеру (без учета языка и региональных параметров).  
  
 Можно `null`один или оба сравниваемых значения. По определению любая строка, включая пустую строку (""), сравнивается больше, чем пустая ссылка; два пустых ссылки сравнивают равными друг другу.  
  
 Сравнение завершается при обнаружении неравенства или при сравнении обеих строк. Однако если две строки сравнивают значение, равное концу одной строки, а другая строка содержит оставшиеся символы, то строка с оставшимися символами считается больше. Возвращаемое значение является результатом последнего выполненного сравнения.  
  
 Непредвиденные результаты могут возникать, если сравнение зависит от правил регистров, зависящих от языка и региональных параметров. Например, в турецком языке в следующем примере выдаются неверные результаты, поскольку в файловой системе в турецком языке не используются лингвистические правила регистров букв «i» в файле «file».  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Сравните имя пути с "File" с помощью порядкового сравнения. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 В следующем примере сравниваются три версии буквы I. На результаты влияют выбранные язык и региональные параметры, учитывается ли регистр и выполняется ли порядковое сравнение.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является значением <see cref="T:System.StringComparison" />.</exception>
        <exception cref="T:System.NotSupportedException">Тип <see cref="T:System.StringComparison" /> не поддерживается.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. Метод <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> не учитывает такие символы при выполнении сравнения с учетом языка и региональных параметров. Чтобы распознать игнорируемые символы в сравнении, укажите значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> для параметра <paramref name="comparisonType" />.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Первая сравниваемая строка.</param>
        <param name="strB">Вторая сравниваемая строка.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при сравнении; в противном случае — значение <see langword="false" />.</param>
        <param name="culture">Объект, предоставляющий сведения об особенностях сравнения, определяемых языком и региональными параметрами.</param>
        <summary>Сравнивает два указанных объекта <see cref="T:System.String" /> (с учетом или без учета регистра), используя сведения о языке и региональных параметрах, и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description><paramref name="strA" /> предшествует <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="strA" /> занимает ту же позицию в порядке сортировки, что и объект <paramref name="strB" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description><paramref name="strA" /> следует за <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При сравнении используется параметр `culture` для получения сведений, относящихся к культуре, таких как правила учета регистра, и алфавитного порядка отдельных символов. Например, язык и региональные параметры могут указывать, что определенные сочетания символов обрабатываются как один символ, а прописные и строчные буквы сравниваются определенным образом, или порядок сортировки символа зависит от символов, предшествующих или Следуйте указаниям.  
  
 Сравнение выполняется с помощью правил сортировки Word. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Можно `null`один или оба сравниваемых значения. По определению любая строка, включая пустую строку (""), сравнивается больше, чем пустая ссылка; два пустых ссылки сравнивают равными друг другу.  
  
 Сравнение завершается при обнаружении неравенства или при сравнении обеих строк. Однако если две строки в сравнении равны концу одной строки, а другая строка содержит оставшиеся символы, то строка с оставшимися символами считается больше. Возвращаемое значение является результатом последнего выполненного сравнения.  
  
 Непредвиденные результаты могут возникать, если сравнение зависит от правил регистров, зависящих от языка и региональных параметров. Например, в турецком языке в следующем примере выдаются неверные результаты, поскольку в файловой системе в турецком языке не используются лингвистические правила регистров букв «i» в файле «file».  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Сравните имя пути с "File" с помощью порядкового сравнения. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 В следующем примере показано, как культура может повлиять на сравнение. В Чешской и Чешскей Республика, "CH" — это один символ, который больше, чем "d". Однако в языке и региональных параметрах США "CH" состоит из двух символов, а "c" меньше "d".  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="culture" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. Метод <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> не учитывает такие символы при выполнении сравнения с учетом языка и региональных параметров. Например, если следующий код выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, сравнение без учета регистра «Animal» с «Ani-недействительностью» (с использованием мягкого дефиса или U + 00AD) с использованием инвариантного языка и региональных параметров указывает, что эти две строки эквивалентны.  
  
[! код-CSharp[System. String. Compare # 23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [! код-VB[System. String. Compare # 23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
Чтобы распознать игнорируемые символы в сравнении строк, вызовите метод <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> и укажите для параметра <paramref name="options" /> значение либо <see cref="F:System.Globalization.CompareOptions.Ordinal" />, либо <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Первая сравниваемая строка.</param>
        <param name="strB">Вторая сравниваемая строка.</param>
        <param name="culture">Язык и региональные параметры, которые предоставляют сведения об особенностях сравнения с учетом языка и региональных параметров.</param>
        <param name="options">Параметры, которые используются во время сравнения (например, игнорирование регистра или символов).</param>
        <summary>Сравнивает два заданных объекта <see cref="T:System.String" />, используя указанные параметры сравнения и сведения о языке и региональных параметрах, которые влияют на сравнение, и возвращает целое число, показывающее связь между двумя строками в порядке сортировки.</summary>
        <returns>32-разрядное целое число со знаком, которое указывает на лексические отношения между <paramref name="strA" /> и <paramref name="strB" />, как показано в следующей таблице. 
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description><paramref name="strA" /> предшествует <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="strA" /> занимает ту же позицию в порядке сортировки, что и объект <paramref name="strB" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description><paramref name="strA" /> следует за <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При сравнении используется параметр `culture` для получения сведений о языке и региональных параметрах, таких как правила учета регистра и алфавитно-ориентированный порядок отдельных символов. Например, определенный язык и региональные параметры могут указывать, что определенные сочетания символов обрабатываются как один символ, а символы верхнего и нижнего регистров сравниваются определенным образом или порядок сортировки символа зависит от символов, которые перед ним или после него.  
  
> [!CAUTION]
>  Метод <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> предназначен главным образом для использования в операциях сортировки или алфабетизинг. Его не следует использовать, когда основной целью вызова метода является определение того, являются ли две строки эквивалентными (т. е. когда цель вызова метода — проверка на наличие возвращаемого значения, равного нулю). Чтобы определить, эквивалентны ли две строки, вызовите метод <xref:System.String.Equals%2A>.  
  
 Сравнение может быть дополнительно указано параметром `options`, который состоит из одного или нескольких элементов перечисления <xref:System.Globalization.CompareOptions>. Однако, поскольку этот метод предназначен для сравнения строк с учетом языка и региональных параметров, значения <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> и <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> не действуют.  
  
 Один или оба сравниваемых значения можно `null`. По определению любая строка, в том числе <xref:System.String.Empty?displayProperty=nameWithType>, сравнивается больше, чем пустая ссылка, и две пустые ссылки сравнивают равными друг другу.  
  
 Сравнение завершается при обнаружении неравенства или при сравнении обеих строк. Однако если две строки в сравнении равны концу одной строки, а другая строка содержит символы, то строка с оставшимися символами считается больше.  
  
   
  
## Examples  
 В следующем примере две строки сравниваются тремя разными способами: с использованием лингвистического сравнения для языка и региональных параметров en-US. использование лингвистического сравнения с учетом регистра для языка и региональных параметров en-US; и используя порядковое сравнение. Он иллюстрирует, как три метода сравнения дают три разных результата.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> не является значением <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="culture" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Метод <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> не учитывает такие символы при выполнении сравнения с учетом языка и региональных параметров. Чтобы распознать игнорируемые символы в сравнении, укажите значение <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для параметра <paramref name="options" />.</para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Первая из сравниваемых строк.</param>
        <param name="indexA">Позиция подстроки в <paramref name="strA" />.</param>
        <param name="strB">Вторая из сравниваемых строк.</param>
        <param name="indexB">Позиция подстроки в <paramref name="strB" />.</param>
        <param name="length">Максимальное число сравниваемых знаков в подстроках.</param>
        <summary>Сравнивает подстроки двух указанных объектов <see cref="T:System.String" /> и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-разрядное целое число со знаком, выражающее лексическое соотношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Подстрока в <paramref name="strA" /> предшествует подстроке в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description> Подстроки появляются в той же позиции в порядке сортировки, или параметр <paramref name="length" /> равен нулю.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Подстрока в <paramref name="strA" /> следует за подстрокой в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подстроки для сравнения начинаются в `strA` в `indexA` и в `strB` в `indexB`. Оба `indexA` и `indexB` отсчитываются от нуля; то есть первый символ в `strA` и `strB` находится в нулевом положении. Длина первой подстроки равна длине `strA` минус `indexA` плюс один. Длина второй подстроки равна длине `strB` минус `indexB` плюс один.  
  
 Число сравниваемых символов — это меньшее из значений длины двух подстрок и `length`. Параметры `indexA`, `indexB`и `length` должны быть неотрицательными.  
  
 При сравнении используется текущий язык и региональные параметры, чтобы получить сведения о языке и региональных параметрах, такие как правила учета регистра и алфавитный порядок отдельных символов. Например, язык и региональные параметры могут указывать, что определенные сочетания символов обрабатываются как один символ, а прописные и строчные буквы сравниваются определенным образом, или порядок сортировки символа зависит от символов, предшествующих или Следуйте указаниям.  
  
 Сравнение выполняется с помощью правил сортировки Word. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  При сравнении строк следует вызвать метод <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>, для которого требуется явно указать тип сравнения строк, используемый методом. Дополнительные сведения см. в разделе [Рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 Можно `null`один или оба сравниваемых значения. По определению любая строка, включая пустую строку (""), сравнивается больше, чем пустая ссылка; два пустых ссылки сравнивают равными друг другу.  
  
 Сравнение завершается при обнаружении неравенства или при сравнении обеих подстрок. Однако если две строки в сравнении равны концу одной строки, а другая строка содержит оставшиеся символы, то строка с оставшимися символами считается больше. Возвращаемое значение является результатом последнего выполненного сравнения.  
  
 Непредвиденные результаты могут возникать, если сравнение зависит от правил регистров, зависящих от языка и региональных параметров. Например, в турецком языке в следующем примере выдаются неверные результаты, поскольку в файловой системе в турецком языке не используются лингвистические правила регистров букв «i» в файле «file».  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Сравните имя пути с "File" с помощью порядкового сравнения. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 В следующем примере сравниваются две подстроки.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="indexA" /> больше значения <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- или - 
 Значение <paramref name="indexB" /> больше значения <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- или - 
 <paramref name="indexA" />, <paramref name="indexB" /> или <paramref name="length" /> является отрицательным значением.  
  
- или - 
<paramref name="indexA" /> или <paramref name="indexB" /> равно <see langword="null" />, а <paramref name="length" /> больше нуля.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. Метод <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> не учитывает эти символы при выполнении лингвистического или зависящего от языка и региональных параметров сравнения. Чтобы распознать игнорируемые символы в сравнении, вызовите метод <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> и укажите значение <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для параметра <paramref name="comparisonType" />.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Первая из сравниваемых строк.</param>
        <param name="indexA">Позиция подстроки в <paramref name="strA" />.</param>
        <param name="strB">Вторая из сравниваемых строк.</param>
        <param name="indexB">Позиция подстроки в <paramref name="strB" />.</param>
        <param name="length">Максимальное число сравниваемых знаков в подстроках.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при сравнении; в противном случае — значение <see langword="false" />.</param>
        <summary>Сравнивает подстроки двух заданных объектов <see cref="T:System.String" /> (с учетом или без учета регистра) и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Подстрока в <paramref name="strA" /> предшествует подстроке в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description> Подстроки появляются в той же позиции в порядке сортировки, или параметр <paramref name="length" /> равен нулю.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Подстрока в <paramref name="strA" /> следует за подстрокой в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подстроки для сравнения начинаются в `strA` в `indexA`и в `strB` в `indexB`. Оба `indexA` и `indexB` отсчитываются от нуля; то есть первый символ в `strA` и `strB` находится в нулевом положении. Длина первой подстроки равна длине `strA` минус `indexA` плюс один. Длина второй подстроки равна длине `strB` минус `indexB` плюс один.  
  
 Число сравниваемых символов — это меньшее из значений длины двух подстрок и `length`. Параметры `indexA`, `indexB`и `length` должны быть неотрицательными.  
  
 При сравнении используется текущий язык и региональные параметры, чтобы получить сведения о языке и региональных параметрах, такие как правила учета регистра и алфавитный порядок отдельных символов. Например, язык и региональные параметры могут указывать, что определенные сочетания символов обрабатываются как один символ, а прописные и строчные буквы сравниваются определенным образом, или порядок сортировки символа зависит от символов, предшествующих или Следуйте указаниям.  
  
 Сравнение выполняется с помощью правил сортировки Word. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  При сравнении строк следует вызвать метод <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>, для которого требуется явно указать тип сравнения строк, используемый методом. Дополнительные сведения см. в разделе [Рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 Можно `null`один или оба сравниваемых значения. По определению любая строка, включая пустую строку (""), сравнивается больше, чем пустая ссылка; два пустых ссылки сравнивают равными друг другу.  
  
 Сравнение завершается при обнаружении неравенства или при сравнении обеих подстрок. Однако если две строки в сравнении равны концу одной строки, а другая строка содержит оставшиеся символы, то строка с оставшимися символами считается больше. Возвращаемое значение является результатом последнего выполненного сравнения.  
  
 Непредвиденные результаты могут возникать, если сравнение зависит от правил регистров, зависящих от языка и региональных параметров. Например, в турецком языке в следующем примере выдаются неверные результаты, поскольку в файловой системе в турецком языке не используются лингвистические правила регистров букв «i» в файле «file».  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 Имя пути должно сравниваться неизменным способом. Правильный код для этого приведен ниже.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 В следующем примере выполняется два сравнения двух подстрок, которые различаются только регистром. Первое сравнение не учитывает регистр, а второе сравнение учитывает регистр.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="indexA" /> больше значения <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- или - 
 Значение <paramref name="indexB" /> больше значения <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- или - 
 <paramref name="indexA" />, <paramref name="indexB" /> или <paramref name="length" /> является отрицательным значением.  
  
- или - 
<paramref name="indexA" /> или <paramref name="indexB" /> равно <see langword="null" />, а <paramref name="length" /> больше нуля.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. Метод <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> не учитывает эти символы при выполнении лингвистического или зависящего от языка и региональных параметров сравнения. Чтобы распознать игнорируемые символы в сравнении, вызовите метод <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> и укажите значение <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для параметра <paramref name="comparisonType" />.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Первая из сравниваемых строк.</param>
        <param name="indexA">Позиция подстроки в <paramref name="strA" />.</param>
        <param name="strB">Вторая из сравниваемых строк.</param>
        <param name="indexB">Позиция подстроки в <paramref name="strB" />.</param>
        <param name="length">Максимальное число сравниваемых знаков в подстроках.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее используемые при сравнении правила.</param>
        <summary>Сравнивает подстроки двух указанных объектов <see cref="T:System.String" /> с использованием заданных правил и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Подстрока в <paramref name="strA" /> предшествует подстроке в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description> Подстроки появляются в одной и той же позиции в порядке сортировки, или параметр <paramref name="length" /> равен нулю.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Подстрока в <paramref name="strA" /> следует за подстрокой в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подстроки для сравнения начинаются в `strA` в `indexA` и в `strB` в `indexB`. Оба `indexA` и `indexB` отсчитываются от нуля; то есть первый символ в `strA` и `strB` находится в нулевом положении, а не на позиции 1. Длина первой подстроки равна длине `strA` минус `indexA` плюс один. Длина второй подстроки равна длине `strB` минус `indexB` плюс один.  
  
 Число сравниваемых символов — это меньшее из значений длины двух подстрок и `length`. Параметры `indexA`, `indexB`и `length` должны быть неотрицательными.  
  
 Параметр `comparisonType` указывает, должно ли сравнение использовать текущий или инвариантный язык и региональные параметры, учитывать или игнорировать регистр сравниваемых значений либо использовать правила сортировки в формате Word (с учетом языка и региональных параметров) или по порядковому номеру (без учета языка и региональных параметров).  
  
 Можно `null`один или оба сравниваемых значения. По определению любая строка, включая пустую строку (""), сравнивается больше, чем пустая ссылка; два пустых ссылки сравнивают равными друг другу.  
  
 Сравнение завершается при обнаружении неравенства или при сравнении обеих подстрок. Однако если две строки сравнивают значение, равное концу одной строки, а другая строка содержит оставшиеся символы, то строка с оставшимися символами считается больше. Возвращаемое значение является результатом последнего выполненного сравнения.  
  
 Непредвиденные результаты могут возникать, если сравнение зависит от правил регистров, зависящих от языка и региональных параметров. Например, в турецком языке в следующем примере выдаются неверные результаты, поскольку в файловой системе в турецком языке не используются лингвистические правила регистров букв «i» в файле «file».  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Сравните имя пути с "File" с помощью порядкового сравнения. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 В следующем примере сравниваются две подстроки.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="indexA" /> больше значения <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- или - 
 Значение <paramref name="indexB" /> больше значения <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- или - 
 <paramref name="indexA" />, <paramref name="indexB" /> или <paramref name="length" /> является отрицательным значением.  
  
- или - 
<paramref name="indexA" /> или <paramref name="indexB" /> равно <see langword="null" />, а <paramref name="length" /> больше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. Метод <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> не учитывает эти символы при выполнении лингвистического или зависящего от языка и региональных параметров сравнения. Чтобы распознать игнорируемые символы в сравнении, укажите значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> для параметра <paramref name="comparisonType" />.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Первая из сравниваемых строк.</param>
        <param name="indexA">Позиция подстроки в <paramref name="strA" />.</param>
        <param name="strB">Вторая из сравниваемых строк.</param>
        <param name="indexB">Позиция подстроки в <paramref name="strB" />.</param>
        <param name="length">Максимальное число сравниваемых знаков в подстроках.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при сравнении; в противном случае — значение <see langword="false" />.</param>
        <param name="culture">Объект, предоставляющий сведения об особенностях сравнения, определяемых языком и региональными параметрами.</param>
        <summary>Сравнивает подстроки двух заданных объектов <see cref="T:System.String" /> (с учетом или без учета регистра), используя сведения о языке и региональных параметрах, и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>Целое число, выражающее лексическое соотношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Подстрока в <paramref name="strA" /> предшествует подстроке в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description> Подстроки появляются в той же позиции в порядке сортировки, или параметр <paramref name="length" /> равен нулю.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Подстрока в <paramref name="strA" /> следует за подстрокой в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подстроки для сравнения начинаются в `strA` в `indexA`и в `strB` в `indexB`. Оба `indexA` и `indexB` отсчитываются от нуля; то есть первый символ в `strA` и `strB` находится в нулевом положении, а не на позиции 1. Длина первой подстроки равна длине `strA` минус `indexA` плюс один. Длина второй подстроки равна длине `strB` минус `indexB` плюс один.  
  
 Число сравниваемых символов — это меньшее из значений длины двух подстрок и `length`. Параметры `indexA`, `indexB`и `length` должны быть неотрицательными.  
  
 При сравнении используется параметр `culture` для получения сведений, относящихся к культуре, таких как правила учета регистра, и алфавитного порядка отдельных символов. Например, язык и региональные параметры могут указывать, что определенные сочетания символов обрабатываются как один символ, а прописные и строчные буквы сравниваются определенным образом, или порядок сортировки символа зависит от символов, предшествующих или Следуйте указаниям.  
  
 Сравнение выполняется с помощью правил сортировки Word. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Можно `null`один или оба сравниваемых значения. По определению любая строка, включая пустую строку (""), сравнивается больше, чем пустая ссылка; два пустых ссылки сравнивают равными друг другу.  
  
 Сравнение завершается при обнаружении неравенства или при сравнении обеих подстрок. Однако если две строки в сравнении равны концу одной строки, а другая строка содержит оставшиеся символы, то строка с оставшимися символами считается больше. Возвращаемое значение является результатом последнего выполненного сравнения.  
  
 Непредвиденные результаты могут возникать, если сравнение зависит от правил регистров, зависящих от языка и региональных параметров. Например, в турецком языке в следующем примере выдаются неверные результаты, поскольку в файловой системе в турецком языке не используются лингвистические правила регистров букв «i» в файле «file».  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Сравните имя пути с "File" с помощью порядкового сравнения. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 В следующем примере сравниваются две подстроки с использованием разных языков и региональных параметров, игнорируя регистр подстрок. Выбранный язык и региональные параметры влияют на то, как сравнивается буква I.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="indexA" /> больше значения <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- или - 
 Значение <paramref name="indexB" /> больше значения <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- или - 
 <paramref name="indexA" />, <paramref name="indexB" /> или <paramref name="length" /> является отрицательным значением.  
  
- или - 
<paramref name="strA" /> или <paramref name="strB" /> равно <see langword="null" />, а <paramref name="length" /> больше нуля.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="culture" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. Метод <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> не учитывает эти символы при выполнении лингвистического или зависящего от языка и региональных параметров сравнения. Чтобы распознать игнорируемые символы в сравнении, вызовите метод <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> и укажите значение <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для параметра <paramref name="options" />.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Первая из сравниваемых строк.</param>
        <param name="indexA">Начальная позиция подстроки в пределах <paramref name="strA" />.</param>
        <param name="strB">Вторая из сравниваемых строк.</param>
        <param name="indexB">Начальная позиция подстроки в пределах <paramref name="strB" />.</param>
        <param name="length">Максимальное число сравниваемых знаков в подстроках.</param>
        <param name="culture">Объект, предоставляющий сведения об особенностях сравнения, определяемых языком и региональными параметрами.</param>
        <param name="options">Параметры, которые используются во время сравнения (например, игнорирование регистра или символов).</param>
        <summary>Сравнивает подстроки двух заданных объектов <see cref="T:System.String" />, используя указанные параметры сравнения и сведения о языке и региональных параметрах, которые влияют на сравнение, и возвращает целое число, показывающее связь между двумя подстроками в порядке сортировки.</summary>
        <returns>Целое число, которое указывает на лексические отношения между двумя подстроками, как показано в следующей таблице.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Подстрока в <paramref name="strA" /> предшествует подстроке в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description> Подстроки появляются в той же позиции в порядке сортировки, или параметр <paramref name="length" /> равен нулю.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Подстрока в <paramref name="strA" /> следует за подстрокой в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подстроки для сравнения начинаются в `strA` позиции `indexA` и в `strB` позиции `indexB`. Длина первой подстроки равна длине `strA` минус `indexA`. Длина второй подстроки равна длине `strB` минус `indexB`.  
  
 Число сравниваемых символов — это меньшее из значений длины двух подстрок и `length`. Параметры `indexA`, `indexB`и `length` должны быть неотрицательными.  
  
 При сравнении используется параметр `culture` для получения сведений о языке и региональных параметрах, таких как правила учета регистра и алфавитно-ориентированный порядок отдельных символов. Например, определенный язык и региональные параметры могут указывать, что определенные сочетания символов обрабатываются как один символ, а символы верхнего и нижнего регистров сравниваются определенным образом или порядок сортировки символа зависит от символов, которые перед ним или после него.  
  
> [!CAUTION]
>  Метод <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> предназначен главным образом для использования в операциях сортировки или алфабетизинг. Его не следует использовать, когда основной целью вызова метода является определение того, эквивалентны ли две подстроки (т. е. когда цель вызова метода — проверка на наличие возвращаемого значения, равного нулю). Чтобы определить, эквивалентны ли две строки, вызовите метод <xref:System.String.Equals%2A>.  
  
 Можно `null`один или оба `strA` и `strB`. По определению любая строка, в том числе <xref:System.String.Empty?displayProperty=nameWithType>, сравнивается больше, чем пустая ссылка, и две пустые ссылки сравнивают равными друг другу.  
  
 Сравнение может быть дополнительно указано параметром `options`, который состоит из одного или нескольких элементов перечисления <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Однако, поскольку этот метод предназначен для сравнения строк с учетом языка и региональных параметров, значения <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> и <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> не действуют.  
  
 Сравнение завершается при обнаружении неравенства или при сравнении обеих подстрок. Однако если две строки в сравнении равны концу одной строки, а другая строка содержит символы, то строка с оставшимися символами считается больше. Возвращаемое значение является результатом последнего выполненного сравнения.  
  
   
  
## Examples  
 В следующем примере метод <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> используется для сравнения фамилий двух людей. Затем они перечисляются в алфавитном порядке.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> не является значением <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="indexA" /> больше значения <paramref name="strA" /><see langword=".Length" />.  
  
- или - 
 Значение <paramref name="indexB" /> больше значения <paramref name="strB" /><see langword=".Length" />.  
  
- или - 
 <paramref name="indexA" />, <paramref name="indexB" /> или <paramref name="length" /> является отрицательным значением.  
  
- или - 
<paramref name="strA" /> или <paramref name="strB" /> равно <see langword="null" />, а <paramref name="length" /> больше нуля.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="culture" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. Метод <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> не учитывает эти символы при выполнении лингвистического или зависящего от языка и региональных параметров сравнения. Чтобы распознать игнорируемые символы в сравнении, укажите значение <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для параметра <paramref name="options" />.</para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сравнивает два объекта <see cref="T:System.String" />, оценивая числовые значения соответствующих объектов <see cref="T:System.Char" /> в каждой строке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Первая сравниваемая строка.</param>
        <param name="strB">Вторая сравниваемая строка.</param>
        <summary>Сравнивает два указанных объекта <see cref="T:System.String" />, оценивая числовые значения соответствующих объектов <see cref="T:System.Char" /> в каждой строке.</summary>
        <returns>Целое число, выражающее лексическое соотношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description>Значение <paramref name="strA" /> меньше <paramref name="strB" />.  
  
 </description></item><item><term> Нуль 
 </term><description>Значения параметров <paramref name="strA" /> и <paramref name="strB" /> равны.  
  
 </description></item><item><term> Больше нуля. 
 </term><description>Значение <paramref name="strA" /> больше значения <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение с учетом регистра, используя правила сортировки по порядковому номеру. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Чтобы выполнить сравнение без учета регистра с помощью правил сортировки по порядковому номеру, вызовите метод <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> с аргументом `comparisonType`, для которого задано значение <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Поскольку <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> является статическим методом, `strA` и `strB` могут быть `null`. Если оба значения являются `null`, метод возвращает 0 (нуль), что означает, что `strA` и `strB` равны. Если только одно из значений имеет `null`, метод считает, что значение, отличное от NULL, больше.  
  
   
  
## Examples  
 В следующем примере выполняется и порядковое сравнение двух строк, которые различаются только регистром.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Первая из сравниваемых строк.</param>
        <param name="indexA">Начальный индекс подстроки в <paramref name="strA" />.</param>
        <param name="strB">Вторая из сравниваемых строк.</param>
        <param name="indexB">Начальный индекс подстроки в <paramref name="strB" />.</param>
        <param name="length">Максимальное число сравниваемых знаков в подстроках.</param>
        <summary>Сравнивает подстроки двух указанных объектов <see cref="T:System.String" />, вычисляя числовые значения соответствующих объектов <see cref="T:System.Char" /> в каждой подстроке.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Подстрока в <paramref name="strA" /> меньше, чем подстрока в <paramref name="strB" />.  
  
 </description></item><item><term> Нуль 
 </term><description> Подстроки равны, или значение параметра <paramref name="length" /> равно нулю.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Подстрока в <paramref name="strA" /> больше, чем подстрока в <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры `indexA`, `indexB`и `length` должны быть неотрицательными.  
  
 Число сравниваемых символов является меньшей длиной `strA` меньше `indexA`, длины `strB` меньше `indexB`и `length`.  
  
 Этот метод выполняет сравнение с учетом регистра, используя правила сортировки по порядковому номеру. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Чтобы выполнить сравнение без учета регистра с помощью правил сортировки по порядковому номеру, вызовите метод <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> с аргументом `comparisonType`, для которого задано значение <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Поскольку <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> является статическим методом, `strA` и `strB` могут быть `null`. Если оба значения являются `null`, метод возвращает 0 (нуль), что означает, что `strA` и `strB` равны. Если только одно из значений имеет `null`, метод считает, что значение, отличное от NULL, больше.  
  
   
  
## Examples  
 В следующем примере показано, что <xref:System.String.CompareOrdinal%2A> и <xref:System.String.Compare%2A> используют разные порядки сортировки.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strA" /> не имеет значение <see langword="null" />, и значение <paramref name="indexA" /> больше <paramref name="strA" />,<see cref="P:System.String.Length" />.  
  
- или - 
 <paramref name="strB" /> не имеет значение <see langword="null" /> , и значение <paramref name="indexB" /> больше <paramref name="strB" />,<see cref="P:System.String.Length" />.  
  
- или - 
 <paramref name="indexA" />, <paramref name="indexB" /> или <paramref name="length" /> является отрицательным значением.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сравнивает данный экземпляр с заданным объектом или строкой <see cref="T:System.String" /> и возвращает целое число, которое показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и заданный объект или строка <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обе перегрузки метода <xref:System.String.CompareTo%2A> выполняют сравнение с учетом языка и региональных параметров, а также с учетом регистра. Этот метод нельзя использовать для сравнений без учета языка и региональных параметров или порядкового сравнения. Для ясности кода рекомендуется избегать метода <xref:System.String.CompareTo%2A> и вызывать метод <xref:System.String.Compare%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Объект, имеющий значение <see cref="T:System.String" />.</param>
        <summary>Сравнивает данный экземпляр с указанным объектом <see cref="T:System.Object" /> и показывает, расположен ли экземпляр перед, после или в той же позиции в порядке сортировки, что и заданный объект <see cref="T:System.Object" />.</summary>
        <returns>32-битовое целое число со знаком, которое показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и параметр <paramref name="value" />.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Данный экземпляр предшествует параметру <paramref name="value" />.  
  
 </description></item><item><term> Нуль 
 </term><description> Данный экземпляр имеет ту же позицию в порядке сортировки, что и <paramref name="value" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Данный экземпляр стоит после параметра <paramref name="value" />.  
  
- или - 
 <paramref name="value" /> — <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` должен быть <xref:System.String>ным объектом.  
  
> [!CAUTION]
>  Метод <xref:System.String.CompareTo%2A> был разработан главным образом для использования в операциях сортировки или алфабетизинг. Его не следует использовать, когда основной целью вызова метода является определение того, эквивалентны ли две строки. Чтобы определить, эквивалентны ли две строки, вызовите метод <xref:System.String.Equals%2A>.  
  
 Этот метод выполняет сравнение по словам (с учетом регистра и с учетом языка и региональных параметров), используя текущий язык и региональные параметры. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Дополнительные сведения о поведении этого метода см. в разделе "Примечания" метода <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере метод <xref:System.String.CompareTo%2A> используется с <xref:System.Object>. Поскольку он пытается сравнить экземпляр <xref:System.String> с `TestClass`ным объектом, метод создает исключение <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> не является объектом <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. Метод <see cref="M:System.String.CompareTo(System.Object)" /> не учитывает такие символы при выполнении сравнения с учетом языка и региональных параметров. Например, если следующий код выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, сравнение «Animal» с «Ani-недействительностью» (с использованием мягкого дефиса или U + 00AD) указывает на то, что две строки эквивалентны.  
  
[!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
Чтобы распознать игнорируемые символы в сравнении строк, вызовите метод <see cref="M:System.String.CompareOrdinal(System.String,System.String)" />.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(string strB) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::String ^ strB);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Строка, сравниваемая с данным экземпляром.</param>
        <summary>Сравнивает данный экземпляр с заданным объектом <see cref="T:System.String" /> и показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и заданная строка.</summary>
        <returns>32-битовое целое число со знаком, которое показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и параметр <paramref name="strB" />.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Данный экземпляр предшествует параметру <paramref name="strB" />.  
  
 </description></item><item><term> Нуль 
 </term><description> Данный экземпляр имеет ту же позицию в порядке сортировки, что и <paramref name="strB" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Данный экземпляр стоит после параметра <paramref name="strB" />.  
  
- или - 
 Свойство <paramref name="strB" /> имеет значение <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение по словам (с учетом регистра и с учетом языка и региональных параметров), используя текущий язык и региональные параметры. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Метод <xref:System.String.CompareTo%2A> был разработан главным образом для использования в операциях сортировки или алфабетизинг. Его не следует использовать, когда основной целью вызова метода является определение того, эквивалентны ли две строки. Чтобы определить, эквивалентны ли две строки, вызовите метод <xref:System.String.Equals%2A>.  
  
 Дополнительные сведения о поведении этого метода см. в разделе "Примечания" метода <xref:System.String.Compare%28System.String%2CSystem.String%29>.  
  
 Этот метод реализует интерфейс <xref:System.IComparable%601?displayProperty=nameWithType> и работает немного лучше, чем метод <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType>, поскольку ему не нужно определять, является ли аргумент `strB` изменяемым типом значения, который должен быть упакован, и не должен приводить его параметр из <xref:System.Object> к <xref:System.String>.  
  
   
  
## Examples  
 В следующем примере метод <xref:System.String.CompareTo%2A> используется для сравнения текущего экземпляра строки с другой строкой.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 В следующем примере показаны универсальные и неуниверсальные версии метода CompareTo для нескольких ссылочных типов.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. Метод <see cref="M:System.String.CompareTo(System.String)" /> не учитывает такие символы при выполнении сравнения с учетом языка и региональных параметров. Например, если следующий код выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, сравнение «Animal» с «Ani-недействительностью» (с использованием мягкого дефиса или U + 00AD) указывает на то, что две строки эквивалентны.  
  
[!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
Чтобы распознать игнорируемые символы в сравнении строк, вызовите метод <see cref="M:System.String.CompareOrdinal(System.String,System.String)" />.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Объединяет один или несколько экземпляров класса <see cref="T:System.String" /> или представления в виде <see cref="T:System.String" /> значений одного или нескольких экземпляров <see cref="T:System.Object" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!NOTE]
>  Для сцепления строк можно также использовать оператор объединения строк языка, например `+` в C#, или `&` и `+` в Visual Basic. Оба компилятора преобразуют оператор объединения в вызов одной из перегрузок `String.Concat`. 

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values">Объект коллекции, реализующий интерфейс <see cref="T:System.Collections.Generic.IEnumerable`1" /> и имеющий аргумент универсального типа <see cref="T:System.String" />.</param>
        <summary>Сцепляет элементы созданной коллекции <see cref="T:System.Collections.Generic.IEnumerable`1" /> типа <see cref="T:System.String" />.</summary>
        <returns>Сцепленные строки в параметре <paramref name="values" />. Или <see cref="F:System.String.Empty" />, если <paramref name="values" /> — это пустой элемент <see langword="IEnumerable(Of String)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод объединяет каждый объект в `values`; Он не добавляет никакие разделители. Чтобы указать разделитель между каждым членом `values`, вызовите метод <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>.  
  
 <xref:System.String.Empty?displayProperty=nameWithtype> строка используется вместо любого элемента null в `values`.  
  
 Если значение параметра `values` — это пустой элемент `IEnumerable(Of String)`, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>. Если `values` `null`, метод вызывает исключение <xref:System.ArgumentNullException>.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> — это удобный метод, позволяющий объединять каждый элемент в коллекции `IEnumerable(Of String)` без предварительного преобразования элементов в массив строк. Он особенно полезен в выражениях запросов LINQ. В следующем примере передается объект `List(Of String)`, содержащий прописные или строчные буквы алфавита, в лямбда-выражение, которое выбирает буквы, равные или превышающие определенную букву (в данном примере — «M»). Коллекция `IEnumerable(Of String)`, возвращаемая методом <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>, передается методу <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> для вывода результата в виде одной строки.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 В следующем примере используется Сиеве алгоритма Ератоссенес для вычисления простых чисел, которые меньше или равны 100. Он присваивает результат объекту <xref:System.Collections.Generic.List%601> типа <xref:System.String>, который затем передается методу <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Объект для представления или значение <see langword="null" />.</param>
        <summary>Создает строковое представление указанного объекта.</summary>
        <returns>Строковое представление значения параметра <paramref name="arg0" /> или <see cref="F:System.String.Empty" />, если значение параметра <paramref name="arg0" /> равно <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.String.Concat%28System.Object%29> представляет `arg0` в виде строки путем вызова метода `ToString` без параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.Concat%2A>.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Массив объектов, содержащий элементы, которые требуется сцепить.</param>
        <summary>Сцепляет строковые представления элементов указанного массива <see cref="T:System.Object" />.</summary>
        <returns>Сцепленные строковые представления значений элементов параметра <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод объединяет каждый объект в `args`, вызывая метод `ToString` без параметров этого объекта. Он не добавляет никакие разделители.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> используется вместо любого пустого объекта в массиве.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.String.Concat%2A> с массивом <xref:System.Object>.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="args" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти.</exception>
        <block subset="none" type="usage"><para>Этот метод не вызывается C++ кодом. C++ Компилятор разрешает вызовы <see cref="Overload:System.String.Concat" /> с четырьмя или более параметрами объекта в качестве вызова <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Массив строк.</param>
        <summary>Сцепляет элементы указанного массива <see cref="T:System.String" />.</summary>
        <returns>Сцепленные элементы <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод объединяет каждый объект в `values`; Он не добавляет никакие разделители.  
  
 Вместо любого объекта null в массиве используется <xref:System.String.Empty?displayProperty=nameWithtype>ная строка.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.String.Concat%2A> с массивом <xref:System.String>.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> — <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Первый из сцепляемых объектов.</param>
        <param name="arg1">Второй из сцепляемых объектов.</param>
        <summary>Сцепляет строковые представления двух указанных объектов.</summary>
        <returns>Сцепленные строковые представления значений <paramref name="arg0" /> и <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод объединяет `arg0` и `arg1`, вызывая метод `ToString` без параметров `arg0` и `arg1`. Он не добавляет никакие разделители.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> используется вместо любого аргумента null.  
  
 Если один из аргументов является ссылкой на массив, метод объединяет строку, представляющую этот массив, а не его члены (например, "System. String []").  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.Concat%2A>.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">Первый диапазон символов только для чтения для сцепления.</param>
        <param name="str1">Второй диапазон символов только для чтения для сцепления.</param>
        <summary>Сцепляет строковые представления двух указанных диапазонов символов только для чтения.</summary>
        <returns>Сцепленные строковые представления значений <paramref name="str0" /> и <paramref name="str1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Первая из сцепляемых строк.</param>
        <param name="str1">Вторая из сцепляемых строк.</param>
        <summary>Сцепляет два указанных экземпляра <see cref="T:System.String" />.</summary>
        <returns>Сцепление <paramref name="str0" /> и <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод объединяет `str0` и `str1`; Он не добавляет никакие разделители.  
  
 Вместо любого аргумента null используется <xref:System.String.Empty?displayProperty=nameWithtype>ная строка.  
  
## Examples  
 В следующем примере объединяются имя, отчество и фамилия человека.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Первый из сцепляемых объектов.</param>
        <param name="arg1">Второй из сцепляемых объектов.</param>
        <param name="arg2">Третий из сцепляемых объектов.</param>
        <summary>Сцепляет строковые представления трех указанных объектов.</summary>
        <returns>Сцепленные строковые представления значений <paramref name="arg0" />, <paramref name="arg1" /> и <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод объединяет `arg0`, `arg1`и `arg2`, вызывая метод `ToString` без параметров для каждого объекта. Он не добавляет никакие разделители.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> используется вместо любого аргумента null.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.Concat%2A>.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">Первый диапазон символов только для чтения для сцепления.</param>
        <param name="str1">Второй диапазон символов только для чтения для сцепления.</param>
        <param name="str2">Третий диапазон символов только для чтения для сцепления.</param>
        <summary>Сцепляет строковые представления трех указанных диапазонов символов только для чтения.</summary>
        <returns>Сцепленные строковые представления значений <paramref name="str0" />, <paramref name="str1" /> и <paramref name="str2" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Первая из сцепляемых строк.</param>
        <param name="str1">Вторая из сцепляемых строк.</param>
        <param name="str2">Третья из сцепляемых строк.</param>
        <summary>Сцепляет три указанных экземпляра <see cref="T:System.String" />.</summary>
        <returns>Сцепление <paramref name="str0" />, <paramref name="str1" /> и <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод объединяет `str0`, `str1`и `str2`; Он не добавляет никакие разделители.  
  
## Examples  
 В следующем примере используется метод <xref:System.String.Concat%2A> для сцепления трех строк и отображения результата.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">Первый из сцепляемых объектов.</param>
        <param name="arg1">Второй из сцепляемых объектов.</param>
        <param name="arg2">Третий из сцепляемых объектов.</param>
        <param name="arg3">Четвертый из сцепляемых объектов.</param>
        <summary>Сцепляет строковые представления четырех указанных объектов и любые объекты, заданные в необязательном списке параметров переменной длины.</summary>
        <returns>Сцепленное строковое представление каждого значения в списке параметров.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот интерфейс API CLS-несовместим. CLS-совместимая альтернатива — <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. Компиляторы C# и Visual Basic автоматически разрешают вызов этого метода как вызов <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Метод объединяет каждый объект в списке параметров, вызывая метод `ToString` без параметров; Он не добавляет никакие разделители.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> используется вместо любого аргумента null.  
  
> [!NOTE]
>  Последний параметр метода <xref:System.String.Concat%2A> — это необязательный список из одного или нескольких дополнительных объектов для сцепления, разделенных запятыми.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> для сцепления списка параметров переменных. В этом случае метод вызывается с девятью параметрами.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Этот метод помечен ключевым словом <see langword="vararg" />, что означает, что он поддерживает переменное число параметров. Метод можно вызывать из Visual C++, но он не может быть вызван из C# кода или Visual Basic. Компиляторы C# и Visual Basic разрешают вызовы в <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> как вызовы <see cref="M:System.String.Concat(System.Object[])" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">Первый диапазон символов только для чтения для сцепления.</param>
        <param name="str1">Второй диапазон символов только для чтения для сцепления.</param>
        <param name="str2">Третий диапазон символов только для чтения для сцепления.</param>
        <param name="str3">Четвертый диапазон символов только для чтения для сцепления.</param>
        <summary>Сцепляет строковые представления четырех указанных диапазонов символов только для чтения.</summary>
        <returns>Сцепленные строковые представления значений <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> и <paramref name="str3" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Первая из сцепляемых строк.</param>
        <param name="str1">Вторая из сцепляемых строк.</param>
        <param name="str2">Третья из сцепляемых строк.</param>
        <param name="str3">Четвертая из сцепляемых строк.</param>
        <summary>Сцепляет четыре указанных экземпляра <see cref="T:System.String" />.</summary>
        <returns>Сцепление <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> и <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод объединяет `str0`, `str1`, `str2`и `str3`; Он не добавляет никакие разделители.  
  
## Examples  
 В следующем примере определяется массив слов из четырех букв, а отдельные буквы хранятся в массиве строк, чтобы их можно было кодировать. Затем вызывается метод <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> для повторной сборки зашифрованных слов.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов параметра <paramref name="values" />.</typeparam>
        <param name="values">Объект коллекции, реализующий интерфейс <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Сцепляет элементы реализации <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Сцепленные элементы в параметре <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод объединяет каждый объект в `values`; Он не добавляет никакие разделители.  
  
 Вместо любого аргумента null используется <xref:System.String.Empty?displayProperty=nameWithtype>ная строка.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> — это удобный метод, позволяющий объединять каждый элемент в коллекции <xref:System.Collections.Generic.IEnumerable%601> без предварительного преобразования элементов в строки. Он особенно полезен в выражениях запросов LINQ, как показано в примере. Строковое представление каждого объекта в коллекции <xref:System.Collections.Generic.IEnumerable%601> является производным путем вызова метода `ToString` объекта.  
  
   
  
## Examples  
 В следующем примере определяется очень простой `Animal` класс, содержащий имя животного, и порядок, к которому он принадлежит. Затем он определяет <xref:System.Collections.Generic.List%601> объект, содержащий количество объектов `Animal`. Метод расширения <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> вызывается для извлечения объектов `Animal`, свойство `Order` которых равно "грызунов". Результат передается методу <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> и отображается в консоли.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="values" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Символ для поиска.</param>
        <summary>Возвращает значение, указывающее, встречается ли указанный символ внутри этой строки.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> выполняется внутри этой строки; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <summary>Возвращает значение, указывающее, встречается ли указанная подстрока внутри этой строки.</summary>
        <returns><see langword="true" />, если параметр <paramref name="value" /> встречается в строке или <paramref name="value" /> является пустой строкой (""); в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров). Поиск начинается с позиции первого символа этой строки и продолжается до последней позиции символа.  
  
 Чтобы определить, содержит ли строка указанную подстроку с использованием чего-либо, отличного от порядкового сравнения (например, сравнение с учетом языка и региональных параметров или сравнение с учетом регистра), можно создать пользовательский метод. В следующем примере показан один из таких подходов. Он определяет метод расширения <xref:System.String>, который включает параметр <xref:System.StringComparison> и указывает, содержит ли строка подстроку при использовании указанной формы сравнения строк.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 В следующем примере вызывается метод расширения `Contains`, чтобы определить, найдена ли подстрока в строке при использовании сравнения по порядковому номеру и порядковому номеру без учета регистра.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Если вы заинтересованы в положении подстроки `value` в текущем экземпляре, можно вызвать метод <xref:System.String.IndexOf%2A>, чтобы получить начальную точку первого вхождения, или же можно вызвать метод <xref:System.String.LastIndexOf%2A>, чтобы получить начальную точку последнего вхождения. Пример включает вызов метода <xref:System.String.IndexOf%28System.String%29>, если подстрока обнаружена в экземпляре строки.  
  
   
  
## Examples  
 В следующем примере определяется, является ли строка "Fox" подстрокой привычного предложения. Если в строке обнаружена строка "Fox", она также отображает ее начальную точку.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Символ для поиска.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее используемые при сравнении правила.</param>
        <summary>Возвращает значение, указывающее, встречается ли указанный символ внутри этой строки, используя указанные правила сравнения.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> выполняется внутри этой строки; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее используемые при сравнении правила.</param>
        <summary>Возвращает значение, указывающее, встречается ли указанная строка внутри этой строки, используя указанные правила сравнения.</summary>
        <returns><see langword="true" />, если параметр <paramref name="value" /> встречается в строке или <paramref name="value" /> является пустой строкой (""); в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Строка для копирования.</param>
        <summary>Создает экземпляр <see cref="T:System.String" />, имеющий то же значение, что и указанный экземпляр <see cref="T:System.String" />.</summary>
        <returns>Новая строка с тем же значением, что и <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Метод `Copy` возвращает объект <xref:System.String>, который имеет то же значение, что и исходная строка, но представляет другую ссылку на объект. Он отличается от операции присваивания, которая назначает существующую строку ссылки на дополнительную объектную переменную.

> [!IMPORTANT]
>  Начиная с .NET Core 3,0 этот метод является устаревшим. Однако мы не рекомендуем использовать его в любой реализации .NET. В частности, из-за изменений в интернировании строк в .NET Core 3,0 в некоторых случаях метод `Copy` не создает новую строку, а просто возвращает ссылку на существующую интернированную строку.   

В зависимости от того, зачем нужно вызывать метод `Copy`, существует несколько альтернатив:

- Если требуется использовать другой экземпляр строки в операции, которая изменяет строку, используйте экземпляр исходной строки. Поскольку строки являются неизменяемыми, строковая операция создает новый экземпляр строки, а исходная строка остается без изменений. В этом случае не следует назначать новую строковую переменную в исходной строковой переменной. Ниже приведен пример.

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#1)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#1)]  
  
   В этом случае вызов метода `Copy` для создания новой строки перед вызовом метода <xref:System.String.Substring%2A> необязательно создает новый экземпляр строки. 

- Если вы хотите создать изменяемый буфер с тем же содержимым, что и исходная строка, вызовите конструктор <xref:System.String.ToCharArray%2A?displayProperty=nameWithType> или <xref:System.Text.StringBuilder.%23ctor(System.String)?displayProperty=nameWithType>. Например:

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#2)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#2)]  

- Если нужно создать изменяемую копию строки, чтобы можно было использовать ненадежный код для изменения содержимого строки, используйте метод <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType>. В следующем примере метод <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> используется для получения указателя на расположение скопированной строки в неуправляемой памяти, приращения кодовой точки Юникода для каждого символа в строке на один и копирует полученную строку обратно в управляемую строку.

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="str" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Индекс первого символа в этом экземпляре, который необходимо скопировать.</param>
        <param name="destination">Массив символов Юникода, в который копируются символы в этом экземпляре.</param>
        <param name="destinationIndex">Индекс в массиве <paramref name="destination" />, с которого начинается копирование.</param>
        <param name="count">Число знаков в этом экземпляре, копируемых в <paramref name="destination" />.</param>
        <summary>Копирует заданное число знаков, начиная с указанной позиции в этом экземпляре до указанной позиции в массиве знаков Юникода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует `count` символы из `sourceIndex` позиции данного экземпляра в `destinationIndex` позиции `destination` массива символов. Этот метод не изменяет размер массива символов `destination`; Он должен иметь достаточное количество элементов для размещения скопированных символов, иначе метод выдаст <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex` и `destinationIndex` отсчитываются от нуля.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.CopyTo%2A>.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="destination" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" /> или <paramref name="count" /> является отрицательным значением. 
- или - 
 <paramref name="sourceIndex" /> не определяет позицию в текущем экземпляре.  
  
- или - 
 <paramref name="destinationIndex" /> не определяет допустимый индекс в массиве <paramref name="destination" />.  
  
- или - 
 <paramref name="count" /> больше, чем длина подстроки от <paramref name="sourceIndex" /> до конца данного экземпляра. 
- или - 
 <paramref name="count" /> больше, чем длина подмассива от <paramref name="destinationIndex" /> до конца массива <paramref name="destination" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState">Тип элемента, который необходимо передать в <paramref name="action" />.</typeparam>
        <param name="length">Длина создаваемой строки.</param>
        <param name="state">Элемент, передаваемый в <paramref name="action" />.</param>
        <param name="action">Обратный вызов для инициализации строки.</param>
        <summary>Создает строку определенной длины и инициализирует ее после создания с помощью указанного обратного вызова.</summary>
        <returns>Созданная строка.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет пустую строку. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значением этого поля является строка нулевой длины, "".  
  
 В коде приложения это поле чаще всего используется в назначениях для инициализации строковой переменной в пустую строку. Чтобы проверить, является ли значение строки `null` или <xref:System.String.Empty?displayProperty=nameWithType>, используйте метод <xref:System.String.IsNullOrEmpty%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, совпадает ли конец данного экземпляра строки с указанной строкой.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Символ, который необходимо сравнить с символом, расположенным в конце этого экземпляра.</param>
        <summary>Определяет, совпадает ли конец данного экземпляра строки с указанным символом.</summary>
        <returns><see langword="true" />, если конец этого экземпляра совпадает с <paramref name="value" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод выполняет сравнение с учетом регистра и с учетом языка и региональных параметров, используя текущий язык и региональные параметры.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка, которую необходимо сравнить с подстрокой, расположенной в конце этого экземпляра.</param>
        <summary>Определяет, совпадает ли конец данного экземпляра строки с указанной строкой.</summary>
        <returns><see langword="true" />, если конец этого экземпляра совпадает с <paramref name="value" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод сравнивает `value` с подстрокой в конце экземпляра, которая имеет ту же длину, что и `value`, и возвращает значение, указывающее, равны ли они. Чтобы быть равными, `value` должен быть ссылкой на этот же экземпляр или соответствовать концу этого экземпляра.  
  
 Этот метод выполняет сравнение по словам (с учетом регистра и с учетом языка и региональных параметров), используя текущий язык и региональные параметры.  
  
   
  
## Examples  
 В следующем примере показано, заканчивается ли каждая строка в массиве точкой (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 В следующем примере определяется метод `StripEndTags`, использующий метод <xref:System.String.EndsWith%28System.String%29> для удаления закрывающих тегов HTML из конца строки. Обратите внимание, что метод `StripEndTags` вызывается рекурсивно, чтобы гарантировать удаление нескольких конечных тегов HTML в конце строки.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Как описано в статье рекомендации [по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию, а вызывают методы, для которых требуется явно указать параметры. Чтобы определить, заканчивается ли строка определенной подстрокой с помощью правил сравнения строк текущего языка и региональных параметров, вызовите перегрузку метода <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его параметра <paramref name="comparisonType" />.</para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка, которую необходимо сравнить с подстрокой, расположенной в конце этого экземпляра.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее способ сравнения данной строки со значением <paramref name="value" />.</param>
        <summary>Определяет, совпадает ли конец экземпляра строки с заданной строкой при сравнении с учетом заданного параметра сравнения.</summary>
        <returns><see langword="true" />, если параметр <paramref name="value" /> соответствует концу данной строки; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.String.EndsWith%2A> сравнивает параметр `value` с подстрокой в конце строки и возвращает значение, указывающее, равны ли они. Чтобы быть равным, `value` должен быть ссылкой на эту же строку, должен быть пустой строкой ("") или совпадать с концом этой строки. Тип сравнения, выполняемого методом <xref:System.String.EndsWith%2A>, зависит от значения параметра `comparisonType`.  
  
   
  
## Examples  
 В следующем примере определяется, заканчивается ли строка определенной подстрокой. На результаты влияют выбранные язык и региональные параметры, учитывается ли регистр и выполняется ли порядковое сравнение.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является значением <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Строка, которую необходимо сравнить с подстрокой, расположенной в конце этого экземпляра.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при сравнении; в противном случае — значение <see langword="false" />.</param>
        <param name="culture">Связанные с языком и региональными параметрами сведения, определяющие, как выполняется сравнение этого экземпляра и <paramref name="value" />. Если значением параметра <paramref name="culture" /> является <see langword="null" />, используется текущий язык и региональные параметры.</param>
        <summary>Определяет, совпадает ли конец данного экземпляра строки с заданной строкой при сравнении с учетом заданного языка и региональных параметров.</summary>
        <returns><see langword="true" />, если параметр <paramref name="value" /> соответствует концу данной строки; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод сравнивает параметр `value` с подстрокой в конце строки, которая имеет ту же длину, что и `value`, и возвращает значение, указывающее, равны ли они. Чтобы быть равным, `value` должен быть ссылкой на этот же экземпляр или соответствовать концу этой строки.  
  
 Этот метод выполняет сравнение по словам (с учетом языка и региональных параметров) с использованием указанного регистра и языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере определяется, находится ли строка в конце другой строки. Метод <xref:System.String.EndsWith%2A> вызывается несколько раз при использовании чувствительности к регистру, нечувствительности к регистру и различных культур, влияющих на результаты поиска.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечисление <see cref="T:System.Text.Rune" /> из этой строки.</summary>
        <returns>Строковый перечислитель Rune.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

### Remarks

Недопустимые последовательности представлены в перечислении <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, равны ли значения двух объектов <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Строка для сравнения с данным экземпляром.</param>
        <summary>Определяет, равны ли значения этого экземпляра и указанного объекта, который также должен быть объектом <see cref="T:System.String" />.</summary>
        <returns><see langword="true" />, если объект <paramref name="obj" /> имеет тип <see cref="T:System.String" /> и его значение совпадает со значением данного экземпляра; в противном случае — <see langword="false" />.  Если значением параметра <paramref name="obj" /> является <see langword="null" />, метод возвращает <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.Equals%2A>.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка для сравнения с данным экземпляром.</param>
        <summary>Определяет, равны ли значения этого экземпляра и указанного объекта <see cref="T:System.String" />.</summary>
        <returns><see langword="true" />, если значение параметра <paramref name="value" /> совпадает со значением данного экземпляра; в противном случае — <see langword="false" />. Если значением параметра <paramref name="value" /> является <see langword="null" />, метод возвращает <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.Equals%2A>. Он сравнивает слово «file» с заголовком с эквивалентным словом, его аналогом в нижнем регистре, эквивалентом в верхнем регистре и словом, содержащим Латинская СТРОЧная БУКВа i (U + 0131) вместо Латинской маленькой буквы I (U + 0069). Поскольку метод <xref:System.String.Equals%28System.String%29> выполняет порядковое сравнение, только сравнение с идентичным словом возвращает `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Первая сравниваемая строка или значение <see langword="null" />.</param>
        <param name="b">Вторая сравниваемая строка или значение <see langword="null" />.</param>
        <summary>Определяет, совпадают ли значения двух указанных объектов <see cref="T:System.String" />.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="a" /> совпадает со значением <paramref name="b" />; в противном случае — значение <see langword="false" />. Если оба параметра <paramref name="a" /> и <paramref name="b" /> имеют значение <see langword="null" />, метод возвращает значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.Equals%2A>.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для сравнения с данным экземпляром.</param>
        <param name="comparisonType">Одно из значений перечисления, задающее способ сравнения строк.</param>
        <summary>Определяет, равны ли значения этой строки и указанного объекта <see cref="T:System.String" />. Параметр определяет язык и региональные параметры, учет регистра и правила сортировки, используемые при сравнении.</summary>
        <returns><see langword="true" />, если значение параметра <paramref name="value" /> совпадает со значением данной строки; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `comparisonType` указывает, должно ли сравнение использовать текущий или инвариантный язык и региональные параметры, учитывать или игнорировать регистр двух сравниваемых строк либо использовать правила сортировки по словам или порядковому номеру.  
  
   
  
## Examples  
 В следующем примере создается массив строк, состоящий из прописной буквы I, строчной буквы i и точки с «ı». Затем он вызывает метод <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> для их сравнения с помощью каждого возможного значения перечисления <xref:System.StringComparison>.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 В следующем примере сравниваются четыре набора слов с помощью каждого члена перечисления <xref:System.StringComparison>.  В сравнениях используются соглашения для языков и региональных параметров "Английский (США)" и "Sami" (Upper Швеция). Обратите внимание, что строки "енциклопæдиа" и "енциклопаедиа" считаются эквивалентными в культуре en-US, но не в культуре (Северный Швеция).  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является значением <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a">Первая сравниваемая строка или значение <see langword="null" />.</param>
        <param name="b">Вторая сравниваемая строка или значение <see langword="null" />.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила сравнения.</param>
        <summary>Определяет, совпадают ли значения двух указанных объектов <see cref="T:System.String" />. Параметр определяет язык и региональные параметры, учет регистра и правила сортировки, используемые при сравнении.</summary>
        <returns><see langword="true" />, если значения параметров <paramref name="a" /> и <paramref name="b" /> совпадают; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `comparisonType` указывает, должно ли сравнение использовать текущий или инвариантный язык и региональные параметры, учитывать или игнорировать регистр двух сравниваемых строк либо использовать правила сортировки по словам или порядковому номеру.  
  
   
  
## Examples  
 В следующем примере сравниваются четыре набора слов с помощью каждого члена перечисления <xref:System.StringComparison>.  В сравнениях используются соглашения для языков и региональных параметров "Английский (США)" и "Sami" (Upper Швеция). Обратите внимание, что строки "енциклопæдиа" и "енциклопаедиа" считаются эквивалентными в культуре en-US, но не в культуре (Северный Швеция).  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является значением <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует значения объектов в строки на основе указанных форматов и вставляет их в другую строку.  
  
Если вы не знакомы с методом `String.Format`, см. краткие сведения в разделе [Начало работы с методом String.Format](#Starting).  
  
В разделе [Примечания](#remarks-top) приводится общая документация для метода `String.Format`.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 Содержание  
  
 Приступая к [работе с методом String. Format](#Starting)   
 [Какой метод следует вызывать?](#FTaskList)   
 [Метод Format в кратком](#Format_Brief)   
 [Элемент форматирования](#FormatItem)   
 [Форматирование аргументов](#HowFormatted)   
 [Форматирование элементов с одинаковым индексом](#SameIndex)   
 [Форматирование и культура](#Format_Culture)   
   [операций пользовательского форматирования](#Format_Custom)  
 [Строка. формат Q & A](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Начало работы с методом String. Format  
 Используйте <xref:System.String.Format%2A?displayProperty=nameWithType>, если необходимо вставить значение объекта, переменной или выражения в другую строку. Например, можно вставить значение <xref:System.Decimal>ого значения в строку, чтобы отобразить ее пользователю в виде одной строки:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 Вы можете контролировать форматирование этого значения:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Помимо форматирования, можно также управлять выравниванием и отступами.  
  
 ### <a name="inserting-a-string"></a>Вставка строки  

 <xref:System.String.Format%2A?displayProperty=nameWithType> начинается со строки формата, за которой следуют один или несколько объектов или выражений, которые будут преобразованы в строки и вставлены в указанное место в строке формата. Например:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 `{0}` в строке формата — это элемент формата. `0` — это индекс объекта, строковое значение которого будет вставлено в этой позиции. (Индексы начинаются с 0.) Если вставляемый объект не является строкой, вызывается его `ToString` метод, чтобы преобразовать его в результирующую строку.  
  
 Вот еще один пример, в котором используются два элемента формата и два объекта в списке объектов:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Количество элементов формата и количество объектов в списке объектов может быть любым, пока индекс каждого элемента формата имеет соответствующий объект в списке объектов. Кроме того, не нужно беспокоиться о том, какая перегрузка вызывается. компилятор выберет подходящий для вас.  
  
 ### <a name="controlling-formatting"></a>Управление форматированием  
 Для управления форматированием объекта можно следовать индексу в элементе форматирования со строкой формата. Например, `{0:d}` применяет строку формата "d" к первому объекту в списке объектов. Ниже приведен пример с одним объектом и двумя элементами форматирования:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Ряд типов поддерживает строки формата, включая все числовые типы ( [стандартные](~/docs/standard/base-types/standard-numeric-format-strings.md) и [Настраиваемые](~/docs/standard/base-types/custom-numeric-format-strings.md) строки формата), все даты и время ( [стандартные](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Настраиваемые](~/docs/standard/base-types/custom-date-and-time-format-strings.md) строки формата) и интервалы времени ( [стандартные](~/docs/standard/base-types/standard-timespan-format-strings.md) и строки [настраиваемого](~/docs/standard/base-types/custom-timespan-format-strings.md) формата), все типы [перечисления и](~/docs/standard/base-types/enumeration-format-strings.md) [идентификаторы GUID](https://msdn.microsoft.com/library/97af8hh4.aspx). Также можно добавить поддержку строк формата для собственных типов.  
  
 ### <a name="controlling-spacing"></a>Управление промежутками  
 Можно определить ширину строки, вставляемой в результирующую строку, с помощью синтаксиса, такого как `{0,12}`, который вставляет 12-символьную строку. В этом случае строковое представление первого объекта выдается по правому краю в 12-символьном поле.  (Если длина строкового представления первого объекта превышает 12 символов, то ширина предпочтительного поля игнорируется, а вся строка вставляется в результирующую строку.)  
  
 В следующем примере определяется 6-символьное поле для хранения строки "Year" и некоторых строк года, а также 15-символьного поля для хранения строки "Population" и некоторых данных о населении. Обратите внимание, что символы вычисляются по правому краю поля.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs#33)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Управление выравниванием  
 По умолчанию строки выводятся по правому краю в поле, если задана ширина поля. Для выровняйте строки по левому краю в поле Ширина поля предшествует знаку минуса, например `{0,-12}` для определения 12-символьного поля с левой границей.  
  
 Следующий пример аналогичен предыдущему, за исключением того, что он по левому краю выдает как метки, так и данные.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> использует функцию составного форматирования. Дополнительные сведения см. в разделе [Составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Какой метод следует вызывать?  
  
|Кому|Call|  
|--------|----------|  
|Форматирование одного или нескольких объектов с помощью соглашений текущего языка и региональных параметров.|За исключением перегрузок, включающих параметр `provider`, остальные <xref:System.String.Format%2A> перегрузки включают параметр <xref:System.String>, за которым следует один или несколько параметров объекта. Поэтому не нужно определять, какую перегрузку <xref:System.String.Format%2A> нужно вызвать. Языковой компилятор выбирает подходящую перегрузку из перегрузок, у которых нет параметра `provider`, в зависимости от списка аргументов. Например, если список аргументов содержит пять аргументов, компилятор вызывает метод <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>.|  
|Форматирование одного или нескольких объектов с помощью соглашений определенного языка и региональных параметров.|За каждой перегрузкой <xref:System.String.Format%2A>, которая начинается с параметра `provider`, следует параметр <xref:System.String> и один или несколько параметров объекта. Поэтому не нужно определять, какую конкретную перегрузку <xref:System.String.Format%2A> нужно вызвать. Языковой компилятор выбирает подходящую перегрузку из перегрузок, которые имеют параметр `provider`, в зависимости от списка аргументов. Например, если список аргументов содержит пять аргументов, компилятор вызывает метод <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>.|  
|Выполните операцию пользовательского форматирования либо с помощью <xref:System.ICustomFormatter>ной реализации, либо с помощью реализации <xref:System.IFormattable>.|Любая из четырех перегрузок с параметром `provider`. Компилятор выбирает подходящую перегрузку из перегрузок, которые имеют параметр `provider`, на основе списка аргументов.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Метод Format в кратком виде 

 Каждая перегрузка метода <xref:System.String.Format%2A> использует [составной компонент форматирования](~/docs/standard/base-types/composite-formatting.md) для включения индексируемых от нуля заполнителей, которые называются *элементами форматирования*, в строке составного формата. Во время выполнения каждый элемент форматирования заменяется строковым представлением соответствующего аргумента в списке параметров. Если аргумент имеет значение `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Например, следующий вызов метода <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> включает строку формата с тремя элементами форматирования, {0}, {1}и {2}, а также список аргументов с тремя элементами.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>Элемент форматирования  
 Элемент форматирования имеет следующий синтаксис:  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Скобки обозначают необязательные элементы. Открывающие и закрывающие фигурные скобки являются обязательными. (Чтобы включить в строку формата открывающую или закрывающую фигурную скобку, см. раздел [экранирование фигурных скобок](~/docs/standard/base-types/composite-formatting.md#escaping-braces) в статье [составного форматирования](~/docs/standard/base-types/composite-formatting.md) .)  
  
 Например, элемент форматирования для форматирования значения валюты может выглядеть следующим образом:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Элемент форматирования содержит следующие элементы:  
  
 *index*  
 Отсчитываемый от нуля индекс аргумента, строковое представление которого должен быть включен в данную точку в строке. Если этот аргумент имеет значение `null`, в этой позиции в строке будет включена пустая строка.  
  
 *Выравнивание*  
 Необязательный параметр. Целое число со знаком, указывающее общую длину поля, в которое вставляется аргумент, а также выровняйте его по правому краю (положительное целое число) или по левому краю (отрицательное целое число). Если параметр *alignment*опущен, строковое представление соответствующего аргумента вставляется в поле без начальных или конечных пробелов.  
  
 Если значение *выравнивания* меньше длины аргумента, которое необходимо вставить, *Выравнивание* игнорируется, а длина строкового представления аргумента используется в качестве ширины поля.  
  
 *formatString*  
 Необязательный параметр. Строка, указывающая формат результирующей строки соответствующего аргумента. Если опустить параметр *FormatString*, то для создания его строкового представления вызывается метод `ToString` без параметров соответствующего аргумента. При указании *FormatString*аргумент, на который ссылается элемент форматирования, должен реализовывать интерфейс <xref:System.IFormattable>. Типы, поддерживающие строки формата, включают:  
  
-   Все типы целочисленных и плавающих точек. (См. раздел [стандартные строки числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime> и <xref:System.DateTimeOffset>. (См. раздел [стандартные строки формата даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Все типы перечислений. (См. раздел [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   значения типа <xref:System.TimeSpan>. (См. раздел [стандартные строки формата TimeSpan](~/docs/standard/base-types/standard-timespan-format-strings.md) и [строки настраиваемого формата TimeSpan](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   Идентификаторы GUID. (См. метод <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>.)  
  
 Однако обратите внимание, что любой пользовательский тип может реализовать <xref:System.IFormattable> или расширить реализацию <xref:System.IFormattable> существующего типа.  
  
 В следующем примере для создания форматированного вывода используются аргументы `alignment` и `formatString`.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>Форматирование аргументов  
 Элементы формата обрабатываются последовательно с начала строки. Каждый элемент формата имеет индекс, соответствующий объекту в списке аргументов метода. Метод <xref:System.String.Format%2A> извлекает аргумент и наследует его строковое представление следующим образом:  
  
-   Если аргумент имеет значение `null`, метод вставляет <xref:System.String.Empty?displayProperty=nameWithType> в результирующую строку. Не нужно беспокоиться об обработке <xref:System.NullReferenceException> для аргументов null. 
  
-   При вызове перегрузки <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> и реализации <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> объекта `provider` возвращает реализацию <xref:System.ICustomFormatter>, не равную null, аргумент передается в метод <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType>. Если элемент форматирования содержит аргумент *FormatString* , он передается в метод в качестве первого аргумента. Если <xref:System.ICustomFormatter>ная реализация доступна и создает строку, отличную от NULL, то эта строка возвращается в виде строкового представления аргумента. в противном случае выполняется следующий шаг.  
  
-   Если аргумент реализует интерфейс <xref:System.IFormattable>, вызывается его <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> реализация.  
  
-   Вызывается метод `ToString` без параметров, который либо переопределяет, либо наследует от реализации базового класса.  
  
 Пример, который перехватывает вызовы к методу <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> и позволяет увидеть, какие сведения метод <xref:System.String.Format%2A> передает методу форматирования для каждого элемента форматирования в строке составного формата, см [. Пример: поставщик перехвата и римские цифры. модуль форматирования](#Format7_Example).  

 Дополнительные сведения см. в разделе [порядок обработки](~/docs/standard/base-types/composite-formatting.md##processing-order) статьи [составное форматирование](~/docs/standard/base-types/composite-formatting.md) .  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Форматирование элементов с одинаковым индексом  
 Метод <xref:System.String.Format%2A> создает исключение <xref:System.FormatException>, если индекс элемента индекса больше или равен числу аргументов в списке аргументов. Однако `format` может содержать больше элементов форматирования, чем количество аргументов, пока несколько элементов формата имеют одинаковый индекс. При вызове метода <xref:System.String.Format%28System.String%2CSystem.Object%29> в следующем примере список аргументов содержит один аргумент, но строка формата включает два элемента форматирования: один отображает десятичное значение числа, а другое — его шестнадцатеричное значение.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Форматирование и культура  
 Как правило, объекты в списке аргументов преобразуются в их строковые представления с использованием правил текущего языка и региональных параметров, возвращаемых свойством <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>. Это поведение можно контролировать, вызвав одну из перегрузок <xref:System.String.Format%2A>, которая включает параметр `provider`. Параметр `provider` является реализацией <xref:System.IFormatProvider>, которая предоставляет настраиваемые сведения о форматировании и языке и региональных параметрах, которые используются для среднего процесса форматирования.  
  
 Интерфейс <xref:System.IFormatProvider> содержит один член <xref:System.IFormatProvider.GetFormat%2A>, который отвечает за возврат объекта, предоставляющего сведения о форматировании. В .NET имеется три реализации <xref:System.IFormatProvider>, которые обеспечивают форматирование для конкретного языка и региональных параметров:  
  
-   <xref:System.Globalization.CultureInfo>. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> метод возвращает объект <xref:System.Globalization.NumberFormatInfo>, зависящий от языка и региональных параметров, для форматирования числовых значений и объект <xref:System.Globalization.DateTimeFormatInfo>, относящийся к культуре, для форматирования значений даты и времени.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, используемый для форматирования значений даты и времени, относящихся к культуре. Его <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> метод возвращает сам себя.  
  
-   <xref:System.Globalization.NumberFormatInfo>, используемый для форматирования числовых значений в зависимости от языка и региональных параметров. Свойство <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> возвращает само себя. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Пользовательские операции форматирования  
 Можно также вызвать любую из перегрузок метода <xref:System.String.Format%2A>, имеющего параметр `provider` типа <xref:System.IFormatProvider> для выполнения пользовательских операций форматирования. Например, можно отформатировать целое число как идентификационный номер или как номер телефона. Чтобы выполнить пользовательское форматирование, аргумент `provider` должен реализовать интерфейсы <xref:System.IFormatProvider> и <xref:System.ICustomFormatter>. Когда методу <xref:System.String.Format%2A> передается <xref:System.ICustomFormatter> реализация в качестве аргумента `provider`, метод <xref:System.String.Format%2A> вызывает его реализацию <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> и запрашивает объект типа <xref:System.ICustomFormatter>. Затем он вызывает метод <xref:System.ICustomFormatter.Format%2A> возвращаемого объекта <xref:System.ICustomFormatter> для форматирования каждого элемента формата в составной строке, передаваемой ему.  
  
 Дополнительные сведения о предоставлении пользовательских решений по форматированию см. [в разделе как определить и использовать поставщики настраиваемых числовых форматов](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) и <xref:System.ICustomFormatter>. Пример преобразования целых чисел в форматированные пользовательские числа см. в разделе [Пример: операция пользовательского форматирования](#Format6_Example). Пример преобразования неподписанных байтов в римские цифры см. в разделе [Пример: поставщик перехвата и модуль форматирования римских чисел](#Format7_Example).  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a>Пример. операция пользовательского форматирования  
 В этом примере определяется поставщик формата, который форматирует целочисленное значение как номер счета клиента в формате x-XXXXX-XX.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Пример: поставщик перехвата и модуль форматирования чисел Roman  
 В этом примере определяется поставщик настраиваемого формата, реализующий интерфейсы <xref:System.ICustomFormatter> и <xref:System.IFormatProvider>, чтобы выполнить два действия:  
  
-   Он отображает параметры, передаваемые в свою <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>ую реализацию. Это позволяет увидеть, какие параметры передаются методу <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> в реализацию пользовательского форматирования для каждого объекта, который он пытается отформатировать. Это может быть полезно при отладке приложения.  
  
-   Если форматируемый объект является значением байта без знака, которое форматируется с помощью строки стандартного формата "R", то пользовательское средство форматирования форматирует числовое значение как римские цифры.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>Строка. формат Q & A  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>Почему рекомендуется использовать интерполяцию строк вместо вызовов метода `String.Format`?

Интерполяция строк:

- Более гибкий. Его можно использовать в любой строке, не требуя вызова метода, поддерживающего составное форматирование. В противном случае необходимо вызвать метод <xref:System.String.Format%2A> или другой метод, поддерживающий составное форматирование, например <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>. 

- Более удобочитаемый. Так как выражение, вставляемое в строку, появляется в выражении с интерполяцией, а не в списке аргументов, интерполяция строк намного проще в коде и чтении. Из-за большей удобочитаемости интерполяция строк может заменить не только вызовы методов составного формата, но и их также можно использовать в операциях объединения строк для создания более краткого, более понятного кода. 

Сравнение следующих двух примеров кода иллюстрирует наилучшее значение интерполяции строк по объединению строк и вызовам методов составного форматирования. Использование нескольких операций сцепления строк в следующем примере создает подробный и трудный для чтения код.

[!code-csharp[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs#QAInterpolated)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

В отличие от этого, использование интерполяции строк в следующем примере создает гораздо более четкий, более краткий код, чем оператор объединения строк и вызов метода <xref:System.String.Format%2A> в предыдущем примере.

[!code-csharp[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs#QAInterpolated2)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Где можно найти список стандартных строк формата, которые можно использовать с элементами форматирования?  
  
-   Для всех целочисленных и типов с плавающей запятой см. статью [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Значения даты и времени см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Значения перечисления см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Значения <xref:System.TimeSpan> см. в разделе [строки стандартного формата TimeSpan](~/docs/standard/base-types/standard-timespan-format-strings.md) и [строки настраиваемого формата TimeSpan](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   <xref:System.Guid> значениях см. в разделе "Примечания" на странице справочника по <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Разделы справки управлять выравниванием результирующих строк, которые заменяют элементы форматирования?  
 Общий синтаксис элемента форматирования:  
  
```  
{index[,alignment][: formatString]}  
```  
  
 где *alignment* — это целое число со знаком, определяющее ширину поля. Если это значение отрицательное, текст в поле выполнится по левому краю. Если он положительный, текст выровняйтеся по правому краю.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Разделы справки контролировать количество цифр после десятичного разделителя?  
 Все [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) , за исключением "D" (которая используется только с целыми числами), "G", "R" и "X", допускают описатель точности, определяющий число десятичных цифр в результирующей строке. В следующем примере используются строки стандартного числового формата для управления количеством десятичных цифр в результирующей строке.  
  
 [!code-csharp[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Если вы используете [строку настраиваемого числового формата](~/docs/standard/base-types/custom-numeric-format-strings.md), используйте описатель формата "0" для управления числом десятичных цифр в результирующей строке, как показано в следующем примере.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Разделы справки контролировать количество цифр целой части?  
 По умолчанию операции форматирования отображают только ненулевые цифры целой части. При форматировании целых чисел можно использовать описатель точности с строками стандартного формата "D" и "X" для управления количеством цифр.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Чтобы получить результирующую строку с указанным числом целых чисел с помощью [настраиваемого описателя числового формата](~/docs/standard/base-types/custom-numeric-format-strings.md)"0", можно указать целое число или количество с плавающей запятой с нулем в начале, как показано в следующем примере.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Сколько элементов можно включить в список форматов?  
 Практические ограничения отсутствуют. Второй параметр метода <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> помечается атрибутом <xref:System.ParamArrayAttribute>, который позволяет включить в список форматов список с разделителями или массив объектов.  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Разделы справки содержать литеральные скобки ("{" и "}") в результирующей строке?  
 Например, как предотвратить исключение следующего вызова метода при возникновении исключения <xref:System.FormatException>?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Одиночная открывающая или закрывающая фигурная скобка всегда интерпретируется как начало или конец элемента форматирования. Чтобы интерпретировать его буквально, его необходимо экранировать. Фигурную скобку можно отключать, добавив еще одну фигурную скобку ("{{" и "}}") вместо "{" и "}"), как показано в следующем вызове метода:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Однако даже экранированные фигурные скобки легко интерпретировать. Рекомендуется включать фигурные скобки в список форматов и использовать элементы форматирования для вставки их в результирующую строку, как показано в следующем примере.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Почему вызов метода String. Format вызывает исключение FormatException?  
 Наиболее распространенной причиной возникновения исключения является то, что индекс элемента форматирования не соответствует объекту в списке Format. Обычно это означает, что вы ввели ненумерованные индексы элементов форматирования или забыли включить объект в список форматов. При попытке включить символ левой или правой фигурной скобки в escape-последовательность также создается <xref:System.FormatException>. Иногда исключение является результатом опечатки; Например, типичная ошибка заключается в ошибочном вводе "[" (левой скобки) вместо "{" (открывающей фигурной скобки).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Если метод Format (System. IFormatProvider, System. String, System. Object []) поддерживает массивы параметров, почему мой код создает исключение при использовании массива?  
 Например, следующий код вызывает исключение <xref:System.FormatException>:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Это проблема разрешения перегрузки компилятора. Поскольку компилятор не может преобразовать массив целых чисел в массив объектов, он обрабатывает целочисленный массив как один аргумент, поэтому он вызывает метод <xref:System.String.Format%28System.String%2CSystem.Object%29>. Исключение возникает из-за четырех элементов форматирования, но только одного элемента в списке Format.  
  
 Поскольку ни Visual Basic, C# ни не могут преобразовывать массив целых чисел в массив объектов, необходимо выполнить преобразование самостоятельно перед вызовом метода <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>. В следующем примере показана одна реализация.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Многочисленные примеры вызова метода <xref:System.String.Format%2A> приведены в разделе « [Примечания](#remarks-top) » этой статьи.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

Вы также можете скачать полный набор `String.Format` примеров, включающих [проект .NET Core 2,0 для C# ](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) и [проект .NET Core 2,0 для Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), из [репозитория DotNet/Samples GitHub](https://github.com/dotnet/samples).

Ниже приведены некоторые примеры, представленные в статье.

### <a name="create-a-format-string"></a>Создание строки формата

[Вставка строки](#inserting-a-string)  
[Элемент форматирования](#the-format-item)  
[Форматирование элементов с одинаковым индексом](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Управление форматированным выводом

[Управление форматированием](#controlling-formatting)  
[Управление промежутками](#controlling-spacing)  
[Управление выравниванием](#controlling-alignment)  
[Управление числом целочисленных цифр](#how-do-i-control-the-number-of-integral-digits)  
[Управление числом цифр после десятичного разделителя](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[Включение литеральных скобок в результирующую строку](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Создание строк формата с учетом языка и региональных параметров

[Форматирование с учетом языка и региональных параметров](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Настройка операции форматирования

[Пользовательская операция форматирования](#example-a-custom-formatting-operation)  
[Модуль форматирования для поставщика перехвата и римских чисел](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Объект для форматирования.</param>
        <summary>Заменяет один или более элементов формата в строке строковым представлением указанного объекта.</summary>
        <returns>Копия <paramref name="format" />, в которой все элементы формата заменены строковыми представлениями <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования значения выражения в строковое представление и встраивания этого представления в строку. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Пример. форматирование одного аргумента  
 
 В следующем примере метод <xref:System.String.Format%28System.String%2CSystem.Object%29> используется для внедрения возраста человека в середину строки.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимый элемент формата в <paramref name="format" />.  
  
- или - 
Индекс элемента формата не равен нулю.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Массив объектов, содержащий нуль или более форматируемых объектов.</param>
        <summary>Заменяет элемент формата в указанной строке строковым представлением соответствующего объекта в указанном массиве.</summary>
        <returns>Копия <paramref name="format" />, в которой элементы формата заменены строковыми представления соответствующих объектов в <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования значения четырех или более выражений в их строковые представления и встраивания этих представлений в строку. Поскольку параметр `args` помечен атрибутом <xref:System.ParamArrayAttribute?displayProperty=nameWithType>, можно передать объекты в метод как отдельные аргументы или как массив <xref:System.Object>. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Пример. форматирование более трех аргументов  
 
 В этом примере создается строка, которая содержит данные о высокой и низкой температуре в определенной дате. Строка составного формата содержит пять элементов формата в C# примере и шесть в Visual Basic примере. Два элемента форматирования определяют ширину строкового представления соответствующего значения, а первый элемент форматирования также включает строку стандартного формата даты и времени.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 Также можно передать объекты в виде массива, а не в виде списка аргументов.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="format" /> или <paramref name="args" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
- или - 
Индекс элемента формата меньше нуля или больше либо равен длине массива <paramref name="args" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Объект для форматирования.</param>
        <summary>Заменяет элементы формата в указанной строке строковым представлением соответствующего объекта. Параметр предоставляет сведения об особенностях форматирования, связанных с языком и региональными параметрами.</summary>
        <returns>Копия <paramref name="format" />, в которой элементы форматирования были заменены строковым представлением <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования значения выражения в строковое представление и встраивания этого представления в строку. При выполнении преобразования метод использует форматирование с учетом языка и региональных параметров или пользовательский модуль форматирования. Метод преобразует `arg0` в строковое представление путем вызова его метода **ToString (IFormatProvider)** или, если соответствующий элемент форматирования объекта включает строку формата, вызывая метод **ToString (String, IFormatProvider)** . Если эти методы не существуют, вызывается метод **ToString** без параметров объекта.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
- или - 
Индекс элемента формата не равен нулю.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Массив объектов, содержащий нуль или более форматируемых объектов.</param>
        <summary>Заменяет элементы формата в строке строковым представлениями соответствующих объектов в указанном массиве. Параметр предоставляет сведения об особенностях форматирования, связанных с языком и региональными параметрами.</summary>
        <returns>Копия <paramref name="format" />, в которой элементы формата заменены строковыми представления соответствующих объектов в <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования четырех или более выражений в их строковые представления и для встраивания этих представлений в строку. При выполнении преобразования метод использует форматирование с учетом языка и региональных параметров или пользовательский модуль форматирования. Метод преобразует каждый аргумент <xref:System.Object> в строковое представление путем вызова его метода **ToString (IFormatProvider)** или, если соответствующий элемент форматирования объекта включает строку формата, вызывая его **ToString (String, IFormatProvider).** метод. Если эти методы не существуют, вызывается метод **ToString** без параметров объекта.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

<a name="culture-sensitive-formatting" /> 

### <a name="example-culture-sensitive-formatting"></a>Пример: форматирование с учетом языка и региональных параметров

 В этом примере используется метод <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> для отображения строкового представления некоторых значений даты и времени и числовых значений с использованием нескольких различных языков и региональных параметров.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="format" /> или <paramref name="args" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
- или - 
Индекс элемента формата меньше нуля или больше либо равен длине массива <paramref name="args" />.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <summary>Заменяет элементы формата в строке строковым представлением двух указанных объектов.</summary>
        <returns>Копия <paramref name="format" />, в которой все элементы формата заменены строковыми представлениями <paramref name="arg0" /> и <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования значений двух выражений в их строковые представления и встраивания этих представлений в строку. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Пример. форматирование двух аргументов  
 
 В этом примере используется метод <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> для вывода данных о времени и температуре, хранящихся в универсальном <xref:System.Collections.Generic.Dictionary%602> объекте. Обратите внимание, что строка формата имеет три элемента форматирования, хотя для форматирования существует только два объекта. Это происходит потому, что первый объект в списке (значение даты и времени) используется двумя элементами форматирования: в первом элементе форматирования отображается время, а во втором отображается дата.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
- или - 
Индекс элемента формата не равен нулю или единице.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <summary>Заменяет элементы формата в строке строковым представлением двух указанных объектов. Параметр предоставляет сведения об особенностях форматирования, связанных с языком и региональными параметрами.</summary>
        <returns>Копия <paramref name="format" />, в которой все элементы формата заменены строковыми представлениями <paramref name="arg0" /> и <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования двух выражений в их строковые представления и встраивания этих представлений в строку. При выполнении преобразования метод использует форматирование с учетом языка и региональных параметров или пользовательский модуль форматирования. Метод преобразует каждый аргумент <xref:System.Object> в строковое представление путем вызова его метода **ToString (IFormatProvider)** или, если соответствующий элемент форматирования объекта включает строку формата, вызывая его **ToString (String, IFormatProvider).** метод. Если эти методы не существуют, вызывается метод **ToString** без параметров объекта.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
- или - 
Индекс элемента формата не равен нулю или единице.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <param name="arg2">Третий объект для форматирования.</param>
        <summary>Заменяет элементы формата в строке строковым представлением трех указанных объектов.</summary>
        <returns>Копия <paramref name="format" />, в которой все элементы формата заменены строковыми представлениями <paramref name="arg0" />, <paramref name="arg1" /> и <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования значений трех выражений в их строковые представления и встраивания этих представлений в строку. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Пример. форматирование трех аргументов  
 
 В этом примере используется метод <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> для создания строки, которая иллюстрирует результат операции логического `And` с двумя целочисленными значениями. Обратите внимание, что строка формата включает шесть элементов форматирования, но в списке параметров метода есть только три элемента, поскольку каждый элемент форматируется двумя разными способами.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
- или - 
Индекс элемента формата меньше нуля или больше двух.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <param name="arg2">Третий объект для форматирования.</param>
        <summary>Заменяет элементы формата в строке строковым представлением трех указанных объектов. Параметр предоставляет сведения об особенностях форматирования, связанных с языком и региональными параметрами.</summary>
        <returns>Копия <paramref name="format" />, в которой все элементы формата заменены строковыми представлениями <paramref name="arg0" />, <paramref name="arg1" /> и <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования трех выражений в их строковые представления и встраивания этих представлений в строку. При выполнении преобразования метод использует форматирование с учетом языка и региональных параметров или пользовательский модуль форматирования. Метод преобразует каждый аргумент <xref:System.Object> в строковое представление путем вызова его метода **ToString (IFormatProvider)** или, если соответствующий элемент форматирования объекта включает строку формата, вызывая его **ToString (String, IFormatProvider).** метод. Если эти методы не существуют, вызывается метод **ToString** без параметров объекта.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
- или - 
Индекс элемента формата меньше нуля или больше двух.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает объект, который может выполнять итерацию отдельных знаков данной строки.</summary>
        <returns>Объект перечислителя.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> Вместо вызова метода <xref:System.String.GetEnumerator%2A> для получения объекта <xref:System.CharEnumerator>, который затем используется для перечисления строки, следует использовать конструкцию итерации языка (в C#, в C++/CLR и в Visual Basic). [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) в C#, [for each](/cpp/dotnet/for-each-in) в C++/CLR, и [для каждого](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) в Visual Basic).
  
 Этот метод позволяет выполнять итерацию отдельных символов в строке. Например, операторы Visual Basic `For Each` и C# `foreach` вызывают этот метод, чтобы получить объект <xref:System.CharEnumerator>, который может предоставлять доступ только для чтения к символам в этом экземпляре строки.  
  
   
  
## Examples  
 В следующем примере выполняется перебор символов в нескольких строках и отображаются сведения об их отдельных символах. Он использует конструкцию итерации языка вместо вызова метода <xref:System.String.GetEnumerator%2A>.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для этой строки.</summary>
        <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поведение <xref:System.String.GetHashCode%2A> зависит от его реализации, которая может изменяться от одной версии среды CLR к другой. Причина этого может быть в том, чтобы повысить производительность <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Если два строковых объекта равны, метод <xref:System.String.GetHashCode%2A> возвращает идентичные значения. Однако не существует уникального значения хэш-кода для каждого уникального строкового значения. Различные строки могут возвращать один и тот же хэш-код.  
>   
>  Сам хэш-код не гарантирует стабильность. Хэш-коды одинаковых строк могут различаться в разных реализациях .NET, в разных версиях .NET и на платформах .NET (например, 32-и 64-бит) для одной версии .NET. В некоторых случаях они могут даже различаться в домене приложения. Это означает, что два последующих запуска одной программы могут возвращать разные хэш-коды.  
>   
>  В результате хэш-коды никогда не следует использовать за пределами домена приложения, в котором они были созданы, они никогда не должны использоваться в качестве ключевых полей в коллекции и никогда не должны сохраняться.  
>   
>  Наконец, не используйте хэш-код вместо значения, возвращаемого криптографической функцией хэширования, если требуется криптографически надежный хэш. Для криптографических хэшей используйте класс, производный от класса <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> или <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>.  
>   
>  Дополнительные сведения о хэш-кодах см. в разделе <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 В классических приложениях можно использовать [элемент\<UseRandomizedStringHashAlgorithm >](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) для создания уникальных хэш-кодов для каждого домена приложения. Это может уменьшить количество конфликтов и повысить общую производительность вставок и поисков, использующих хэш-таблицы. В следующем примере показано, как использовать [элемент\<UseRandomizedStringHashAlgorithm >](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Он определяет класс `DisplayString`, содержащий закрытую строковую константу, `s`, значением которой является строка. Он также включает метод `ShowStringHashCode`, который отображает значение строки и ее хэш-код вместе с именем домена приложения, в котором метод выполняется.
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 При выполнении примера без указания файла конфигурации он отображает подобный следующему вывод. Обратите внимание, что хэш-коды для строки идентичны в обоих доменах приложений.  
  
```
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC
```  
  
 Однако при добавлении следующего файла конфигурации в каталог примеров и запуске примера, хэш-коды для той же строки будут отличаться по домену приложения.  
  
```xml
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>
```  
  
 Если файл конфигурации существует, пример отображает следующие выходные данные:  
  
```  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D
String 'This is a string.' in domain 'NewDomain': 75CC8236
```  
  
> [!IMPORTANT]
>  Хэш-коды используются для эффективного вставки и получения объектов с ключом из хэш-таблиц. Однако хэш-коды не однозначно идентифицируют строки. Идентичные строки имеют одинаковые хэш-коды, но среда CLR может также назначать один и тот же хэш-код разным строкам. Кроме того, хэш-коды могут различаться в зависимости от версии .NET, платформой в пределах одной версии и домена приложения. Поэтому не следует выполнять сериализацию или сохранять значения хэш-кода, а также использовать их в качестве ключей в хэш-таблице или словаре.  
  
 Дополнительные сведения об использовании хэш-кодов и метода `GetHashCode` см. в разделе <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.GetHashCode%2A> с использованием различных входных строк.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Значение, возвращаемое <see cref="M:System.String.GetHashCode" />, зависит от платформы. Он отличается от 32-разрядных и 64-разрядных версий .NET Framework. Он также может отличаться в разных версиях .NET Framework и .NET Core.</para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; элемент</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Диапазон символов только для чтения.</param>
        <summary>Возвращает хэш-код для предоставленного диапазона символов, доступного только для чтения.</summary>
        <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="comparisonType">Одно из значений перечисления, определяющее используемые при сравнении правила.</param>
        <summary>Возвращает хэш-код для этой строки, используя указанные правила.</summary>
        <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Диапазон символов только для чтения.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее используемые при сравнении правила.</param>
        <summary>Возвращает хэш-код для предоставленного диапазона символов, доступного только для чтения, используя указанные правила.</summary>
        <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref readonly char GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; char ^ GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; char" Usage="string.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Char</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="netcore-3.0">
            <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ссылку на элемент строки при нулевом индексе.</summary>
        <returns>Символ, представляющий ссылку на элемент строки при нулевом индексе.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Метод `GetPinnableReference` возвращает символ, который можно использовать для закрепления <xref:System.String> в памяти. Он должен поддерживать использование <xref:System.String> в фиксированном операторе.

          ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Строка пуста.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.TypeCode" /> для класса <see cref="T:System.String" />.</summary>
        <returns>Константа перечислимого типа, <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере отображается константа перечисления <xref:System.TypeCode> для типа <xref:System.String>.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанного символа Юникода или строки в пределах данного экземпляра. Метод возвращает -1, если знак или строка не найдена в данном экземпляре.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Искомый знак Юникода.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанного символа Юникода в данной строке.</summary>
        <returns>Отсчитываемое от нуля значение индекса параметра <paramref name="value" />, если этот знак найден; в противном случае — значение -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля.  
  
 Этот метод выполняет поиск по порядковому номеру (без учета языка и региональных параметров), где символ считается эквивалентным другому символу, только если их скалярные значения в Юникоде одинаковы. Чтобы выполнить поиск с учетом языка и региональных параметров, используйте метод <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, где скалярное значение Юникода, представляющее составной символ, например лигатура "Æ" (U + 00C6), может считаться эквивалентным любому вхождению компонентов символа в правильном последовательность, например "AE" (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере показано, как можно выполнить поиск символа в <xref:System.String> с помощью метода <xref:System.String.IndexOf%2A>.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения значения указанной строки в данном экземпляре.</summary>
        <returns>Положение в индексе (начиная с нуля) параметра <paramref name="value" />, если эта строка найдена, или значение -1, если она не найдена. Если значение <paramref name="value" /> равно <see cref="F:System.String.Empty" />, то возвращаемое значение равно 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля.  
  
 Этот метод выполняет поиск по словам (с учетом регистра и с учетом языка и региональных параметров), используя текущий язык и региональные параметры. Поиск начинается с позиции первого символа данного экземпляра и продолжается до последней позиции символа.  
  
 Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров параметр `value` содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если `value` состоит только из одного или нескольких игнорируемых символов, метод <xref:System.String.IndexOf%28System.String%29> всегда возвращает 0 (нуль), чтобы указать, что соответствие обнаружено в начале текущего экземпляра. В следующем примере метод <xref:System.String.IndexOf%28System.String%29> используется для поиска трех подстрок (мягкий дефис (U + 00AD), мягкий дефис, за которым следует "n", и мягкий дефис, за которым следует "m") в двух строках. Только одна из строк содержит мягкий перенос. Если пример выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в каждом случае, поскольку мягкий дефис является проигнорированным символом, результат будет таким же, как если бы мягкий перенос не включался в `value`. При поиске только мягкого дефиса метод возвращает 0 (ноль), чтобы указать, что обнаружено совпадение в начале строки.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 В следующем примере выполняется поиск "n" в "Animal". Поскольку индексы строк начинаются с нуля, а не из одного, метод <xref:System.String.IndexOf%28System.String%29> указывает, что "n" находится в позиции 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 В следующем примере метод <xref:System.String.IndexOf%2A> используется для определения начальной положения имени животного в предложении. Затем она использует эту точку для вставки прилагательного, описывающего животное в предложение.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Как описано в статье рекомендации [по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию, а вызывают методы, для которых требуется явно указать параметры. Чтобы найти первый индекс подстроки в экземпляре строки с помощью правил сравнения текущего языка и региональных параметров, вызовите перегрузку метода <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его параметра `comparisonType`.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Искомый знак Юникода.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанного символа Юникода в данной строке. Поиск начинается с указанной позиции знака.</summary>
        <returns>Отсчитываемая от нуля позиция индекса параметра <paramref name="value" /> с начала строки, если символ найден. Значение –1, если символ не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с 0. Параметр `startIndex` может иметь значение в диапазоне от 0 до длины экземпляра строки. Если `startIndex` равно длине экземпляра строки, метод возвращает значение-1.  
  
 Поиск в диапазоне от `startIndex` до конца строки.  
  
 Этот метод выполняет поиск по порядковому номеру (без учета языка и региональных параметров), где символ считается эквивалентным другому символу, только если их скалярные значения в Юникоде одинаковы. Чтобы выполнить поиск с учетом языка и региональных параметров, используйте метод <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, где скалярное значение Юникода, представляющее составной символ, например лигатура "Æ" (U + 00C6), может считаться эквивалентным любому вхождению компонентов символа в правильном последовательность, например "AE" (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.IndexOf%2A>.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> имеет значение меньше нуля или больше длины строки.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Символ для поиска.</param>
        <param name="comparisonType">Значение перечисления, определяющее правила поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанного символа Юникода в данной строке. Параметр определяет тип поиска заданного символа.</summary>
        <returns>Отсчитываемое от нуля значение индекса параметра <paramref name="value" />, если этот знак найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Нумерация индексов начинается с нуля.  
  
Параметр `comparisonType` является членом перечисления <xref:System.StringComparison>, который определяет, использует ли поиск аргумента `value` текущий или инвариантный язык и региональные параметры, учитывает регистр или не учитывает регистр либо использует правила сравнения по словам или порядковому номеру.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения значения указанной строки в данном экземпляре. Поиск начинается с указанной позиции знака.</summary>
        <returns>Отсчитываемая от нуля позиция индекса параметра <paramref name="value" /> с начала текущего экземпляра, если строка найдена. Значение –1, если строка не найдена. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с 0. Параметр `startIndex` может иметь значение в диапазоне от 0 до длины экземпляра строки. Если `startIndex` равно длине экземпляра строки, метод возвращает значение-1.  
  
 Этот метод выполняет поиск по словам (с учетом регистра и с учетом языка и региональных параметров), используя текущий язык и региональные параметры. Поиск начинается с `startIndex` позиции символа этого экземпляра и продолжается до последней позиции символа.  
  
 Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров параметр `value` содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если `value` состоит только из одного или нескольких игнорируемых символов, метод <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> всегда возвращает `startIndex`, то есть позиции символа, с которой начинается поиск. В следующем примере метод <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> используется для поиска расположения мягкого дефиса (U + 00AD), за которым следует символ "m" в двух строках. Только одна из строк содержит требуемую подстроку. Если пример выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий дефис является игнорируемым символом, метод возвращает индекс "m" в строке. Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m".  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 В следующем примере выполняется поиск всех вхождений указанной строки в целевой строке.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> имеет значение меньше нуля или больше длины этой строки.</exception>
        <block subset="none" type="usage"><para>Как описано в статье рекомендации [по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию, а вызывают методы, для которых требуется явно указать параметры. Чтобы найти первый индекс подстроки, которая происходит после определенной позиции символа, используя правила сравнения текущего языка и региональных параметров, вызовите перегрузку метода <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />, указав значение <see cref="F:System.StringComparison.CurrentCulture" /> для его параметра `comparisonType`.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанной строки в текущем объекте <see cref="T:System.String" />. Параметр определяет тип поиска заданной строки.</summary>
        <returns>Индекс позиции строки, заданной в параметре <paramref name="value" />, если она найдена, и -1, если нет. Если значение <paramref name="value" /> равно <see cref="F:System.String.Empty" />, то возвращаемое значение равно 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля.  
  
 Параметр `comparisonType` задает поиск параметра `value` с использованием текущего или инвариантного языка и региональных параметров, с учетом регистра или без учета регистра, а также с использованием правил сравнения по словам или порядковому номеру.  
  
   
  
## Examples  
 В следующем примере показаны три перегрузки метода <xref:System.String.IndexOf%2A>, которые находят первое вхождение строки в другой строке, используя различные значения перечисления <xref:System.StringComparison>.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров (то есть, если параметр <paramref name="comparisonType" /> не имеет значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) параметр <paramref name="value" /> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если <paramref name="value" /> состоит только из одного или нескольких игнорируемых символов, метод <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> всегда возвращает 0 (нуль), чтобы указать, что соответствие обнаружено в начале текущего экземпляра.  
  
В следующем примере метод <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> используется для поиска трех подстрок (мягкий дефис (U + 00AD), мягкий дефис, за которым следует "n", и мягкий дефис, за которым следует "m") в двух строках. Только одна из строк содержит мягкий перенос. Если пример выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, поскольку мягкий дефис является игнорируемым символом, поиск с учетом языка и региональных параметров возвращает то же значение, которое возвращается, если мягкий перенос не был включен в строку поиска. Однако порядковый поиск по порядковому номеру успешно находит мягкий дефис в одной строке и сообщает, что он отсутствует во второй строке.  
  
[!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Искомый знак Юникода.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанного символа в данном экземпляре. Поиск начинается с указанной позиции знака; проверяется заданное количество позиций.</summary>
        <returns>Отсчитываемая от нуля позиция индекса параметра <paramref name="value" /> с начала строки, если символ найден. Значение –1, если символ не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск начинается с `startIndex` и продолжается `startIndex` + `count`-1. Символ в `startIndex` + `count` не включается в поиск.  
  
 Нумерация индексов начинается с 0 (нуля). Параметр `startIndex` может иметь значение в диапазоне от 0 до длины экземпляра строки.  
  
 Этот метод выполняет поиск по порядковому номеру (без учета языка и региональных параметров), где символ считается эквивалентным другому символу, только если их скалярные значения в Юникоде одинаковы. Чтобы выполнить поиск с учетом языка и региональных параметров, используйте метод <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, где скалярное значение Юникода, представляющее составной символ, например лигатура "Æ" (U + 00C6), может считаться эквивалентным любому вхождению компонентов символа в правильном последовательность, например "AE" (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.IndexOf%2A>.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> или <paramref name="startIndex" /> является отрицательным значением.  
  
- или - 
 <paramref name="startIndex" /> больше длины этой строки.  
  
- или - 
 <paramref name="count" /> больше, чем длина этой строки минус <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения значения указанной строки в данном экземпляре. Поиск начинается с указанной позиции знака; проверяется заданное количество позиций.</summary>
        <returns>Отсчитываемая от нуля позиция индекса параметра <paramref name="value" /> с начала текущего экземпляра, если строка найдена. Значение –1, если строка не найдена. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с 0 (нуля). Параметр `startIndex` может иметь значение в диапазоне от 0 до длины экземпляра строки.  
  
 Этот метод выполняет поиск по словам (с учетом регистра и с учетом языка и региональных параметров), используя текущий язык и региональные параметры. Поиск начинается с `startIndex` и продолжается `startIndex` + `count`-1. Символ в `startIndex` + `count` не включается в поиск.  
  
 Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров параметр `value` содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если `value` состоит только из одного или нескольких игнорируемых символов, метод <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> всегда возвращает `startIndex`, то есть позиции символа, с которой начинается поиск. В следующем примере метод <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> используется для поиска позиции мягкого дефиса (U + 00AD), за которым следует символ "m", начиная с третьего по шестой позиции символа в двух строках. Только одна из строк содержит требуемую подстроку. Если пример выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий дефис является игнорируемым символом, метод возвращает индекс "m" в строке, когда он выполняет сравнение с учетом языка и региональных параметров. Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m".  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 В следующем примере выполняется поиск индекса всех вхождений строки "he" в подстроке другой строки. Обратите внимание, что количество символов для поиска должно быть пересчитано для каждой итерации.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> или <paramref name="startIndex" /> является отрицательным значением.  
  
- или - 
 <paramref name="startIndex" /> больше длины этой строки.  
  
- или - 
 <paramref name="count" /> больше, чем длина этой строки минус <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage"><para>Как описано в статье рекомендации [по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию, а вызывают методы, для которых требуется явно указать параметры. Чтобы использовать правила сравнения текущего языка и региональных параметров для выполнения этой операции, вызовите перегрузку метода <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его параметра `comparisonType`.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанной строки в текущем объекте <see cref="T:System.String" />. Параметры задают начальную позицию поиска в текущей строке и тип поиска.</summary>
        <returns>Отсчитываемая от нуля позиция параметра <paramref name="value" /> с начала текущего экземпляра, если строка найдена, или -1, если нет. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с 0. Параметр `startIndex` может иметь значение в диапазоне от 0 до длины экземпляра строки. Если `startIndex` равно длине экземпляра строки, метод возвращает значение-1.  
  
 Параметр `comparisonType` задает поиск параметра `value` с использованием текущего или инвариантного языка и региональных параметров, с учетом регистра или без учета регистра, а также с использованием правил сравнения по словам или порядковому номеру.  
  
   
  
## Examples  
 В следующем примере показаны три перегрузки метода <xref:System.String.IndexOf%2A>, которые находят первое вхождение строки в другой строке, используя различные значения перечисления <xref:System.StringComparison>.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> имеет значение меньше нуля или больше длины этой строки.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров (то есть, если параметр <paramref name="comparisonType" /> не имеет значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) параметр <paramref name="value" /> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если <paramref name="value" /> состоит только из одного или нескольких игнорируемых символов, метод <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> всегда возвращает <paramref name="startIndex" />, то есть позиции символа, с которой начинается поиск.  
  
В следующем примере метод <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> используется для поиска позиции мягкого дефиса (U + 00AD), за которым следует символ "m", начиная с третьего положения символа в двух строках. Только одна из строк содержит необходимую подстроку. Если пример выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий дефис является игнорируемым символом, метод возвращает индекс "m" в строке, когда он выполняет сравнение с учетом языка и региональных параметров. Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m". Этот метод возвращает индекс мягкого переноса в первой строке только при выполнении порядкового сравнения.  
  
[!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанной строки в текущем объекте <see cref="T:System.String" />. Параметры задают начальную позицию поиска в текущей строке, количество проверяемых знаков текущей строки и тип поиска.</summary>
        <returns>Отсчитываемая от нуля позиция параметра <paramref name="value" /> с начала текущего экземпляра, если строка найдена, или -1, если нет. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с 0 (нуля). Параметр `startIndex` может иметь значение в диапазоне от 0 до длины экземпляра строки.  
  
 Поиск начинается с `startIndex` и продолжается `startIndex` + `count`-1. Символ в `startIndex` + `count` не включается в поиск.  
  
 Параметр `comparisonType` задает поиск параметра `value` с использованием текущего или инвариантного языка и региональных параметров, с учетом регистра или без учета регистра, а также с использованием правил сравнения по словам или порядковому номеру.  
  
   
  
## Examples  
 В следующем примере показаны три перегрузки метода <xref:System.String.IndexOf%2A>, которые находят первое вхождение строки в другой строке, используя различные значения перечисления <xref:System.StringComparison>.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> или <paramref name="startIndex" /> является отрицательным значением.  
  
- или - 
 <paramref name="startIndex" /> больше длины этого экземпляра.  
  
- или - 
 <paramref name="count" /> больше, чем длина этой строки минус <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров (то есть, если параметр <paramref name="comparisonType" /> не имеет значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) параметр <paramref name="value" /> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если <paramref name="value" /> состоит только из одного или нескольких игнорируемых символов, метод <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> всегда возвращает <paramref name="startIndex" />, то есть позиции символа, с которой начинается поиск.  
  
В следующем примере метод <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> используется для поиска позиции мягкого дефиса (U + 00AD), за которым следует символ "m", начиная с третьего по шестой позиции символа в двух строках. Только одна из строк содержит требуемую подстроку. Если пример выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий дефис является игнорируемым символом, метод возвращает индекс "m" в строке, когда он выполняет сравнение с учетом языка и региональных параметров. Однако при выполнении порядкового сравнения он находит подстроку только в первой строке. Обратите внимание, что в случае первой строки, которая включает мягкий дефис, за которым следует символ "m", метод не возвращает индекс мягкого дефиса, а вместо этого возвращает индекс "m", когда он выполняет сравнение с учетом языка и региональных параметров. Этот метод возвращает индекс мягкого переноса в первой строке только при выполнении порядкового сравнения.  
  
[!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает индекс первого обнаруженного в данном экземпляре знака из указанного массива знаков Юникода. Метод возвращает -1, если знаки массива не найдены в этом экземпляре.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Массив знаков Юникода, содержащий один или несколько искомых знаков.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого обнаруженного в данном экземпляре символа из указанного массива символов Юникода.</summary>
        <returns>Начинающееся с нуля значение индекса первого вхождения какого-либо знака из <paramref name="anyOf" /> в данном экземпляре; -1, если не найден ни один знак из <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля.  
  
 При поиске `anyOf` учитывается регистр. Если `anyOf` является пустым массивом, метод находит совпадение в начале строки (то есть в нулевом индексе).  
  
 Этот метод выполняет поиск по порядковому номеру (без учета языка и региональных параметров), где символ считается эквивалентным другому символу, только если их скалярные значения в Юникоде одинаковы. Чтобы выполнить поиск с учетом языка и региональных параметров, используйте метод <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, где скалярное значение Юникода, представляющее составной символ, например лигатура "Æ" (U + 00C6), может считаться эквивалентным любому вхождению компонентов символа в правильном последовательность, например "AE" (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере выполняется поиск первого гласного в строке.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="anyOf" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Массив знаков Юникода, содержащий один или несколько искомых знаков.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого обнаруженного в данном экземпляре символа из указанного массива символов Юникода. Поиск начинается с указанной позиции знака.</summary>
        <returns>Начинающееся с нуля значение индекса первого вхождения какого-либо знака из <paramref name="anyOf" /> в данном экземпляре; -1, если не найден ни один знак из <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля. Параметр `startIndex` может находиться в диапазоне от 0 до значения, меньшего, чем длина экземпляра строки.  
  
 Поиск в диапазоне от `startIndex` до конца строки.  
  
 При поиске `anyOf` учитывается регистр.  
  
 Этот метод выполняет поиск по порядковому номеру (без учета языка и региональных параметров), где символ считается эквивалентным другому символу, только если их скалярное значение в Юникоде одинаково. Чтобы выполнить поиск с учетом языка и региональных параметров, используйте метод <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, где скалярное значение Юникода, представляющее составной символ, например лигатура "Æ" (U + 00C6), может считаться эквивалентным любому вхождению компонентов символа в правильном последовательность, например "AE" (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере выполняется поиск индекса вхождения любого символа строки "имеет" в подстроке другой строки.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> является отрицательным значением.  
  
- или - 
 <paramref name="startIndex" /> больше, чем количество символов в данном экземпляре.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Массив знаков Юникода, содержащий один или несколько искомых знаков.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого обнаруженного в данном экземпляре символа из указанного массива символов Юникода. Поиск начинается с указанной позиции знака; проверяется заданное количество позиций.</summary>
        <returns>Начинающееся с нуля значение индекса первого вхождения какого-либо знака из <paramref name="anyOf" /> в данном экземпляре; -1, если не найден ни один знак из <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск начинается с `startIndex` и продолжается `startIndex` + `count`-1. Символ в `startIndex` + `count` не включается в поиск.  
  
 Нумерация индексов начинается с нуля. Параметр `startIndex` может находиться в диапазоне от 0 до значения, меньшего, чем длина экземпляра строки.  
  
 При поиске `anyOf` учитывается регистр.  
  
 Этот метод выполняет поиск по порядковому номеру (без учета языка и региональных параметров), где символ считается эквивалентным другому символу, только если их скалярное значение в Юникоде одинаково. Чтобы выполнить поиск с учетом языка и региональных параметров, используйте метод <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, где скалярное значение Юникода, представляющее составной символ, например лигатура "Æ" (U + 00C6), может считаться эквивалентным любому вхождению компонентов символа в правильном последовательность, например "AE" (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере выполняется поиск индекса вхождения любого символа строки "вспомогательные" в подстроке другой строки.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="anyOf" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> или <paramref name="startIndex" /> является отрицательным значением.  
  
- или - 
 <paramref name="count" /> + <paramref name="startIndex" /> больше, чем количество символов в этом экземпляре.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">Положение отсчитываемого от нуля индекса вставки.</param>
        <param name="value">Строка, которую требуется вставить.</param>
        <summary>Возвращает новую строку, в которой указанная строка вставляется в указанной позиции индекса в данном экземпляре.</summary>
        <returns>Новая строка, эквивалентная данному экземпляру, но с тем отличием, что в положение <paramref name="value" /> помещено значение <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `startIndex` равен длине этого экземпляра, `value` добавляется в конец этого экземпляра.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой `value` вставляется в текущий экземпляр.  
  
 Например, возвращаемое значение `"abc".Insert(2, "XYZ")` — «Абксизк».  
  
   
  
## Examples  
 В следующем примере вставляется символ пробела в четвертой позиции символа (символ с индексом 3) строки.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 Следующее консольное приложение предлагает пользователям ввести одно или несколько прилагательных для описания двух животных. Затем он вызывает метод <xref:System.String.Insert%2A> для вставки текста, введенного пользователем, в строку.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> имеет отрицательное значение или больше длины этого экземпляра.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Строка для поиска в пуле интернирования.</param>
        <summary>Извлекает системную ссылку на указанный объект <see cref="T:System.String" />.</summary>
        <returns>Системная ссылка на значение <paramref name="str" />, если оно уже интернировано; в противном случае возвращается новая ссылка на строку со значением <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда CLR сохраняет хранилище строк, сохраняя таблицу, называемую пулом интернирования, которая содержит одну ссылку на каждую уникальную строку литерала, объявленную или созданную программно в программе. Следовательно, экземпляр литеральной строки с определенным значением встречается только один раз в системе.  
  
 Например, если присвоить одну и ту же строку литерала нескольким переменным, среда выполнения извлекает одну и ту же ссылку на литеральную строку из пула интернирования и назначает ее каждой переменной.  
  
 Метод <xref:System.String.Intern%2A> использует пул интернирования для поиска строки, равной значению `str`. Если такая строка существует, возвращается ее ссылка в пуле интернирования. Если строка не существует, в пул интернирования добавляется ссылка на `str`, а затем возвращается ссылка.  
  
 В следующем примере строка s1, имеющая значение "MyTest", уже интернирована, так как это литерал в программе. Класс <xref:System.Text.StringBuilder?displayProperty=nameWithType> создает новый строковый объект, имеющий то же значение, что и S1. Ссылка на эту строку присваивается S2. Метод <xref:System.String.Intern%2A> выполняет поиск строки, имеющей то же значение, что и S2. Так как такая строка существует, метод возвращает ту же ссылку, которая назначена S1. Затем эта ссылка назначается S3. Ссылки S1 и S2 не равны, так как они ссылаются на разные объекты. ссылается на равенство S1 и S3, так как они ссылаются на одну и ту же строку.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Сравните этот метод с методом <xref:System.String.IsInterned%2A>.  
  
## <a name="version-considerations"></a>Рекомендации по версиям  
 В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]метод <xref:System.String.Intern%2A> возвращается к его поведению в .NET Framework 1,0 и 1,1 в отношении изоляции пустой строки. В следующем примере переменной `str1` присваивается ссылка на <xref:System.String.Empty?displayProperty=nameWithtype>, а переменной `str2` присваивается ссылка на <xref:System.String.Empty?displayProperty=nameWithtype>, которая возвращается путем вызова метода <xref:System.String.Intern%2A> после преобразования <xref:System.Text.StringBuilder> объекта, значение которого <xref:System.String.Empty?displayProperty=nameWithtype> строке. Затем ссылки, содержащиеся в `str1` и `str2`, сравниваются на равенство.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 В [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]и [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` и `str2` равны. В [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] и [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]`str1` и `str2` не равны.  
  
## <a name="performance-considerations"></a>Особенности производительности  
 Если вы пытаетесь уменьшить общий объем памяти, выделяемой для приложения, помните, что интернирование строки имеет два нежелательных побочных эффекта. Во-первых, память, выделенная для интернированных <xref:System.String> объектов, скорее всего, не будет освобождена до тех пор, пока не завершится работа среды CLR. Причина в том, что ссылка CLR на интернированный <xref:System.String> объект может сохраняться после завершения приложения или даже домена приложения. Во-вторых, для интернирования строки необходимо сначала создать строку. Память, используемая объектом <xref:System.String>, по-прежнему должна быть выделена, даже несмотря на то, что память в конечном итоге будет собираться сборщиком мусора.  
  
 В .NET Framework версии 2,0 появился элемент перечисления <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType>. Элемент <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> помечает сборку как не требует интернирования строкового литерала. К сборке можно применить <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> с помощью атрибута <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute>. Кроме того, при использовании [Ngen. exe (генератора образов в машинном кодах)](~/docs/framework/tools/ngen-exe-native-image-generator.md) для компиляции сборки в режиме предварительного выполнения строки не выдаются между модулями.  
  
   
  
## Examples  
 В следующем примере используются три строки, равные значению, чтобы определить, равны ли вновь созданная строка и интернированная строка.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="str" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Строка для поиска в пуле интернирования.</param>
        <summary>Извлекает ссылку на указанный объект <see cref="T:System.String" />.</summary>
        <returns>Ссылка на значение <paramref name="str" />, если оно находится в пуле интернирования среды CLR; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда CLR автоматически поддерживает таблицу, называемую пулом интернирования, которая содержит единственный экземпляр каждой уникальной строковой константы литерала, объявленной в программе, а также любой уникальный экземпляр <xref:System.String>, который добавляется программно путем вызова метода <xref:System.String.Intern%2A>.  
  
 Пул интернирования экономит хранилище строк. Если литеральная строковая константа присваивается нескольким переменным, каждая переменная задается как ссылка на одну и ту же константу в пуле интернирования, а не на несколько разных экземпляров <xref:System.String>, имеющих одинаковые значения.  
  
 Этот метод ищет `str` в пуле интернирования. Если `str` уже был интернирован, возвращается ссылка на этот экземпляр. в противном случае возвращается `null`.  
  
 Сравните этот метод с методом <xref:System.String.Intern%2A>.  
  
 Этот метод не возвращает логическое значение. При вызове метода, так как требуется логическое значение, указывающее, является ли конкретная строка интернированной, можно использовать следующий код.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  Начиная с версии .NET Framework 2,0, можно переопределить использование пула интернирования при использовании [Ngen. exe (генератор образов в машинном кодах)](~/docs/framework/tools/ngen-exe-native-image-generator.md) для установки сборки в кэш образов в машинном кодах на локальном компьютере. Дополнительные сведения см. в разделе рекомендации по повышению производительности раздела "Примечания" для свойства <xref:System.String.Intern%2A>.  
  
   
  
## Examples  
 В следующем примере показано, что строки литерала автоматически интернированы компилятором.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="str" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Указывает, находится ли данная строка в определенной форме нормализации Юникода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Указывает, находится ли данная строка в форме нормализации Юникода C.</summary>
        <returns><see langword="true" />, если данная строка находится в форме нормализации Юникода C; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые символы Юникода имеют несколько эквивалентных двоичных представлений, состоящих из наборов комбинированных и/или составных символов Юникода. Наличие нескольких представлений для одного символа усложняет поиск, сортировку, сопоставление и другие операции.  
  
 Стандарт Unicode определяет процесс, называемый нормализацией, который возвращает одно двоичное представление при наличии любого из эквивалентных двоичных представлений символа. Нормализацию можно выполнить с помощью нескольких алгоритмов, называемых формами нормализации, которые подчиняются различным правилам. В настоящее время .NET поддерживает формы нормализации C, D, KC и KD.  
  
 Описание поддерживаемых форм нормализации Юникода см. в разделе <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере определяется, является ли строка успешно нормализованной для различных форм нормализации.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий экземпляр содержит недопустимые символы Юникода.</exception>
        <block subset="none" type="usage"><para>Метод <see cref="Overload:System.String.IsNormalized" /> возвращает <see langword="false" /> сразу же после того, как он встречает первый Ненормализованный символ в строке. Таким образом, если строка содержит ненормализованные символы, за которыми следуют недопустимые символы Юникода, метод <see cref="Overload:System.String.Normalize" /> выдаст исключение <see cref="T:System.ArgumentException" /> хотя <see cref="Overload:System.String.IsNormalized" /> возвращает <see langword="false" />.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Форма нормализации Юникода.</param>
        <summary>Указывает, находится ли данная строка в заданной форме нормализации Юникода.</summary>
        <returns><see langword="true" />, если строка находится в форме нормализации, указанной в параметре <paramref name="normalizationForm" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые символы Юникода имеют несколько эквивалентных двоичных представлений, состоящих из наборов комбинированных и/или составных символов Юникода. Наличие нескольких представлений для одного символа усложняет поиск, сортировку, сопоставление и другие операции.  
  
 Стандарт Unicode определяет процесс, называемый нормализацией, который возвращает одно двоичное представление при наличии любого из эквивалентных двоичных представлений символа. Нормализацию можно выполнить с помощью нескольких алгоритмов, называемых формами нормализации, которые подчиняются различным правилам. В настоящее время .NET поддерживает формы нормализации C, D, KC и KD.  
  
 Описание поддерживаемых форм нормализации Юникода см. в разделе <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируются методы <xref:System.String.IsNormalized%2A> и <xref:System.String.Normalize%2A>.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий экземпляр содержит недопустимые символы Юникода.</exception>
        <block subset="none" type="usage"><para>Метод <see cref="Overload:System.String.IsNormalized" /> возвращает <see langword="false" /> сразу же после того, как он встречает первый Ненормализованный символ в строке. Таким образом, если строка содержит ненормализованные символы, за которыми следуют недопустимые символы Юникода, метод <see cref="Overload:System.String.Normalize" /> выдаст исключение <see cref="T:System.ArgumentException" /> хотя <see cref="Overload:System.String.IsNormalized" /> возвращает <see langword="false" />.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для проверки.</param>
        <summary>Указывает, действительно ли указанная строка является строкой <see langword="null" /> или пустой строкой ("").</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> равен <see langword="null" /> или пустой строке (""); в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> — это удобный метод, позволяющий одновременно проверить, является ли <xref:System.String> `null` или его значение <xref:System.String.Empty?displayProperty=nameWithType>. Он эквивалентен следующему коду:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Можно использовать метод <xref:System.String.IsNullOrWhiteSpace%2A>, чтобы проверить, является ли строка `null`ой, ее значением <xref:System.String.Empty?displayProperty=nameWithType>или она состоит только из пробельных символов.  
  
## <a name="what-is-a-null-string"></a>Что такое строка со значением NULL?

Строка `null`, если ей не было присвоено значение (в C++ и Visual Basic) или если ей явно присвоено значение `null`. Хотя функция [составного форматирования](~/docs/standard/base-types/composite-formatting.md) может корректно обработать строку со значением NULL, как показано в следующем примере, при попытке вызвать метод, если его члены создают <xref:System.NullReferenceException>.  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>Что такое пустая строка?  

Строка пуста, если ей явно присваивается пустая строка ("") или <xref:System.String.Empty?displayProperty=nameWithType>. Пустая строка имеет <xref:System.String.Length%2A> 0.  В следующем примере создается пустая строка и отображается ее значение и длина.  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 В следующем примере изучаются три строки и определяется, имеет ли каждая строка значение, является пустой строкой или `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для проверки.</param>
        <summary>Указывает, имеет ли указанная строка значение <see langword="null" />, является ли она пустой строкой или строкой, состоящей только из символов-разделителей.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> имеет значение <see langword="null" /> или <see cref="F:System.String.Empty" />, либо если параметр <paramref name="value" /> содержит только символы-разделители.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> — это удобный метод, похожий на следующий код, за исключением того, что он обеспечивает высокую производительность:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Пробельные символы определяются стандартом Юникода. Метод <xref:System.String.IsNullOrWhiteSpace%2A> интерпретирует любой символ, возвращающий значение `true`, при передаче в метод <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> в виде символа пробела.  
  
   
  
## Examples  
 В следующем примере создается массив строк, а затем каждый элемент массива передается в метод <xref:System.String.IsNullOrWhiteSpace%2A>.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сцепляет элементы указанного массива или элементы коллекции, помещая между ними заданный разделитель.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Символ для использования в качестве разделителя. <paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="value" /> более одного элемента.</param>
        <param name="values">Массив объектов, строковые представления которых будут сцеплены.</param>
        <summary>Сцепляет строковые представления объектов из массива, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из элементов <paramref name="values" />, разделяемых символом <paramref name="separator" />.

- или -

<see cref="F:System.String.Empty" />, если <paramref name="values" /> не содержит элементов или если все элементы <paramref name="values" /> равны <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Длина получившейся строки превышает максимально допустимую (<see cref="F:System.Int32.MaxValue" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Символ для использования в качестве разделителя. <paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="value" /> более одного элемента.</param>
        <param name="value">Массив сцепляемых строк.</param>
        <summary>Сцепляет строки из массива, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из элементов <paramref name="value" />, разделяемых символом <paramref name="separator" />.

- или -

<see cref="F:System.String.Empty" />, если <paramref name="value" /> не содержит элементов или если все элементы <paramref name="value" /> равны <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Длина получившейся строки превышает максимально допустимую (<see cref="F:System.Int32.MaxValue" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Строка для использования в качестве разделителя.<paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="values" /> более одного элемента.</param>
        <param name="values">Коллекция, содержащая сцепляемые строки.</param>
        <summary>Сцепляет элементы созданной коллекции <see cref="T:System.Collections.Generic.IEnumerable`1" /> типа <see cref="T:System.String" />, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из элементов <paramref name="values" />, разделяемых строками <paramref name="separator" />.

- или -

<see cref="F:System.String.Empty" />, если <paramref name="values" /> не содержит элементов или если все элементы <paramref name="values" /> равны <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `separator` `null`, вместо нее используется пустая строка (<xref:System.String.Empty?displayProperty=nameWithType>). Если какой-либо элемент `values` имеет `null`, вместо него используется пустая строка.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> — это удобный метод, позволяющий объединять каждый элемент в коллекции `IEnumerable(Of String)` без предварительного преобразования элементов в массив строк. Он особенно полезен в выражениях запросов LINQ. В следующем примере передается объект `List(Of String)`, содержащий прописные или строчные буквы алфавита, в лямбда-выражение, которое выбирает буквы, равные или превышающие определенную букву (в данном примере — «M»). Коллекция `IEnumerable(Of String)`, возвращаемая методом <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>, передается методу <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> для вывода результата в виде одной строки.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 В следующем примере используется Сиеве алгоритма Ератоссенес для вычисления простых чисел, которые меньше или равны 100. Он присваивает результат объекту <xref:System.Collections.Generic.List%601> типа <xref:System.String>, который затем передается методу <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="values" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Длина получившейся строки превышает максимально допустимую (<see cref="F:System.Int32.MaxValue" />).</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Строка для использования в качестве разделителя. <paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="values" /> более одного элемента.</param>
        <param name="values">Массив, содержащий элементы, которые требуется сцепить.</param>
        <summary>Сцепляет элементы массива объектов, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из элементов <paramref name="values" />, разделяемых строками <paramref name="separator" />. Если <paramref name="values" /> равен пустому массиву, метод возвращает значение <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `separator` является `null` или если какой-либо элемент `values`, кроме первого элемента, `null`, вместо него используется пустая строка (<xref:System.String.Empty?displayProperty=nameWithType>). Если первый элемент `values` `null`, см. раздел Примечания для вызывающих объектов.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> — это удобный метод, позволяющий объединять каждый элемент в массиве объектов без явного преобразования его элементов в строки. Строковое представление каждого объекта в массиве извлекается путем вызова метода `ToString` объекта.  
  
   
  
## Examples  
 В следующем примере используется Сиеве алгоритма Ератоссенес для вычисления простых чисел, которые меньше или равны 100. Он присваивает результат целочисленному массиву, который затем передается в метод <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="values" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Длина получившейся строки превышает максимально допустимую (<see cref="F:System.Int32.MaxValue" />).</exception>
        <block subset="none" type="usage"><para>Если первый элемент <paramref name="values" /> имеет <see langword="null" />, метод <see cref="M:System.String.Join(System.String,System.Object[])" /> не объединяет элементы в <paramref name="values" />, а вместо этого возвращает <see cref="F:System.String.Empty" />. Для этой проблемы доступно несколько решений. Проще всего присвоить значение <see cref="F:System.String.Empty" /> первому элементу массива, как показано в следующем примере.  
  
[! код-CSharp[System. String. Join # 6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! код-VB[System. String. Join # 6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String()) As String" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Строка для использования в качестве разделителя. <paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="value" /> более одного элемента.</param>
        <param name="value">Массив, содержащий элементы, которые требуется сцепить.</param>
        <summary>Сцепляет все элементы массива строк, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из элементов <paramref name="value" />, разделяемых строками <paramref name="separator" />. Если <paramref name="value" /> равен пустому массиву, метод возвращает значение <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например, если `separator` имеет значение ",", а элементы `value` — "Apple", "оранжевый", "виноград" и "груша", `Join(separator, value)` возвращает "Apple, оранжевый, виноград, груша".  
  
 Если `separator` `null`, вместо нее используется пустая строка (<xref:System.String.Empty?displayProperty=nameWithType>). Если какой-либо элемент в `value` имеет `null`, вместо него используется пустая строка.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.Join%2A>.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Длина получившейся строки превышает максимально допустимую (<see cref="F:System.Int32.MaxValue" />).</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">Сцепляет определенное количество строк из массива начиная с указанного индекса, помещая между ними заданный разделитель.</param>
        <param name="value">Массив сцепляемых строк.</param>
        <param name="startIndex">Первый сцепляемый элемент в <paramref name="value" />.</param>
        <param name="count">Количество сцепляемых элементов из <paramref name="value" /> начиная с элемента в позиции <paramref name="startIndex" />.</param>
        <summary>Сцепляет до <paramref name="count" /> строк из массива начиная с элемента из <paramref name="value" /> в позиции <paramref name="startIndex" />, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из элементов <paramref name="value" />, разделяемых символом <paramref name="separator" />.

- или -

<see cref="F:System.String.Empty" />, если параметр <paramref name="count" /> равен нулю, <paramref name="value" /> не содержит элементов или все элементы в <paramref name="value" /> равны <see langword="null" /> или <see cref="F:System.String.Empty" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startIndex" /> или <paramref name="count" /> имеет отрицательное значение.

- или -

Значение <paramref name="startIndex" /> превышает длину <paramref name="value" />  - <paramref name="count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Длина получившейся строки превышает максимально допустимую (<see cref="F:System.Int32.MaxValue" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Строка для использования в качестве разделителя. <paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="value" /> более одного элемента.</param>
        <param name="value">Массив, содержащий элементы, которые требуется сцепить.</param>
        <param name="startIndex">Первый используемый элемент массива <paramref name="value" />.</param>
        <param name="count">Число используемых элементов массива <paramref name="value" />.</param>
        <summary>Сцепляет указанные элементы массива строк, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из строк из параметра <paramref name="value" />, разделяемых строками <paramref name="separator" />.  
  
- или - 
 <see cref="F:System.String.Empty" />, если параметр <paramref name="count" /> равен нулю, параметр <paramref name="value" /> не содержит элементов или параметр <paramref name="separator" /> и все элементы параметра <paramref name="value" /> равны <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например, если `separator` имеет значение ",", а элементы `value` — "Apple", "оранжевый", "виноград" и "груша", `Join(separator, value, 1, 2)` возвращает "оранжевый, виноград".  
  
 Если `separator` `null`, вместо нее используется пустая строка (<xref:System.String.Empty?displayProperty=nameWithType>). Если какой-либо элемент в `value` имеет `null`, вместо него используется пустая строка.  
  
   
  
## Examples  
 В следующем примере объединяются два элемента из массива названий фруктов.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="count" /> меньше 0.

- или -

<paramref name="startIndex" /> плюс <paramref name="count" /> больше, чем число элементов в <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов параметра <paramref name="values" />.</typeparam>
        <param name="separator">Символ для использования в качестве разделителя. <paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="values" /> более одного элемента.</param>
        <param name="values">Коллекция, содержащая сцепляемые объекты.</param>
        <summary>Сцепляет элементы созданной коллекции, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из элементов <paramref name="values" />, разделяемых символом <paramref name="separator" />. Если <paramref name="values" /> не содержит членов, метод возвращает <see cref="F:System.String.Empty" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="values" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Длина получившейся строки превышает максимально допустимую (<see cref="F:System.Int32.MaxValue" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов параметра <paramref name="values" />.</typeparam>
        <param name="separator">Строка для использования в качестве разделителя. <paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="values" /> более одного элемента.</param>
        <param name="values">Коллекция, содержащая сцепляемые объекты.</param>
        <summary>Сцепляет элементы созданной коллекции, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из элементов <paramref name="values" />, разделяемых строками <paramref name="separator" />. Если <paramref name="values" /> не содержит членов, метод возвращает <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `separator` `null`, вместо нее используется пустая строка (<xref:System.String.Empty?displayProperty=nameWithType>). Если какой-либо элемент `values` имеет `null`, вместо него используется пустая строка.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> — это удобный метод, позволяющий объединять каждый элемент коллекции <xref:System.Collections.Generic.IEnumerable%601> без предварительного преобразования их в строки. Строковое представление каждого объекта в коллекции <xref:System.Collections.Generic.IEnumerable%601> является производным путем вызова метода `ToString` объекта.  
  
 Этот метод полезен в выражениях запросов LINQ. Например, следующий код определяет очень простой `Animal` класс, который содержит имя животного и порядок его принадлежности. Затем он определяет объект <xref:System.Collections.Generic.List%601>, содержащий количество объектов `Animal`. Метод расширения <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> вызывается для извлечения объектов `Animal`, свойство `Order` которых равно "грызунов". Результат передается в метод <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 В следующем примере используется Сиеве алгоритма Ератоссенес для вычисления простых чисел, которые меньше или равны 100. Он присваивает результат объекту <xref:System.Collections.Generic.List%601> типа Integer, который затем передается методу <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="values" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Длина получившейся строки превышает максимально допустимую (<see cref="F:System.Int32.MaxValue" />).</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанного символа Юникода или строки в пределах данного экземпляра. Метод возвращает -1, если знак или строка не найдена в данном экземпляре.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Знак Юникода, который необходимо найти.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанного символа Юникода в пределах данного экземпляра.</summary>
        <returns>Отсчитываемое от нуля значение индекса параметра <paramref name="value" />, если этот знак найден; в противном случае — значение -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля. То есть первый символ в строке находится в нулевом индексе, а последний — в <xref:System.String.Length%2A>-1.  
  
 Этот метод начинает поиск с последней позиции символа данного экземпляра и переходит назад к началу до тех пор, пока не обнаружит `value` или не проверит первый символ. При поиске учитывается регистр.  
  
 Этот метод выполняет поиск по порядковому номеру (без учета языка и региональных параметров), где символ считается эквивалентным другому символу, только если их скалярные значения в Юникоде одинаковы. Чтобы выполнить поиск с учетом языка и региональных параметров, используйте метод <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, где скалярное значение Юникода, представляющее составной символ, например лигатура "Æ" (U + 00C6), может считаться эквивалентным любому вхождению компонентов символа в правильном последовательность, например "AE" (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере определяется метод `ExtractFilename`, который использует метод <xref:System.String.LastIndexOf%28System.Char%29> для поиска последнего символа разделителя каталога в строке и извлечения имени файла строки. Если файл существует, метод возвращает имя файла без пути.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанной строки в данном экземпляре.</summary>
        <returns>Положение в отсчитываемом от нуля индексе параметра <paramref name="value" />, если эта строка найдена, или значение -1, если она не найдена. Если параметр <paramref name="value" /> равен <see cref="F:System.String.Empty" />, возвращаемым значением является последняя позиция в индексе данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля. То есть первый символ в строке находится в нулевом индексе, а последний — в <xref:System.String.Length%2A>-1.  
  
 Поиск начинается с последней позиции символа данного экземпляра и переходит назад к началу до тех пор, пока не обнаружится `value` или не будет проверена первая позиции символа.  
  
 Этот метод выполняет поиск по словам (с учетом регистра и с учетом языка и региональных параметров), используя текущий язык и региональные параметры.  
  
 Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров параметр `value` содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если `value` состоит только из одного или нескольких игнорируемых символов, метод <xref:System.String.LastIndexOf%28System.String%29> всегда возвращает <xref:System.String.Length%2A?displayProperty=nameWithType>-1, который представляет последнюю позиции индекса в текущем экземпляре. В следующем примере метод <xref:System.String.LastIndexOf%28System.String%29> используется для поиска трех подстрок (мягкий дефис (U + 00AD), мягкий дефис, за которым следует "n", и мягкий дефис, за которым следует "m") в двух строках. Только одна из строк содержит мягкий перенос. Если пример выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в каждом случае, поскольку мягкий дефис является проигнорированным символом, результат будет таким же, как если бы мягкий перенос не включался в `value`. При поиске только мягкого дефиса метод возвращает 6 и 5. Эти значения соответствуют индексу последнего символа в двух строках.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 Следующий пример удаляет открывающие и закрывающие HTML-теги из строки, если теги начинаются и завершают строку. Если строка заканчивается закрывающей скобкой (">"), в примере используется метод <xref:System.String.LastIndexOf%2A> для нахождение начала закрывающего тега.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Как описано в статье рекомендации [по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию, а вызывают методы, для которых требуется явно указать параметры. Чтобы найти последний индекс подстроки в экземпляре строки с помощью правил сравнения текущего языка и региональных параметров, вызовите перегрузку метода <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его параметра <paramref name="comparisonType" />.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Знак Юникода, который необходимо найти.</param>
        <param name="startIndex">Начальное положение поиска. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанного символа Юникода в пределах данного экземпляра. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки.</summary>
        <returns>Отсчитываемая от нуля позиция параметра <paramref name="value" /> в индексе, если этот символ найден, или значение -1, если он не найден или текущий экземпляр равен <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля. То есть первый символ в строке находится в нулевом индексе, а последний — в <xref:System.String.Length%2A>-1. Этот метод начинает поиск с `startIndex` позиции символа этого экземпляра и переходит назад к началу текущего экземпляра до тех пор, пока не будет найден `value` или не будет проверена первая позиция символа. Например, если `startIndex` имеет значение <xref:System.String.Length%2A>-1, метод ищет каждый символ из последнего символа в строке в начале. При поиске учитывается регистр.  
  
 Этот метод выполняет поиск по порядковому номеру (без учета языка и региональных параметров), где символ считается эквивалентным другому символу, только если их скалярные значения в Юникоде одинаковы. Чтобы выполнить поиск с учетом языка и региональных параметров, используйте метод <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, где скалярное значение Юникода, представляющее составной символ, например лигатура "Æ" (U + 00C6), может считаться эквивалентным любому вхождению компонентов символа в правильном последовательность, например "AE" (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере выполняется поиск индекса всех вхождений символа в строке, начиная с конца строки до начала строки.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> меньше нуля либо равно или превышает длину этого экземпляра.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанной строки в данном экземпляре. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки.</summary>
        <returns>Отсчитываемая от нуля начальная позиция индекса параметра <paramref name="value" />, если строка найдена; значение -1, если строка не найдена или значение текущего экземпляра равно <see cref="F:System.String.Empty" />. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является наименьшее значение из <paramref name="startIndex" /> и последнего значения индекса в данном экземпляре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля. То есть первый символ в строке находится в нулевом индексе, а последний — в <xref:System.String.Length%2A>-1.  
  
 Поиск начинается с `startIndex` позиции символа этого экземпляра и продолжается в направлении до начала до тех пор, пока не обнаружится `value` или не будет проверен первый символ. Например, если `startIndex` имеет значение <xref:System.String.Length%2A>-1, метод ищет каждый символ из последнего символа в строке в начале.  
  
 Этот метод выполняет поиск по словам (с учетом регистра и с учетом языка и региональных параметров), используя текущий язык и региональные параметры.  
  
 Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров параметр `value` содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если `value` состоит только из одного или нескольких игнорируемых символов, метод <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> всегда возвращает `startIndex`, то есть позиции символа, с которой начинается поиск. В следующем примере метод <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> используется для поиска подстроки, которая содержит мягкий дефис (U + 00AD) и предшествует или включает в себя окончательный символ "m" в строке. Если пример выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, так как мягкий дефис в строке поиска игнорируется, вызов метода для поиска подстроки, состоящей из мягкого дефиса, а "m" возвращает расположение "m" в строке , в то время как вызов метода для поиска подстроки, состоящей из мягкого дефиса, а "n" возвращает расположение "n". Если строка поиска содержит только мягкий дефис, метод возвращает индекс "m", который представляет значение `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 В следующем примере выполняется поиск индекса всех вхождений строки в целевой строке с конца целевой строки до начала целевой строки.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> меньше нуля или больше длины текущего экземпляра.  
  
- или - 
Текущий экземпляр равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> меньше –1 или больше нуля.</exception>
        <block subset="none" type="usage"><para>Как описано в статье рекомендации [по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию, а вызывают методы, для которых требуется явно указать параметры. Чтобы найти индекс подстроки, которая предшествует определенной позиции символа, используя правила сравнения текущего языка и региональных параметров, вызовите перегрузку метода <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его параметра <paramref name="comparisonType" />.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля последнего вхождения указанной строки в текущем объекте <see cref="T:System.String" />. Параметр определяет тип поиска заданной строки.</summary>
        <returns>Начальное положение в отсчитываемом от нуля индексе параметра <paramref name="value" />, если эта строка найдена, или значение -1, если она не найдена. Если параметр <paramref name="value" /> равен <see cref="F:System.String.Empty" />, возвращаемым значением является последняя позиция в индексе данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля. То есть первый символ в строке находится в нулевом индексе, а последний — в <xref:System.String.Length%2A>-1.  
  
 Параметр `comparisonType` задает поиск параметра `value` с использованием текущего или инвариантного языка и региональных параметров, с учетом регистра или без учета регистра, а также с использованием правил сравнения по словам или порядковому номеру.  
  
 Поиск начинается с последней позиции символа данного экземпляра и переходит назад к началу до тех пор, пока не обнаружится `value` или не будет проверена первая позиции символа.  
  
   
  
## Examples  
 В следующем примере показаны три перегрузки метода <xref:System.String.LastIndexOf%2A>, которые находят Последнее вхождение строки в другой строке, используя различные значения перечисления <xref:System.StringComparison>.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров (то есть, если параметр <paramref name="options" /> не имеет значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) параметр <paramref name="value" /> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если <paramref name="value" /> состоит только из одного или нескольких игнорируемых символов, метод <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> всегда возвращает <see cref="P:System.String.Length" />-1, который представляет последнюю позиции индекса в текущем экземпляре.  
  
В следующем примере метод <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> используется для поиска трех подстрок (мягкий дефис (U + 00AD), мягкий дефис, за которым следует "n", и мягкий дефис, за которым следует "m") в двух строках. Только одна из строк содержит мягкий перенос. Если пример выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, поскольку мягкий дефис является игнорируемым символом, поиск с учетом языка и региональных параметров возвращает то же значение, которое возвращается, если мягкий перенос не был включен в строку поиска. Однако порядковый поиск по порядковому номеру успешно находит мягкий дефис в одной строке и сообщает, что он отсутствует во второй строке.  
  
[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Знак Юникода, который необходимо найти.</param>
        <param name="startIndex">Начальное положение поиска. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанного символа Юникода в подстроке в пределах данного экземпляра. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки для заданного числа позиций символов.</summary>
        <returns>Отсчитываемая от нуля позиция параметра <paramref name="value" /> в индексе, если этот символ найден, или значение -1, если он не найден или текущий экземпляр равен <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля. То есть первый символ в строке находится в нулевом индексе, а последний — в <xref:System.String.Length%2A>-1.  
  
 Этот метод начинает поиск с `startIndex` позиции символа и переходит назад к началу этого экземпляра до тех пор, пока не будет найден `value` или не будут проверены `count` позиции символов. Например, если `startIndex` имеет значение <xref:System.String.Length%2A>-1, метод выполняет поиск обратно `count` символов из последнего символа в строке. При поиске учитывается регистр.  
  
 Этот метод выполняет поиск по порядковому номеру (без учета языка и региональных параметров), где символ считается эквивалентным другому символу, только если их скалярное значение в Юникоде одинаково. Чтобы выполнить поиск с учетом языка и региональных параметров, используйте метод <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, где скалярное значение Юникода, представляющее составной символ, например лигатура "Æ" (U + 00C6), может считаться эквивалентным любому вхождению компонентов символа в правильном последовательность, например "AE" (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере выполняется поиск индекса всех вхождений символа в подстроке, начиная с конца подстроки до начала подстроки.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> меньше нуля либо равно или превышает длину этого экземпляра.  
  
- или - 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> - <paramref name="count" /> + 1 является отрицательным числом.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанной строки в данном экземпляре. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки для заданного числа позиций символов.</summary>
        <returns>Отсчитываемая от нуля начальная позиция индекса параметра <paramref name="value" />, если строка найдена; значение -1, если строка не найдена или значение текущего экземпляра равно <see cref="F:System.String.Empty" />. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является наименьшее значение из <paramref name="startIndex" /> и последнего значения индекса в данном экземпляре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля. То есть первый символ в строке находится в нулевом индексе, а последний — в <xref:System.String.Length%2A>-1.  
  
 Поиск начинается с `startIndex` позиции символа этого экземпляра и продолжается в направлении до начала до тех пор, пока не будет найден `value` или не будут проверены `count` позиции символов. Например, если `startIndex` имеет значение <xref:System.String.Length%2A>-1, метод выполняет поиск обратно `count` символов из последнего символа в строке.  
  
 Этот метод выполняет поиск по словам (с учетом регистра и с учетом языка и региональных параметров), используя текущий язык и региональные параметры.  
  
 Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров параметр `value` содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если `value` состоит только из одного или нескольких игнорируемых символов, метод <xref:System.String.LastIndexOf%2A> всегда возвращает `startIndex`, то есть позиции символа, с которой начинается поиск. В следующем примере метод <xref:System.String.LastIndexOf%2A> используется для поиска расположения мягкого дефиса (U + 00AD) в двух символах, предшествующих конечной букве "m" двух строк. Только одна из строк содержит требуемую подстроку. Если пример выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий дефис является игнорируемым символом, метод возвращает индекс "m" в строке, когда он выполняет сравнение с учетом языка и региональных параметров. Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m".  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 В следующем примере выполняется поиск индекса всех вхождений строки в подстроке, начиная с конца подстроки до начала подстроки.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> является отрицательным значением.  
  
- или - 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> является отрицательным.  
  
- или - 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> превышает длину этого экземпляра.  
  
- или - 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> - <paramref name="count" /> + 1 указывает позицию вне пределов данного экземпляра.  
  
- или - 
Текущий экземпляр равен <see cref="F:System.String.Empty" />, а <paramref name="start" /> меньше -1 или больше нуля.  
  
- или - 
Текущий экземпляр равен <see cref="F:System.String.Empty" />, а <paramref name="count" /> больше 1.</exception>
        <block subset="none" type="usage"><para>Как описано в статье рекомендации [по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию, а вызывают методы, для которых требуется явно указать параметры. Чтобы выполнить эту операцию с помощью правил сравнения текущего языка и региональных параметров, вызовите перегрузку метода <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его параметра <paramref name="comparisonType" />.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля последнего вхождения указанной строки в текущем объекте <see cref="T:System.String" />. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки. Параметр определяет тип сравнения для выполнения во время поиска заданной строки.</summary>
        <returns>Отсчитываемая от нуля начальная позиция индекса параметра <paramref name="value" />, если эта строка найдена, или значение -1, если строка не найдена или текущий экземпляр равен <see cref="F:System.String.Empty" />. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является наименьшее значение из <paramref name="startIndex" /> и последнего значения индекса в данном экземпляре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля. То есть первый символ в строке находится в нулевом индексе, а последний — в <xref:System.String.Length%2A>-1.  
  
 Поиск начинается с `startIndex` позиции символа и переходит назад, пока не обнаружится `value` или не будет проверен первый символ. Например, если `startIndex` имеет значение <xref:System.String.Length%2A>-1, метод ищет каждый символ из последнего символа в строке в начале.  
  
 Параметр `comparisonType` задает поиск параметра `value` с использованием текущего или инвариантного языка и региональных параметров, с учетом регистра или без учета регистра, а также с использованием правил сравнения по словам или порядковому номеру.  
  
   
  
## Examples  
 В следующем примере показаны три перегрузки метода <xref:System.String.LastIndexOf%2A>, которые находят Последнее вхождение строки в другой строке, используя различные значения перечисления <xref:System.StringComparison>.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> меньше нуля или больше длины текущего экземпляра.  
  
- или - 
Текущий экземпляр равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> меньше -1 или больше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров (то есть, если параметр <paramref name="comparisonType" /> не имеет значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) параметр <paramref name="value" /> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если <paramref name="value" /> состоит только из одного или нескольких игнорируемых символов, метод <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> всегда возвращает <paramref name="startIndex" />, то есть позиции символа, с которой начинается поиск.  
  
В следующем примере метод <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> используется для поиска положения мягкого дефиса (U + 00AD), за которым следует символ "m", начиная с последнего "m" в двух строках. Только одна из строк содержит требуемую подстроку. Если пример выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий дефис является игнорируемым символом, метод возвращает индекс "m" в строке, когда он выполняет сравнение с учетом языка и региональных параметров. Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m". Этот метод возвращает индекс мягкого переноса в первой строке только при выполнении порядкового сравнения.  
  
[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила поиска.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанной строки в данном экземпляре. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки для заданного числа позиций символов. Параметр определяет тип сравнения для выполнения во время поиска заданной строки.</summary>
        <returns>Отсчитываемая от нуля начальная позиция индекса параметра <paramref name="value" />, если эта строка найдена, или значение -1, если строка не найдена или текущий экземпляр равен <see cref="F:System.String.Empty" />. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является наименьшее значение из <paramref name="startIndex" /> и последнего значения индекса в данном экземпляре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля. То есть первый символ в строке находится в нулевом индексе, а последний — в <xref:System.String.Length%2A>-1.  
  
 Поиск начинается с `startIndex` позиции символа и переходит назад до тех пор, пока не будет найден `value` или не будут проверены `count` позиции символов. Например, если `startIndex` имеет значение <xref:System.String.Length%2A>-1, метод выполняет поиск обратно `count` символов из последнего символа в строке.  
  
 Параметр `comparisonType` задает поиск параметра `value` с использованием текущего или инвариантного языка и региональных параметров, с учетом регистра или без учета регистра, а также с использованием правил сравнения по словам или порядковому номеру.  
  
   
  
## Examples  
 В следующем примере показаны три перегрузки метода <xref:System.String.LastIndexOf%2A>, которые находят Последнее вхождение строки в другой строке, используя различные значения перечисления <xref:System.StringComparison>.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> является отрицательным значением.  
  
- или - 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> является отрицательным.  
  
- или - 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> превышает длину этого экземпляра.  
  
- или - 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> – <paramref name="count" /> + 1 указывает позицию вне пределов данного экземпляра.  
  
- или - 
Текущий экземпляр равен <see cref="F:System.String.Empty" />, а <paramref name="start" /> меньше -1 или больше нуля.  
  
- или - 
Текущий экземпляр равен <see cref="F:System.String.Empty" />, а <paramref name="count" /> больше 1.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров (то есть, если параметр <paramref name="comparisonType" /> не имеет значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) параметр <paramref name="value" /> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если <paramref name="value" /> состоит только из одного или нескольких игнорируемых символов, метод <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> всегда возвращает <paramref name="startIndex" />, то есть позиции символа, с которой начинается поиск.  
  
В следующем примере метод <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> используется для поиска позиции мягкого дефиса (U + 00AD), за которым следует символ "m", а не первая позиции символа перед последним "m" в двух строках. Только одна из строк содержит требуемую подстроку. Если пример выполняется в [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий дефис является игнорируемым символом, метод возвращает индекс "m" в строке, когда он выполняет сравнение с учетом языка и региональных параметров. Однако при выполнении порядкового сравнения он находит подстроку только в первой строке. Обратите внимание, что в случае первой строки, которая включает мягкий дефис, за которым следует символ "m", метод не возвращает индекс мягкого дефиса, а вместо этого возвращает индекс "m", когда он выполняет сравнение с учетом языка и региональных параметров. Этот метод возвращает индекс мягкого переноса в первой строке только при выполнении порядкового сравнения.  
  
[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения в данном экземпляре какого-либо одного или нескольких символов, указанных в массиве символов Юникода. Метод возвращает -1, если знаки массива не найдены в этом экземпляре.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Массив знаков Юникода, содержащий один или несколько искомых знаков.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения в данном экземпляре какого-либо одного или нескольких символов, указанных в массиве символов Юникода.</summary>
        <returns>Значение индекса последнего вхождения какого-либо знака из <paramref name="anyOf" /> в данном экземпляре; -1, если ни один знак из <paramref name="anyOf" /> не был найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля.  
  
 Этот метод начинает поиск с последней позиции символа данного экземпляра и переходит назад к началу до тех пор, пока не будет найден символ в `anyOf` или не будет проверена первая позиции символа. При поиске учитывается регистр.  
  
 Этот метод выполняет поиск по порядковому номеру (без учета языка и региональных параметров), где символ считается эквивалентным другому символу, только если их скалярные значения в Юникоде одинаковы. Чтобы выполнить поиск с учетом языка и региональных параметров, используйте метод <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, где скалярное значение Юникода, представляющее составной символ, например лигатура "Æ" (U + 00C6), может считаться эквивалентным любому вхождению компонентов символа в правильном последовательность, например "AE" (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере выполняется поиск индекса последнего вхождения любого символа в строке "имеет значение" в другой строке.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Массив знаков Юникода, содержащий один или несколько искомых знаков.</param>
        <param name="startIndex">Позиция, с которой начинается поиск. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения в данном экземпляре какого-либо одного или нескольких символов, указанных в массиве символов Юникода. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки.</summary>
        <returns>Значение индекса последнего вхождения какого-либо знака из <paramref name="anyOf" /> в данном экземпляре; -1, если ни один знак из <paramref name="anyOf" /> не был найден или текущий экземпляр равен <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля.  
  
 Этот метод начинает поиск с `startIndex` позиции символа этого экземпляра и переходит назад к началу до тех пор, пока не обнаружится символ в `anyOf` или не будет проверена первая позиции символа. При поиске учитывается регистр.  
  
 Этот метод выполняет поиск по порядковому номеру (без учета языка и региональных параметров), где символ считается эквивалентным другому символу, только если их скалярные значения в Юникоде одинаковы. Чтобы выполнить поиск с учетом языка и региональных параметров, используйте метод <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, где скалярное значение Юникода, представляющее составной символ, например лигатура "Æ" (U + 00C6), может считаться эквивалентным любому вхождению компонентов символа в правильном последовательность, например "AE" (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере выполняется поиск индекса последнего вхождения любого символа в строке "имеет значение" в подстроке другой строки.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="anyOf" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> указывает позицию вне пределов данного экземпляра.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Массив знаков Юникода, содержащий один или несколько искомых знаков.</param>
        <param name="startIndex">Позиция, с которой начинается поиск. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения в данном экземпляре какого-либо одного или нескольких символов, указанных в массиве символов Юникода. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки для заданного числа позиций символов.</summary>
        <returns>Значение индекса последнего вхождения какого-либо знака из <paramref name="anyOf" /> в данном экземпляре; -1, если ни один знак из <paramref name="anyOf" /> не был найден или текущий экземпляр равен <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нумерация индексов начинается с нуля.  
  
 Этот метод начинает поиск с `startIndex` позиции символа этого экземпляра и переходит назад к началу до тех пор, пока не будет найден символ в `anyOf` или не будут проверены `count` позиции символов. При поиске учитывается регистр.  
  
 Этот метод выполняет поиск по порядковому номеру (без учета языка и региональных параметров), где символ считается эквивалентным другому символу, только если их скалярные значения в Юникоде одинаковы. Чтобы выполнить поиск с учетом языка и региональных параметров, используйте метод <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, где скалярное значение Юникода, представляющее составной символ, например лигатура "Æ" (U + 00C6), может считаться эквивалентным любому вхождению компонентов символа в правильном последовательность, например "AE" (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере выполняется поиск индекса последнего вхождения любого символа в строке "вспомогательной" в подстроке другой строки.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="anyOf" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="count" /> или <paramref name="startIndex" /> является отрицательным числом.  
  
- или - 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а разность <paramref name="startIndex" /> и <paramref name="count" /> + 1 меньше нуля.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает число знаков в текущем объекте <see cref="T:System.String" />.</summary>
        <value>Количество знаков в текущей строке.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.String.Length%2A> возвращает количество объектов <xref:System.Char> в данном экземпляре, а не число символов Юникода. Причина заключается в том, что символ Юникода может быть представлен более чем одним <xref:System.Char>. Используйте класс <xref:System.Globalization.StringInfo?displayProperty=nameWithType> для работы с каждым символом Юникода вместо каждой <xref:System.Char>.  
  
 В некоторых языках, таких как C и C++, символ NULL обозначает конец строки. В .NET символ NULL может быть внедрен в строку. Если строка содержит один или несколько символов NULL, они включаются в общую длину строки. Например, в следующей строке подстроки "ABC" и "def" разделяются символом NULL. Свойство <xref:System.String.Length%2A> возвращает значение 7, которое указывает, что включает в себя шесть алфавитных символов, а также символ null.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 В следующем примере демонстрируется свойство <xref:System.String.Length%2A>.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает новую строку, двоичное представление которой находится в определенной нормализованной форме Юникода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает новую строку, текстовое значение которой совпадает с данной строкой, а двоичное представление находится в нормализованной форме C Юникода.</summary>
        <returns>Новая нормализованная строка, текстовое значение которой совпадает с данной строкой, а двоичное представление находится в нормализованной форме C Юникода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые символы Юникода имеют несколько эквивалентных двоичных представлений, состоящих из наборов комбинированных и/или составных символов Юникода. Например, любая из следующих кодовых позиций может представлять букву «ắ»:  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U+0061 U+0306 U+0301  
  
 Наличие нескольких представлений для одного символа усложняет поиск, сортировку, сопоставление и другие операции.  
  
 Стандарт Unicode определяет процесс, называемый нормализацией, который возвращает одно двоичное представление при наличии любого из эквивалентных двоичных представлений символа. Нормализацию можно выполнить с помощью нескольких алгоритмов, называемых формами нормализации, которые подчиняются различным правилам. .NET поддерживает четыре формы нормализации (C, D, KC и KD), которые определены стандартом Юникода. Если две строки представлены в одной и той же форме нормализации, их можно сравнить с помощью сравнения по порядковому номеру.  
  
 Для нормализации и сравнения двух строк выполните следующие действия.  
  
1.  Получение строк для сравнения из источника входных данных, например файла или устройства ввода пользователя.  
  
2.  Вызовите метод <xref:System.String.Normalize>, чтобы нормализовать строки в форму нормализации C.  
  
3.  Чтобы сравнить две строки, вызовите метод, поддерживающий порядковое сравнение строк, например метод <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>, и укажите значение <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> или <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> в качестве аргумента <xref:System.StringComparison>. Чтобы отсортировать массив нормализованных строк, передайте `comparer` значение <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> или <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> в соответствующую перегрузку <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Выдавать строки в отсортированном выводе на основе заказа, указанного на предыдущем шаге.  
  
 Описание поддерживаемых форм нормализации Юникода см. в разделе <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере строка нормализуется в каждую из четырех форм нормализации, подтверждающая, что строка была нормализована до указанной формы нормализации, а затем перечисляются кодовые точки в нормализованной строке.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий экземпляр содержит недопустимые символы Юникода.</exception>
        <block subset="none" type="usage"><para>Метод <see cref="Overload:System.String.IsNormalized" /> возвращает <see langword="false" /> сразу же после того, как он встречает первый Ненормализованный символ в строке. Таким образом, если строка содержит ненормализованные символы, за которыми следуют недопустимые символы Юникода, метод <see cref="Overload:System.String.Normalize" /> выдаст исключение <see cref="T:System.ArgumentException" /> хотя <see cref="Overload:System.String.IsNormalized" /> возвращает <see langword="false" />.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Форма нормализации Юникода.</param>
        <summary>Возвращает новую строку, текстовое значение которой совпадает с данной строкой, а двоичное представление находится в заданной нормализованной форме Юникода.</summary>
        <returns>Новая строка, текстовое значение которой совпадает с данной строкой, а двоичное представление находится в форме нормализации, заданной в параметре <paramref name="normalizationForm" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые символы Юникода имеют несколько эквивалентных двоичных представлений, состоящих из наборов комбинированных и/или составных символов Юникода. Наличие нескольких представлений для одного символа усложняет поиск, сортировку, сопоставление и другие операции.  
  
 Стандарт Unicode определяет процесс, называемый нормализацией, который возвращает одно двоичное представление при наличии любого из эквивалентных двоичных представлений символа. Нормализацию можно выполнить с помощью нескольких алгоритмов, называемых формами нормализации, которые подчиняются различным правилам. .NET поддерживает четыре формы нормализации (C, D, KC и KD), которые определены стандартом Юникода. Если две строки представлены в одной и той же форме нормализации, их можно сравнить с помощью сравнения по порядковому номеру.  
  
 Для нормализации и сравнения двух строк выполните следующие действия.  
  
1.  Получение строк для сравнения из источника входных данных, например файла или устройства ввода пользователя.  
  
2.  Вызовите метод <xref:System.String.Normalize%28System.Text.NormalizationForm%29>, чтобы нормализовать строки в указанную форму нормализации.  
  
3.  Чтобы сравнить две строки, вызовите метод, поддерживающий порядковое сравнение строк, например метод <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>, и укажите значение <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> или <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> в качестве аргумента <xref:System.StringComparison>. Чтобы отсортировать массив нормализованных строк, передайте `comparer` значение <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> или <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> в соответствующую перегрузку <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Выдавать строки в отсортированном выводе на основе заказа, указанного на предыдущем шаге.  
  
 Описание поддерживаемых форм нормализации Юникода см. в разделе <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере строка нормализуется в каждую из четырех форм нормализации, подтверждающая, что строка была нормализована до указанной формы нормализации, а затем перечисляются кодовые точки в нормализованной строке.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий экземпляр содержит недопустимые символы Юникода.</exception>
        <block subset="none" type="usage"><para>Метод <see cref="Overload:System.String.IsNormalized" /> возвращает <see langword="false" /> сразу же после того, как он встречает первый Ненормализованный символ в строке. Таким образом, если строка содержит ненормализованные символы, за которыми следуют недопустимые символы Юникода, то метод <see cref="Overload:System.String.Normalize" /> может вызвать исключение <see cref="T:System.ArgumentException" /> хотя <see cref="Overload:System.String.IsNormalized" /> возвращает <see langword="false" />.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Первая сравниваемая строка или значение <see langword="null" />.</param>
        <param name="b">Вторая сравниваемая строка или значение <see langword="null" />.</param>
        <summary>Определяет, равны ли значения двух указанных строк.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="a" /> совпадает со значением <paramref name="b" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.String.op_Equality%2A> определяет операцию оператора равенства для класса <xref:System.String>. Он позволяет выполнять код, как показано в разделе "пример". Оператор, в свою очередь, вызывает статический метод <xref:System.String.Equals%28System.String%2CSystem.String%29>, который выполняет сравнение по порядковому номеру (с учетом регистра и без учета языка и региональных параметров).  
  
> [!NOTE]
>  Компилятор Visual Basic не разрешает оператор равенства как вызов метода <xref:System.String.op_Equality%2A>. Вместо этого оператор равенства заключает в оболочку вызов метода <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показан оператор равенства.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Строка для неявного преобразования.</param>
        <summary>Определяет неявное преобразование указанной строки в доступный только для чтения диапазон символов.</summary>
        <returns>Доступный только для чтения диапазон символов, представляющий строку.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Первая сравниваемая строка или значение <see langword="null" />.</param>
        <param name="b">Вторая сравниваемая строка или значение <see langword="null" />.</param>
        <summary>Определяет, различаются ли значения двух указанных строк.</summary>
        <returns>Значение <see langword="true" />, если значение <paramref name="a" /> отличается от значения <paramref name="b" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.String.op_Inequality%2A> определяет операцию оператора неравенства для класса <xref:System.String>.   Он позволяет выполнять код, как показано в разделе "примеры".  
  
 Оператор <xref:System.String.op_Inequality%2A>, в свою очередь, вызывает статический метод <xref:System.String.Equals%28System.String%2CSystem.String%29>, который выполняет сравнение по порядковому номеру (с учетом регистра и без учета языка и региональных параметров).  
  
> [!NOTE]
>  Компилятор Visual Basic не разрешает оператор неравенства как вызов метода <xref:System.String.op_Inequality%2A>. Вместо этого оператор неравенства заключает в оболочку вызов метода <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показан оператор неравенства.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает новую строку указанной длины, в которой начало текущей строки заполняется пробелами или указанным знаком Юникода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Количество знаков в полученной строке, равное числу исходных знаков плюс некоторое количество добавленных для заполнения знаков.</param>
        <summary>Возвращает новую строку, в которой знаки данного экземпляра выровнены по правому краю путем добавления слева символов-разделителей до указанной общей длины.</summary>
        <returns>Новая строка, эквивалентная данному экземпляру, но с выравниванием по правому краю и с добавленными слева пробелами, необходимыми для достижения длины <paramref name="totalWidth" />. Однако если значение параметра <paramref name="totalWidth" /> меньше длины данного экземпляра, метод возвращает ссылку на имеющийся экземпляр. Если значение параметра <paramref name="totalWidth" /> равно длине данного экземпляра, метод возвращает новую строку, идентичную данному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пространство Юникода определяется как шестнадцатеричное 0x0020.  
  
 Метод <xref:System.String.PadLeft%28System.Int32%29> дополняет начало возвращаемой строки. Это означает, что при использовании с языками с письмом справа налево он дополняет правую часть строки.  
  
> [!NOTE]
>  Если метод <xref:System.String.PadLeft%2A> дополняет текущий экземпляр символами пробела, этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, дополненную начальными пробелами, чтобы ее общая длина `totalWidth` символов.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.PadLeft%2A>.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="totalWidth" /> меньше нуля.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Количество знаков в полученной строке, равное числу исходных знаков плюс некоторое количество добавленных для заполнения знаков.</param>
        <param name="paddingChar">Добавляемый в качестве заполнителя знак Юникода.</param>
        <summary>Возвращает новую строку, в которой знаки данного экземпляра выровнены по правому краю путем добавления слева пробелов или указанного знака Юникода до указанной общей длины.</summary>
        <returns>Новая строка, эквивалентная данному экземпляру, но с выравниванием по правому краю и с добавленными слева знаками <paramref name="paddingChar" />, необходимыми для достижения длины <paramref name="totalWidth" />. Однако если значение параметра <paramref name="totalWidth" /> меньше длины данного экземпляра, метод возвращает ссылку на имеющийся экземпляр. Если значение параметра <paramref name="totalWidth" /> равно длине данного экземпляра, метод возвращает новую строку, идентичную данному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> дополняет начало возвращаемой строки. Это означает, что при использовании с языками с письмом справа налево он дополняет правую часть строки.  
  
> [!NOTE]
>  Если метод <xref:System.String.PadLeft%2A> дополняет текущий экземпляр символами пробела, этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, дополненную начальными `paddingChar` символами, чтобы ее общая длина `totalWidth` символов.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.PadLeft%2A>.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="totalWidth" /> меньше нуля.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает новую строку указанной длины, в которой конец текущей строки заполняется символами-разделителями или указанным знаком Юникода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Количество знаков в полученной строке, равное числу исходных знаков плюс некоторое количество добавленных для заполнения знаков.</param>
        <summary>Возвращает новую строку, в которой знаки данной строки выровнены по левому краю путем добавления справа пробелов до указанной общей длины.</summary>
        <returns>Новая строка, эквивалентная данному экземпляру, но с выравниванием по левому краю и с добавленными справа пробелами, необходимыми для достижения длины <paramref name="totalWidth" />. Однако если значение параметра <paramref name="totalWidth" /> меньше длины данного экземпляра, метод возвращает ссылку на имеющийся экземпляр. Если значение параметра <paramref name="totalWidth" /> равно длине данного экземпляра, метод возвращает новую строку, идентичную данному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пространство Юникода определяется как шестнадцатеричное 0x0020.  
  
 Метод <xref:System.String.PadRight%28System.Int32%29> дополняет конец возвращаемой строки. Это означает, что при использовании с языками с письмом справа налево он дополняет левую часть строки.  
  
> [!NOTE]
>  Если метод <xref:System.String.PadRight%2A> дополняет текущий экземпляр символами пробела, этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, дополненную конечным пробелом, чтобы ее общая длина была `totalWidth` символов.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.PadRight%2A>.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="totalWidth" /> меньше нуля.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Количество знаков в полученной строке, равное числу исходных знаков плюс некоторое количество добавленных для заполнения знаков.</param>
        <param name="paddingChar">Добавляемый в качестве заполнителя знак Юникода.</param>
        <summary>Возвращает новую строку, в которой знаки данной строки выровнены по левому краю путем добавления справа пробелов или указанного знака Юникода до указанной общей длины.</summary>
        <returns>Новая строка, эквивалентная данному экземпляру, но с выравниванием по левому краю и с добавленными справа знаками <paramref name="paddingChar" />, необходимыми для достижения длины <paramref name="totalWidth" />. Однако если значение параметра <paramref name="totalWidth" /> меньше длины данного экземпляра, метод возвращает ссылку на имеющийся экземпляр. Если значение параметра <paramref name="totalWidth" /> равно длине данного экземпляра, метод возвращает новую строку, идентичную данному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> дополняет конец возвращаемой строки. Это означает, что при использовании с языками с письмом справа налево он дополняет левую часть строки.  
  
> [!NOTE]
>  Если метод <xref:System.String.PadRight%2A> дополняет текущий экземпляр символами пробела, этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, дополненную завершающими `paddingChar` символами, чтобы ее общая длина `totalWidth` символов.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.PadRight%2A>.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="totalWidth" /> меньше нуля.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает новую строку, в которой удалено указанное число знаков текущей строки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">Отсчитываемая от нуля позиция, с которой начинается удаление знаков.</param>
        <summary>Возвращает новую строку, в которой были удалены все символы, начиная с указанной позиции и до конца в текущем экземпляре.</summary>
        <returns>Новая строка, эквивалентная данной строке за минусом удаленных знаков.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]строки отсчитываются от нуля. Значение параметра `startIndex` может варьироваться от нуля до значения, меньшего, чем длина экземпляра строки.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой удаляются все символы из `startIndex` позиций в конец исходной строки.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.Remove%2A>. В этом случае весь текст, начиная с указанного индекса, удаляется с конца строки. В последнем случае удаляются три символа, начиная с указанного индекса.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> меньше нуля.  
  
- или - 
 <paramref name="startIndex" /> указывает положение, которое находится за пределами этой строки.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Отсчитываемая от нуля позиция, с которой начинается удаление знаков.</param>
        <param name="count">Число символов для удаления.</param>
        <summary>Возвращает новую строку, в которой было удалено указанное число символов в указанной позиции.</summary>
        <returns>Новая строка, эквивалентная данному экземпляру за минусом удаленных знаков.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]строки отсчитываются от нуля. Значение параметра `startIndex` может варьироваться от нуля до значения, меньшего, чем длина экземпляра строки.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой было удалено количество символов, заданных параметром `count`. Символы удаляются в позиции, указанной параметром `startIndex`.  
  
   
  
## Examples  
 В следующем примере показано, как можно удалить отчество из полного имени.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="count" /> меньше нуля.  
  
- или - 
 <paramref name="startIndex" /> плюс <paramref name="count" /> указывает позицию за пределами этого экземпляра.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает новую строку, в которой все вхождения заданного знака Юникода или <see cref="T:System.String" /> в текущей строке заменены другим заданным знаком Юникода или <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Заменяемый знак Юникода.</param>
        <param name="newChar">Знак Юникода для замены всех обнаруженных вхождений <paramref name="oldChar" />.</param>
        <summary>Возвращает новую строку, в которой все вхождения заданного знака Юникода в текущем экземпляре заменены другим заданным знаком Юникода.</summary>
        <returns>Строка, эквивалентная данному экземпляру, но с тем отличием, что все вхождения <paramref name="oldChar" /> заменены на <paramref name="newChar" />. Если <paramref name="oldChar" /> не обнаружен в текущем экземпляре метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для поиска `oldChar`этот метод выполняет поиск по порядковому номеру (с учетом регистра и без учета языка и региональных параметров).  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все вхождения `oldChar` заменяются `newChar`.  
  
 Поскольку этот метод возвращает измененную строку, можно объединить последовательные вызовы метода <xref:System.String.Replace%2A> для выполнения нескольких замен в исходной строке. Вызовы методов выполняются слева направо. Ниже приведен пример.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 В следующем примере создается список значений с разделителями-запятыми путем замены запятыми пробелов между сериями чисел.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Строка, которую требуется заменить.</param>
        <param name="newValue">Строка для замены всех вхождений <paramref name="oldValue" />.</param>
        <summary>Возвращает новую строку, в которой все вхождения заданной строки в текущем экземпляре заменены другой заданной строкой.</summary>
        <returns>Строка, эквивалентная текущей строке, но с тем отличием, что все вхождения <paramref name="oldValue" /> заменены на <paramref name="newValue" />. Если <paramref name="oldValue" /> не обнаружен в текущем экземпляре метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `newValue` `null`, удаляются все вхождения `oldValue`.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все вхождения `oldValue` заменяются `newValue`.  
  
 Для поиска `oldValue`этот метод выполняет поиск по порядковому номеру (с учетом регистра и без учета языка и региональных параметров).  
  
 Поскольку этот метод возвращает измененную строку, можно объединить последовательные вызовы метода <xref:System.String.Replace%2A> для выполнения нескольких замен в исходной строке. Вызовы методов выполняются слева направо. Ниже приведен пример.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 В следующем примере показано, как можно использовать метод <xref:System.String.Replace%2A> для исправления орфографической ошибки.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="oldValue" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> является пустой строкой ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">Строка, которую требуется заменить.</param>
        <param name="newValue">Строка для замены всех вхождений <paramref name="oldValue" />.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее способ поиска <paramref name="oldValue" /> в пределах экземпляра.</param>
        <summary>Возвращает новую строку, в которой все вхождения заданной строки в текущем экземпляре заменены другой заданной строкой с использованием указанного типа сравнения.</summary>
        <returns>Строка, эквивалентная текущей строке, но с тем отличием, что все вхождения <paramref name="oldValue" /> заменены на <paramref name="newValue" />. Если <paramref name="oldValue" /> не обнаружен в текущем экземпляре метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
Если `newValue` `null`, удаляются все вхождения `oldValue`.

> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все вхождения `oldValue` заменяются `newValue`.

Этот метод выполняет поиск `oldValue` с использованием языка и региональных параметров и чувствительности к регистру, описанной `comparisonType`.

Поскольку этот метод возвращает измененную строку, можно объединить последовательные вызовы метода <xref:System.String.Replace%2A> для выполнения нескольких замен в исходной строке. Вызовы методов выполняются слева направо. Ниже приведен пример.

[!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
[!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> является пустой строкой ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">Строка, которую требуется заменить.</param>
        <param name="newValue">Строка для замены всех вхождений <paramref name="oldValue" />.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы регистр при сравнении игнорировался; в противном случае значение <see langword="false" />.</param>
        <param name="culture">Язык и региональные параметры, используемые при сравнении.</param>
        <summary>Возвращает новую строку, в которой все вхождения заданной строки в текущем экземпляре заменены другой заданной строкой с использованием указанных языка и региональных параметры, а также учета регистра.</summary>
        <returns>Строка, эквивалентная текущей строке, но с тем отличием, что все вхождения <paramref name="oldValue" /> заменены на <paramref name="newValue" />. Если <paramref name="oldValue" /> не обнаружен в текущем экземпляре метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
Если `newValue` `null`, удаляются все вхождения `oldValue`.

> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все вхождения `oldValue` заменяются `newValue`.

Этот метод выполняет поиск `oldValue` используя указанный `culture` и `ignoreCase` чувствительности к регистру.

Поскольку этот метод возвращает измененную строку, можно объединить последовательные вызовы метода <xref:System.String.Replace%2A> для выполнения нескольких замен в исходной строке. Вызовы методов выполняются слева направо. Ниже приведен пример.

[!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
[!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> является пустой строкой ("").</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает строковый массив, содержащий подстроки данного экземпляра, разделенные элементами заданной строки или массива знаков Юникода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> используется для разбиения строки с разделителями на подстроки. Можно использовать либо массив символов, чтобы указать ноль, один или несколько символов-разделителей (метод <xref:System.String.Split%28System.Char%5B%5D%29>), либо можно использовать массив символов, чтобы указать ноль, одну или несколько строк разделителей. Перегрузки метода <xref:System.String.Split%2A> позволяют ограничить количество подстрок, возвращаемых методом (метод <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29>), для определения того, включены ли пустые строки в возвращаемые подстроки (методы <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> и <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> или как методы <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> и <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>).  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>Альтернативы String. Split

 Метод <xref:System.String.Split%2A> не всегда является лучшим способом разбивать строку с разделителями на подстроки. Если вы не хотите извлекать все подстроки из строки с разделителями или хотите проанализировать строку на основе шаблона вместо набора символов-разделителей, рассмотрим следующие варианты.  
  
### <a name="regular-expressions"></a>Регулярные выражения  
 Если строки соответствуют фиксированному шаблону, можно использовать регулярное выражение для извлечения и обработки их элементов. Например, если строки имеют*форму "номер* *операнда* ** числа", можно использовать [регулярное выражение](~/docs/standard/base-types/regular-expressions.md) для извлечения и обработки элементов строки. Ниже приведен пример:  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Шаблон регулярного выражения `(\d+)\s+([-+*/])\s+(\d+)` определяется следующим образом:  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(\d+)`|Совпадение с одной или несколькими десятичными цифрами. Это первая группа записи.|  
|`\s+`|Совпадение с одним или несколькими символами пробела.|  
|`([-+*/])`|Совпадение со знаком арифметического оператора (+,-, * или/). Это вторая группа записи.|  
|`\s+`|Совпадение с одним или несколькими символами пробела.|  
|`(\d+)`|Совпадение с одной или несколькими десятичными цифрами. Это третья группа записи.|  
  
 Можно также использовать регулярное выражение для извлечения подстрок из строки на основе шаблона, а не фиксированного набора символов. Это распространенный сценарий, когда происходит одно из следующих условий:  
  
-   Один или несколько символов-разделителей не всегда являются разделителями в экземпляре <xref:System.String>.  
  
-   Последовательность и количество символов-разделителей являются переменными или неизвестными.  
  
 Например, метод <xref:System.String.Split%2A> нельзя использовать для разбиения следующей строки, так как количество `\n` (в C#) или `vbCrLf` (в Visual Basic) являются переменными и не всегда являются разделителями.  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 Регулярное выражение может легко разделить эту строку, как показано в следующем примере.  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Шаблон регулярного выражения `\[([^\[\]]+)\]` определяется следующим образом:  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\[`|Совпадение с открывающей скобкой.|  
|`([^\[\]]+)`|Совпадение с любым символом, который не является открывающей или закрывающей круглой скобкой один или несколько раз. Это первая группа записи.|  
|`\]`|Совпадение с закрывающей скобкой.|  
  
 Метод <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> практически идентичен <xref:System.String.Split%2A?displayProperty=nameWithType>, за исключением того, что он разделяет строку на основе шаблона регулярного выражения вместо фиксированной кодировки. Например, в следующем примере используется метод <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> для разбиения строки, содержащей подстроки, с помощью различных сочетаний дефисов и других символов.  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Шаблон регулярного выражения `\s-\s?[+*]?\s?-\s` определяется следующим образом:  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\s-`|Совпадение с символом пробела, за которым следует дефис.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`[+*]?`|Совпадение с нулем или одним вхождением символа + или *.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`-\s`|Совпадение с дефисом, за которым следует пробельный символ.|  
  
### <a name="search-methods-and-the-substring-method"></a>Методы поиска и метод substring  
 Если вы не заинтересованы во всех подстроках в строке, то можете использовать один из методов сравнения строк, возвращающих индекс, с которого начинается сопоставление. Затем можно вызвать метод <xref:System.String.Substring%2A>, чтобы извлечь нужную подстроку. Ниже перечислены методы сравнения строк.  
  
-   <xref:System.String.IndexOf%2A>, возвращающий Отсчитываемый от нуля индекс первого вхождения символа или строки в экземпляре строки.  
  
-   <xref:System.String.IndexOfAny%2A>, возвращающий Отсчитываемый от нуля индекс в текущем экземпляре строки первого вхождения любого символа в массиве символов.  
  
-   <xref:System.String.LastIndexOf%2A>, возвращающий Отсчитываемый от нуля индекс последнего вхождения символа или строки в экземпляре строки.  
  
-   <xref:System.String.LastIndexOfAny%2A>, возвращающий Отсчитываемый от нуля индекс в текущем экземпляре строки последнего вхождения любого символа в массиве символов.  
  
 В следующем примере метод <xref:System.String.IndexOf%2A> используется для поиска точек в строке. Затем он использует метод <xref:System.String.Substring%2A> для возврата полных предложений.  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Массив символов, разделяющий подстроки в данной строке, пустой массив, не содержащий разделителей, или <see langword="null" />.</param>
        <summary>Разделяет строку на подстроки в зависимости от символов в массиве разделителей.</summary>
        <returns>Массив, элементы которого содержат подстроки из этого экземпляра, разделенные символами из <paramref name="separator" />. Дополнительные сведения см. в разделе "Примечания".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если строка отделяется от известного набора символов, можно использовать метод <xref:System.String.Split%28System.Char%5B%5D%29>, чтобы разделить его на подстроки.   
  
### <a name="return-value-details"></a>Сведения о возвращаемом значении  
 Символы разделителей не включаются в элементы возвращаемого массива. Например, если массив разделителя содержит символ "-", а значение текущего экземпляра строки — "AA-BB-CC", метод возвращает массив, содержащий три элемента: "AA", "BB" и "CC".  
  
 Если этот экземпляр не содержит символов в `separator`, возвращаемый массив состоит из одного элемента, содержащего этот экземпляр.  
  
 Каждый элемент `separator` определяет отдельный символ-разделитель. Если два разделителя являются смежными или обнаружен разделитель в начале или в конце этого экземпляра, соответствующий элемент в возвращаемом массиве содержит <xref:System.String.Empty?displayProperty=nameWithtype>. Далее приводятся некоторые примеры.  
  
|Строковое значение|Separator|Возвращаемый массив|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|New char [] {', ', ' '} (C#)<br /><br /> Char () = {"," c, "" c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|New char [] {'. '} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|Банан|New char [] {'. '} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|{"Полукруглое"}|  
|"Дарб\нсмарба" (C#)<br /><br /> "Дарб" & Вблф & "Смарба" (Visual Basic)|New char [] {} (C#)<br /><br /> Char () = {} (Visual Basic)|{"Дарб", "Смарба"}|  
|"Дарб\нсмарба" (C#)<br /><br /> "Дарб" & Вблф & "Смарба" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Дарб", "Смарба"}|  
  
### <a name="the-separator-array"></a>Массив разделителя  
 Каждый элемент разделителя определяет отдельный разделитель, состоящий из одного символа. Если аргумент `separator` `null` или не содержит символов, метод рассматривает пробельные символы как разделители. Пробельные символы определяются стандартом Unicode. они возвращают `true`, если они передаются в метод <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>String. Split (char []) и разрешение перегрузки компилятора  
 Хотя один параметр для этой перегрузки <xref:System.String.Split%2A?displayProperty=nameWithType> является массивом символов, его можно вызвать с помощью одного символа, как показано в следующем примере.  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Поскольку параметр `separator` дополнен атрибутом <xref:System.ParamArrayAttribute>, компиляторы будут интерпретировать один символ как одноэлементный массив символов. Это не так для других <xref:System.String.Split%2A?displayProperty=nameWithType> перегрузок, включающих параметр `separator`; необходимо явно передать перегрузку массива символов в качестве аргумента `separator`.  
  
### <a name="comparison-details"></a>Сведения о сравнении  
 Метод <xref:System.String.Split%28System.Char%5B%5D%29> извлекает подстроки из этой строки, разделенные одним или несколькими символами в массиве `separator`, и возвращает эти подстроки как элементы массива.  
  
 Метод <xref:System.String.Split%28System.Char%5B%5D%29> ищет разделители, выполняя сравнения с использованием правил сортировки порядковых номеров с учетом регистра. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе Перечисление <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
### <a name="performance-considerations"></a>Особенности производительности  
 <xref:System.String.Split%2A> методы выделяют память для возвращаемого объекта массива и объект <xref:System.String> для каждого элемента массива. Если для приложения требуется оптимальная производительность или управление выделением памяти является критически важным в приложении, рассмотрите возможность использования метода <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>. Кроме того, можно использовать метод <xref:System.String.Compare%2A> для нахождение подстроки в строке.  
  
 Чтобы разделить строку по символу-разделителю, используйте метод <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>, чтобы указать символ-разделитель в строке. Чтобы разделить строку в строке-разделителе, используйте метод <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>, чтобы указать первый символ строки разделителя. Затем используйте метод <xref:System.String.Compare%2A>, чтобы определить, равны ли символы, указанные после первого символа, оставшимся символам строки разделителя.  
  
 Кроме того, если для разделения строк в нескольких вызовах метода <xref:System.String.Split%2A> используется один и тот же набор символов, рассмотрите возможность создания одного массива и ссылки на него в каждом вызове метода. Это значительно сокращает дополнительную нагрузку на каждый вызов метода.  
  
## Examples  
 В следующем примере показано, как извлечь отдельные слова из блока текста, рассматривая пробелы и знаки пунктуации в качестве разделителей. Массив символов, передаваемый в параметр `separator` метода <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>, состоит из символа пробела и символа табуляции вместе с некоторыми общими символами пунктуации.  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] и более ранних версиях, если метод <see cref="M:System.String.Split(System.Char[])" /> передается <paramref name="separator" />, который <see langword="null" /> или не содержит символов, метод использует слегка отличающийся набор символов для разбиения строки, чем метод <see cref="M:System.String.Trim(System.Char[])" /> для обрезки строки. Начиная с .NET Framework 4, оба метода используют идентичный набор пробельных символов Юникода.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">Символ, разделяющий подстроки в этой строке.</param>
        <param name="options">Одно из значений перечисления, определяющее, должны ли пустые подстроки исключаться из возвращаемого значения при разделении.</param>
        <summary>Разделяет строку на подстроки в соответствии с указанным символом-разделителем.</summary>
        <returns>Массив, элементы которого содержат подстроки из этого экземпляра, разделенные символом <paramref name="separator" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Массив символов, разделяющий подстроки в данной строке, пустой массив, не содержащий разделителей, или <see langword="null" />.</param>
        <param name="count">Максимальное число возвращаемых подстрок.</param>
        <summary>Разбивает строку на максимальное число подстрок в зависимости от символов в массиве. Можно также указать максимальное число возвращаемых подстрок.</summary>
        <returns>Массив, элементы которого содержат подстроки данного экземпляра, разделенные одним или более знаками из <paramref name="separator" />. Дополнительные сведения см. в разделе "Примечания".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Символы разделителей не включаются в элементы возвращаемого массива.  
  
 Если этот экземпляр не содержит символов в `separator`, возвращаемый массив состоит из одного элемента, содержащего этот экземпляр. Если `count` равен нулю, возвращается пустой массив.  
  
 Если параметр `separator` имеет значение `null` или не содержит символов, то символы пробела считаются разделителями. Символы пробела определяются стандартом Юникода и возвращают `true`, если они передаются в метод <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.  
  
 Каждый элемент `separator` определяет отдельный символ-разделитель. Если два разделителя являются смежными или обнаружен разделитель в начале или в конце данного экземпляра, соответствующий элемент массива содержит <xref:System.String.Empty?displayProperty=nameWithtype>.  
  
 Если в этом экземпляре больше `count` подстрок, то первый `count` минус 1 подстроки возвращаются в первом `count` минус 1 элемента возвращаемого значения, а остальные символы в этом экземпляре возвращаются в последнем элементе возвращаемого значения.  
  
 Если `count` больше числа подстрок, возвращаются доступные подстроки и исключение не создается.  
  
 В следующей таблице приведены примеры.  
  
|Строковое значение|Separator|Count|Возвращаемый массив|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|New char [] {', ', ' '} (C#)<br /><br /> Char () = {"," c, "" c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|New char [] {'. '} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|Банан|New char [] {'. '} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|2|{"Полукруглое"}|  
|"Дарб\нсмарба" (C#)<br /><br /> "Дарб" & Вблф & "Смарба" (Visual Basic)|New char [] {} (C#)<br /><br /> Char () = {} (Visual Basic)|1|{"Дарб\нсмарба"} (C#)<br /><br /> "Дарб" & Вблф & "Смарба" (Visual Basic)|  
|"Дарб\нсмарба" (C#)<br /><br /> "Дарб" & Вблф & "Смарба" (Visual Basic)|New char [] null (C#)<br /><br /> Char () = Nothing|2|{"Дарб", "Смарба"}|  
|"Дарб\нсмарба" (C#)<br /><br /> "Дарб" & Вблф & "Смарба" (Visual Basic)|New char [] null (C#)<br /><br /> Char () = Nothing|100|{"Дарб", "Смарба"}|  
  
### <a name="performance-considerations"></a>Особенности производительности  
 <xref:System.String.Split%2A> методы выделяют память для возвращаемого объекта массива и объект <xref:System.String> для каждого элемента массива. Если для приложения требуется оптимальная производительность или управление выделением памяти является критически важным в приложении, рассмотрите возможность использования метода <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> и, при необходимости, метода <xref:System.String.Compare%2A> для нахождение подстроки в строке.  
  
 При разделении строки в символ-разделителе используйте метод <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>, чтобы указать символ разделителя в строке. При разделении строки в строке-разделителе используйте метод <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>, чтобы указать первый символ строки разделителя. Затем используйте метод <xref:System.String.Compare%2A>, чтобы определить, равны ли символы, указанные после первого символа, оставшимся символам строки разделителя.  
  
 Кроме того, если для разделения строк в нескольких вызовах метода <xref:System.String.Split%2A> используется один и тот же набор символов, рассмотрите возможность создания одного массива и ссылки на него в каждом вызове метода. Это значительно сокращает дополнительную нагрузку на каждый вызов метода.  
  
   
  
## Examples  
 В следующем примере показано, как `count` влияет на количество строк, возвращаемых <xref:System.String.Split%2A>.  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> является отрицательным значением.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] и более ранних версиях, если метод <see cref="M:System.String.Split(System.Char[])" /> передается <paramref name="separator" />, который <see langword="null" /> или не содержит символов, метод использует слегка отличающийся набор символов для разбиения строки, чем метод <see cref="M:System.String.Trim(System.Char[])" /> для обрезки строки. Начиная с .NET Framework 4, оба метода используют идентичный набор пробельных символов Юникода.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Массив символов, разделяющий подстроки в данной строке, пустой массив, не содержащий разделителей, или <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, чтобы исключить пустые элементы из возвращаемого массива; или <see cref="F:System.StringSplitOptions.None" /> для включения пустых элементов в возвращаемый массив.</param>
        <summary>Разбивает строку на подстроки в зависимости от символов в массиве. Можно указать, включают ли подстроки пустые элементы массива.</summary>
        <returns>Массив, элементы которого содержат подстроки данной строки, разделенные одним или более знаками из <paramref name="separator" />. Дополнительные сведения см. в разделе "Примечания".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Сведения о возвращаемом значении  
 Символы-разделители (символы в массиве `separator`) не включаются в элементы возвращаемого массива. Например, если массив `separator` содержит символ "-", а значение текущего экземпляра строки — "AA-BB-CC", метод возвращает массив, содержащий три элемента: "AA", "BB" и "CC".  
  
 Если этот экземпляр не содержит символов в `separator`, возвращаемый массив состоит из одного элемента, содержащего этот экземпляр.  
  
 Если параметр `options` имеет значение <xref:System.StringSplitOptions.RemoveEmptyEntries> и длина этого экземпляра равна нулю, метод возвращает пустой массив.  
  
 Каждый элемент `separator` определяет отдельный разделитель, состоящий из одного символа. Если аргумент `options` <xref:System.StringSplitOptions.None>, а два разделителя являются смежными или в начале или в конце этого экземпляра обнаружен разделитель, то соответствующий элемент массива содержит <xref:System.String.Empty?displayProperty=nameWithType>. Например, если `separator` включает два элемента: "-" и "\_", значение экземпляра строки — "-\_AA-\_", а значение аргумента `options` — <xref:System.StringSplitOptions.None>, метод возвращает массив строк со следующими пятью элементами :  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, представляющий пустую строку, предшествующую символу "-" с индексом 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, представляющий пустую строку между символом "-" в индексе 0 и символом "_" в индексе 1.  
  
3.  "AA",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, представляющий пустую строку, следующую за символом "_" в индексе 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, представляющий пустую строку, которая соответствует символу "-" в индексе 5.  
  
### <a name="the-separator-array"></a>Массив разделителя  
 Если параметр `separator` имеет значение `null` или не содержит символов, то символы пробела считаются разделителями. Символы пробела определяются стандартом Юникода и возвращают `true`, если они передаются в метод <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.  
  
 Если параметр `separator` в вызове этой перегруженной версии метода имеет значение `null`, разрешение перегрузки компилятора завершается ошибкой. Чтобы однозначно определить вызываемый метод, код должен указывать тип `null`. В следующем примере показано несколько способов однозначного определения этой перегрузки.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>Сведения о сравнении  
 Метод <xref:System.String.Split%2A> извлекает подстроки из этой строки, разделенные одним или несколькими символами в параметре `separator`, и возвращает эти подстроки как элементы массива.  
  
 Метод <xref:System.String.Split%2A> ищет разделители, выполняя сравнения с использованием правил сортировки порядковых номеров с учетом регистра. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе Перечисление <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
### <a name="performance-considerations"></a>Особенности производительности  
 <xref:System.String.Split%2A> методы выделяют память для возвращаемого объекта массива и объект <xref:System.String> для каждого элемента массива. Если для приложения требуется оптимальная производительность или управление выделением памяти является критически важным в приложении, рассмотрите возможность использования метода <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> и, при необходимости, метода <xref:System.String.Compare%2A> для нахождение подстроки в строке.  
  
 При разделении строки в символ-разделителе используйте метод <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>, чтобы указать символ разделителя в строке. При разделении строки в строке-разделителе используйте метод <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>, чтобы указать первый символ строки разделителя. Затем используйте метод <xref:System.String.Compare%2A>, чтобы определить, равны ли символы, указанные после первого символа, оставшимся символам строки разделителя.  
  
 Кроме того, если для разделения строк в нескольких вызовах метода <xref:System.String.Split%2A> используется один и тот же набор символов, рассмотрите возможность создания одного массива и ссылки на него в каждом вызове метода. Это значительно сокращает дополнительную нагрузку на каждый вызов метода.  
  
   
  
## Examples  
 В следующем примере используется перечисление <xref:System.StringSplitOptions> для включения или исключения подстрок, созданных методом <xref:System.String.Split%2A>.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> не является одним из значений <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] и более ранних версиях, если метод <see cref="M:System.String.Split(System.Char[])" /> передается <paramref name="separator" />, который <see langword="null" /> или не содержит символов, метод использует слегка отличающийся набор символов для разбиения строки, чем метод <see cref="M:System.String.Trim(System.Char[])" /> для обрезки строки. Начиная с .NET Framework 4, оба метода используют идентичный набор пробельных символов Юникода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">Строка, разделяющая подстроки в этой строке.</param>
        <param name="options">Одно из значений перечисления, определяющее, должны ли пустые подстроки исключаться из возвращаемого значения при разделении.</param>
        <summary>Разделяет строку на подстроки в соответствии с указанной строкой-разделителем.</summary>
        <returns>Массив, элементы которого содержат подстроки из этого экземпляра, разделенные символом <paramref name="separator" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Массив строк, разделяющих подстроки в данной строке, пустой массив, не содержащий разделителей, или <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, чтобы исключить пустые элементы из возвращаемого массива; или <see cref="F:System.StringSplitOptions.None" /> для включения пустых элементов в возвращаемый массив.</param>
        <summary>Разбивает строку на подстроки в зависимости от строк в массиве. Можно указать, включают ли подстроки пустые элементы массива.</summary>
        <returns>Массив, элементы которого содержат подстроки данной строки, разделенные одной или более строками из <paramref name="separator" />. Дополнительные сведения см. в разделе "Примечания".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если строка отделяется от известного набора строк, можно использовать метод <xref:System.String.Split%2A>, чтобы разделить его на подстроки.  
  
### <a name="return-value-details"></a>Сведения о возвращаемом значении  
 Строки разделителей не включаются в элементы возвращаемого массива. Например, если массив `separator` содержит строку "--", а значение текущего экземпляра строки — "AA--BB-CC", метод возвращает массив, содержащий три элемента: "AA", "BB" и "CC".  
  
 Если этот экземпляр не содержит строк в `separator`, возвращаемый массив состоит из одного элемента, содержащего этот экземпляр.  
  
 Если параметр `options` имеет значение <xref:System.StringSplitOptions.RemoveEmptyEntries> и длина этого экземпляра равна нулю, метод возвращает пустой массив.  
  
 Каждый элемент `separator` определяет отдельный разделитель, состоящий из одного или нескольких символов. Если аргумент `options` <xref:System.StringSplitOptions.None>, а два разделителя являются смежными или в начале или в конце этого экземпляра обнаружен разделитель, то соответствующий элемент массива содержит <xref:System.String.Empty?displayProperty=nameWithType>. Например, если `separator` включает два элемента: "-" и "\_", значение экземпляра строки — "-\_AA-\_", а значение аргумента `options` — <xref:System.StringSplitOptions.None>, метод возвращает массив проверочного со следующими пятью элементами. :  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, представляющий пустую строку, предшествующую подстроке "-" с индексом 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, представляющий пустую строку между подстрокой "-" с индексом 0 и подстрокой "_" с индексом 1.  
  
3.  "AA",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, представляющий пустую строку, следующую за подстрокой "_" с индексом 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, представляющий пустую строку, следующую за подстрокой «-» с индексом 5.  
  
### <a name="the-separator-array"></a>Массив разделителя  
 Если любой из элементов в `separator` состоит из нескольких символов, вся подстрока считается разделителем. Например, если один из элементов в `separator` равен 10, попытка разделить строку «This10is10a10string». Возвращает следующий массив из четырех элементов: {"this", "имеет значение", "a", "строка". }.  
  
 Если параметр `separator` имеет значение `null` или не содержит символов, то символы пробела считаются разделителями. Символы пробела определяются стандартом Юникода и возвращают `true`, если они передаются в метод <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.  
  
 Если параметр `separator` в вызове этой перегруженной версии метода имеет значение `null`, разрешение перегрузки компилятора завершается ошибкой. Чтобы однозначно определить вызываемый метод, код должен указывать тип `null`. В следующем примере показано несколько способов однозначного определения этой перегрузки.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>Сведения о сравнении  
 Метод <xref:System.String.Split%2A> извлекает подстроки из этой строки, разделенные одной или несколькими строками в параметре `separator`, и возвращает эти подстроки как элементы массива.  
  
 Метод <xref:System.String.Split%2A> ищет разделители, выполняя сравнения с использованием правил сортировки порядковых номеров с учетом регистра. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе Перечисление <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Метод <xref:System.String.Split%2A> игнорирует любой элемент `separator`, значение которого равно `null`, или пустую строку ("").  
  
 Чтобы избежать неоднозначных результатов, когда строки в `separator` содержат общие символы, <xref:System.String.Split%2A> операция продолжается от начала до конца значения экземпляра и соответствует первому элементу в `separator`, который равен разделителю в экземпляре. Порядок, в котором подстроки встречаются в экземпляре, имеет приоритет над порядком элементов в `separator`.  
  
 Например, рассмотрим экземпляр, значение которого равно «abcdef». Если первый элемент в `separator` был "EF", а второй элемент — "bcde", результатом операции разбиения будет массив строк, содержащий два элемента: "a" и "f". Это обусловлено тем, что обнаружена подстрока в экземпляре «bcde» и соответствует элементу в `separator` перед тем, как будет обнаружена подстрока «f».  
  
 Однако, если первый элемент `separator` был "BCD", а второй элемент был "BC", результатом операции разбиения будет массив строк, содержащий два элемента: "a" и "EF". Это происходит потому, что "BCD" является первым разделителем в `separator`, который соответствует разделителю в экземпляре. Если порядок разделителей был реверсирован, так что первый элемент был "BC", а второй — "BCD", результатом будет массив строк, содержащий два элемента: "a" и "def".  
  
### <a name="performance-considerations"></a>Особенности производительности  
 <xref:System.String.Split%2A> методы выделяют память для возвращаемого объекта массива и объект <xref:System.String> для каждого элемента массива. Если для приложения требуется оптимальная производительность или управление выделением памяти является критически важным в приложении, рассмотрите возможность использования метода <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> и, при необходимости, метода <xref:System.String.Compare%2A> для нахождение подстроки в строке.  
  
 При разделении строки в символ-разделителе используйте метод <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>, чтобы указать символ разделителя в строке. При разделении строки в строке-разделителе используйте метод <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>, чтобы указать первый символ строки разделителя. Затем используйте метод <xref:System.String.Compare%2A>, чтобы определить, равны ли символы, указанные после первого символа, оставшимся символам строки разделителя.  
  
 Кроме того, если для разделения строк в нескольких вызовах метода <xref:System.String.Split%2A> используется один и тот же набор символов, рассмотрите возможность создания одного массива и ссылки на него в каждом вызове метода. Это значительно сокращает дополнительную нагрузку на каждый вызов метода.  
  
   
  
## Examples  
 В следующем примере показана разница в массивах, возвращаемых путем вызова метода <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> строки с параметром `options`, равным <xref:System.StringSplitOptions.None?displayProperty=nameWithType> и <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 В следующем примере определяется массив разделителей, включающих знаки препинания и пробелы. Передача этого массива вместе со значением <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> в метод <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> возвращает массив, состоящий из отдельных слов из строки.  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Обратите внимание, что метод вызывается с аргументом `options`, для которого задано значение <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>. Это предотвращает включение в возвращаемый массив значений <xref:System.String.Empty?displayProperty=nameWithType>, представляющих пустые подстроки, совпадающие между знаками препинания и пробелами.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> не является одним из значений <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] и более ранних версиях, если метод <see cref="M:System.String.Split(System.Char[])" /> передается <paramref name="separator" />, который <see langword="null" /> или не содержит символов, метод использует слегка отличающийся набор символов для разбиения строки, чем метод <see cref="M:System.String.Trim(System.Char[])" /> для обрезки строки. Начиная с .NET Framework 4, оба метода используют идентичный набор пробельных символов Юникода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">Символ, разделяющий подстроки в этом экземпляре.</param>
        <param name="count">Максимальное количество элементов в массиве.</param>
        <param name="options">Одно из значений перечисления, определяющее, должны ли пустые подстроки исключаться из возвращаемого значения при разделении.</param>
        <summary>Разделяет строку на максимальное количество подстрок в соответствии с указанным символом-разделителем.</summary>
        <returns>Массив, элементы которого содержат максимум <paramref name="count" /> подстрок из этого экземпляра, разделенных символом <paramref name="separator" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Если строка уже была разбита `count`-1 раз, но конец строки не был достигнут, последняя строка в возвращенном массиве будет содержать оставшуюся конечную подстроку этого экземпляра без вмешательства пользователя.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Массив символов, разделяющий подстроки в данной строке, пустой массив, не содержащий разделителей, или <see langword="null" />.</param>
        <param name="count">Максимальное число возвращаемых подстрок.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, чтобы исключить пустые элементы из возвращаемого массива; или <see cref="F:System.StringSplitOptions.None" /> для включения пустых элементов в возвращаемый массив.</param>
        <summary>Разбивает строку на максимальное число подстрок в зависимости от символов в массиве.</summary>
        <returns>Массив, элементы которого содержат подстроки данной строки, разделенные одним или более знаками из <paramref name="separator" />. Дополнительные сведения см. в разделе "Примечания".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Символы разделителей не включаются в элементы возвращаемого массива.  
  
 Если этот экземпляр не содержит символов в `separator`или параметр `count` равен 1, то возвращаемый массив состоит из одного элемента, содержащего этот экземпляр. Если параметр `separator` имеет значение `null` или не содержит символов, то символы пробела считаются разделителями. Символы пробела определяются стандартом Юникода и возвращают `true`, если они передаются в метод <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>. Однако если параметр `separator` в вызове этой перегрузки метода имеет `null`, разрешение перегрузки компилятора завершается ошибкой. Чтобы однозначно определить вызываемый метод, код должен указывать тип значения NULL. В следующем примере показано несколько способов однозначного определения этой перегрузки.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Если параметр `count` равен нулю или параметр `options` имеет значение <xref:System.StringSplitOptions.RemoveEmptyEntries> и длина этого экземпляра равна нулю, возвращается пустой массив.  
  
 Каждый элемент `separator` определяет отдельный символ-разделитель. Если параметр `options` имеет значение <xref:System.StringSplitOptions.None>, а два разделителя являются смежными или в начале или в конце этого экземпляра обнаружен разделитель, то соответствующий элемент массива содержит <xref:System.String.Empty?displayProperty=nameWithtype>.  
  
 Если в этом экземпляре больше `count` подстрок, то первый `count` минус 1 подстроки возвращаются в первом `count` минус 1 элемента возвращаемого значения, а остальные символы в этом экземпляре возвращаются в последнем элементе возвращаемого значения.  
  
 Если `count` больше числа подстрок, возвращаются доступные подстроки и исключение не создается.  
  
### <a name="performance-considerations"></a>Особенности производительности  
 <xref:System.String.Split%2A> методы выделяют память для возвращаемого объекта массива и объект <xref:System.String> для каждого элемента массива. Если для приложения требуется оптимальная производительность или управление выделением памяти является критически важным в приложении, рассмотрите возможность использования метода <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> и, при необходимости, метода <xref:System.String.Compare%2A> для нахождение подстроки в строке.  
  
 При разделении строки в символ-разделителе используйте метод <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>, чтобы указать символ разделителя в строке. При разделении строки в строке-разделителе используйте метод <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>, чтобы указать первый символ строки разделителя. Затем используйте метод <xref:System.String.Compare%2A>, чтобы определить, равны ли символы, указанные после первого символа, оставшимся символам строки разделителя.  
  
 Кроме того, если для разделения строк в нескольких вызовах метода <xref:System.String.Split%2A> используется один и тот же набор символов, рассмотрите возможность создания одного массива и ссылки на него в каждом вызове метода. Это значительно сокращает дополнительную нагрузку на каждый вызов метода.  
  
   
  
## Examples  
 В следующем примере используется перечисление <xref:System.StringSplitOptions> для включения или исключения подстрок, созданных методом <xref:System.String.Split%2A>.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> не является одним из значений <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] и более ранних версиях, если метод <see cref="M:System.String.Split(System.Char[])" /> передается <paramref name="separator" />, который <see langword="null" /> или не содержит символов, метод использует слегка отличающийся набор символов для разбиения строки, чем метод <see cref="M:System.String.Trim(System.Char[])" /> для обрезки строки. Начиная с .NET Framework 4, оба метода используют идентичный набор пробельных символов Юникода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">Строка, разделяющая подстроки в этом экземпляре.</param>
        <param name="count">Максимальное количество элементов в массиве.</param>
        <param name="options">Одно из значений перечисления, определяющее, должны ли пустые подстроки исключаться из возвращаемого значения при разделении.</param>
        <summary>Разделяет строку на максимальное количество подстрок в соответствии с указанной строкой-разделителем.</summary>
        <returns>Массив, элементы которого содержат максимум <paramref name="count" /> подстрок из этого экземпляра, разделенных символом <paramref name="separator" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Если строка уже была разбита `count`-1 раз, но конец строки не был достигнут, последняя строка в возвращенном массиве будет содержать оставшуюся конечную подстроку этого экземпляра без вмешательства пользователя.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Массив строк, разделяющих подстроки в данной строке, пустой массив, не содержащий разделителей, или <see langword="null" />.</param>
        <param name="count">Максимальное число возвращаемых подстрок.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, чтобы исключить пустые элементы из возвращаемого массива; или <see cref="F:System.StringSplitOptions.None" /> для включения пустых элементов в возвращаемый массив.</param>
        <summary>Разбивает строку на максимальное число подстрок в зависимости от строк в массиве. Можно указать, включают ли подстроки пустые элементы массива.</summary>
        <returns>Массив, элементы которого содержат подстроки данной строки, разделенные одной или более строками из <paramref name="separator" />. Дополнительные сведения см. в разделе "Примечания".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Сведения о возвращаемом значении  
 Строки разделителей не включаются в элементы возвращаемого массива.  
  
 Если этот экземпляр не содержит строк в `separator`или параметр `count` равен 1, то возвращаемый массив состоит из одного элемента, содержащего этот экземпляр. Если параметр `separator` имеет значение `null` или не содержит символов, то символы пробела считаются разделителями. Символы пробела определяются стандартом Юникода и возвращают `true`, если они передаются в метод <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>. Однако если параметр `separator` в вызове этой перегрузки метода имеет `null`, разрешение перегрузки компилятора завершается ошибкой. Чтобы однозначно определить вызываемый метод, код должен указывать тип `null`. В следующем примере показано несколько способов однозначного определения этой перегрузки.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Если параметр `count` равен нулю или параметр `options` имеет значение <xref:System.StringSplitOptions.RemoveEmptyEntries> и длина этого экземпляра равна нулю, возвращается пустой массив.  
  
 Каждый элемент `separator` определяет отдельный разделитель, состоящий из одного или нескольких символов. Если параметр `options` имеет значение <xref:System.StringSplitOptions.None>, а два разделителя являются смежными или в начале или в конце этого экземпляра обнаружен разделитель, то соответствующий элемент массива содержит <xref:System.String.Empty?displayProperty=nameWithtype>.  
  
 Если в этом экземпляре больше `count` подстрок, то первый `count` минус 1 подстроки возвращаются в первом `count` минус 1 элемента возвращаемого значения, а остальные символы в этом экземпляре возвращаются в последнем элементе возвращаемого значения.  
  
 Если `count` больше числа подстрок, возвращаются доступные подстроки и исключение не создается.  
  
### <a name="the-separator-array"></a>Массив разделителя  
 Если любой из элементов в `separator` состоит из нескольких символов, вся подстрока считается разделителем. Например, если один из элементов в `separator` равен 10, попытка разделить строку «This10is10a10string». Возвращает этот массив из четырех элементов: {"this", "имеет значение", "a", "строка". }.  
  
### <a name="comparison-details"></a>Сведения о сравнении  
 Метод <xref:System.String.Split%2A> извлекает подстроки из этой строки, разделенные одной или несколькими строками в параметре `separator`, и возвращает эти подстроки как элементы массива.  
  
 Метод <xref:System.String.Split%2A> ищет разделители, выполняя сравнения с использованием правил сортировки порядковых номеров с учетом регистра. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе Перечисление <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Метод <xref:System.String.Split%2A> игнорирует любой элемент `separator`, значение которого равно `null`, или пустую строку ("").  
  
 Чтобы избежать неоднозначных результатов, когда строки в `separator` содержат общие символы, метод <xref:System.String.Split%2A> переходит от начала к концу значения экземпляра и соответствует первому элементу в `separator`, который равен разделителю в экземпляре. Порядок, в котором подстроки встречаются в экземпляре, имеет приоритет над порядком элементов в `separator`.  
  
 Например, рассмотрим экземпляр, значение которого равно «abcdef». Если первый элемент в `separator` был "EF", а второй элемент — "bcde", результатом операции разбиения будет "a" и "f". Это обусловлено тем, что обнаружена подстрока в экземпляре «bcde» и соответствует элементу в `separator` перед тем, как будет обнаружена подстрока «f».  
  
 Однако, если первый элемент `separator` был "BCD", а второй элемент — "BC", результатом операции разбиения будет "a" и "EF". Это происходит потому, что "BCD" является первым разделителем в `separator`, который соответствует разделителю в экземпляре. Если порядок разделителей был реверсирован, так что первый элемент был "BC", а второй элемент — "BCD", результатом будет "a" и "def".  
  
### <a name="performance-considerations"></a>Особенности производительности  
 <xref:System.String.Split%2A> методы выделяют память для возвращаемого объекта массива и объект <xref:System.String> для каждого элемента массива. Если для приложения требуется оптимальная производительность или управление выделением памяти является критически важным в приложении, рассмотрите возможность использования метода <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> и, при необходимости, метода <xref:System.String.Compare%2A> для нахождение подстроки в строке.  
  
 При разделении строки в символ-разделителе используйте метод <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>, чтобы указать символ разделителя в строке. При разделении строки в строке-разделителе используйте метод <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>, чтобы указать первый символ строки разделителя. Затем используйте метод <xref:System.String.Compare%2A>, чтобы определить, равны ли символы, указанные после первого символа, оставшимся символам строки разделителя.  
  
 Кроме того, если для разделения строк в нескольких вызовах метода <xref:System.String.Split%2A> используется один и тот же набор символов, рассмотрите возможность создания одного массива и ссылки на него в каждом вызове метода. Это значительно сокращает дополнительную нагрузку на каждый вызов метода.  
  
   
  
## Examples  
 В следующем примере используется перечисление <xref:System.StringSplitOptions> для включения или исключения подстрок, созданных методом <xref:System.String.Split%2A>.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> не является одним из значений <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] и более ранних версиях, если метод <see cref="M:System.String.Split(System.Char[])" /> передается <paramref name="separator" />, который <see langword="null" /> или не содержит символов, метод использует слегка отличающийся набор символов для разбиения строки, чем метод <see cref="M:System.String.Trim(System.Char[])" /> для обрезки строки. Начиная с .NET Framework 4, оба метода используют идентичный набор пробельных символов Юникода.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, совпадает ли начало данного экземпляра строки с указанной строкой.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Сравниваемый символ.</param>
        <summary>Определяет, начинается ли данный экземпляр строки с указанного символа.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> соответствует началу данной строки; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод выполняет сравнение по словам (с учетом регистра и с учетом языка и региональных параметров), используя текущий язык и региональные параметры.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка, подлежащая сравнению.</param>
        <summary>Определяет, совпадает ли начало данного экземпляра строки с указанной строкой.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> соответствует началу данной строки; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод сравнивает `value` с подстрокой в начале этого экземпляра, которая имеет ту же длину, что и `value`, и возвращает значение, указывающее, равны ли они. Значение `value` должно быть равно пустой строке (<xref:System.String.Empty?displayProperty=nameWithType>), должно быть ссылкой на этот же экземпляр или должно соответствовать началу этого экземпляра.

Этот метод выполняет сравнение по словам (с учетом регистра и с учетом языка и региональных параметров), используя текущий язык и региональные параметры.

## Examples

В следующем примере определяется метод `StripStartTags`, использующий метод <xref:System.String.StartsWith%28System.String%29> для удаления открывающих тегов HTML из начала строки. Обратите внимание, что метод `StripStartTags` вызывается рекурсивно, чтобы гарантировать удаление нескольких открывающих тегов HTML в начале строки. В этом примере не удаляются HTML-теги, внедренные в строку.

[!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
[!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
[!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Как описано в статье рекомендации [по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию, а вызывают методы, для которых требуется явно указать параметры. Чтобы определить, начинается ли строка с определенной подстроки с помощью правил сравнения строк текущего языка и региональных параметров, вызовите перегрузку метода <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его параметра <paramref name="comparisonType" />.</para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка, подлежащая сравнению.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее способ сравнения данной строки со значением <paramref name="value" />.</param>
        <summary>Определяет, совпадает ли начало этого экземпляра строки с заданной строкой при сравнении с учетом заданного параметра сравнения.</summary>
        <returns>Значение <see langword="true" />, если данный экземпляр начинается со значения <paramref name="value" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.String.StartsWith%2A> сравнивает параметр `value` с подстрокой в начале этой строки и возвращает значение, указывающее, равны ли они. Чтобы быть равным, `value` должен быть ссылкой на эту же строку, должен быть пустой строкой ("") или совпадать с началом этой строки. Тип сравнения, выполняемого методом <xref:System.String.StartsWith%2A>, зависит от значения параметра `comparisonType`. Сравнение может использовать соглашения текущего языка и региональных параметров (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> и <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) или инвариантный язык и региональные параметры (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> и <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>) либо может состоять из символьно-символьного сравнения кодовых точек (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> или <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). При сравнении можно также использовать регистр (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>или <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>) или игнорировать регистр (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 В следующем примере выполняется поиск строки «The» в начале более длинной строки, которая начинается со слова «The». Как видно из выходных данных в примере, вызов метода <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29>, который выполняет сравнение с учетом языка и региональных параметров без учета регистра, не соответствует строке, а вызов, выполняющий сравнение с учетом языка и региональных параметров и без учета регистра, соответствует строке.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 В следующем примере определяется, начинается ли строка с определенной подстроки. Он инициализирует двумерный массив строк. Первый элемент во втором измерении содержит строку, а второй элемент содержит строку для поиска в начале первой строки. На результаты влияют выбранные язык и региональные параметры, учитывается ли регистр и выполняется ли порядковое сравнение. Обратите внимание, что, когда экземпляр строки содержит лигатуру, сравнения, учитывающие культуру, с последовательными символами успешно совпадают.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является значением <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Строка, подлежащая сравнению.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при сравнении; в противном случае — значение <see langword="false" />.</param>
        <param name="culture">Связанные с языком и региональными параметрами сведения, определяющие, как выполняется сравнение этой строки и <paramref name="value" />. Если значением параметра <paramref name="culture" /> является <see langword="null" />, используется текущий язык и региональные параметры.</param>
        <summary>Определяет, совпадает ли начало экземпляра строки с заданной строкой при сравнении с учетом заданного языка и региональных параметров.</summary>
        <returns><see langword="true" />, если параметр <paramref name="value" /> соответствует началу данной строки; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод сравнивает параметр `value` с подстрокой в начале этой строки, которая имеет ту же длину, что и `value`, и возвращает значение, указывающее, равны ли они. Значение `value` должно быть равно пустой строке (<xref:System.String.Empty?displayProperty=nameWithType>), должно быть ссылкой на этот же экземпляр или должно соответствовать началу этого экземпляра.  
  
 Этот метод выполняет сравнение с использованием указанного регистра и языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере определяется, происходит ли строка в начале другой строки. Метод <xref:System.String.StartsWith%2A> вызывается несколько раз при использовании чувствительности к регистру, нечувствительности к регистру и различных культур, влияющих на результаты поиска.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Извлекает подстроку из данного экземпляра.  
  
 Этот член перегружен. Для получения полной информации о данном члене, включая синтаксис, использование и примеры, щелкните имя в списке перегрузок.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Отсчитываемая от нуля позиция первого знака подстроки в данном экземпляре.</param>
        <summary>Извлекает подстроку из данного экземпляра. Подстрока начинается в указанном положении символов и продолжается до конца строки.</summary>
        <returns>Строка, эквивалентная подстроке, которая начинается с <paramref name="startIndex" /> в данном экземпляре, или <see cref="F:System.String.Empty" />, если значение <paramref name="startIndex" /> равно длине данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.String.Substring%28System.Int32%29> вызывается для извлечения подстроки из строки, которая начинается с указанной позиции символа и заканчивается в конце строки. Начальная позиции символа начинается с нуля; Иными словами, первый символ в строке находится по индексу 0, а не к индексу 1. Чтобы извлечь подстроку, которая начинается с указанной позиции символа и заканчивается до конца строки, вызовите метод <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, которая начинается с позиции `startIndex` в текущей строке.  
  
 Чтобы извлечь подстроку, которая начинается с определенного символа или последовательности символов, вызовите метод, например <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOf%2A>, чтобы получить значение `startIndex`. Во втором примере это показано. Он извлекает значение ключа, которое начинается с одной позиции символа после символа "=".  
  
 Если `startIndex` равен нулю, метод возвращает исходную строку без изменений.  
   
  
## Examples  
 В следующем примере показано получение подстроки из строки.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 В следующем примере метод <xref:System.String.Substring%2A> используется для разделения пар "ключ-значение", разделенных символом равенства ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Метод <xref:System.String.IndexOf%2A> используется для получения позиции знака равенства в строке. Вызов метода <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> извлекает имя ключа, которое начинается с первого символа в строке и расширяется для количества символов, возвращаемых при вызове метода <xref:System.String.IndexOf%2A>. Затем вызов метода <xref:System.String.Substring%28System.Int32%29> извлекает значение, присвоенное ключу. Он начинается с одной позиции символа за знаком равенства и расширяется до конца строки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Отсчитываемая от нуля позиция первого знака подстроки в данном экземпляре.</param>
        <param name="length">Число символов в подстроке.</param>
        <summary>Извлекает подстроку из данного экземпляра. Подстрока начинается с указанной позиции знака и имеет указанную длину.</summary>
        <returns>Строка, эквивалентная подстроке длиной <paramref name="length" />, которая начинается с <paramref name="startIndex" /> в данном экземпляре, или <see cref="F:System.String.Empty" />, если значение <paramref name="startIndex" /> равно длине данного экземпляра, а значение <paramref name="length" /> равно нулю.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> вызывается для извлечения подстроки из строки, которая начинается с указанной позиции символа и заканчивается до конца строки. Начальная позиции символа начинается с нуля; Иными словами, первый символ в строке находится по индексу 0, а не к индексу 1. Чтобы извлечь подстроку, которая начинается с указанной позиции символа и продолжается до конца строки, вызовите метод <xref:System.String.Substring%28System.Int32%29>.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку с `length` символами, начиная с положения `startIndex` в текущей строке.  
  
 Параметр `length` представляет общее число символов, извлекаемых из текущего экземпляра строки. Сюда входит начальный символ, найденный по индексу `startIndex`.  Иными словами, метод <xref:System.String.Substring%2A> пытается извлечь символы из `startIndex` индекса в индекс `startIndex` + `length`-1.  
  
 Чтобы извлечь подстроку, которая начинается с определенного символа или последовательности символов, вызовите метод, например <xref:System.String.IndexOf%2A> или <xref:System.String.LastIndexOf%2A>, чтобы получить значение `startIndex`.  
  
 Если подстрока расширяется с `startIndex` на указанную последовательность символов, можно вызвать метод, например <xref:System.String.IndexOf%2A>, или <xref:System.String.LastIndexOf%2A>, чтобы получить индекс конечного символа или последовательности символов.  Затем это значение можно преобразовать в индекс в строке следующим образом:  
  
-   Если вы искали один символ, который помечает конец подстроки, `length` параметр равен `endIndex` - `startIndex` + 1, где `endIndex` является возвращаемым значением метода <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOf%2A>. В следующем примере извлекается непрерывный блок символов "b" из строки.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Если вы искали несколько символов, которые помечают конец подстроки, `length` параметр равен `endIndex` + `endMatchLength` - `startIndex`, где `endIndex` является возвращаемым значением метода <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOf%2A> , а `endMatchLength` — это длина последовательности символов, отмечающая конец подстроки. В следующем примере извлекается блок текста, содержащий элемент `<definition>` XML.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Если символ или последовательность символов не включена в конец подстроки, то параметр `length` равен `endIndex` - `startIndex`, где `endIndex` является возвращаемым значением метода <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOf%2A>.  
  
 Если `startIndex` равен нулю и равна длине текущей строки, метод возвращает исходную строку без изменений.  
  
   
  
## Examples  
 В следующем примере показан простой вызов метода <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>, который извлекает два символа из строки, начиная с шестой позиции символа (то есть в индексе пять).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 В следующем примере метод <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> используется в следующих трех случаях для изоляции подстрок в строке. В двух случаях подстроки используются в сравнениях, а в третьем случае возникает исключение, так как указаны недопустимые параметры.  
  
-   Он извлекает один и третий позиции в строке (с индексом 2) и сравнивает его с символом "c". Это сравнение возвращает `true`.  
  
-   Он извлекает ноль символов, начиная с четвертой позиции в строке (с индексом 3) и передает ее методу <xref:System.String.IsNullOrEmpty%2A>. Это возвращает значение true, поскольку вызов метода <xref:System.String.Substring%2A> возвращает <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Он пытается извлечь один символ, начиная с четвертой позиции в строке. Так как в этой позиции нет символа, вызов метода вызывает исключение <xref:System.ArgumentOutOfRangeException>.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 В следующем примере метод <xref:System.String.Substring%2A> используется для разделения пар "ключ-значение", разделенных символом равенства ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Метод <xref:System.String.IndexOf%2A> используется для получения позиции знака равенства в строке. Вызов метода <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> извлекает имя ключа, которое начинается с первого символа в строке и расширяется для количества символов, возвращаемых при вызове метода <xref:System.String.IndexOf%2A>. Затем вызов метода <xref:System.String.Substring%28System.Int32%29> извлекает значение, присвоенное ключу. Он начинается с одной позиции символа за знаком равенства и расширяется до конца строки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> плюс <paramref name="length" /> указывает на позицию за пределами данного экземпляра.  
  
- или - 
 Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, выполняющий перебор элементов текущего объекта <see cref="T:System.String" />.</summary>
        <returns>Строго типизированный перечислитель, который можно использовать для перебора элементов текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Его можно использовать только в том случае, если экземпляр <xref:System.String> приводится к объекту интерфейса <xref:System.Collections.Generic.IEnumerable%601>. Дополнительные сведения см. в описании метода <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, выполняющий перебор элементов текущего объекта <see cref="T:System.String" />.</summary>
        <returns>Перечислитель, который можно использовать для перебора элементов текущей строки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.Collections.IEnumerable>. Дополнительные сведения см. в описании метода <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">Объект, имеющий значение <see cref="T:System.String" />.</param>
        <summary>Сравнивает данный экземпляр с указанным объектом <see cref="T:System.Object" /> и показывает, расположен ли экземпляр перед, после или в той же позиции в порядке сортировки, что и заданный объект <see cref="T:System.Object" />.</summary>
        <returns>32-битовое целое число со знаком, которое показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и параметр <paramref name="value" />.

          <list type="table">
            <listheader>
              <term>Значение</term>
              <description>Условие</description>
            </listheader>
            <item>
              <term>Меньше нуля</term>
              <description>Данный экземпляр предшествует параметру <paramref name="value" />.</description>
            </item>
            <item>
              <term>Нуль</term>
              <description>Данный экземпляр имеет ту же позицию в порядке сортировки, что и <paramref name="value" />.</description>
            </item>
            <item>
              <term>Больше нуля</term>
              <description>Данный экземпляр стоит после параметра <paramref name="value" />.

- или -

                Свойство <paramref name="value" /> имеет значение <see langword="null" />.</description>
            </item>
          </list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`value` должен быть <xref:System.String>ным объектом.

> [!CAUTION]
>  Метод <xref:System.String.CompareTo%2A> был разработан главным образом для использования в операциях сортировки или алфабетизинг. Его не следует использовать, когда основной целью вызова метода является определение того, эквивалентны ли две строки. Чтобы определить, эквивалентны ли две строки, вызовите метод <xref:System.String.Equals%2A>.

Этот метод выполняет сравнение по словам (с учетом регистра и с учетом языка и региональных параметров), используя текущий язык и региональные параметры. Дополнительные сведения о сортировке по словам, строкам и порядковым номерам см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.

Дополнительные сведения о поведении этого метода см. в разделе "Примечания" метода <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType>.

## Examples

В следующем примере метод <xref:System.String.CompareTo%2A> используется с <xref:System.Object>. Поскольку он пытается сравнить экземпляр <xref:System.String> с `TestClass`ным объектом, метод создает исключение <xref:System.ArgumentException>.

[!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
[!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
[!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> не является объектом <see cref="T:System.String" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.TypeCode" /> для класса <see cref="T:System.String" />.</summary>
        <returns>Константа перечислимого типа, <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples

В следующем примере отображается константа перечисления <xref:System.TypeCode> для типа <xref:System.String>.

[!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
[!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
[!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" />, если значение текущей строки равно <see cref="F:System.Boolean.TrueString" />; <see langword="false" />, если значение текущей строки равно <see cref="F:System.Boolean.FalseString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущей строки не равно <see cref="F:System.Boolean.TrueString" /> или <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число больше <see cref="F:System.Byte.MaxValue" /> или меньше <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Знак с индексом 0 в текущем объекте <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число меньше <see cref="F:System.Decimal.MinValue" /> или больше <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число меньше <see cref="F:System.Double.MinValue" /> или больше <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число больше <see cref="F:System.Int16.MaxValue" /> или меньше <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число больше <see cref="F:System.SByte.MaxValue" /> или меньше <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.

- или -

Значение <see langword="null" /> для использования соглашений о форматировании текущих языка и региональных параметров.</param>
        <summary>Описание этого члена см. в разделе <see cref="T:System.IConvertible.ToString(System.IFormatProvider)" />.</summary>
        <returns>Экземпляр <see cref="T:System.String" />, эквивалентный значению данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <see cref="T:System.String" /> приведен к типу интерфейса <see cref="T:System.IConvertible" />.

          ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип возвращаемого объекта.</param>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ChangeType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Значение текущего объекта <see cref="T:System.String" /> нельзя преобразовать в тип, заданный параметром <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число больше <see cref="F:System.UInt16.MaxValue" /> или меньше <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число больше <see cref="F:System.UInt32.MaxValue" /> или меньше <see cref="F:System.UInt32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемым альтернативным вариантом является вызов метода <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует знаки данного экземпляра в массив знаков Юникода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Копирует знаки данного экземпляра в массив знаков Юникода.</summary>
        <returns>Массив знаков Юникода, элементами которого являются отдельные знаки из данного экземпляра. Если этот экземпляр является пустой строкой, то возвращаемый массив пуст и его длина равна нулю.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует каждый символ (то есть каждый объект <xref:System.Char>) в строке в массив символов. Первый скопированный символ находится в нулевом индексе возвращенного массива символов; последний скопированный символ находится в индексе <xref:System.Array.Length%2A?displayProperty=nameWithType>-1.  
  
 Чтобы создать строку из символов в массиве символов, вызовите конструктор <xref:System.String.%23ctor%28System.Char%5B%5D%29>.  
  
 Чтобы создать массив байтов, содержащий закодированные символы в строке, создайте экземпляр соответствующего объекта <xref:System.Text.Encoding> и вызовите его метод <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType>. Ниже перечислены некоторые стандартные кодировки, доступные в .NET.  
  
|кодировка|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Дополнительные сведения см. [в разделе кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.String.ToCharArray%2A> для извлечения символов из строки в массив символов. Затем она отображает исходную строку и элементы в массиве.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 В следующем примере определяется строка, содержащая символы, которые служат разделителями в строке с разделителями. Затем он вызывает метод <xref:System.String.ToCharArray%2A>, чтобы создать массив символов, который можно передать методу <xref:System.String.Split%28System.Char%5B%5D%29>, чтобы разделить строку с разделителями на отдельные подстроки.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Начальная позиция подстроки в данном экземпляре.</param>
        <param name="length">Длина подстроки в данном экземпляре.</param>
        <summary>Копирует знаки из указанной подстроки данного экземпляра в массив знаков Юникода.</summary>
        <returns>Массив знаков Юникода, элементами которого являются <paramref name="length" /> знаков данного экземпляра начиная с позиции <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует символы из части строки в массив символов. Чтобы создать строку из диапазона символов в массиве символов, вызовите конструктор <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>.  
  
 Параметр `startIndex` отсчитывается от нуля. То есть индекс первого символа в экземпляре строки равен нулю.  
  
 Если `length` равен нулю, возвращаемый массив пуст и имеет нулевую длину. Если этот экземпляр является `null` или пустой строкой (""), возвращаемый массив пуст и имеет нулевую длину.  
  
 Чтобы создать массив байтов, содержащий закодированные символы в части строки, создайте экземпляр соответствующего объекта <xref:System.Text.Encoding> и вызовите его метод <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29>. Ниже перечислены некоторые из стандартных кодировок, доступных в .NET.  
  
|кодировка|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Дополнительные сведения см. [в разделе кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 В следующем примере подстрока в строке преобразуется в массив символов, затем перечисляется и отображаются элементы массива.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.  
  
- или - 
 <paramref name="startIndex" /> + <paramref name="length" /> больше длины этого экземпляра.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает копию этой строки, переведенную в нижний регистр.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает копию этой строки, переведенную в нижний регистр.</summary>
        <returns>Строка в нижнем регистре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод учитывает правила регистра текущего языка и региональных параметров.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все символы в текущем экземпляре преобразуются в нижний регистр.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Операция учета регистра, полученная в результате вызова метода <xref:System.String.ToLower>, учитывает соглашения о регистрах текущего языка и региональных параметров в учетной записи. Если требуется версия идентификатора операционной системы в нижнем регистре или в верхнем регистре, например имя файла, именованный канал или раздел реестра, используйте методы <xref:System.String.ToLowerInvariant%2A> или <xref:System.String.ToUpperInvariant%2A>. Это дает тот же результат в каждом языке и региональных параметрах (в отличие от метода <xref:System.String.ToLower>) и выполняется более эффективно.  
  
   
  
## Examples  
 В следующем примере несколько строк со смешанным регистром преобразуется в нижний регистр.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Как описано в статье рекомендации [по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методов регистра строк, которые заменяют значения по умолчанию, а вызывают методы, для которых требуется явно указать параметры. Чтобы преобразовать символ в нижний регистр с помощью соглашений о регистре текущего языка и региональных параметров, вызовите перегрузку метода <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> со значением <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> для его параметра <paramref name="culture" />.</para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Объект, задающий правила определения регистра для языка и региональных параметров.</param>
        <summary>Возвращает копию этой строки, переведенную в нижний регистр, используя правила определения регистра заданного языка и региональных параметров.</summary>
        <returns>Эквивалент текущей строки в нижнем регистре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Правила учета регистра языка и региональных параметров, заданные параметром `culture`, определяют способ изменения регистра строки.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все символы в текущем экземпляре преобразуются в нижний регистр.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Если методу <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> передается <xref:System.Globalization.CultureInfo> объект, отличный от <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, то при выполнении операции с регистром учитывается правила, зависящие от языка и региональных параметров. Если требуется версия идентификатора операционной системы в нижнем регистре или в верхнем регистре, например имя файла, именованный канал или раздел реестра, используйте метод <xref:System.String.ToLowerInvariant%2A> или <xref:System.String.ToUpperInvariant%2A>. Это дает тот же результат в каждой культуре и работает более эффективно.  
  
   
  
## Examples  
 В следующем примере две строки символов верхнего регистра преобразуются в символы нижнего регистра с использованием английской-США и турецкого Турция языка, а затем сравниваются строки в нижнем регистре. Строки в верхнем регистре идентичны, за исключением того, что для каждого вхождения ПРОПИСной буквы Юникода I в одной строке другая строка содержит ПРОПИСную БУКВу I с ТОЧКОЙ выше.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает копию этого объекта <see cref="T:System.String" /> , переведенную в нижний регистр, используя правила учета регистра инвариантного языка и региональных параметров.</summary>
        <returns>Эквивалент текущей строки в нижнем регистре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Инвариантная культура представляет язык и региональные параметры, не учитывающие язык и региональные параметры. Он связан с английским языком, но не с определенной страной или регионом. Дополнительные сведения см. в описании свойства <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Если приложение зависит от регистра строки, изменяющейся предсказуемым способом, который не влияет на текущий язык и региональные параметры, используйте метод <xref:System.String.ToLowerInvariant%2A>. Метод <xref:System.String.ToLowerInvariant%2A> эквивалентен `ToLower(CultureInfo.InvariantCulture)`. Метод рекомендуется использовать, когда коллекция строк должна находиться в прогнозируемом порядке в элементе управления пользовательского интерфейса.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все символы в текущем экземпляре преобразуются в нижний регистр.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Если требуется версия идентификатора операционной системы в нижнем регистре или в верхнем регистре, например имя файла, именованный канал или раздел реестра, используйте методы <xref:System.String.ToLowerInvariant%2A> или <xref:System.String.ToUpperInvariant%2A>.  
  
   
  
## Examples  
 В следующем примере определяется массив строк, содержащий одно слово на нескольких языках. Метод <xref:System.String.ToLowerInvariant%2A> используется для заполнения элементов параллельного массива с версией каждого слова без учета регистра. Метод <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> используется для сортировки массива с учетом регистра на основе порядка элементов в массиве нижнего регистра, чтобы элементы отображались в том же порядке независимо от языка.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует значение данного экземпляра в <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает этот экземпляр <see cref="T:System.String" />; реальное преобразование не осуществляется.</summary>
        <returns>Текущая строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поскольку этот метод просто возвращает текущую строку без изменений, нет необходимости вызывать ее напрямую. Обычно он вызывается неявно в операции составного форматирования, как показано в примере.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.String.ToString%2A>. Обратите внимание, что в примере явно не вызывается метод <xref:System.String.ToString%2A>. Вместо этого метод вызывается неявно функцией [составного форматирования](~/docs/standard/base-types/composite-formatting.md) .  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">(Зарезервирован.) Объект, предоставляющий сведения о форматировании, связанные с определенным языком и региональными параметрами.</param>
        <summary>Возвращает этот экземпляр <see cref="T:System.String" />; реальное преобразование не осуществляется.</summary>
        <returns>Текущая строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` зарезервировано и сейчас не участвует в этой операции.  
  
 Поскольку этот метод просто возвращает текущую строку без изменений, нет необходимости вызывать ее напрямую.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает копию этой строки, переведенную в верхний регистр.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает копию этой строки, переведенную в верхний регистр.</summary>
        <returns>Эквивалент текущей строки в верхнем регистре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует правила регистра текущего языка и региональных параметров для преобразования каждого символа в текущем экземпляре в эквивалент в верхнем регистре. Если символ не имеет эквивалента в верхнем регистре, он включается в возвращаемую строку без изменений.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все символы в текущем экземпляре преобразуются в верхний регистр.  
  
 Метод <xref:System.String.ToUpper%2A> часто используется для преобразования строки в верхний регистр, чтобы ее можно было использовать в сравнении без учета регистра. Лучшим методом для сравнения без учета регистра является вызов метода сравнения строк, имеющего параметр <xref:System.StringComparison>, значение которого равно <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> для сравнения с учетом языка и региональных параметров, без учета регистра.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Операция учета регистра, полученная в результате вызова метода <xref:System.String.ToUpper>, учитывает соглашения о регистрах текущего языка и региональных параметров в учетной записи. Если требуется версия идентификатора операционной системы в нижнем регистре или в верхнем регистре, например имя файла, именованный канал или раздел реестра, используйте метод <xref:System.String.ToLowerInvariant%2A> или <xref:System.String.ToUpperInvariant%2A>. Это дает тот же результат в каждом языке и региональных параметрах (в отличие от метода <xref:System.String.ToUpper>) и выполняется более эффективно.  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.String.ToUpper%2A> для преобразования последовательности из односимвольных строк, которые содержат каждый символ в наборе символов Basic латиница, Latin-1, а также расширенной латиницы. Затем она отображает каждую строку, чей символ в верхнем регистре отличается от символа нижнего регистра.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Как описано в статье рекомендации [по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методов регистра строк, которые заменяют значения по умолчанию, а вызывают методы, для которых требуется явно указать параметры. Чтобы преобразовать строку в верхний регистр с помощью соглашений о регистре текущего языка и региональных параметров, вызовите перегрузку метода <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> со значением <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> для его параметра <paramref name="culture" />.</para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Объект, задающий правила определения регистра для языка и региональных параметров.</param>
        <summary>Возвращает копию этой строки, переведенную в верхний регистр, используя правила определения регистра заданного языка и региональных параметров.</summary>
        <returns>Эквивалент текущей строки в верхнем регистре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Правила учета регистра языка и региональных параметров, заданные параметром `culture`, определяют способ изменения регистра строки.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все символы в текущем экземпляре преобразуются в верхний регистр.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Если методу <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> передается <xref:System.Globalization.CultureInfo> объект, отличный от <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, то при выполнении операции с регистром учитывается правила, зависящие от языка и региональных параметров. Если требуется версия идентификатора операционной системы в нижнем регистре или в верхнем регистре, например имя файла, именованный канал или раздел реестра, используйте метод <xref:System.String.ToLowerInvariant%2A> или <xref:System.String.ToUpperInvariant%2A>. Это дает тот же результат в каждой культуре и работает более эффективно.  
  
   
  
## Examples  
 В следующем примере строка строчных символов преобразуется в две строки символов верхнего регистра с помощью языков и региональных параметров "Английский-США" и турецкого Турция, а затем сравниваются строки верхнего регистра. Строки в верхнем регистре идентичны, за исключением того, что для каждого вхождения ПРОПИСной буквы Юникода I в одной строке другая строка содержит ПРОПИСную БУКВу I с ТОЧКОЙ выше.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает копию этого объекта <see cref="T:System.String" /> , переведенную в верхний регистр, используя правила учета регистра инвариантного языка и региональных параметров.</summary>
        <returns>Эквивалент текущей строки в верхнем регистре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Инвариантная культура представляет язык и региональные параметры, не учитывающие язык и региональные параметры. Он связан с английским языком, но не с определенной страной или регионом. Дополнительные сведения см. в описании свойства <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Если приложение зависит от регистра строки, изменяющейся предсказуемым способом, который не влияет на текущий язык и региональные параметры, используйте метод <xref:System.String.ToUpperInvariant%2A>. Метод <xref:System.String.ToUpperInvariant%2A> эквивалентен `ToUpper(CultureInfo.InvariantCulture)`. Метод рекомендуется использовать, когда коллекция строк должна находиться в прогнозируемом порядке в элементе управления пользовательского интерфейса.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все символы в текущем экземпляре преобразуются в верхний регистр.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Если требуется версия идентификатора операционной системы в нижнем регистре или в верхнем регистре, например имя файла, именованный канал или раздел реестра, используйте методы <xref:System.String.ToLowerInvariant%2A> или <xref:System.String.ToUpperInvariant%2A>.  
  
   
  
## Examples  
 В следующем примере определяется массив строк, содержащий одно слово на нескольких языках. Метод <xref:System.String.ToUpperInvariant%2A> используется для заполнения элементов параллельного массива с версией каждого слова без учета регистра. Метод <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> используется для сортировки массива с учетом регистра на основе порядка элементов в массиве в верхнем регистре, чтобы элементы отображались в том же порядке независимо от языка.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает новую строку, в которой удалены все начальные и конечные вхождения заданного набора символов из текущей строки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все начальные и конечные символы пробела из текущей строки.</summary>
        <returns>Строка, оставшаяся после удаления всех знаков пробела из начала и конца текущей строки. Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Метод `Trim` удаляет из текущей строки все начальные и конечные символы пробела. Каждая начальная и конечная операции усечения останавливается при обнаружении символа, не являющегося пробелом. Например, если текущей строкой является "ABC XYZ", метод `Trim` возвращает "ABC XYZ". Чтобы удалить пробельные символы между словами в строке, используйте [регулярные выражения .NET](~/docs/standard/base-types/regular-expressions.md).

> [!NOTE]
>  Если метод `Trim` удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой удаляются все начальные и конечные символы пробела, найденные в текущем экземпляре.

Если текущая строка равна <xref:System.String.Empty?displayProperty=nameWithtype> или все символы в текущем экземпляре состоят из пробельных символов, метод возвращает <xref:System.String.Empty?displayProperty=nameWithtype>.

Пробельные символы определяются стандартом Юникода. Метод `Trim` удаляет все ведущие и замыкающие символы, которые создают возвращаемое значение `true`, когда они передаются в метод <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.

## Examples

В следующем примере метод <xref:System.String.Trim?displayProperty=nameWithType> используется для удаления лишних пробелов из строк, вводимых пользователем, перед их сцеплением.

[!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
[!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
[!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранние версии поддерживают внутренний список пробелов, которые обрезаются этим методом. Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], метод обрезает все пробельные символы Юникода (то есть символы, создающие <see langword="true" /> возвращаемое значение, когда они передаются в метод <see cref="M:System.Char.IsWhiteSpace(System.Char)" />). В связи с этим изменением метод <see cref="M:System.String.Trim" /> в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версиях удаляет два символа: пустое пространство нулевой ширины (U + 200B) и НУЛЕВую ширину свободного пространства (U + FEFF), что метод <see cref="M:System.String.Trim" /> в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]и более поздних версиях не удаляется. Кроме того, метод <see cref="M:System.String.Trim" /> в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версиях не обрезает три пробела в Юникоде: МОНГОЛЬСКИЙ ГЛАСный разделитель (U + 180E), УЗКИе пространства без ПЕРЕРЫВов (U + 202F) и среднее МАТЕМАТИЧЕСКое пространство (U + 205F).</para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">Удаляемый символ Юникода.</param>
        <summary>Удаляет все начальные и конечные экземпляры символа из текущей строки.</summary>
        <returns>Строка, оставшаяся после удаления всех экземпляров символа <paramref name="trimChar" /> из начала и конца текущей строки. Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Метод `Trim(System.Char)` удаляет из текущей строки все начальные и конечные экземпляры `trimChar` символа. Каждая начальная и конечная операция усечения останавливается при обнаружении символа, отличного от `trimChar`. Например, если `trimChar` `-`, а текущая строка — "---ABC---XYZ----", то метод `Trim(System.Char)` возвращает "ABC---XYZ". Чтобы удалить символы между словами в строке, используйте [регулярные выражения .NET](~/docs/standard/base-types/regular-expressions.md).

> [!NOTE]
>  Если метод `Trim(System.Char)` удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой удаляются все начальные и конечные `trimChar` символы, найденные в текущем экземпляре.

Если текущая строка равна <xref:System.String.Empty?displayProperty=nameWithtype> или все символы в текущем экземпляре состоят из `trimChar` символов, метод возвращает <xref:System.String.Empty?displayProperty=nameWithtype>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Массив удаляемых знаков Юникода или <see langword="null" />.</param>
        <summary>Удаляет все начальные и конечные вхождения набора символов, заданного в виде массива, из текущей строки.</summary>
        <returns>Строка, оставшаяся после удаления всех вхождений символов, заданных в параметре <paramref name="trimChars" />, из начала и конца текущей строки. Если значением параметра <paramref name="trimChars" /> является <see langword="null" /> или пустой массив, удаляются символы-разделители. Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Метод `Trim(System.Char[])` удаляет из текущей строки все начальные и конечные символы, которые находятся в параметре `trimChars`. Каждая начальная и конечная операция усечения останавливается при обнаружении символа, который не находится в `trimChars`. Например, если текущая строка — "123abc456xyz789", а `trimChars` содержит цифры от "1" до "9", метод `Trim(System.Char[])` возвращает "abc456xyz".

> [!NOTE]
>  Если метод `Trim(System.Char[])` удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой удаляются все начальные и конечные `trimChars` символы, найденные в текущем экземпляре.

Если текущая строка равна <xref:System.String.Empty?displayProperty=nameWithtype> или все символы в текущем экземпляре состоят из символов в массиве `trimChars`, то метод возвращает <xref:System.String.Empty?displayProperty=nameWithtype>.

Если `trimChars` имеет `null` или пустой массив, этот метод удаляет все начальные или конечные символы, которые возвращают метод, который возвращает `true`, когда они передаются в метод <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.

## Examples

В следующем примере метод `Trim(System.Char[])` используется для удаления пробелов, звездочек (*) и апострофа (') из строки.

[!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
[!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
[!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранние версии поддерживают внутренний список пробелов, которые этот метод обрезает, если <paramref name="trimChars" /> <see langword="null" /> или пустой массив. Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], если <paramref name="trimChars" /> <see langword="null" /> или пустой массив, метод обрезает все пробельные символы Юникода (то есть символы, которые формируют возвращаемое значение <see langword="true" />, когда они передаются в метод <see cref="M:System.Char.IsWhiteSpace(System.Char)" />). В связи с этим изменением метод <see cref="M:System.String.Trim" /> в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версиях удаляет два символа: пустое пространство нулевой ширины (U + 200B) и НУЛЕВую ширину свободного пространства (U + FEFF), что метод <see cref="M:System.String.Trim" /> в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]и более поздних версиях не удаляется. Кроме того, метод <see cref="M:System.String.Trim" /> в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версиях не обрезает три пробела в Юникоде: МОНГОЛЬСКИЙ ГЛАСный разделитель (U + 180E), УЗКИе пространства без ПЕРЕРЫВов (U + 202F) и среднее МАТЕМАТИЧЕСКое пространство (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все конечные символы пробела из текущей строки.</summary>
        <returns>Строка, оставшаяся после удаления всех символов пробела из конца текущей строки. Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Метод `TrimEnd` удаляет из текущей строки все конечные символы пробела. Операция Trim останавливается, когда в конце строки обнаруживается первый символ, отличный от пробела. Например, если текущей строкой является "ABC XYZ", метод `TrimEnd` возвращает "ABC XYZ".

> [!NOTE]
>  Если метод `TrimEnd` удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все конечные символы пробела удаляются из текущей строки.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">Удаляемый символ Юникода.</param>
        <summary>Удаляет все конечные вхождения символа из текущей строки.</summary>
        <returns>Строка, оставшаяся после удаления всех вхождений символа <paramref name="trimChar" /> из конца текущей строки. Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Метод `TrimEnd(System.Char)` удаляет из текущей строки все конечные `trimChar` символы. Операция Trim останавливается, когда в конце строки встречается первый символ, который не `trimChar`. Например, если `trimChar` `-`, а текущая строка — "---ABC---XYZ----", то метод `TrimEnd(System.Char)` возвращает "---ABC---XYZ".

> [!NOTE]
>  Если метод `TrimEnd(System.Char)` удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все конечные `trimChar` символы удаляются из текущей строки.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Массив удаляемых знаков Юникода или <see langword="null" />.</param>
        <summary>Удаляет все конечные вхождения набора символов, заданного в виде массива, из текущей строки.</summary>
        <returns>Строка, оставшаяся после удаления всех вхождений символов, заданных в параметре <paramref name="trimChars" />, из конца текущей строки. Если значением параметра <paramref name="trimChars" /> является <see langword="null" /> или пустой массив, удаляются символы-разделители в Юникоде. Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Метод `TrimEnd(System.Char[])` удаляет из текущей строки все конечные символы, которые находятся в параметре `trimChars`. Операция Trim останавливается, когда в конце строки встречается первый символ, не являющийся `trimChars`. Например, если текущая строка — "123abc456xyz789", а `trimChars` содержит цифры от "1" до "9", метод `TrimEnd(System.Char[])` возвращает "123abc456xyz".

> [!NOTE]
>  Если метод `TrimEnd(System.Char[])` удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой все конечные символы, найденные в `trimChars`, удаляются из текущей строки.

## Examples

В следующем примере показано, как можно использовать метод `TrimEnd(System.Char[])` для удаления знаков пробела или знаков препинания с конца строки.

[!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
[!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранние версии поддерживают внутренний список пробелов, которые этот метод обрезает, если <paramref name="trimChars" /> <see langword="null" /> или пустой массив. Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], если <paramref name="trimChars" /> <see langword="null" /> или пустой массив, метод обрезает все пробельные символы Юникода (то есть символы, которые формируют возвращаемое значение <see langword="true" />, когда они передаются в метод <see cref="M:System.Char.IsWhiteSpace(System.Char)" />). В связи с этим изменением метод <see cref="M:System.String.Trim" /> в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версиях удаляет два символа: пустое пространство нулевой ширины (U + 200B) и НУЛЕВую ширину свободного пространства (U + FEFF), что метод <see cref="M:System.String.Trim" /> в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и более поздних версиях не удаляется. Кроме того, метод <see cref="M:System.String.Trim" /> в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версиях не обрезает три пробела в Юникоде: МОНГОЛЬСКИЙ ГЛАСный разделитель (U + 180E), УЗКИе пространства без ПЕРЕРЫВов (U + 202F) и среднее МАТЕМАТИЧЕСКое пространство (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все начальные символы пробела из текущей строки.</summary>
        <returns>Строка, оставшаяся после удаления всех символов пробела из начала текущей строки. Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Метод `TrimStart` удаляет из текущей строки все начальные пробельные символы. Операция Trim останавливается при обнаружении символа, не являющегося пробелом. Например, если текущей строкой является "ABC XYZ", метод `TrimStart` возвращает "ABC XYZ".

> [!NOTE]
>  Если метод `TrimStart` удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой удаляются все начальные пробелы, найденные в текущем экземпляре.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">Удаляемый символ Юникода.</param>
        <summary>Удаляет все начальные вхождения указанного символа из текущей строки.</summary>
        <returns>Строка, оставшаяся после удаления всех вхождений символа <paramref name="trimChar" /> из начала текущей строки. Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Метод `TrimStart(System.Char)` удаляет из текущей строки все ведущие `trimChar` символы. Операция Trim останавливается при обнаружении символа, который не `trimChar`. Например, если `trimChar` `-`, а текущая строка — "---ABC---XYZ----", то метод `TrimStart(System.Char)` возвращает "ABC---XYZ----".

> [!NOTE]
>  Если метод `TrimStart(System.Char)` удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой удаляются все ведущие `trimChar` символы, найденные в текущем экземпляре.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Массив удаляемых знаков Юникода или <see langword="null" />.</param>
        <summary>Удаляет все начальные вхождения набора символов, заданного в виде массива, из текущей строки.</summary>
        <returns>Строка, оставшаяся после удаления всех вхождений символов, заданных в параметре <paramref name="trimChars" />, из начала текущей строки. Если значением параметра <paramref name="trimChars" /> является <see langword="null" /> или пустой массив, удаляются символы-разделители. Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Метод `TrimStart(System.Char[])` удаляет из текущей строки все ведущие символы, которые находятся в параметре `trimChars`. Операция Trim останавливается при обнаружении символа, который не находится в `trimChars`. Например, если текущая строка — "123abc456xyz789", а `trimChars` содержит цифры от "1" до "9", метод `TrimStart(System.Char[])` возвращает "abc456xyz789".

> [!NOTE]
>  Если метод `TrimStart(System.Char[])` удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, в которой удаляются все ведущие символы, находящиеся в параметре `trimChars`, найденном в текущем экземпляре.

## Examples

В следующем примере показаны основные функциональные возможности метода <xref:System.String.TrimStart%2A>.

[!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
[!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

В следующем примере используется метод <xref:System.String.TrimStart%2A> для удаления пробелов и символов комментариев из строк исходного кода. Метод `StripComments` создает оболочку для вызова <xref:System.String.TrimStart%2A> и передает ему массив символов, содержащий пробел, и символ комментария, который представляет собой апостроф (') в Visual Basic и косую черту (/) в C#. Метод <xref:System.String.TrimStart%2A> также вызывается для удаления начальных пробелов при оценке того, является ли строка комментарием.

[!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
[!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]

В следующем примере показан вызов метода `StripComments`.

[!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
[!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранние версии поддерживают внутренний список пробелов, которые этот метод обрезает, если <paramref name="trimChars" /> <see langword="null" /> или пустой массив. Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], если <paramref name="trimChars" /> <see langword="null" /> или пустой массив, метод обрезает все пробельные символы Юникода (то есть символы, которые формируют возвращаемое значение <see langword="true" />, когда они передаются в метод <see cref="M:System.Char.IsWhiteSpace(System.Char)" />). В связи с этим изменением метод <see cref="M:System.String.Trim" /> в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версиях удаляет два символа: пустое пространство нулевой ширины (U + 200B) и НУЛЕВую ширину свободного пространства (U + FEFF), что метод <see cref="M:System.String.Trim" /> в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и более поздних версиях не удаляется. Кроме того, метод <see cref="M:System.String.Trim" /> в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версиях не обрезает три пробела в Юникоде: МОНГОЛЬСКИЙ ГЛАСный разделитель (U + 180E), УЗКИе пространства без ПЕРЕРЫВов (U + 202F) и среднее МАТЕМАТИЧЕСКое пространство (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>
