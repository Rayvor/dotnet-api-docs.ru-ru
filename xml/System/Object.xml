<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="27a5a54cf0b066193ccd803fbf6159e1a3ce530f" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67250291" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="28993-101">Поддерживает все классы в иерархии классов .NET и предоставляет низкоуровневые службы для производных классов.</span><span class="sxs-lookup"><span data-stu-id="28993-101">Supports all classes in the .NET class hierarchy and provides low-level services to derived classes.</span></span> <span data-ttu-id="28993-102">Является исходным базовым классом для всех классов .NET и корнем иерархии типов.</span><span class="sxs-lookup"><span data-stu-id="28993-102">This is the ultimate base class of all .NET classes; it is the root of the type hierarchy.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28993-103">В большинстве языков не требуется объявлять для классов наследование от <xref:System.Object>, так как они наследуют его неявно.</span><span class="sxs-lookup"><span data-stu-id="28993-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="28993-104">Поскольку все классы в .NET являются производными от <xref:System.Object>, каждый метод, определенный в <xref:System.Object> класс доступен во всех объектах в системе.</span><span class="sxs-lookup"><span data-stu-id="28993-104">Because all classes in .NET are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="28993-105">Производные классы могут переопределять некоторые из этих методов, включая:</span><span class="sxs-lookup"><span data-stu-id="28993-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="28993-106"><xref:System.Object.Equals%2A> — Поддерживает сравнение объектов.</span><span class="sxs-lookup"><span data-stu-id="28993-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="28993-107"><xref:System.Object.Finalize%2A> — Выполняет операции очистки, прежде чем объект автоматически освобождается.</span><span class="sxs-lookup"><span data-stu-id="28993-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="28993-108"><xref:System.Object.GetHashCode%2A> — Создает число, соответствующее значению объекта для поддержки использования хэш-таблицы.</span><span class="sxs-lookup"><span data-stu-id="28993-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="28993-109"><xref:System.Object.ToString%2A> — Создает удобочитаемого текста строку, описывающую экземпляр класса.</span><span class="sxs-lookup"><span data-stu-id="28993-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="28993-110">Особенности производительности</span><span class="sxs-lookup"><span data-stu-id="28993-110">Performance Considerations</span></span>  
 <span data-ttu-id="28993-111">При разработке класса, например коллекции, который должен обрабатывать объекты любого типа, вы можете создавать члены класса, принимающие экземпляры класса <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="28993-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="28993-112">Однако процесс упаковки-преобразования и распаковки-преобразования для типа требует вычислительных затрат.</span><span class="sxs-lookup"><span data-stu-id="28993-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="28993-113">Если вы знаете, что новый класс будет часто обрабатывать определенные типы значений, для минимизации затрат на упаковку-преобразование можно использовать две тактики.</span><span class="sxs-lookup"><span data-stu-id="28993-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="28993-114">Создание общего метода, принимающего тип <xref:System.Object>, и набора специализированных перегрузок метода для каждого из типов значений, которые, как предполагается, будут часто обрабатываться классом.</span><span class="sxs-lookup"><span data-stu-id="28993-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="28993-115">Если существует специализированный метод, который принимает указанный при вызове тип параметра, упаковка-преобразование не выполняется и вызывается специализированный метод.</span><span class="sxs-lookup"><span data-stu-id="28993-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="28993-116">Если у метода отсутствует аргумент, который соответствует указанному при вызове типу параметра, выполняется упаковка-преобразование параметра и вызывается общий метод.</span><span class="sxs-lookup"><span data-stu-id="28993-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="28993-117">Использование универсальных шаблонов при разработке метода и его членов.</span><span class="sxs-lookup"><span data-stu-id="28993-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="28993-118">Среда CLR создает закрытый универсальный тип при создании экземпляра класса с указанием аргумента универсального типа.</span><span class="sxs-lookup"><span data-stu-id="28993-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="28993-119">Универсальный метод принимает аргумент определенного типа, и его можно вызывать без упаковки-преобразования параметра.</span><span class="sxs-lookup"><span data-stu-id="28993-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="28993-120">Несмотря на то, что иногда бывает необходимо создавать классы общего назначения, которые принимают и возвращают типы <xref:System.Object>, можно повысить производительность, создав также специализированный класс для обработки определенного часто используемого типа.</span><span class="sxs-lookup"><span data-stu-id="28993-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="28993-121">Например, наличие специализированного класса для задания и получения логических значений позволяет избежать затрат на их упаковку-преобразование и распаковку-преобразование.</span><span class="sxs-lookup"><span data-stu-id="28993-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28993-122">В следующем примере определяется тип Point, производный от класса <xref:System.Object>, и переопределяются многие виртуальные методы класса <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="28993-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="28993-123">Кроме того, в примере показано, как вызывать многие из статических методов и методов экземпляра класса <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="28993-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="28993-124">Открытые статические (<see langword="Shared" /> в Visual Basic) члены этого типа являются потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="28993-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="28993-125">Для членов экземпляра потокобезопасность не гарантируется.</span><span class="sxs-lookup"><span data-stu-id="28993-125">Instance members are not guaranteed to be thread-safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="28993-126">Инициализирует новый экземпляр класса <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="28993-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28993-127">Этот конструктор вызывается конструкторами в производных классах, но его также можно напрямую создать экземпляр <xref:System.Object> класса.</span><span class="sxs-lookup"><span data-stu-id="28993-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="28993-128">Определяет, равны ли два экземпляра объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-128">Determines whether two object instances are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="28993-129">Объект, который требуется сравнить с текущим объектом.</span><span class="sxs-lookup"><span data-stu-id="28993-129">The object to compare with the current object.</span></span></param>
        <summary><span data-ttu-id="28993-130">Определяет, равен ли заданный объект текущему объекту.</span><span class="sxs-lookup"><span data-stu-id="28993-130">Determines whether the specified object is equal to the current object.</span></span></summary>
        <returns><span data-ttu-id="28993-131">Значение <see langword="true" />, если указанный объект равен текущему объекту; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="28993-131"><see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28993-132">Тип сравнения между текущим экземпляром и `obj` параметр зависит от того, является ли текущий экземпляр является ссылочным типом или типом значения.</span><span class="sxs-lookup"><span data-stu-id="28993-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  
  
-   <span data-ttu-id="28993-133">Если текущий экземпляр является ссылочным типом, <xref:System.Object.Equals%28System.Object%29> метод проверяет ссылочное равенство и вызов <xref:System.Object.Equals%28System.Object%29> метод эквивалентен методу вызова <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="28993-134">Равенство ссылок означает, что объектные переменные, которые сравниваются ссылаются на тот же объект.</span><span class="sxs-lookup"><span data-stu-id="28993-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="28993-135">В следующем примере результат таком сравнении.</span><span class="sxs-lookup"><span data-stu-id="28993-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="28993-136">Он определяет `Person` класс, который является ссылочным типом, и вызывает метод `Person` класс конструктора для создания двух новых `Person` объектов, `person1a` и `person2`, которые имеют одинаковое значение.</span><span class="sxs-lookup"><span data-stu-id="28993-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="28993-137">А также назначает `person1a` другой переменной объекта, `person1b`.</span><span class="sxs-lookup"><span data-stu-id="28993-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="28993-138">Как видно в результатах показано в примере `person1a` и `person1b` равны, так как они ссылаются на один объект.</span><span class="sxs-lookup"><span data-stu-id="28993-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="28993-139">Тем не менее `person1a` и `person2` не равны, несмотря на то, что они имеют одинаковое значение.</span><span class="sxs-lookup"><span data-stu-id="28993-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="28993-140">Если текущий экземпляр является типом значения, <xref:System.Object.Equals%28System.Object%29> метод проверка на равенство значений.</span><span class="sxs-lookup"><span data-stu-id="28993-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="28993-141">Равенство значений означает следующее:</span><span class="sxs-lookup"><span data-stu-id="28993-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="28993-142">Два объекта имеют тот же тип.</span><span class="sxs-lookup"><span data-stu-id="28993-142">The two objects are of the same type.</span></span> <span data-ttu-id="28993-143">Как показано в следующем примере, <xref:System.Byte> объект, имеющий значение 12 не равно <xref:System.Int32> объект, имеющий значение 12, так как оба объекта имеют различные типы во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="28993-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="28993-144">Значения открытых и закрытых полей из двух объектов равны.</span><span class="sxs-lookup"><span data-stu-id="28993-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="28993-145">В следующем примере проверяется на предмет равенства значений.</span><span class="sxs-lookup"><span data-stu-id="28993-145">The following example tests for value equality.</span></span> <span data-ttu-id="28993-146">Он определяет `Person` структуру, которая является типом значения, и вызывает метод `Person` класс конструктора для создания двух новых `Person` объектов, `person1` и `person2`, которые имеют одинаковое значение.</span><span class="sxs-lookup"><span data-stu-id="28993-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="28993-147">Как показывают выходные данные из примера, несмотря на то, что две объектные переменные ссылаются на разные объекты `person1` и `person2` равны, поскольку они имеют одинаковое значение для частного `personName` поля.</span><span class="sxs-lookup"><span data-stu-id="28993-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="28993-148">Так как <xref:System.Object> класс является базовым классом для всех типов в .NET Framework, <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод обеспечивает сравнение на равенство по умолчанию для всех других типов.</span><span class="sxs-lookup"><span data-stu-id="28993-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="28993-149">Тем не менее, часто переопределить типы <xref:System.Object.Equals%2A> метод реализация равенства значений.</span><span class="sxs-lookup"><span data-stu-id="28993-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="28993-150">Дополнительные сведения см. в разделе заметки для вызывающих объектов и примечания для разработчиков производных классов разделов.</span><span class="sxs-lookup"><span data-stu-id="28993-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="28993-151">Заметки о [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="28993-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="28993-152">При вызове <xref:System.Object.Equals%28System.Object%29> перегрузку метода в классе в [!INCLUDE[wrt](~/includes/wrt-md.md)], он предоставляет поведение по умолчанию для классов, которые не переопределяют <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="28993-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="28993-153">Это является частью возможностей .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. в разделе [приложений .NET Framework поддерживает для Windows Store и среды выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="28993-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="28993-154">Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] не наследуют <xref:System.Object>и в настоящее время не использовать <xref:System.Object.Equals%28System.Object%29> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="28993-155">Тем не менее, в них могут быть <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, и <xref:System.Object.GetHashCode%2A> методов при их использовании в коде C# или Visual Basic и .NET Framework предоставляет поведение по умолчанию для этих методов.</span><span class="sxs-lookup"><span data-stu-id="28993-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="28993-156">классы, которые создаются на языке C# или Visual Basic можно переопределить <xref:System.Object.Equals%28System.Object%29> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="28993-156">classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="28993-157">Заметки о вызывающих объектов</span><span class="sxs-lookup"><span data-stu-id="28993-157">Notes for Callers</span></span>  
 <span data-ttu-id="28993-158">Производные классы часто переопределить <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод реализация равенства значений.</span><span class="sxs-lookup"><span data-stu-id="28993-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="28993-159">Кроме того, типы также часто предоставляют дополнительные строго типизированные перегрузки для `Equals` метод, обычно путем реализации <xref:System.IEquatable%601> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="28993-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="28993-160">При вызове `Equals` метод для проверки на равенство, следует знать, переопределяет ли текущий экземпляр <xref:System.Object.Equals%2A?displayProperty=nameWithType> и понять, как конкретный вызов `Equals` метод не будет устранена.</span><span class="sxs-lookup"><span data-stu-id="28993-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="28993-161">В противном случае вы может выполнять тест на равенство, которое отличается от требуемого, и метод может вернуть непредвиденное значение.</span><span class="sxs-lookup"><span data-stu-id="28993-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="28993-162">Ниже приведен пример.</span><span class="sxs-lookup"><span data-stu-id="28993-162">The following example provides an illustration.</span></span> <span data-ttu-id="28993-163">Он создает три <xref:System.Text.StringBuilder> объектов с одинаковых строк и затем вызывает четыре `Equals` методы.</span><span class="sxs-lookup"><span data-stu-id="28993-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="28993-164">Первый вызов метода возвращает `true`и возврат оставшихся трех `false`.</span><span class="sxs-lookup"><span data-stu-id="28993-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="28993-165">В первом случае строго типизированный <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> вызове перегрузки метода, который проверяет равенство значений.</span><span class="sxs-lookup"><span data-stu-id="28993-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="28993-166">Поскольку строки назначены две <xref:System.Text.StringBuilder> объекты равны, метод возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="28993-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="28993-167">Тем не менее <xref:System.Text.StringBuilder> не переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28993-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="28993-168">По этой причине при <xref:System.Text.StringBuilder> объект приведен к <xref:System.Object>, когда <xref:System.Text.StringBuilder> экземпляру назначается переменной типа <xref:System.Object>и когда <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> методу передается два <xref:System.Text.StringBuilder> объекты, значение по умолчанию <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="28993-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="28993-169">Так как <xref:System.Text.StringBuilder> является ссылочным типом, это эквивалентно передаче двух <xref:System.Text.StringBuilder> объектов <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="28993-170">Несмотря на то что все три <xref:System.Text.StringBuilder> объекты содержат идентичные строки, они ссылаются на три разных объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="28993-171">Таким образом, эти три метода вызовы будут возвращать `false`.</span><span class="sxs-lookup"><span data-stu-id="28993-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="28993-172">Вы можете сравнить текущий объект другому объекту ссылочное равенство, вызвав <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="28993-173">В Visual Basic, можно также использовать `is` ключевое слово (например, `If Me Is otherObject Then ...`).</span><span class="sxs-lookup"><span data-stu-id="28993-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="28993-174">Примечания о наследовании</span><span class="sxs-lookup"><span data-stu-id="28993-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="28993-175">При определении собственного типа, этот тип наследует функций, определенных в `Equals` метод своего базового типа.</span><span class="sxs-lookup"><span data-stu-id="28993-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="28993-176">В следующей таблице перечислены реализации по умолчанию `Equals` метод для основных категорий типов в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="28993-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="28993-177">Категория типа</span><span class="sxs-lookup"><span data-stu-id="28993-177">Type category</span></span>|<span data-ttu-id="28993-178">Равенство определяется</span><span class="sxs-lookup"><span data-stu-id="28993-178">Equality defined by</span></span>|<span data-ttu-id="28993-179">Комментарии</span><span class="sxs-lookup"><span data-stu-id="28993-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="28993-180">Класс, производный непосредственно от <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="28993-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="28993-181">Равенство ссылок; аналогичен вызову <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28993-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="28993-182">Структура</span><span class="sxs-lookup"><span data-stu-id="28993-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="28993-183">Равенство значений; прямое сравнение по байтам или сравнения по полям, с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="28993-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="28993-184">Перечисление</span><span class="sxs-lookup"><span data-stu-id="28993-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="28993-185">Значения должны иметь одинаковый тип перечисления и тем же базовым значением.</span><span class="sxs-lookup"><span data-stu-id="28993-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="28993-186">делегат</span><span class="sxs-lookup"><span data-stu-id="28993-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="28993-187">Делегаты должен иметь одинаковый тип и списки вызовов идентичны.</span><span class="sxs-lookup"><span data-stu-id="28993-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="28993-188">Интерфейс</span><span class="sxs-lookup"><span data-stu-id="28993-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="28993-189">Равенство ссылок.</span><span class="sxs-lookup"><span data-stu-id="28993-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="28993-190">Для типа значения, необходимо всегда выполнять переопределение <xref:System.Object.Equals%2A>, так как проверка на равенство, основанные на отражении являются причиной низкой производительности.</span><span class="sxs-lookup"><span data-stu-id="28993-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="28993-191">Можно также переопределить реализацию по умолчанию <xref:System.Object.Equals%2A> для ссылочных типов для проверки на равенство значений, а не равенство ссылок и для определения равенства значений точное значение.</span><span class="sxs-lookup"><span data-stu-id="28993-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="28993-192">Такие реализации <xref:System.Object.Equals%2A> возврата `true` Если два объекта имеют одно и то же значение, даже если они не являются одним экземпляром.</span><span class="sxs-lookup"><span data-stu-id="28993-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="28993-193">Разработчик типа решает, что составляет значения объекта, но обычно некоторые или все данные, хранящиеся в переменных экземпляра объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="28993-194">Например, значение <xref:System.String> основана на символы строки. значение <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> переопределения методов <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод для возврата `true` для любых двух экземпляров, которые содержат те же символы, в том же порядке строк.</span><span class="sxs-lookup"><span data-stu-id="28993-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="28993-195">В следующем примере показано, как переопределить <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод для проверки на равенство значений.</span><span class="sxs-lookup"><span data-stu-id="28993-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="28993-196">Этот параметр переопределяет <xref:System.Object.Equals%2A> метод `Person` класса.</span><span class="sxs-lookup"><span data-stu-id="28993-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="28993-197">Если `Person` принят реализацию его базового класса равенства двух `Person` объекта будут равны, только если на них ссылки объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="28993-198">Однако в этом случае два `Person` объекты равны, если они имеют одинаковое значение для `Person.Id` свойство.</span><span class="sxs-lookup"><span data-stu-id="28993-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="28993-199">Помимо переопределения <xref:System.Object.Equals%2A>, можно реализовать <xref:System.IEquatable%601> интерфейс, чтобы предоставить строго типизированные проверка на равенство.</span><span class="sxs-lookup"><span data-stu-id="28993-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="28993-200">Следующие инструкции должны соблюдаться для всех реализаций <xref:System.Object.Equals%28System.Object%29> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="28993-201">В списке `x`, `y`, и `z` представляют ссылки на объекты, которые не являются **null**.</span><span class="sxs-lookup"><span data-stu-id="28993-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="28993-202">`x.Equals(x)` Возвращает `true`, за исключением случаев, с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="28993-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="28993-203">См. в разделе [60559:2011 ISO/IEC/IEEE, арифметики с плавающей запятой технологии--микропроцессора систем, сведения](https://www.iso.org/standard/57469.html).</span><span class="sxs-lookup"><span data-stu-id="28993-203">See [ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic](https://www.iso.org/standard/57469.html).</span></span>  
  
-   <span data-ttu-id="28993-204">`x.Equals(y)` возвращает то же значение, что и `y.Equals(x)`.</span><span class="sxs-lookup"><span data-stu-id="28993-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="28993-205">`x.Equals(y)` Возвращает `true` Если оба `x` и `y` являются `NaN`.</span><span class="sxs-lookup"><span data-stu-id="28993-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="28993-206">Если `(x.Equals(y) && y.Equals(z))` возвращает `true`, затем `x.Equals(z)` возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="28993-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="28993-207">Последовательные вызовы `x.Equals(y)` возвращать то же значение до тех пор, пока объекты ссылается `x` и `y` не изменяются.</span><span class="sxs-lookup"><span data-stu-id="28993-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="28993-208">`x.Equals(null)` возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="28993-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="28993-209">Реализации <xref:System.Object.Equals%2A> не должны создавать исключений; они всегда должны возвращать значение.</span><span class="sxs-lookup"><span data-stu-id="28993-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="28993-210">Например если `obj` — `null`, <xref:System.Object.Equals%2A> метод должен возвращать `false` вместо выдачи <xref:System.ArgumentNullException>.</span><span class="sxs-lookup"><span data-stu-id="28993-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="28993-211">Следуйте приведенным ниже рекомендациям при переопределении метода <xref:System.Object.Equals%28System.Object%29>:</span><span class="sxs-lookup"><span data-stu-id="28993-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="28993-212">Типы, реализующие <xref:System.IComparable> необходимо переопределить <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="28993-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="28993-213">Типы, переопределяющие <xref:System.Object.Equals%28System.Object%29> необходимо также переопределить <xref:System.Object.GetHashCode%2A>; в противном случае — значение хэш-таблицы могут работать неправильно.</span><span class="sxs-lookup"><span data-stu-id="28993-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="28993-214">Вы должны рассмотреть реализацию <xref:System.IEquatable%601> интерфейс для поддержки строго типизированных проверка на равенство.</span><span class="sxs-lookup"><span data-stu-id="28993-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="28993-215">Ваш <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> реализация должна возвратить результаты, которые соответствуют <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="28993-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="28993-216">Если язык программирования поддерживает перегрузку операторов, а также перегружать оператор равенства для данного типа, необходимо также переопределить <xref:System.Object.Equals%28System.Object%29> метод вернет тот же результат, что и оператор равенства.</span><span class="sxs-lookup"><span data-stu-id="28993-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="28993-217">Это гарантирует, что код библиотеки классов, который использует <xref:System.Object.Equals%2A> (такие как <xref:System.Collections.ArrayList> и <xref:System.Collections.Hashtable>) ведет себя таким образом, согласуется с тем, как оператор равенства, используемый кодом приложения.</span><span class="sxs-lookup"><span data-stu-id="28993-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="28993-218">Рекомендации для ссылочных типов</span><span class="sxs-lookup"><span data-stu-id="28993-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="28993-219">Следующие правила применяются к переопределенным <xref:System.Object.Equals%28System.Object%29> для ссылочного типа:</span><span class="sxs-lookup"><span data-stu-id="28993-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="28993-220">Переопределение <xref:System.Object.Equals%2A> Если семантика типа основана на том факте, что тип представляет некоторые значения.</span><span class="sxs-lookup"><span data-stu-id="28993-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="28993-221">Большинство ссылочных типов не следует перегружать оператор равенства, даже если они переопределяют <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="28993-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="28993-222">Тем не менее при реализации ссылочного типа, который предназначен для семантического значения, например, тип комплексного числа, необходимо переопределить оператор равенства.</span><span class="sxs-lookup"><span data-stu-id="28993-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="28993-223">Не следует переопределять <xref:System.Object.Equals%2A> на изменяемый ссылочный тип.</span><span class="sxs-lookup"><span data-stu-id="28993-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="28993-224">Это обусловлено переопределение <xref:System.Object.Equals%2A> необходимо также переопределить <xref:System.Object.GetHashCode%2A> метод, как описано в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="28993-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="28993-225">Это означает, что хэш-код экземпляра изменяемый ссылочный тип можно изменить во время существования, что может привести объект к потере в хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="28993-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="28993-226">Рекомендации для типов значений</span><span class="sxs-lookup"><span data-stu-id="28993-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="28993-227">Следующие правила применяются к переопределенным <xref:System.Object.Equals%28System.Object%29> для типа значения:</span><span class="sxs-lookup"><span data-stu-id="28993-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="28993-228">При определении тип значения, который включает в себя одно или несколько полей, значения которого являются ссылочными типами, необходимо переопределить <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="28993-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="28993-229"><xref:System.Object.Equals%28System.Object%29> Реализации <xref:System.ValueType> выполняет сравнение по байтам, для которых типы значений поля являются все типы значений, но он использует отражение для выполнения сравнения типов значений, поля которых включают ссылочные типы по полям.</span><span class="sxs-lookup"><span data-stu-id="28993-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="28993-230">При переопределении <xref:System.Object.Equals%2A> и выбранного языка программирования поддерживает перегрузку операторов, необходимо перегрузить оператор равенства.</span><span class="sxs-lookup"><span data-stu-id="28993-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="28993-231">Следует реализовать <xref:System.IEquatable%601> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="28993-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="28993-232">Вызова строго типизированного <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> метод позволят избежать упаковки-преобразования `obj` аргумент.</span><span class="sxs-lookup"><span data-stu-id="28993-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28993-233">В следующем примере показан `Point` класса, переопределяющего <xref:System.Object.Equals%2A> метод, чтобы предоставить равенства значений и `Point3D` класс, который является производным от `Point`.</span><span class="sxs-lookup"><span data-stu-id="28993-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="28993-234">Так как `Point` переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> для проверки на равенство значений, <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод не вызывается.</span><span class="sxs-lookup"><span data-stu-id="28993-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="28993-235">Тем не менее `Point3D.Equals` вызовы `Point.Equals` поскольку `Point` реализует <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> способом, который предоставляет равенства значений.</span><span class="sxs-lookup"><span data-stu-id="28993-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="28993-236">`Point.Equals` Метод проверяет, убедитесь, что `obj` аргумент не является **null** и что он ссылается на экземпляр того же типа, что и этот объект.</span><span class="sxs-lookup"><span data-stu-id="28993-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="28993-237">Если проверка завершается с ошибкой, метод возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="28993-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="28993-238">`Point.Equals` Вызовы методов <xref:System.Object.GetType%2A> метод, чтобы определить, совпадают ли типы среды выполнения двух объектов.</span><span class="sxs-lookup"><span data-stu-id="28993-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="28993-239">Если используется метод проверки формы `obj is Point` в C# или `TryCast(obj, Point)` в Visual Basic, будет возвращать `true` в случаях, где `obj` является экземпляром класса, производного от `Point`, даже если `obj` и текущий экземпляр не того же типа времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="28993-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="28993-240">Убедившись, что оба объекта имеют одного типа, метод приводит `obj` ввода `Point` и возвращает результат сравнения двух объектов полей экземпляра.</span><span class="sxs-lookup"><span data-stu-id="28993-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="28993-241">В `Point3D.Equals`, наследуемого `Point.Equals` метод, который переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, вызывается перед выполнением других действий.</span><span class="sxs-lookup"><span data-stu-id="28993-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="28993-242">Так как `Point3D` является запечатанным (`NotInheritable` в Visual Basic), проверку в форме `obj is Point` в C# или `TryCast(obj, Point)` в Visual Basic — достаточно, чтобы убедиться, что `obj` является `Point3D` объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="28993-243">Если это `Point3D` объекта, оно приводится к `Point` объекта и передается в реализацию базового класса <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="28993-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="28993-244">Только тогда, когда унаследованный `Point.Equals` возвращает `true` метод compare `z` экземпляр полей, представленные в производном классе.</span><span class="sxs-lookup"><span data-stu-id="28993-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="28993-245">В следующем примере определяется `Rectangle` класс, реализующий внутри прямоугольника, как два `Point` объектов.</span><span class="sxs-lookup"><span data-stu-id="28993-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="28993-246">`Rectangle` Класса также переопределения <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> для предоставления равенство значений.</span><span class="sxs-lookup"><span data-stu-id="28993-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="28993-247">В некоторых языках, таких как C# и Visual Basic поддерживает перегрузку операторов.</span><span class="sxs-lookup"><span data-stu-id="28993-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="28993-248">Если тип перегружает оператор равенства, необходимо также переопределить <xref:System.Object.Equals%28System.Object%29> метод, чтобы предоставить те же функциональные возможности.</span><span class="sxs-lookup"><span data-stu-id="28993-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="28993-249">Обычно это выполняется путем написания <xref:System.Object.Equals%28System.Object%29> метод с точки зрения перегруженный оператор равенства, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="28993-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="28993-250">Поскольку `Complex` является типом значения, он не может быть производным от.</span><span class="sxs-lookup"><span data-stu-id="28993-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="28993-251">Таким образом, переопределение, чтобы <xref:System.Object.Equals%28System.Object%29> метод не требуется вызывать <xref:System.Object.GetType%2A> чтобы определить точный тип времени выполнения каждого объекта, но ее можно вместо этого используйте `is` оператор в C# или `TypeOf` оператора в Visual Basic, чтобы проверить тип `obj` параметра.</span><span class="sxs-lookup"><span data-stu-id="28993-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="28993-252">Первый из сравниваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="28993-252">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="28993-253">Второй из сравниваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="28993-253">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="28993-254">Определяет, считаются ли равными указанные экземпляры объектов.</span><span class="sxs-lookup"><span data-stu-id="28993-254">Determines whether the specified object instances are considered equal.</span></span></summary>
        <returns><span data-ttu-id="28993-255"><see langword="true" />, если указанные объекты равны; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="28993-255"><see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="28993-256">Если оба параметра <paramref name="objA" /> и <paramref name="objB" /> имеют значение **NULL**, метод возвращает значение <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="28993-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28993-257">Статический <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> метод указывает, является ли два объекта, `objA` и `objB`, равны.</span><span class="sxs-lookup"><span data-stu-id="28993-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="28993-258">Он также предоставляет возможность проверки объектов, значение которого равно **null** на предмет равенства.</span><span class="sxs-lookup"><span data-stu-id="28993-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="28993-259">Он сравнивает `objA` и `objB` равенство следующим образом:</span><span class="sxs-lookup"><span data-stu-id="28993-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="28993-260">Он определяет, представляют ли два объекта одну и ту же ссылку объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="28993-261">Если это так, метод возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="28993-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="28993-262">Этот тест, аналогичен вызову <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="28993-263">Кроме того, если оба `objA` и `objB` являются **null**, метод возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="28993-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="28993-264">Он определяет, является ли либо `objA` или `objB` — **null**.</span><span class="sxs-lookup"><span data-stu-id="28993-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="28993-265">Если так, он возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="28993-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="28993-266">Если два объекта представляют одну и ту же ссылку объекта, и ни один не **null**, он вызывает `objA`.`Equals` (`objB`) и возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="28993-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="28993-267">Это означает, что если `objA` переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> вызывается метод, это переопределение.</span><span class="sxs-lookup"><span data-stu-id="28993-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28993-268">В следующем примере показано <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> метод и сравнивает его с <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="28993-269">Позволяет объекту попытаться освободить ресурсы и выполнить другие операции очистки, перед тем как он будет уничтожен во время сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="28993-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28993-270"><xref:System.Object.Finalize%2A> Метод используется для выполнения операций очистки на неуправляемые ресурсы, удерживаемые текущим объектом до уничтожения объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="28993-271">Метод защищен и поэтому доступен, только через этот класс или класс, производный.</span><span class="sxs-lookup"><span data-stu-id="28993-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="28993-272">Содержание</span><span class="sxs-lookup"><span data-stu-id="28993-272">In this section:</span></span>  
  
-   [<span data-ttu-id="28993-273">Как работает завершения</span><span class="sxs-lookup"><span data-stu-id="28993-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="28993-274">Примечания для разработчиков</span><span class="sxs-lookup"><span data-stu-id="28993-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="28993-275">Вместо этого класс SafeHandle</span><span class="sxs-lookup"><span data-stu-id="28993-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="28993-276">Как работает завершения</span><span class="sxs-lookup"><span data-stu-id="28993-276">How finalization works</span></span>  
 <span data-ttu-id="28993-277"><xref:System.Object> Класс не предоставляет реализацию для <xref:System.Object.Finalize%2A> метод и сборщик мусора не помечать типы, производные от <xref:System.Object> для финализации, если только они переопределяют <xref:System.Object.Finalize%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="28993-278">Если тип переопределяется <xref:System.Object.Finalize%2A> метод, сборщик мусора добавляет запись для каждого экземпляра типа внутреннюю структуру, называемую очередью завершения.</span><span class="sxs-lookup"><span data-stu-id="28993-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="28993-279">Очереди на финализацию. содержит записи для всех объектов в управляемой куче, необходимо запустить, код завершения, прежде чем сборщик мусора мог освободить память.</span><span class="sxs-lookup"><span data-stu-id="28993-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="28993-280">Затем сборщик мусора вызывает <xref:System.Object.Finalize%2A> метод автоматически при следующих условиях:</span><span class="sxs-lookup"><span data-stu-id="28993-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="28993-281">После сборщик мусора обнаружил, что объект недоступен, если объект завершение было отключено с помощью вызова <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="28993-282">**В .NET Framework только**, во время завершения работы домена приложения, если объект не было отключено.</span><span class="sxs-lookup"><span data-stu-id="28993-282">**On .NET Framework only**, during shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="28993-283">Во время завершения работы были закрыты даже объекты, которые по-прежнему доступны.</span><span class="sxs-lookup"><span data-stu-id="28993-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="28993-284"><xref:System.Object.Finalize%2A> автоматически вызывается только один раз на данном экземпляре, если объект повторно зарегистрировать с помощью механизма, такие как <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> и <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> впоследствии не был вызван метод.</span><span class="sxs-lookup"><span data-stu-id="28993-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="28993-285"><xref:System.Object.Finalize%2A> операции имеют следующие ограничения:</span><span class="sxs-lookup"><span data-stu-id="28993-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="28993-286">Точное время выполнения метода завершения не определен.</span><span class="sxs-lookup"><span data-stu-id="28993-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="28993-287">Чтобы обеспечить детерминированного освобождения ресурсов для экземпляров класса, реализовывать `Close` метод или предоставить <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализации.</span><span class="sxs-lookup"><span data-stu-id="28993-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="28993-288">Методы завершения для двух объектов не гарантируется выполнение в каком-либо порядке, даже если один объект ссылается на другой.</span><span class="sxs-lookup"><span data-stu-id="28993-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="28993-289">То есть если объект A содержит ссылку на объект B и оба имеют методы завершения, объект B может быть уже был завершен при запуске метода завершения объекта типа.</span><span class="sxs-lookup"><span data-stu-id="28993-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="28993-290">Поток, на котором выполняется метод завершения не определен.</span><span class="sxs-lookup"><span data-stu-id="28993-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="28993-291"><xref:System.Object.Finalize%2A> Метода могут не работать до завершения или вообще не может выполняться в следующих исключительных обстоятельствах:</span><span class="sxs-lookup"><span data-stu-id="28993-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="28993-292">Если другой метод завершения блокирования на неопределенное время (переходит в бесконечный цикл, пытается получить блокировку, он никогда не получает и так далее).</span><span class="sxs-lookup"><span data-stu-id="28993-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="28993-293">Так как среда выполнения пытается выполнять методы завершения для завершения, другие методы завершения может не вызываться, если финализатор неопределенное время.</span><span class="sxs-lookup"><span data-stu-id="28993-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="28993-294">Если процесс завершается без предоставления среде выполнения возможность очистки.</span><span class="sxs-lookup"><span data-stu-id="28993-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="28993-295">В этом случае первый уведомлением среды выполнения о завершении процесса — это уведомление DLL_PROCESS_DETACH.</span><span class="sxs-lookup"><span data-stu-id="28993-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="28993-296">Среда выполнения продолжает для завершения объектов во время завершения работы только в том случае, пока количество Завершаемые объекты продолжает уменьшаться.</span><span class="sxs-lookup"><span data-stu-id="28993-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="28993-297">Если <xref:System.Object.Finalize%2A> или переопределение <xref:System.Object.Finalize%2A> создает исключение и среда выполнения не будет размещено в приложение, которое переопределяет политику по умолчанию, среда выполнения завершает процесс и отсутствие активного `try` / `finally` блоки или метод завершения выполняются.</span><span class="sxs-lookup"><span data-stu-id="28993-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="28993-298">Такое поведение гарантирует целостность процесса, если метод завершения не может освобождения или удаления ресурсов.</span><span class="sxs-lookup"><span data-stu-id="28993-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="28993-299">Переопределение метода Finalize</span><span class="sxs-lookup"><span data-stu-id="28993-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="28993-300">Необходимо переопределить <xref:System.Object.Finalize%2A> для класса, который использует неуправляемые ресурсы, такие как дескрипторы файлов или подключения к базе данных, которые должны быть освобождены при управляемый объект, который использует их во время сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="28993-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="28993-301">Не должен реализовывать <xref:System.Object.Finalize%2A> метод для управляемых объектов, так как сборщик мусора автоматически освобождает управляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="28993-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="28993-302">Если <xref:System.Runtime.InteropServices.SafeHandle> доступен объект, который служит оболочкой неуправляемый ресурс, рекомендуется реализовать шаблон dispose с безопасным дескриптором и переопределяет <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="28993-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="28993-303">Дополнительные сведения см. в разделе [SafeHandle альтернатива](#SafeHandle) раздел.</span><span class="sxs-lookup"><span data-stu-id="28993-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="28993-304"><xref:System.Object.Finalize%2A?displayProperty=nameWithType> Метод не выполняет никаких действий по умолчанию, но необходимо переопределить <xref:System.Object.Finalize%2A> только в том случае, если необходимо и только для освобождения неуправляемых ресурсов.</span><span class="sxs-lookup"><span data-stu-id="28993-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="28993-305">Освобождение памяти обычно занимает больше времени при выполнении операции завершения, поскольку она требует по крайней мере два сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="28993-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="28993-306">Кроме того, необходимо переопределить <xref:System.Object.Finalize%2A> метод для ссылки только для типов.</span><span class="sxs-lookup"><span data-stu-id="28993-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="28993-307">Среда CLR завершает только ссылочные типы.</span><span class="sxs-lookup"><span data-stu-id="28993-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="28993-308">Он игнорирует методы завершения для типов значений.</span><span class="sxs-lookup"><span data-stu-id="28993-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="28993-309">Область <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метод `protected`.</span><span class="sxs-lookup"><span data-stu-id="28993-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="28993-310">При переопределении метода в классе следует поддерживать эта ограниченная область действия.</span><span class="sxs-lookup"><span data-stu-id="28993-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="28993-311">Сохраняя <xref:System.Object.Finalize%2A> метод, защищенный, не позволит пользователям приложения при вызове объекта <xref:System.Object.Finalize%2A> метод напрямую.</span><span class="sxs-lookup"><span data-stu-id="28993-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="28993-312">Каждая реализация <xref:System.Object.Finalize%2A> в производном типе, необходимо вызвать реализацию его базового типа <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="28993-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="28993-313">Это единственный случай, в какие приложения могут вызывать код <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="28993-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="28993-314">Объекта <xref:System.Object.Finalize%2A> метод не следует вызывать метод для любого объекта, за исключением этого базового класса.</span><span class="sxs-lookup"><span data-stu-id="28993-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="28993-315">Это потому, что при вызове других объектов собирается в то же время, что и вызывающий объект, например в случае закрытия среды CLR.</span><span class="sxs-lookup"><span data-stu-id="28993-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="28993-316">Компилятор C# не позволяет переопределить <xref:System.Object.Finalize%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="28993-317">Вместо этого предоставлять метод завершения, реализовав [деструктор](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) для класса.</span><span class="sxs-lookup"><span data-stu-id="28993-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="28993-318">Деструктор C# автоматически вызывает деструкторы базового класса.</span><span class="sxs-lookup"><span data-stu-id="28993-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="28993-319">Visual C++ также предоставляет свой собственный синтаксис для реализации <xref:System.Object.Finalize%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="28993-320">Дополнительные сведения см. в разделе «Деструкторы и методы завершения» из [как: Определение и использование классов и структур (C++выполняет)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span><span class="sxs-lookup"><span data-stu-id="28993-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="28993-321">Так как сборка мусора является недетерминированным, вы не знаете точно в том случае, когда сборщик мусора выполняет финализации.</span><span class="sxs-lookup"><span data-stu-id="28993-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="28993-322">Чтобы освободить ресурсы немедленно, вы также можете реализовать [шаблон удаления](~/docs/standard/garbage-collection/implementing-dispose.md) и <xref:System.IDisposable> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="28993-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="28993-323"><xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Реализации могут быть вызваны потребителям вашего класса, чтобы освободить неуправляемые ресурсы, а также можно использовать <xref:System.Object.Finalize%2A> метод для освобождения неуправляемых ресурсов в случае недоступности <xref:System.IDisposable.Dispose%2A> метод не вызывается.</span><span class="sxs-lookup"><span data-stu-id="28993-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="28993-324"><xref:System.Object.Finalize%2A> можно предпринять практически любые действия, включая восстановление объекта (который доступности еще раз), после его очищено во время сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="28993-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="28993-325">Тем не менее объект может быть восстановлен только один раз; <xref:System.Object.Finalize%2A> не может быть вызвана восстановленных объектов во время сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="28993-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span>
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="28993-326">Альтернатива SafeHandle</span><span class="sxs-lookup"><span data-stu-id="28993-326">The SafeHandle alternative</span></span>  
 <span data-ttu-id="28993-327">Создание надежных методов завершения часто является сложной задачей, поскольку не может делать предположения о состоянии приложения и необработанные исключения системы, такие как <xref:System.OutOfMemoryException> и <xref:System.StackOverflowException> завершения метода завершения.</span><span class="sxs-lookup"><span data-stu-id="28993-327">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="28993-328">Вместо реализации метода завершения для класса, чтобы освободить неуправляемые ресурсы, можно использовать объект, который является производным от <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> класса программы-оболочки для неуправляемых ресурсов, а затем реализуйте шаблон удаления без метода завершения.</span><span class="sxs-lookup"><span data-stu-id="28993-328">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="28993-329">.NET Framework предоставляет следующие классы в <xref:Microsoft.Win32?displayProperty=nameWithType> пространство имен, являются производными от <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="28993-329">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="28993-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> Представляет класс-оболочку для дескриптора файла.</span><span class="sxs-lookup"><span data-stu-id="28993-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="28993-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> Представляет класс-оболочку для дескрипторов файлов, размещенный в памяти.</span><span class="sxs-lookup"><span data-stu-id="28993-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="28993-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> Представляет класс-оболочку для указателя на блок неуправляемой памяти.</span><span class="sxs-lookup"><span data-stu-id="28993-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="28993-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, и <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> являются классы-оболочки для криптографических дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="28993-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="28993-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> Представляет класс-оболочку для дескриптора канала.</span><span class="sxs-lookup"><span data-stu-id="28993-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="28993-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> Представляет класс-оболочку для дескриптора в раздел реестра.</span><span class="sxs-lookup"><span data-stu-id="28993-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="28993-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Представляет класс-оболочку для дескриптора ожидания.</span><span class="sxs-lookup"><span data-stu-id="28993-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="28993-337">В следующем примере используется [шаблон удаления](~/docs/standard/garbage-collection/implementing-dispose.md) с безопасные дескрипторы вместо переопределения <xref:System.Object.Finalize%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-337">The following example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="28993-338">Он определяет `FileAssociation` класс-оболочку реестра сведения о приложении, которое обрабатывает файлы с расширением определенного файла.</span><span class="sxs-lookup"><span data-stu-id="28993-338">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="28993-339">Обрабатывает два реестра, возвращаются в виде `out` параметров по Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) вызовы функций передаются <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> конструктор.</span><span class="sxs-lookup"><span data-stu-id="28993-339">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="28993-340">Защищенный тип `Dispose` затем вызывает метод `SafeRegistryHandle.Dispose` метод для освобождения этих двух дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="28993-340">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="28993-341">В следующем примере проверяется, <xref:System.Object.Finalize%2A> метод вызывается, когда объект, переопределяющий <xref:System.Object.Finalize%2A> уничтожается.</span><span class="sxs-lookup"><span data-stu-id="28993-341">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="28993-342">Обратите внимание, что в рабочем приложении <xref:System.Object.Finalize%2A> метод был бы переопределен, чтобы освободить неуправляемые ресурсы, удерживаемые объектом.</span><span class="sxs-lookup"><span data-stu-id="28993-342">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="28993-343">Также Обратите внимание, что в примере C# предоставляет деструктор вместо переопределения <xref:System.Object.Finalize%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-343">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="28993-344">Дополнительный пример, который переопределяет <xref:System.Object.Finalize%2A> метод, см. в разделе <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-344">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="28993-345">Служит хэш-функцией по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="28993-345">Serves as the default hash function.</span></span></summary>
        <returns><span data-ttu-id="28993-346">Хэш-код для текущего объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-346">A hash code for the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28993-347">Хэш-код — это числовое значение, которое используется для вставки и идентификации объекта в коллекции на основе хэша, такие как <xref:System.Collections.Generic.Dictionary%602> класс, <xref:System.Collections.Hashtable> класса или типа, производного от <xref:System.Collections.DictionaryBase> класса.</span><span class="sxs-lookup"><span data-stu-id="28993-347">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="28993-348"><xref:System.Object.GetHashCode%2A> Метод предоставляет этот хэш-код для алгоритмов, требующих быстрой проверки на равенство объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-348">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28993-349">Сведения об использовании хэш-кодов в хэш-таблицы и некоторые дополнительные хэш-код алгоритмы, см. в разделе [хэш-функции](https://en.wikipedia.org/wiki/Hash_function) запись в Википедии.</span><span class="sxs-lookup"><span data-stu-id="28993-349">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="28993-350">Два объекта, равно возвращаемого значения хэш-кодов, которые равны.</span><span class="sxs-lookup"><span data-stu-id="28993-350">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="28993-351">Однако обратное неверно: равно хэш-коды не подразумевают равенство объекта, так как разные объекты (неравных) может иметь одинаковые хэш-кодов.</span><span class="sxs-lookup"><span data-stu-id="28993-351">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="28993-352">Кроме того, .NET не гарантирует, что реализация по умолчанию <xref:System.Object.GetHashCode%2A> метод и значение, этот метод возвращает может отличаться от реализаций .NET, например разных версий .NET Framework и .NET Core и платформ, таких как 32-разрядных и 64-разрядных платформах.</span><span class="sxs-lookup"><span data-stu-id="28993-352">Furthermore, .NET does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET implementations, such as different versions of .NET Framework and .NET Core, and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="28993-353">По этим причинам не используйте реализация по умолчанию этот метод в качестве уникального идентификатора объекта в целях хэширования.</span><span class="sxs-lookup"><span data-stu-id="28993-353">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="28993-354">Из этого, выполните два последствия.</span><span class="sxs-lookup"><span data-stu-id="28993-354">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="28993-355">Не следует предполагать, что равно хэш-коды подразумевают равенство объектов.</span><span class="sxs-lookup"><span data-stu-id="28993-355">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="28993-356">Никогда не следует сохранять или использовать хэш-код за пределами домена приложения, в котором он был создан, поскольку тот же объект может хэш-между доменами приложений, процессами и платформ.</span><span class="sxs-lookup"><span data-stu-id="28993-356">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="28993-357">Хэш-код предназначен для эффективную вставку и поиска в коллекции, основанные на хэш-таблицу.</span><span class="sxs-lookup"><span data-stu-id="28993-357">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="28993-358">Хэш-код не постоянное значение.</span><span class="sxs-lookup"><span data-stu-id="28993-358">A hash code is not a permanent value.</span></span> <span data-ttu-id="28993-359">По этой причине:</span><span class="sxs-lookup"><span data-stu-id="28993-359">For this reason:</span></span>  
>   
> -   <span data-ttu-id="28993-360">Не сериализации значения хэш-кода и сохранять их в базах данных.</span><span class="sxs-lookup"><span data-stu-id="28993-360">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="28993-361">Не используйте хэш-код как ключ для извлечения объекта из коллекции с ключом.</span><span class="sxs-lookup"><span data-stu-id="28993-361">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="28993-362">Не отправляли хэш-кодов по доменам приложений и процессов.</span><span class="sxs-lookup"><span data-stu-id="28993-362">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="28993-363">В некоторых случаях хэш-коды можно было вычислить на основе домена на уровне процесса или на уровне приложения.</span><span class="sxs-lookup"><span data-stu-id="28993-363">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="28993-364">Не используйте хэш-код вместо значения, возвращаемого функцией шифрования хэширования, при необходимости криптостойкой хэш.</span><span class="sxs-lookup"><span data-stu-id="28993-364">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="28993-365">Для криптографических хэшей, используйте класс, производный от <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> или <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> класса.</span><span class="sxs-lookup"><span data-stu-id="28993-365">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="28993-366">Не выполняйте проверку на предмет равенства хэш-кодов, чтобы определить, равны ли два объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-366">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="28993-367">(Не эквивалентны объекты могут иметь одинаковые хэш-коды.) Чтобы проверить на предмет равенства, вызовите <xref:System.Object.ReferenceEquals%2A> или <xref:System.Object.Equals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-367">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="28993-368"><xref:System.Object.GetHashCode%2A> Метод может быть переопределен с помощью производного типа.</span><span class="sxs-lookup"><span data-stu-id="28993-368">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="28993-369">Если <xref:System.Object.GetHashCode%2A> — не выполнено переопределение, хэш-коды для ссылочных типов вычисляются путем вызова <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> на основе методов базового класса, который вычисляет хэш-код, для ссылки на объект; Дополнительные сведения, см. в разделе <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28993-369">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="28993-370">Другими словами, два объекта, для которого <xref:System.Object.ReferenceEquals%2A> возвращает метод `true` иметь одинаковые хэш-кодов.</span><span class="sxs-lookup"><span data-stu-id="28993-370">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="28993-371">Если типы значений не переопределяют <xref:System.Object.GetHashCode%2A>, <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> метод базового класса использует отражение для вычисления хэш-код на основе значений поля типа.</span><span class="sxs-lookup"><span data-stu-id="28993-371">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="28993-372">Другими словами типы значений, поля которых имеют одинаковые значения имеют равно хэш-кодов.</span><span class="sxs-lookup"><span data-stu-id="28993-372">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="28993-373">Дополнительные сведения о переопределении <xref:System.Object.GetHashCode%2A>, см. в разделе «Примечания для разработчиков производных классов».</span><span class="sxs-lookup"><span data-stu-id="28993-373">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="28993-374">При переопределении <xref:System.Object.GetHashCode%2A> метод, необходимо также переопределить <xref:System.Object.Equals%2A>и наоборот.</span><span class="sxs-lookup"><span data-stu-id="28993-374">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="28993-375">Если переопределенный <xref:System.Object.Equals%2A> возвращает `true` при двух объектов для проверки на равенство, переопределенный <xref:System.Object.GetHashCode%2A> метод должен возвращать одинаковое значение для двух объектов.</span><span class="sxs-lookup"><span data-stu-id="28993-375">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="28993-376">Если объект, который используется как ключ в хэш-таблице не предоставляет полезную реализацию <xref:System.Object.GetHashCode%2A>, поставщиком хэш-кода можно указать, указав <xref:System.Collections.IEqualityComparer> реализации к одной из перегрузок <xref:System.Collections.Hashtable> конструктора класса.</span><span class="sxs-lookup"><span data-stu-id="28993-376">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="28993-377">Заметки о [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="28993-377">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="28993-378">При вызове <xref:System.Object.GetHashCode%2A> метод к классу, [!INCLUDE[wrt](~/includes/wrt-md.md)], он предоставляет поведение по умолчанию для классов, которые не переопределяют <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="28993-378">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="28993-379">Это является частью возможностей .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. в разделе [приложений .NET Framework поддерживает для Windows Store и среды выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="28993-379">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="28993-380">Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] не наследуют <xref:System.Object>и в настоящее время не использовать <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="28993-380">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="28993-381">Тем не менее, в них могут быть <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, и <xref:System.Object.GetHashCode%2A> методов при их использовании в коде C# или Visual Basic и .NET Framework предоставляет поведение по умолчанию для этих методов.</span><span class="sxs-lookup"><span data-stu-id="28993-381">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="28993-382">классы, которые создаются на языке C# или Visual Basic можно переопределить <xref:System.Object.GetHashCode%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-382">classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28993-383">Один из самых простых способов для вычисления хэш-код для числового значения с той же или меньший диапазон, чем <xref:System.Int32> типа является просто возвращают это значение.</span><span class="sxs-lookup"><span data-stu-id="28993-383">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="28993-384">Пример такой реализации для `Number` структуры.</span><span class="sxs-lookup"><span data-stu-id="28993-384">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="28993-385">Как правило тип имеет несколько полей данных, которые могут участвовать в создании хэш-код.</span><span class="sxs-lookup"><span data-stu-id="28993-385">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="28993-386">Один из способов создания хэш-код является объединение этих полей с помощью `XOR (eXclusive OR)` операции, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="28993-386">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="28993-387">Предыдущий пример возвращает одинаковый хэш-код для (n1, n2) и (n2, n1) и поэтому может создавать дополнительные конфликтов, чем предпочтительны.</span><span class="sxs-lookup"><span data-stu-id="28993-387">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="28993-388">Таким образом, чтобы хэш-кодов в этих случаях не идентичны доступны несколько решений.</span><span class="sxs-lookup"><span data-stu-id="28993-388">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="28993-389">Один — вернуть хэш-код `Tuple` объект, который совпадает с порядком каждого поля.</span><span class="sxs-lookup"><span data-stu-id="28993-389">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="28993-390">В следующем примере показано возможная реализация, которая использует <xref:System.Tuple%602> класса.</span><span class="sxs-lookup"><span data-stu-id="28993-390">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="28993-391">Обратите внимание на то, производительность создания `Tuple` объекта может значительно повлиять на общую производительность приложения, который хранит большое количество объектов в хэш-таблицы.</span><span class="sxs-lookup"><span data-stu-id="28993-391">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="28993-392">Второй альтернативное решение включает в себя изменение веса отдельных хэш-коды, сдвиг влево хэш-коды последующих полей двух или более разрядами.</span><span class="sxs-lookup"><span data-stu-id="28993-392">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="28993-393">Лучше всего вместо уничтожается, биты, сдвигаемые дальше 31 разряд завернуть, а не отменены.</span><span class="sxs-lookup"><span data-stu-id="28993-393">Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="28993-394">Поскольку биты отбрасываются операторами сдвига влево, в C# и Visual Basic, для этого требуется создание левой метода shift и перенос следующим образом:</span><span class="sxs-lookup"><span data-stu-id="28993-394">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="28993-395">В следующем примере затем используется этот метод shift и перенос для вычисления хэш-код `Point` структура, используемая в предыдущих примерах.</span><span class="sxs-lookup"><span data-stu-id="28993-395">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="28993-396">Хэш-функции используется для быстрого создания числа (хэш-код), соответствующее значению объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-396">A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</span></span> <span data-ttu-id="28993-397">Хэш-функции обычно специфичны для каждого типа и для уникальности, необходимо использовать по крайней мере одно из полей экземпляра как входные данные.</span><span class="sxs-lookup"><span data-stu-id="28993-397">Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</span></span> <span data-ttu-id="28993-398">Хэш-коды не должно быть вычислено с помощью значения статических полей.</span><span class="sxs-lookup"><span data-stu-id="28993-398">Hash codes should not be computed by using the values of static fields.</span></span>  
  
<span data-ttu-id="28993-399">Для классов, производных от <see cref="T:System.Object" />, <see langword="GetHashCode" /> метод можно делегировать базовому классу <see cref="M:System.Object.GetHashCode" /> реализации только в том случае, если производный класс определяет равенство ссылок.</span><span class="sxs-lookup"><span data-stu-id="28993-399">For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality.</span></span> <span data-ttu-id="28993-400">Реализация по умолчанию <see cref="M:System.Object.GetHashCode" /> для ссылки на типы Возвращает хэш-код, который эквивалентен возвращенного <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-400">The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method.</span></span> <span data-ttu-id="28993-401">Можно переопределить <see cref="M:System.Object.GetHashCode" /> для неизменяемого ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="28993-401">You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types.</span></span> <span data-ttu-id="28993-402">В общем случае для изменяемые ссылочные типы, должны переопределять <see cref="M:System.Object.GetHashCode" /> только если:</span><span class="sxs-lookup"><span data-stu-id="28993-402">In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:</span></span> 
<span data-ttu-id="28993-403">— Вы можете вычислить хэш-код из полей, которые не являются изменяемыми; или</span><span class="sxs-lookup"><span data-stu-id="28993-403">-   You can compute the hash code from fields that are not mutable; or</span></span> 
<span data-ttu-id="28993-404">— Убедитесь, что хэш-код из изменяемого объекта не изменяется, пока объект, содержащийся в коллекции, которая зависит от ее хэш-код.</span><span class="sxs-lookup"><span data-stu-id="28993-404">-   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</span></span>  
  
<span data-ttu-id="28993-405">В противном случае можно подумать, что изменяемый объект теряются в хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="28993-405">Otherwise, you might think that the mutable object is lost in the hash table.</span></span> <span data-ttu-id="28993-406">Если вы выберете для переопределения <see cref="M:System.Object.GetHashCode" /> для изменяемый ссылочный тип, к документации по должна обеспечивать что пользователи вашего типа не могут изменять значения объекта во время хранения объекта в хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="28993-406">If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</span></span>  
  
<span data-ttu-id="28993-407">Для типов значений <see cref="M:System.ValueType.GetHashCode" /> предоставляет стандартную реализацию кода хэш, который использует отражение.</span><span class="sxs-lookup"><span data-stu-id="28993-407">For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection.</span></span> <span data-ttu-id="28993-408">Рассмотрите возможность его переопределения для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="28993-408">You should consider overriding it for better performance.</span></span>  
  
 <block subset="none" type="note"><para>  
 <span data-ttu-id="28993-409">Дополнительные сведения и примеры, которые вычисляют хэш-кодов в различными способами см. в разделе «примеры».</span><span class="sxs-lookup"><span data-stu-id="28993-409">For more information and examples that compute hash codes in a variety of ways, see the Examples section.</span></span>  
  
</para></block>  
  
 <span data-ttu-id="28993-410">Хэш-функции должен иметь следующие свойства:</span><span class="sxs-lookup"><span data-stu-id="28993-410">A hash function must have the following properties:</span></span> 
<span data-ttu-id="28993-411">— Если два объекта считаются равными, <see cref="M:System.Object.GetHashCode" /> метод для каждого объекта должен возвращать то же значение.</span><span class="sxs-lookup"><span data-stu-id="28993-411">-   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value.</span></span> <span data-ttu-id="28993-412">Тем не менее, если два объекта не сравнении считаются равными, <see cref="M:System.Object.GetHashCode" /> методов для двух объектов не требуется возвращать разные значения.</span><span class="sxs-lookup"><span data-stu-id="28993-412">However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.</span></span>  
  
<span data-ttu-id="28993-413">- <see cref="M:System.Object.GetHashCode" /> Метод для объекта, необходимо постоянно возвращает же хэш-код до тех пор, пока не существует каких-либо изменений в состояние объекта, которое определяет возвращаемое значение объекта [System.Object.Equals](xref:System.Object.Equals*) метод.</span><span class="sxs-lookup"><span data-stu-id="28993-413">-   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method.</span></span> <span data-ttu-id="28993-414">Обратите внимание, что это справедливо только для текущего выполнения приложения, и что разные хэш-код могут быть возвращены, если приложение запускается снова.</span><span class="sxs-lookup"><span data-stu-id="28993-414">Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</span></span>  
  
<span data-ttu-id="28993-415">— Для повышения производительности хэш-функции следует создавать равномерное распределение для всех входных данных, включая входные данные, которые сильно кластеризован.</span><span class="sxs-lookup"><span data-stu-id="28993-415">-   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</span></span> <span data-ttu-id="28993-416">Подразумевается, что небольшие изменения для состояния объекта должно привести к внесении значительных изменений в результирующее хэш-код для достижения оптимальной производительности хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="28993-416">An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</span></span>  
  
<span data-ttu-id="28993-417">-Хэш функции должны быть недорогих для вычисления.</span><span class="sxs-lookup"><span data-stu-id="28993-417">-   Hash functions should be inexpensive to compute.</span></span>  
  
<span data-ttu-id="28993-418">- <see cref="M:System.Object.GetHashCode" /> Метод не должен вызывать исключения.</span><span class="sxs-lookup"><span data-stu-id="28993-418">-   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.</span></span>  
  
<span data-ttu-id="28993-419">Например, реализация <see cref="M:System.String.GetHashCode" /> метод <see cref="T:System.String" /> класс возвращает одинаковые хэш-коды для идентичные строковые значения.</span><span class="sxs-lookup"><span data-stu-id="28993-419">For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values.</span></span> <span data-ttu-id="28993-420">Таким образом, два <see cref="T:System.String" /> объекты возвращают одинаковый хэш-код, если они представляют тот же строковый параметр.</span><span class="sxs-lookup"><span data-stu-id="28993-420">Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value.</span></span> <span data-ttu-id="28993-421">Кроме того, этот метод использует все символы в строке для создания случайно распределенного результата, даже в том случае, если входные данные является кластеризованным экземпляром в определенные диапазоны (например, многие пользователи применяют строки, содержащие только первые 128 ASCII, даже если Строка может содержать любой из 65535 символов Юникода).</span><span class="sxs-lookup"><span data-stu-id="28993-421">Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</span></span>  
  
<span data-ttu-id="28993-422">Предоставление хорошей хэш-функции для каждого класса может существенно повлиять на производительность Добавление соответствующих объектов в хэш-таблицу.</span><span class="sxs-lookup"><span data-stu-id="28993-422">Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</span></span> <span data-ttu-id="28993-423">В хэш-таблицы с ключами, которые обеспечивают реализацию хорошей хэш-функции поиск элементов требуется постоянное время (например, операцией o(1)).</span><span class="sxs-lookup"><span data-stu-id="28993-423">In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</span></span> <span data-ttu-id="28993-424">В хэш-таблице при плохой реализации хэш-функции, производительность поиска зависит от числа элементов в хэш-таблицы (например, операцией O (`n`) операции, где `n` — количество элементов в хэш-таблице).</span><span class="sxs-lookup"><span data-stu-id="28993-424">In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table).</span></span> <span data-ttu-id="28993-425">Пользователь-злоумышленник может входные данные, которое увеличивает количество конфликтов, которые может значительно ухудшить производительность приложений, которые зависят от хэш-таблицы, при следующих условиях:</span><span class="sxs-lookup"><span data-stu-id="28993-425">A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</span></span> 
<span data-ttu-id="28993-426">-Когда хэш-функциям произвести часто конфликтов.</span><span class="sxs-lookup"><span data-stu-id="28993-426">-   When hash functions produce frequent collisions.</span></span>  
  
<span data-ttu-id="28993-427">-Когда значительная доля объектов в хэш-таблицу произвести хэш-кодов, которые равны или приблизительно равно друг с другом.</span><span class="sxs-lookup"><span data-stu-id="28993-427">-   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</span></span>  
  
<span data-ttu-id="28993-428">— При вводе пользователями данных, из которого вычисляется хэш-код.</span><span class="sxs-lookup"><span data-stu-id="28993-428">-   When users input the data from which the hash code is computed.</span></span>  
  
<span data-ttu-id="28993-429">Производные классы, переопределяющие <see cref="M:System.Object.GetHashCode" /> необходимо также переопределить <see cref="M:System.Object.Equals(System.Object)" /> гарантировать, что два объекта считаются равными, имеют одинаковый хэш-код; в противном случае <see cref="T:System.Collections.Hashtable" /> типа могут работать неправильно.</span><span class="sxs-lookup"><span data-stu-id="28993-429">Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</span></span></para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="28993-430">Возвращает объект <see cref="T:System.Type" /> для текущего экземпляра.</span><span class="sxs-lookup"><span data-stu-id="28993-430">Gets the <see cref="T:System.Type" /> of the current instance.</span></span></summary>
        <returns><span data-ttu-id="28993-431">Точный тип текущего экземпляра в среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="28993-431">The exact runtime type of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28993-432">Так как <xref:System.Object?displayProperty=nameWithType> является базовым классом для всех типов в .NET системе типов <xref:System.Object.GetType%2A> метод может использоваться для возврата <xref:System.Type> объекты, представляющие все типы .NET.</span><span class="sxs-lookup"><span data-stu-id="28993-432">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET types.</span></span> <span data-ttu-id="28993-433">.NET распознает следующие пять категорий типов:</span><span class="sxs-lookup"><span data-stu-id="28993-433">.NET recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="28993-434">Классы, которые являются производными от <xref:System.Object?displayProperty=nameWithType>,</span><span class="sxs-lookup"><span data-stu-id="28993-434">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="28993-435">Типы, которые являются производными от значений <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28993-435">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="28993-436">Интерфейсы, которые являются производными от <xref:System.Object?displayProperty=nameWithType> начиная с .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="28993-436">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="28993-437">Перечислений, которые являются производными от <xref:System.Enum?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28993-437">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="28993-438">Делегаты, которые являются производными от <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28993-438">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="28993-439">Для двух объектов `x` и `y` , которые имеют типы идентичные среды выполнения, `Object.ReferenceEquals(x.GetType(),y.GetType())` возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="28993-439">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="28993-440">В следующем примере используется <xref:System.Object.GetType%2A> метод с <xref:System.Object.ReferenceEquals%2A> метод, чтобы определить, является ли одно числовое значение совпадает с типом двух числовых значений.</span><span class="sxs-lookup"><span data-stu-id="28993-440">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="28993-441">Чтобы определить, является ли объект определенного типа, можно использовать ключевое слово языка типа сравнения или создания.</span><span class="sxs-lookup"><span data-stu-id="28993-441">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="28993-442">Например, можно использовать `TypeOf…Is` конструкции в Visual Basic или `is` ключевого слова C#.</span><span class="sxs-lookup"><span data-stu-id="28993-442">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="28993-443"><xref:System.Object.GetType%2A> Метод наследуется всеми типами, которые являются производными от <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="28993-443">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="28993-444">Это означает, что, помимо использования ключевого слова сравнения собственный язык, можно использовать <xref:System.Object.GetType%2A> метод для определения типа, определенного объекта, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="28993-444">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <span data-ttu-id="28993-445"><xref:System.Type> Объект предоставляет метаданные, связанные с классом текущего <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="28993-445">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28993-446">В следующем примере кода показано, что <xref:System.Object.GetType%2A> возвращает тип среды выполнения текущего экземпляра.</span><span class="sxs-lookup"><span data-stu-id="28993-446">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="28993-447">Создает неполную копию текущего объекта <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="28993-447">Creates a shallow copy of the current <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="28993-448">Неполная копия объекта <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="28993-448">A shallow copy of the current <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28993-449"><xref:System.Object.MemberwiseClone%2A> Метод создает неполную копию путем создания нового объекта, а затем скопировать нестатические поля текущего объекта в новый объект.</span><span class="sxs-lookup"><span data-stu-id="28993-449">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="28993-450">Если поле является типом значения, выполняется копию бит за битом поля.</span><span class="sxs-lookup"><span data-stu-id="28993-450">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="28993-451">Если поле имеет ссылочный тип, ссылка копируется, а не объект, который указывает ссылка; Поэтому исходный объект и его копия, относятся к тому же объекту.</span><span class="sxs-lookup"><span data-stu-id="28993-451">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="28993-452">Например рассмотрим объект, называемый X, который ссылается на объекты A и B объект б, в свою очередь, ссылается на объект C. Неполная копия объекта X создает новый объект X2, который также ссылается на объекты, А и б. Напротив глубокую копию объекта X создает новый объект X2, который ссылается на новые объекты, A2 и B2, которые являются копиями A и B2 б, в свою очередь, ссылается на новый объект C2, который является копией C. Пример демонстрирует различие между shallow и глубокого копирования.</span><span class="sxs-lookup"><span data-stu-id="28993-452">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="28993-453">Существуют многочисленные способы реализации операции глубокую копию, если операция Неполная копия выполнена пользователем <xref:System.Object.MemberwiseClone%2A> метод не соответствует вашим потребностям.</span><span class="sxs-lookup"><span data-stu-id="28993-453">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="28993-454">В число этих требований входят следующие:</span><span class="sxs-lookup"><span data-stu-id="28993-454">These include the following:</span></span>  
  
-   <span data-ttu-id="28993-455">Вызовите конструктор класса объекта для копирования для создания второго объекта значениями свойств, полученными из первого объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-455">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="28993-456">При этом предполагается, что значения объекта полностью определяются его конструктор.</span><span class="sxs-lookup"><span data-stu-id="28993-456">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="28993-457">Вызовите <xref:System.Object.MemberwiseClone%2A> способ создания неполную копию объекта, а затем назначьте новые объекты, значения которого совпадают с исходного объекта для любого свойства или поля, значения которого являются ссылочными типами.</span><span class="sxs-lookup"><span data-stu-id="28993-457">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="28993-458">`DeepCopy` Этот подход показан метод в примере.</span><span class="sxs-lookup"><span data-stu-id="28993-458">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="28993-459">Сериализовать объект в быть глубокого копирования, а затем восстановите сериализованные данные переменной другому объекту.</span><span class="sxs-lookup"><span data-stu-id="28993-459">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="28993-460">Отражение с рекурсией можно используйте для выполнения операции глубокого копирования.</span><span class="sxs-lookup"><span data-stu-id="28993-460">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28993-461">В следующем примере показано <xref:System.Object.MemberwiseClone%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-461">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="28993-462">Он определяет `ShallowCopy` метод, который вызывает <xref:System.Object.MemberwiseClone%2A> метод для выполнения операции неполную копию `Person` объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-462">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="28993-463">Он также определяет `DeepCopy` метод, который выполняет операцию глубокую копию на `Person` объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-463">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="28993-464">В этом примере `Person.IdInfo` возвращает `IdInfo` объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-464">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="28993-465">Как видно в результатах показано в примере при `Person` клонировании объекта путем вызова <xref:System.Object.MemberwiseClone%2A> метод, клонированный `Person` объект — это независимая копия исходного объекта, за исключением того, что они имеют одинаковое `Person.IdInfo` ссылка на объект.</span><span class="sxs-lookup"><span data-stu-id="28993-465">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="28993-466">В результате изменения клона `Person.IdInfo` изменении свойства исходного объекта `Person.IdInfo` свойство.</span><span class="sxs-lookup"><span data-stu-id="28993-466">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="28993-467">С другой стороны, когда выполняется операция глубокую копию, клонированный `Person` объекта, включая его `Person.IdInfo` свойство, может быть изменено без влияния на исходный объект.</span><span class="sxs-lookup"><span data-stu-id="28993-467">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="28993-468">Первый из сравниваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="28993-468">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="28993-469">Второй из сравниваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="28993-469">The second object  to compare.</span></span></param>
        <summary><span data-ttu-id="28993-470">Определяет, совпадают ли указанные экземпляры <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="28993-470">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span></span></summary>
        <returns><span data-ttu-id="28993-471">Значение <see langword="true" />, если параметр <paramref name="objA" /> соответствует тому же экземпляру, что и параметр <paramref name="objB" />, или же оба они имеют значение **NULL**; в противном случае значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="28993-471"><see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28993-472">В отличие от <xref:System.Object.Equals%2A> метода и оператор равенства, <xref:System.Object.ReferenceEquals%2A> метод не может быть переопределен.</span><span class="sxs-lookup"><span data-stu-id="28993-472">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="28993-473">Из-за этого, если вы хотите протестировать две ссылки на объекты на равенство, и вы не знаете о реализации `Equals` метод, можно вызвать <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-473">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="28993-474">Тем не менее возвращаемое значение <xref:System.Object.ReferenceEquals%2A> метод может показаться подозрительной активности в этих двух сценариев:</span><span class="sxs-lookup"><span data-stu-id="28993-474">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="28993-475">При сравнении типов значений.</span><span class="sxs-lookup"><span data-stu-id="28993-475">When comparing value types.</span></span> <span data-ttu-id="28993-476">Если `objA` и `objB` являются типами значений, они упакованы, прежде чем они будут переданы <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-476">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="28993-477">Это означает, что если оба `objA` и `objB` тем же экземпляром типом значения, представляющие <xref:System.Object.ReferenceEquals%2A> тем не менее, метод возвращает `false`, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="28993-477">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="28993-478">Сведения о упаковки-преобразования типов значений, см. в разделе [упаковка-преобразование и распаковка-преобразование](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span><span class="sxs-lookup"><span data-stu-id="28993-478">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="28993-479">При сравнении строк.</span><span class="sxs-lookup"><span data-stu-id="28993-479">When comparing strings.</span></span> <span data-ttu-id="28993-480">Если `objA` и `objB` представляют собой строки, <xref:System.Object.ReferenceEquals%2A> возвращает метод `true` Если интернировано строки.</span><span class="sxs-lookup"><span data-stu-id="28993-480">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="28993-481">Он не выполняет проверку на предмет равенства значений.</span><span class="sxs-lookup"><span data-stu-id="28993-481">It does not perform a test for value equality.</span></span>  <span data-ttu-id="28993-482">В следующем примере `s1` и `s2` равны, поскольку они являются два экземпляра одной интернированные строки.</span><span class="sxs-lookup"><span data-stu-id="28993-482">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="28993-483">Тем не менее `s3` и `s4` не равны, так как несмотря на то, что они являются имеют идентичные строковые значения, эта строка не начал работать.</span><span class="sxs-lookup"><span data-stu-id="28993-483">However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="28993-484">Дополнительные сведения об интернировании см. в разделе <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28993-484">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28993-485">В следующем примере используется <xref:System.Object.ReferenceEquals%2A> для определения того, если два объекта являются одним экземпляром.</span><span class="sxs-lookup"><span data-stu-id="28993-485">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="28993-486">Возвращает строку, представляющую текущий объект.</span><span class="sxs-lookup"><span data-stu-id="28993-486">Returns a string that represents the current object.</span></span></summary>
        <returns><span data-ttu-id="28993-487">Строка, представляющая текущий объект.</span><span class="sxs-lookup"><span data-stu-id="28993-487">A string that represents the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28993-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> форматирование основной метод в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="28993-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="28993-489">Он преобразует объект в строковое представление, так как это подходящее для отображения.</span><span class="sxs-lookup"><span data-stu-id="28993-489">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="28993-490">(Сведения о форматировании поддержки в .NET Framework, см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).) Используемые по умолчанию реализации <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод возвращает полное имя типа объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-490">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="28993-491">Вы может попасть на эту страницу, щелкнув ссылку из списка членов другого типа.</span><span class="sxs-lookup"><span data-stu-id="28993-491">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="28993-492">Это потому, что этот тип не переопределяет <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28993-492">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="28993-493">Вместо этого он наследует функциональные возможности <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-493">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="28993-494">Типы часто переопределить <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, чтобы предоставить более подходящим строковое представление определенного типа.</span><span class="sxs-lookup"><span data-stu-id="28993-494">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="28993-495">Типы также часто перегружать <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, чтобы обеспечить поддержку для строки формата или форматирование с учетом языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="28993-495">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="28993-496">Содержание</span><span class="sxs-lookup"><span data-stu-id="28993-496">In this section:</span></span>  
  
 <span data-ttu-id="28993-497">[Метод Object.ToString() по умолчанию](#Default) </span><span class="sxs-lookup"><span data-stu-id="28993-497">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="28993-498">[Переопределение метода Object.ToString()](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="28993-498">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="28993-499">[Перегрузка метода ToString](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="28993-499">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="28993-500">[Расширение метода Object.ToString](#Extending) </span><span class="sxs-lookup"><span data-stu-id="28993-500">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="28993-501">Примечания для среды выполнения Windows</span><span class="sxs-lookup"><span data-stu-id="28993-501">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="28993-502">Метод Object.ToString() по умолчанию</span><span class="sxs-lookup"><span data-stu-id="28993-502">The default Object.ToString() method</span></span>  
 <span data-ttu-id="28993-503">Реализация по умолчанию <xref:System.Object.ToString%2A> метод возвращает полное имя типа <xref:System.Object>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="28993-503">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="28993-504">Так как <xref:System.Object> является базовым классом для всех ссылочных типов в .NET Framework, это поведение наследуется ссылочных типов, не переопределяющих <xref:System.Object.ToString%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-504">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="28993-505">Это показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="28993-505">The following example illustrates this.</span></span> <span data-ttu-id="28993-506">Он определяет класс с именем `Object1` , принимающий реализацию по умолчанию все <xref:System.Object> члены.</span><span class="sxs-lookup"><span data-stu-id="28993-506">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="28993-507">Его <xref:System.Object.ToString%2A> метод возвращает полное имя объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-507">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="28993-508">Переопределение метода Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="28993-508">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="28993-509">Типы обычно переопределить <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, чтобы вернуть строку, которая представляет экземпляр объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-509">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="28993-510">Например, базовый типы, такие как <xref:System.Char>, <xref:System.Int32>, и <xref:System.String> предоставляют <xref:System.Object.ToString%2A> реализаций, которые возвращают значение, представляющее объект строковая форма.</span><span class="sxs-lookup"><span data-stu-id="28993-510">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="28993-511">В следующем примере определяется класс, `Object2`, который переопределяет <xref:System.Object.ToString%2A> метод для возврата имени типа вместе с его значением.</span><span class="sxs-lookup"><span data-stu-id="28993-511">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="28993-512">В следующей таблице перечислены категории типов в .NET и указывает ли они переопределяют <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-512">The following table lists the type categories in .NET and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="28993-513">Категория типа</span><span class="sxs-lookup"><span data-stu-id="28993-513">Type category</span></span>|<span data-ttu-id="28993-514">Переопределяет Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="28993-514">Overrides Object.ToString()</span></span>|<span data-ttu-id="28993-515">Поведение</span><span class="sxs-lookup"><span data-stu-id="28993-515">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="28993-516">Класс</span><span class="sxs-lookup"><span data-stu-id="28993-516">Class</span></span>|<span data-ttu-id="28993-517">Н/Д</span><span class="sxs-lookup"><span data-stu-id="28993-517">n/a</span></span>|<span data-ttu-id="28993-518">Н/Д</span><span class="sxs-lookup"><span data-stu-id="28993-518">n/a</span></span>|  
|<span data-ttu-id="28993-519">Структура</span><span class="sxs-lookup"><span data-stu-id="28993-519">Structure</span></span>|<span data-ttu-id="28993-520">Да (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="28993-520">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="28993-521">Аналогично `Object.ToString()`</span><span class="sxs-lookup"><span data-stu-id="28993-521">Same as `Object.ToString()`</span></span>|  
|<span data-ttu-id="28993-522">Перечисление</span><span class="sxs-lookup"><span data-stu-id="28993-522">Enumeration</span></span>|<span data-ttu-id="28993-523">Да (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="28993-523">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="28993-524">Имя члена</span><span class="sxs-lookup"><span data-stu-id="28993-524">The member name</span></span>|  
|<span data-ttu-id="28993-525">Интерфейс</span><span class="sxs-lookup"><span data-stu-id="28993-525">Interface</span></span>|<span data-ttu-id="28993-526">Нет</span><span class="sxs-lookup"><span data-stu-id="28993-526">No</span></span>|<span data-ttu-id="28993-527">Н/Д</span><span class="sxs-lookup"><span data-stu-id="28993-527">n/a</span></span>|  
|<span data-ttu-id="28993-528">делегат</span><span class="sxs-lookup"><span data-stu-id="28993-528">Delegate</span></span>|<span data-ttu-id="28993-529">Нет</span><span class="sxs-lookup"><span data-stu-id="28993-529">No</span></span>|<span data-ttu-id="28993-530">Н/Д</span><span class="sxs-lookup"><span data-stu-id="28993-530">n/a</span></span>|  
  
 <span data-ttu-id="28993-531">См. примечания к разделу наследники Дополнительные сведения о переопределении <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="28993-531">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="28993-532">Перегрузка метода ToString</span><span class="sxs-lookup"><span data-stu-id="28993-532">Overloading the ToString method</span></span>  
 <span data-ttu-id="28993-533">Помимо переопределения без параметров <xref:System.Object.ToString?displayProperty=nameWithType> перегрузку метода, многие типы `ToString` метод, чтобы предоставить версии метода, которые принимают параметры.</span><span class="sxs-lookup"><span data-stu-id="28993-533">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="28993-534">Чаще всего это делается для обеспечения поддержки форматирование переменных и форматирование, зависящее от языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="28993-534">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="28993-535">Следующий пример перегрузок `ToString` метод, чтобы вернуть результирующую строку, включающую значение различных полей данного `Automobile` класса.</span><span class="sxs-lookup"><span data-stu-id="28993-535">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="28993-536">Он определяет четыре строки формата: G, который возвращает имя модели и год. D, который возвращает имя модели, год и количества дверей; C, который возвращает имя модели, год и число цилиндров; и объект, который возвращает строку со значениями всех четырех полей.</span><span class="sxs-lookup"><span data-stu-id="28993-536">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="28993-537">В следующем примере вызывается перегруженный <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод для отображения форматирование значения валюты, зависящее от языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="28993-537">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="28993-538">Дополнительные сведения о формате строк и форматирования с учетом языка и региональных параметров, см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="28993-538">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="28993-539">Строки формата, поддерживаемые числовые значения, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="28993-539">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="28993-540">Строки формата, поддерживаемых значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Custom Date и Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="28993-540">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="28993-541">Расширение метода Object.ToString</span><span class="sxs-lookup"><span data-stu-id="28993-541">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="28993-542">Так как тип наследует значение по умолчанию <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, можно найти его поведение нежелательным и хотите изменить его.</span><span class="sxs-lookup"><span data-stu-id="28993-542">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="28993-543">Это особенно верно, массивы и классы коллекций.</span><span class="sxs-lookup"><span data-stu-id="28993-543">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="28993-544">Хотя можно ожидать `ToString` метод класса массива или коллекции для отображения значений его членов, его вместо отображает полное имя типа, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="28993-544">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="28993-545">У вас есть несколько вариантов для создания результирующей строки, в котором вы хотите.</span><span class="sxs-lookup"><span data-stu-id="28993-545">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="28993-546">Если тип является массивом, объектом коллекции или объект, реализующий <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601> интерфейсов, вы можете перечислить его элементов с помощью `foreach` инструкции на языке C# или `For Each...Next` конструкции в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="28993-546">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="28993-547">Если класс не является `sealed` (в C#) или `NotInheritable` (в Visual Basic), вы можете разрабатывать класс-оболочку, который наследует от базового класса, <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, которую нужно настроить.</span><span class="sxs-lookup"><span data-stu-id="28993-547">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="28993-548">Как минимум для этого необходимо сделать следующее:</span><span class="sxs-lookup"><span data-stu-id="28993-548">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="28993-549">Реализуйте все необходимые конструкторы.</span><span class="sxs-lookup"><span data-stu-id="28993-549">Implement any necessary constructors.</span></span> <span data-ttu-id="28993-550">Производные классы не наследуют свои конструкторы базового класса.</span><span class="sxs-lookup"><span data-stu-id="28993-550">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="28993-551">Переопределить <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, чтобы вернуть результирующую строку, в котором вы хотите.</span><span class="sxs-lookup"><span data-stu-id="28993-551">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="28993-552">В следующем примере определяется класс-оболочку для <xref:System.Collections.Generic.List%601> класса.</span><span class="sxs-lookup"><span data-stu-id="28993-552">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="28993-553">Этот параметр переопределяет <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод для отображения значения каждого метода коллекции, а не полное имя типа.</span><span class="sxs-lookup"><span data-stu-id="28993-553">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="28993-554">Разработка [метод расширения](~/docs/standard/design-guidelines/extension-methods.md) , возвращает результирующую строку, которая требуется.</span><span class="sxs-lookup"><span data-stu-id="28993-554">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="28993-555">Обратите внимание, что не может переопределить значение по умолчанию <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод таким образом (то есть расширение класса (в C#) или модуля (в Visual Basic) не может иметь метод без параметров с именем `ToString` , вызываемый вместо оригинального типа `ToString` метод .</span><span class="sxs-lookup"><span data-stu-id="28993-555">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="28993-556">Необходимо указать другое имя для вашей без параметров `ToString` замены.</span><span class="sxs-lookup"><span data-stu-id="28993-556">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="28993-557">В следующем примере определяются два метода, которые расширяют <xref:System.Collections.Generic.List%601> класса: конструктор без параметров `ToString2` метод и `ToString` метод с <xref:System.String> параметр, который представляет строку формата.</span><span class="sxs-lookup"><span data-stu-id="28993-557">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="28993-558">Заметки о [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="28993-558">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="28993-559">При вызове <xref:System.Object.ToString%2A> метод к классу, [!INCLUDE[wrt](~/includes/wrt-md.md)], он предоставляет поведение по умолчанию для классов, которые не переопределяют <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="28993-559">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="28993-560">Это является частью возможностей .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. в разделе [приложений .NET Framework поддерживает для Windows Store и среды выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="28993-560">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="28993-561">Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] не наследуют <xref:System.Object>и не всегда использовать <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="28993-561">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and don't always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="28993-562">Тем не менее, они всегда могут быть <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, и <xref:System.Object.GetHashCode%2A> методов при их использовании в коде C# или Visual Basic и .NET Framework предоставляет поведение по умолчанию для этих методов.</span><span class="sxs-lookup"><span data-stu-id="28993-562">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="28993-563">Начиная с [!INCLUDE[net_v451](~/includes/net-v451-md.md)], среда CLR будет использовать [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) на [!INCLUDE[wrt](~/includes/wrt-md.md)] объекта до возврата к реализация по умолчанию <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28993-563">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="28993-564">классы, которые создаются на языке C# или Visual Basic можно переопределить <xref:System.Object.ToString%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28993-564">classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a><span data-ttu-id="28993-565">[!INCLUDE[wrt](~/includes/wrt-md.md)] И интерфейс IStringable</span><span class="sxs-lookup"><span data-stu-id="28993-565">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="28993-566">Начиная с [!INCLUDE[win81](~/includes/win81-md.md)], [!INCLUDE[wrt](~/includes/wrt-md.md)] включает в себя [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) единственный метод которого [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), обеспечивает базовую поддержку форматирования, сравнимую с предоставляемые <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28993-566">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="28993-567">Чтобы избежать неоднозначности, не следует реализовывать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) на управляемых типов.</span><span class="sxs-lookup"><span data-stu-id="28993-567">To prevent ambiguity, you should not implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="28993-568">При вызове машинного кода или кода, написанного на языках, таких как JavaScript управляемые объекты или C++/CX, у них могут реализовать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="28993-568">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="28993-569">Среда CLR автоматически перенаправляет вызовы из [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) для <xref:System.Object.ToString%2A?displayProperty=nameWithType> событий [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) не был реализован в управляемый объект.</span><span class="sxs-lookup"><span data-stu-id="28993-569">The common language runtime will automatically route calls from [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="28993-570">Так как среда CLR автоматически реализует [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) для всех управляемых типов в [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] приложений, мы рекомендуем, что вы не укажете свои собственные [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) реализации.</span><span class="sxs-lookup"><span data-stu-id="28993-570">Because the common language runtime auto-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="28993-571">Реализация [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) может привести к непредвиденному поведению при вызове `ToString` из [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX или JavaScript.</span><span class="sxs-lookup"><span data-stu-id="28993-571">Implementing [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="28993-572">Если вы решили реализовать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) в открытом управляемом типе, экспортируемом в [!INCLUDE[wrt](~/includes/wrt-md.md)] компонента, применяются следующие ограничения:</span><span class="sxs-lookup"><span data-stu-id="28993-572">If you do choose to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="28993-573">Вы можете определить [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) интерфейс только в отношениях «класс реализует», такие как</span><span class="sxs-lookup"><span data-stu-id="28993-573">You can define the [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="28993-574">в C# или</span><span class="sxs-lookup"><span data-stu-id="28993-574">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="28993-575">в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="28993-575">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="28993-576">Не может реализовать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) в интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="28993-576">You cannot implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="28993-577">Нельзя объявить параметр типа [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="28993-577">You cannot declare a parameter to be of type [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="28993-578">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) не может быть типом возвращаемого значения метода, свойства или поля.</span><span class="sxs-lookup"><span data-stu-id="28993-578">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="28993-579">Нельзя скрывать вашей [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) реализации от базовых классов с помощью определения метода, например следующие:</span><span class="sxs-lookup"><span data-stu-id="28993-579">You cannot hide your [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="28993-580">Вместо этого [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) должна всегда переопределять реализацию базового класса.</span><span class="sxs-lookup"><span data-stu-id="28993-580">Instead, the [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="28993-581">Реализацию `ToString` можно скрыть только путем вызова этого метода в строго типизированном экземпляре класса.</span><span class="sxs-lookup"><span data-stu-id="28993-581">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="28993-582">Обратите внимание, что в различных условиях вызовы из машинного кода в управляемый тип, реализующий [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) или скрывает его [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) реализация может привести к непредвиденному поведению.</span><span class="sxs-lookup"><span data-stu-id="28993-582">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="28993-583">При реализации собственных типов, должны переопределять <see cref="M:System.Object.ToString" /> метод для возврата значений, которые важны для этих типов.</span><span class="sxs-lookup"><span data-stu-id="28993-583">When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types.</span></span> <span data-ttu-id="28993-584">Производные классы, которые требуется дополнительный контроль над форматированием чем <see cref="M:System.Object.ToString" /> предоставляет можно реализовать <see cref="T:System.IFormattable" /> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="28993-584">Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface.</span></span> <span data-ttu-id="28993-585">Его <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> метод позволяет определить строк формата, обеспечивающие управление форматированием и использовать <see cref="T:System.IFormatProvider" /> объект, способный предоставлять для форматирования, зависящего от языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="28993-585">Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.</span></span>  
  
<span data-ttu-id="28993-586">Переопределяет из <see cref="M:System.Object.ToString" /> метода следует придерживаться следующих рекомендаций:</span><span class="sxs-lookup"><span data-stu-id="28993-586">Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:</span></span> 
<span data-ttu-id="28993-587">-Возвращаемой строки должно быть понятным и читабельными для пользователей.</span><span class="sxs-lookup"><span data-stu-id="28993-587">-   The returned string should be friendly and readable by humans.</span></span>  
  
<span data-ttu-id="28993-588">-Возвращаемой строки должен однозначно определять значение экземпляра объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-588">-   The returned string should uniquely identify the value of the object instance.</span></span>  
  
<span data-ttu-id="28993-589">-Возвращаемой строки должен быть как можно более короткими, чтобы он подходит для отображения с помощью отладчика.</span><span class="sxs-lookup"><span data-stu-id="28993-589">-   The returned string should be as short as possible so that it is suitable for display by a debugger.</span></span>  
  
<span data-ttu-id="28993-590">- <see cref="M:System.Object.ToString" /> Переопределения не должен возвращать <see cref="F:System.String.Empty" /> или пустая строка.</span><span class="sxs-lookup"><span data-stu-id="28993-590">-   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.</span></span>  
  
<span data-ttu-id="28993-591">- <see cref="M:System.Object.ToString" /> Переопределения не должен создавать исключение.</span><span class="sxs-lookup"><span data-stu-id="28993-591">-   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.</span></span>  
  
<span data-ttu-id="28993-592">-Если строковое представление экземпляра региональные параметры, или можно форматировать разными способами, реализовать <see cref="T:System.IFormattable" /> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="28993-592">-   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.</span></span>  
  
<span data-ttu-id="28993-593">— Если возвращаемая строка содержит конфиденциальные сведения, следует сначала запрашивать соответствующее разрешение.</span><span class="sxs-lookup"><span data-stu-id="28993-593">-   If the returned string includes sensitive information, you should first demand an appropriate permission.</span></span> <span data-ttu-id="28993-594">Если требование завершается успешно, вы можете вернуть конфиденциальной информации; в противном случае следует возвращать строку, которая исключает конфиденциальные данные.</span><span class="sxs-lookup"><span data-stu-id="28993-594">If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</span></span>  
  
<span data-ttu-id="28993-595">- <see cref="M:System.Object.ToString" /> Переопределение должно иметь не наблюдаемый побочных эффектов, чтобы избежать затруднений при отладке.</span><span class="sxs-lookup"><span data-stu-id="28993-595">-   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging.</span></span> <span data-ttu-id="28993-596">Например, вызов <see cref="M:System.Object.ToString" /> метод не должен изменять значения полей экземпляра.</span><span class="sxs-lookup"><span data-stu-id="28993-596">For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.</span></span>  
  
<span data-ttu-id="28993-597">— Если ваш тип реализует метод синтаксического анализа (или <see langword="Parse" /> или <see langword="TryParse" /> метода, конструктора или некоторые другие статический метод, который создает экземпляр типа из строки), необходимо убедиться, что строка, возвращаемая <see cref="M:System.Object.ToString" /> метод может быть преобразовать в экземпляр объекта.</span><span class="sxs-lookup"><span data-stu-id="28993-597">-   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</span></span></para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="28993-598">Типы форматирования в .NET</span><span class="sxs-lookup"><span data-stu-id="28993-598">Formatting Types in .NET</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>