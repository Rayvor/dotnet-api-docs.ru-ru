<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6778182e96c45560805aa9f6c8cac64c818a8ff5" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70372792" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Поддерживает все классы в иерархии классов .NET и предоставляет низкоуровневые службы для производных классов. Является исходным базовым классом для всех классов .NET и корнем иерархии типов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве языков не требуется объявлять для классов наследование от <xref:System.Object>, так как они наследуют его неявно.  
  
 Поскольку все классы в .NET являются производными <xref:System.Object>от, каждый метод, определенный <xref:System.Object> в классе, доступен во всех объектах в системе. Производные классы могут переопределять некоторые из этих методов, включая:  
  
-   <xref:System.Object.Equals%2A>— Поддерживает сравнения между объектами.  
  
-   <xref:System.Object.Finalize%2A>— Выполняет операции очистки до автоматического освобождения объекта.  
  
-   <xref:System.Object.GetHashCode%2A>— Создает число, соответствующее значению объекта для поддержки использования хэш-таблицы.  
  
-   <xref:System.Object.ToString%2A>— Создает понятную для человека текстовую строку, описывающую экземпляр класса.  
  
## <a name="performance-considerations"></a>Особенности производительности  
 При разработке класса, например коллекции, который должен обрабатывать объекты любого типа, вы можете создавать члены класса, принимающие экземпляры класса <xref:System.Object>. Однако процесс упаковки-преобразования и распаковки-преобразования для типа требует вычислительных затрат. Если вы знаете, что новый класс будет часто обрабатывать определенные типы значений, для минимизации затрат на упаковку-преобразование можно использовать две тактики.  
  
-   Создание общего метода, принимающего тип <xref:System.Object>, и набора специализированных перегрузок метода для каждого из типов значений, которые, как предполагается, будут часто обрабатываться классом. Если существует специализированный метод, который принимает указанный при вызове тип параметра, упаковка-преобразование не выполняется и вызывается специализированный метод. Если у метода отсутствует аргумент, который соответствует указанному при вызове типу параметра, выполняется упаковка-преобразование параметра и вызывается общий метод.  
  
-   Использование универсальных шаблонов при разработке метода и его членов. Среда CLR создает закрытый универсальный тип при создании экземпляра класса с указанием аргумента универсального типа. Универсальный метод принимает аргумент определенного типа, и его можно вызывать без упаковки-преобразования параметра.  
  
 Несмотря на то, что иногда бывает необходимо создавать классы общего назначения, которые принимают и возвращают типы <xref:System.Object>, можно повысить производительность, создав также специализированный класс для обработки определенного часто используемого типа. Например, наличие специализированного класса для задания и получения логических значений позволяет избежать затрат на их упаковку-преобразование и распаковку-преобразование.  
  
   
  
## Examples  
 В следующем примере определяется тип Point, производный от класса <xref:System.Object>, и переопределяются многие виртуальные методы класса <xref:System.Object>. Кроме того, в примере показано, как вызывать многие из статических методов и методов экземпляра класса <xref:System.Object>.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Открытые статические (<see langword="Shared" /> в Visual Basic) члены этого типа являются потокобезопасными. Для членов экземпляра потокобезопасность не гарантируется.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Object" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор вызывается конструкторами в производных классах, но его также можно использовать для непосредственного создания экземпляра <xref:System.Object> класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, равны ли два экземпляра объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, который требуется сравнить с текущим объектом.</param>
        <summary>Определяет, равен ли заданный объект текущему объекту.</summary>
        <returns>Значение <see langword="true" />, если указанный объект равен текущему объекту; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип сравнения текущего экземпляра и `obj` параметра зависит от того, является ли текущий экземпляр ссылочным типом или типом значения.  
  
-   Если текущий экземпляр является ссылочным типом, <xref:System.Object.Equals%28System.Object%29> метод проверяет равенство ссылок, а вызов <xref:System.Object.Equals%28System.Object%29> метода эквивалентен вызову <xref:System.Object.ReferenceEquals%2A> метода. Равенство ссылок означает, что сравниваемые объектные переменные ссылаются на один и тот же объект. В следующем примере показан результат такого сравнения. Он `Person` определяет класс, который является ссылочным типом, и `Person` вызывает конструктор класса для создания экземпляров двух новых `Person` объектов `person1a` и, имеющих одно `person2`и то же значение. Она также назначается `person1a` другой объектной переменной, `person1b`. Как показано в выходных данных примера, и `person1a` `person1b` равны, так как они ссылаются на один и тот же объект. `person1a` Однако и `person2` не равны, хотя они имеют одинаковое значение.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Если текущий экземпляр является типом значения, <xref:System.Object.Equals%28System.Object%29> метод проверяет равенство значений. Равенство значений означает следующее:  
  
    -   Два объекта имеют один и тот же тип. Как показано в следующем примере, <xref:System.Byte> объект со значением 12 не <xref:System.Int32> равен объекту со значением 12, поскольку два объекта имеют разные типы времени выполнения.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   Значения открытого и закрытого полей двух объектов равны. В следующем примере проверяется равенство значений. Он `Person` определяет структуру, которая является типом значения, и `Person` вызывает конструктор класса для создания экземпляров двух новых `Person` объектов `person1` и, имеющих одно и `person2`то же значение. Как видно из выходных данных примера, две объектные переменные ссылаются на разные объекты `person1` и `person2` равны, так как они имеют одинаковое значение для закрытого `personName` поля.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Поскольку класс является базовым классом для всех типов в .NET Framework <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , метод предоставляет сравнение на равенство по умолчанию для всех остальных типов. <xref:System.Object> Однако типы часто переопределяют <xref:System.Object.Equals%2A> метод, чтобы реализовать равенство значений. Дополнительные сведения см. в примечаниях для вызывающих объектов и примечаний для разделов наследников.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Примечания для[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 При вызове <xref:System.Object.Equals%28System.Object%29> перегрузки метода для класса [!INCLUDE[wrt](~/includes/wrt-md.md)]в он предоставляет поведение по умолчанию для классов, которые не переопределяются <xref:System.Object.Equals%28System.Object%29>. Это является частью поддержки, предоставляемой .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. раздел [поддержка .NET Framework для приложений Магазина Windows и среда выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] классе не наследуют <xref:System.Object> <xref:System.Object.Equals%28System.Object%29> и в настоящее время не реализуют метод. Однако <xref:System.Object.ToString%2A>они выглядят как методы, <xref:System.Object.Equals%28System.Object%29>и <xref:System.Object.GetHashCode%2A> при их использовании в коде C# или Visual Basic, а .NET Framework предоставляет поведение по умолчанию для этих методов.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]классы, написанные на C# языке или Visual Basic могут переопределять <xref:System.Object.Equals%28System.Object%29> перегрузку метода.  
  
## <a name="notes-for-callers"></a>Примечания для вызывающих объектов  
 Производные классы часто переопределяют <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод для реализации равенства значений. Кроме того, типы часто предоставляют дополнительный строго типизированную перегрузку для `Equals` метода, обычно <xref:System.IEquatable%601> реализуя интерфейс. При вызове `Equals` метода для проверки на равенство следует знать, переопределяются <xref:System.Object.Equals%2A?displayProperty=nameWithType> ли текущий экземпляр и понимаете, как разрешается определенный `Equals` вызов метода. В противном случае вы можете выполнить проверку на равенство, отличное от предполагаемого, и метод может вернуть непредвиденное значение.  
  
 Ниже приведен пример. Он создает три <xref:System.Text.StringBuilder> объекта с одинаковыми строками, а затем выполняет четыре `Equals` вызова методов. Первый вызов метода возвращает `true`, а остальные три возвращают. `false`  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 В первом случае вызывается перегруженный метод <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> строгой типизации, который проверяет равенство значений. Так как строки, назначенные двум <xref:System.Text.StringBuilder> объектам, равны, метод возвращает. `true` Однако не переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. <xref:System.Text.StringBuilder> В <xref:System.Text.StringBuilder> связи с этим при приведении объекта <xref:System.Object>к <xref:System.Text.StringBuilder> типу, когда экземпляр присваивается переменной типа <xref:System.Object>, и когда <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> методу передается два <xref:System.Text.StringBuilder> объекта, по умолчанию используется <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>вызывается метод. Поскольку <xref:System.Text.StringBuilder> является ссылочным типом, это эквивалентно передаче двух <xref:System.Text.StringBuilder> объектов в <xref:System.Object.ReferenceEquals%2A> метод. Хотя все три <xref:System.Text.StringBuilder> объекта содержат одинаковые строки, они ссылаются на три различных объекта. В результате эти три вызова метода возвращают `false`.  
  
 Можно сравнить текущий объект с другим объектом для равенства ссылок, вызвав <xref:System.Object.ReferenceEquals%2A> метод. В Visual Basic также можно использовать `is` ключевое слово (например, `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Примечания для наследников  
 При определении собственного типа этот тип наследует функциональность, определенную `Equals` методом базового типа. В следующей таблице приведена реализация `Equals` метода по умолчанию для основных категорий типов в .NET Framework.  
  
|Категория типа|Равенство, определенное|Комментарии|  
|-------------------|-------------------------|--------------|  
|Класс, производный непосредственно от<xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Равенство ссылок; эквивалентно вызову <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|Структура|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Равенство значений; прямое побайтовое сравнение или Сравнение полей по полям с помощью отражения.|  
|Перечисление|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|Значения должны иметь одинаковый тип перечисления и одно и то же базовое значение.|  
|делегат|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|Делегаты должны иметь одинаковый тип с одинаковыми списками вызовов.|  
|Интерфейс|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Равенство ссылок.|  
  
 Для типа значения следует всегда переопределять <xref:System.Object.Equals%2A>, поскольку тесты на равенство, основанные на отражении, имеют низкую производительность. Можно также переопределить реализацию <xref:System.Object.Equals%2A> по умолчанию для ссылочных типов, чтобы проверить равенство значений, а не равенство ссылок и определить точное значение равенства значений. Такие реализации <xref:System.Object.Equals%2A> возвращают `true` , если два объекта имеют одинаковое значение, даже если они не являются одним и тем же экземпляром. Разработчик типа принимает решение, что составляет значение объекта, но обычно это некоторые или все данные, хранящиеся в переменных экземпляра объекта. Например, значение <xref:System.String> объекта основано на символах строки <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> . метод переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод, возвращаемый `true` для любых двух экземпляров строк, содержащих одинаковые символы в том же порядке.  
  
 В следующем примере показано, как переопределить <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод для проверки на равенство значений. Он переопределяет <xref:System.Object.Equals%2A> метод `Person` для класса. Если `Person` он принял реализацию равенства базового класса, два `Person` объекта будут равны, только если они ссылались на один объект. Однако в этом случае два `Person` объекта равны, если они имеют одинаковое значение `Person.Id` для свойства.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Помимо переопределения <xref:System.Object.Equals%2A>, можно <xref:System.IEquatable%601> реализовать интерфейс, чтобы обеспечить строго типизированный тест на равенство.  
  
 Следующие инструкции должны быть истинными для всех реализаций <xref:System.Object.Equals%28System.Object%29> метода. В `x`списке, `y`, и `z` представляют ссылки на объекты, которые не равны **null**.  
  
-   `x.Equals(x)`Возвращает `true`, за исключением случаев, в которых задействованы типы с плавающей запятой. См. статью [ISO/IEC/IEEE 60559:2011, информационные технологии — системы микропроцессора — арифметические операции с плавающей запятой](https://www.iso.org/standard/57469.html).  
  
-   `x.Equals(y)` возвращает то же значение, что и `y.Equals(x)`.  
  
-   `x.Equals(y)`Возвращает `true` , `x` если и`y` имеют`NaN`значение.  
  
-   Если `(x.Equals(y) && y.Equals(z))` возвращает `true`, возвращается`x.Equals(z)` значение .`true`  
  
-   Последовательные вызовы `x.Equals(y)` возвращают одно и то же значение до тех пор, пока объекты `y` , `x` на которые ссылаются и, не изменяются.  
  
-   `x.Equals(null)` возвращает `false`.  
  
 Реализации не должны вызывать исключения. они всегда должны возвращать значение. <xref:System.Object.Equals%2A> `obj` Например, если имеет значение `null`, <xref:System.Object.Equals%2A> метод должен возвращать `false` , а не создавать <xref:System.ArgumentNullException>исключение.  
  
 При переопределении <xref:System.Object.Equals%28System.Object%29>выполните следующие рекомендации.  
  
-   Типы, реализующие <xref:System.IComparable> , <xref:System.Object.Equals%28System.Object%29>должны переопределяться.  
  
-   Типы, переопределяющие <xref:System.Object.Equals%28System.Object%29> , <xref:System.Object.GetHashCode%2A>также должны переопределяться; в противном случае хэш-таблицы могут работать неправильно.  
  
-   Рекомендуется реализовать <xref:System.IEquatable%601> интерфейс для поддержки строго типизированных тестов на равенство. Ваша <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> реализация должна возвращать результаты, которые <xref:System.Object.Equals%2A>соответствуют.  
  
-   Если ваш язык программирования поддерживает перегрузку операторов и вы передаете оператор равенства для заданного типа, необходимо также переопределить <xref:System.Object.Equals%28System.Object%29> метод, чтобы он возвращал тот же результат, что и оператор равенства. Это позволяет гарантировать, что код библиотеки классов, <xref:System.Object.Equals%2A> используемый ( <xref:System.Collections.ArrayList> например, <xref:System.Collections.Hashtable>и), ведет себя таким образом, который согласуется с тем, как код приложения использует оператор равенства.  
  
### <a name="guidelines-for-reference-types"></a>Рекомендации по ссылочным типам  
 Следующие рекомендации применяются для переопределения <xref:System.Object.Equals%28System.Object%29> ссылочного типа.  
  
-   Рассмотрите возможность <xref:System.Object.Equals%2A> переопределения, если семантика типа основана на том, что тип представляет некоторые значения.  
  
-   Большинство ссылочных типов не должны перегружать оператор равенства, даже если они <xref:System.Object.Equals%2A>переопределяют. Однако при реализации ссылочного типа, который должен иметь семантику значений, например тип комплексного числа, необходимо переопределить оператор равенства.  
  
-   Не следует переопределять <xref:System.Object.Equals%2A> для изменяемого ссылочного типа. Это обусловлено тем, <xref:System.Object.Equals%2A> что переопределение требует также <xref:System.Object.GetHashCode%2A> переопределения метода, как описано в предыдущем разделе. Это означает, что хэш-код экземпляра изменяемого ссылочного типа может измениться в течение своего времени существования, что может привести к потере объекта в хэш-таблице.  
  
### <a name="guidelines-for-value-types"></a>Рекомендации по типам значений  
 Ниже приведены рекомендации по переопределению <xref:System.Object.Equals%28System.Object%29> для типа значения.  
  
-   При определении типа значения, включающего одно или несколько полей, значения которых являются ссылочными типами, следует переопределить <xref:System.Object.Equals%28System.Object%29>. Реализация, предоставляемая <xref:System.ValueType> функцией, выполняет побайтовое сравнение для типов значений, поля которых являются типами значений, но использует отражение для выполнения сравнения по полям типов значений, поля которых включают ссылочные типы. <xref:System.Object.Equals%28System.Object%29>  
  
-   Если вы переопределяете <xref:System.Object.Equals%2A> и язык разработки поддерживает перегрузку операторов, необходимо перегрузить оператор равенства.  
  
-   Необходимо реализовать <xref:System.IEquatable%601> интерфейс. Вызов строго типизированного <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> метода позволяет избежать `obj` упаковки-преобразования аргумента.  
  
   
  
## Examples  
 `Point` В следующем примере показан класс, который <xref:System.Object.Equals%2A> переопределяет метод, чтобы обеспечить равенство `Point3D` значений, и класс, производный `Point`от. Поскольку `Point` <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> переопределения <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> для проверки равенства значений, метод не вызывается. `Point3D.Equals` Однако вызывается `Point.Equals` , `Point` поскольку <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> реализуется способом, предоставляющим равенство значений.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 Метод проверяет, что аргумент не равен null и ссылается на экземпляр того же типа, что и этот объект. **** `obj` `Point.Equals` Если проверка завершается ошибкой, метод возвращает `false`значение.  
  
 `Point.Equals` Метод<xref:System.Object.GetType%2A> вызывает метод, чтобы определить, идентичны ли типы времени выполнения двух объектов. Если метод `obj is Point` использовал проверку формы в C# или `TryCast(obj, Point)` Visual Basic, проверка вернется `true` в `Point`случаях, когда `obj` является экземпляром производного класса, `obj` хотя и текущий экземпляр имеет разные типы времени выполнения. Убедившись, что оба объекта имеют одинаковый тип, метод приводится `obj` к типу `Point` и возвращает результат сравнения полей экземпляров двух объектов.  
  
 В `Point3D.Equals`унаследованный `Point.Equals` метод, который переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, вызывается до того, как все еще выполняется. Поскольку `Point3D` является запечатанным классом`NotInheritable` (в Visual Basic), проверка формы `obj is Point` в C# `TryCast(obj, Point)` `Point3D` или в Visual Basic достаточно, чтобы гарантировать, что `obj` является объектом. Если это `Point` <xref:System.Object.Equals%2A>объект, он приводится к объекту и передается в реализацию базового класса. `Point3D` Только при возврате `Point.Equals` `true` унаследованного метода метод сравнивает `z` поля экземпляра, представленные в производном классе.  
  
 В следующем примере определяется `Rectangle` класс, который внутренне реализует прямоугольник как два `Point` объекта. Класс также переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , чтобы обеспечить равенство значений. `Rectangle`  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Некоторые языки, такие C# как и Visual Basic, поддерживают перегрузку операторов. Если тип перегружает оператор равенства, он также должен переопределять <xref:System.Object.Equals%28System.Object%29> метод, чтобы обеспечить ту же функциональность. Обычно это достигается путем написания <xref:System.Object.Equals%28System.Object%29> метода с точки зрения перегруженного оператора равенства, как показано в следующем примере.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Поскольку `Complex` является типом значения, он не может быть производным от.  Поэтому <xref:System.Object.Equals%28System.Object%29> методу переопределения метода не требуется вызывать <xref:System.Object.GetType%2A> для определения точного типа времени выполнения каждого объекта, `is` но вместо этого можно использовать оператор в C# или `TypeOf` оператор в Visual Basic, чтобы проверить тип `obj` параметр.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Первый из сравниваемых объектов.</param>
        <param name="objB">Второй из сравниваемых объектов.</param>
        <summary>Определяет, считаются ли равными указанные экземпляры объектов.</summary>
        <returns><see langword="true" />, если указанные объекты равны; в противном случае — <see langword="false" />. Если оба параметра <paramref name="objA" /> и <paramref name="objB" /> имеют значение **NULL**, метод возвращает значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статический <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> метод указывает, равны ли два объекта `objA` , `objB`и. Он также позволяет тестировать объекты, значение которых равно **null** , для проверки на равенство. Он сравнивает `objA` и `objB` для равенства следующим образом:  
  
-   Он определяет, представляют ли два объекта одну и ту же ссылку на объект. В противном случае метод возвращает `true`значение. Этот тест эквивалентен вызову <xref:System.Object.ReferenceEquals%2A> метода. Кроме того, если оба `objA` значения `objB` и имеют **значение NULL**, метод `true`возвращает.  
  
-   Он определяет, `objB` является `objA` ли либо **значением NULL**. Если это так, возвращается `false`значение.  
  
-   Если два объекта не представляют одну и ту же ссылку на объект и ни один из них не `objA`имеет`Equals` **значения NULL**, то вызывает. (`objB`) и возвращает результат. Это означает, что `objA` если <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> переопределяет метод, вызывается это переопределение.  
  
   
  
## Examples  
 В следующем примере показан <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> метод и его сравнение <xref:System.Object.ReferenceEquals%2A> с методом.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Finalize() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Позволяет объекту попытаться освободить ресурсы и выполнить другие операции очистки, перед тем как он будет уничтожен во время сборки мусора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A> Метод используется для выполнения операций очистки неуправляемых ресурсов, хранящихся в текущем объекте, до уничтожения объекта. Этот метод защищен и поэтому доступен только через этот класс или производный класс.  
  
 Содержание  
  
-   [Принцип работы финализации](#How)  
  
-   [Примечания для разработчиков](#Notes)  
  
-   [Альтернатива SafeHandle](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Принцип работы финализации  
 Класс не предоставляет реализацию <xref:System.Object.Finalize%2A> для метода, и сборщик мусора не помечает типы, производные от <xref:System.Object> для завершения, если только они не переопределяют <xref:System.Object.Finalize%2A> метод. <xref:System.Object>  
  
 Если тип переопределяет <xref:System.Object.Finalize%2A> метод, сборщик мусора добавляет запись для каждого экземпляра типа во внутреннюю структуру, называемую очередью финализации. Очередь финализации содержит записи для всех объектов в управляемой куче, код завершения которых должен быть выполнен до освобождения памяти сборщиком мусора. Затем сборщик мусора вызывает <xref:System.Object.Finalize%2A> метод автоматически при выполнении следующих условий:  
  
-   После того как сборщик мусора обнаружит, что объект недоступен, за исключением случаев, когда объект был исключен из финализации путем вызова <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метода.  
  
-   **Только в .NET Framework**, во время завершения работы домена приложения, если только объект не исключен из финализации. Во время завершения работы, даже объекты, которые по-прежнему доступны, завершаются.  
  
 <xref:System.Object.Finalize%2A>метод автоматически вызывается только один раз для данного экземпляра, если только объект не будет повторно зарегистрирован с помощью механизма, такого <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> как, и не был впоследствии вызван методом. <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>  
  
 <xref:System.Object.Finalize%2A>операции имеют следующие ограничения.  
  
-   Точное время выполнения метода завершения не определено. Чтобы обеспечить детерминированный выпуск ресурсов для экземпляров класса, реализуйте `Close` метод или <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> предоставьте реализацию.  
  
-   Методы завершения двух объектов не гарантированно выполняются в каком бы то ни было определенном порядке, даже если один объект ссылается на другой. То есть если объект A имеет ссылку на объект B и оба метода имеют методы завершения, то объект B может быть уже завершен при запуске метода завершения объекта A.  
  
-   Поток, в котором выполняется метод завершения, не определен.  
  
 <xref:System.Object.Finalize%2A> Метод может не выполняться до завершения или вообще не выполняться при следующих исключительных обстоятельствах:  
  
-   Если другой метод завершения блокируется неограниченно (переходит в бесконечный цикл, пытается получить блокировку, которую он никогда не может получить и т. д.). Поскольку среда выполнения пытается выполнить методы завершения до завершения, другие методы завершения могут не вызываться, если метод завершения блокирует неограниченное время.  
  
-   Значение, если процесс завершается без предоставления среде выполнения возможности очистки. В этом случае первое уведомление среды выполнения о завершении процесса — это DLL_PROCESS_DETACH уведомление.  
  
 Среда выполнения продолжит завершать объекты во время завершения работы только в тот момент, когда число объектов, которые можно завершить, будет уменьшаться.  
  
 Если <xref:System.Object.Finalize%2A> `try` или / переопределение `finally` вызывает исключение, а среда выполнения не размещается приложением, которое переопределяет политику по умолчанию, среда выполнения завершает процесс и не обрабатывает активные блоки или <xref:System.Object.Finalize%2A> методы завершения выполняются. Такое поведение обеспечивает целостность процессов, если финализатор не может освободить или уничтожить ресурсы.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Переопределение метода Finalize 
 Необходимо переопределить <xref:System.Object.Finalize%2A> для класса, использующего неуправляемые ресурсы, такие как дескрипторы файлов или подключения к базе данных, которые должны быть освобождены, когда управляемый объект, использующий их, будет удален во время сборки мусора. Не следует реализовывать <xref:System.Object.Finalize%2A> метод для управляемых объектов, так как сборщик мусора вывысвобождает управляемые ресурсы автоматически.  
  
> [!IMPORTANT]
>  Если доступен <xref:System.Object.Finalize%2A>объект, который создает оболочку для неуправляемого ресурса, рекомендуемым альтернативом является реализация шаблона удаления с помощью безопасного маркера, а не переопределения. <xref:System.Runtime.InteropServices.SafeHandle> Дополнительные сведения см. [в разделе альтернатива SafeHandle](#SafeHandle) .  
  
 По умолчанию <xref:System.Object.Finalize%2A>методне выполняет никаких действий, но при необходимости его следует переопределить только для освобождения неуправляемых ресурсов. <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Освобождение памяти обычно занимает намного больше времени, если выполняется операция финализации, так как для нее требуется как минимум две сборки мусора. Кроме того, следует переопределить <xref:System.Object.Finalize%2A> метод только для ссылочных типов. Среда CLR завершает только ссылочные типы. Он игнорирует методы завершения для типов значений.  

Областью действия <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метода является `protected`. Эту ограниченную область следует поддерживать при переопределении метода в классе. Сохраняя <xref:System.Object.Finalize%2A> защищенный метод, пользователи приложения не смогут напрямую вызывать <xref:System.Object.Finalize%2A> метод объекта.
  
 Каждая реализация <xref:System.Object.Finalize%2A> в производном типе должна вызывать <xref:System.Object.Finalize%2A>реализацию его базового типа. Это единственный случай, когда коду приложения разрешено вызывать <xref:System.Object.Finalize%2A>. <xref:System.Object.Finalize%2A> Метод объекта не должен вызывать метод для всех объектов, отличных от базового класса. Это связано с тем, что другие вызываемые объекты могут собираться одновременно с вызывающим объектом, например в случае завершения работы среды CLR. 
  
> [!NOTE]
>  C# Компилятор не позволяет переопределить <xref:System.Object.Finalize%2A> метод. Вместо этого метод завершения предоставляется путем реализации [деструктора](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) для класса. C# Деструктор автоматически вызывает деструктор своего базового класса.  
>   
>  Визуальный C++ элемент <xref:System.Object.Finalize%2A> также предоставляет собственный синтаксис для реализации метода. Дополнительные сведения см. в подразделе "деструкторы и методы завершения" статьи [как Определение и использование классов и структур (C++/CLI).](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)  
  
 Поскольку сборка мусора является недетерминированной, вы точно не узнаете, когда сборщик мусора выполняет завершение. Для немедленного освобождения ресурсов можно также выбрать реализацию [шаблона удаления](~/docs/standard/garbage-collection/implementing-dispose.md) и <xref:System.IDisposable> интерфейса. Реализация может быть вызвана потребителями вашего класса для освобождения неуправляемых ресурсов, и <xref:System.Object.Finalize%2A> метод можно использовать для высвобождения неуправляемых ресурсов <xref:System.IDisposable.Dispose%2A> в случае, если метод не вызывается. <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>  
  
 <xref:System.Object.Finalize%2A>может выполнить практически любое действие, включая восстановление объекта (т. е. сделать объект доступным снова) после его очистки во время сборки мусора. Однако объект может быть восстановлен только один раз. <xref:System.Object.Finalize%2A> нельзя вызвать для восстановленных объектов во время сборки мусора.
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>Альтернатива SafeHandle  
 Создание надежных методов завершения зачастую сложно, поскольку вы не можете делать предположения о состоянии приложения, а также из-за необработанных системных исключений, таких как <xref:System.OutOfMemoryException> , <xref:System.StackOverflowException> и завершения метода завершения. Вместо реализации метода завершения для класса для освобождения неуправляемых ресурсов можно использовать объект, производный от <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> класса, для упаковки неуправляемых ресурсов, а затем реализовать шаблон Dispose без метода завершения. .NET Framework предоставляет следующие классы в <xref:Microsoft.Win32?displayProperty=nameWithType> пространстве имен, которые являются производными от: <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>— Это класс-оболочка для маркера файла.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>— Это класс-оболочка для дескрипторов размещенных в памяти файлов.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle>— Это класс-оболочка для указателя на блок неуправляемой памяти.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> и<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> являются классами-оболочками для криптографических дескрипторов.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle>— Это класс-оболочка для дескрипторов канала.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>— Это класс-оболочка для маркера в разделе реестра.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>— Это класс-оболочка для обработчика ожидания.  
  
 В следующем примере [шаблон Dispose](~/docs/standard/garbage-collection/implementing-dispose.md) используется с надежными дескрипторами вместо переопределения <xref:System.Object.Finalize%2A> метода. Он определяет `FileAssociation` класс, который заключает в реестр сведения о приложении, обрабатывающем файлы с определенным расширением файла. Два дескриптора реестра, возвращаемые в качестве `out` параметров вызовами функции Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) , <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> передаются в конструктор. После этого защищенный `Dispose` метод типа `SafeRegistryHandle.Dispose` вызывает метод для высвобождения этих двух дескрипторов.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 В следующем примере проверяется, <xref:System.Object.Finalize%2A> вызывается ли метод при уничтожении объекта, переопределяющего. <xref:System.Object.Finalize%2A> Обратите внимание, что в рабочем приложении <xref:System.Object.Finalize%2A> метод будет переопределен для освобождения неуправляемых ресурсов, удерживаемых объектом. Также обратите внимание C# , что в примере вместо переопределения <xref:System.Object.Finalize%2A> метода предоставляется деструктор.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Дополнительный пример переопределения <xref:System.Object.Finalize%2A> метода см. в <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> описании метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Служит хэш-функцией по умолчанию.</summary>
        <returns>Хэш-код для текущего объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Хэш-код — это числовое значение, которое используется для вставки и задания объекта в коллекции на основе хэша <xref:System.Collections.Generic.Dictionary%602> <xref:System.Collections.Hashtable> , такой как класс, класс или тип, производный от <xref:System.Collections.DictionaryBase> класса. <xref:System.Object.GetHashCode%2A> Метод предоставляет этот хэш-код для алгоритмов, требующих быстрых проверок равенства объектов.  
  
> [!NOTE]
>  Сведения о том, как хэш-коды используются в хэш-таблицах и некоторых дополнительных алгоритмах хэш-кода, см. в записи [хэш-функции](https://en.wikipedia.org/wiki/Hash_function) в Википедии.  
  
 Два объекта, которые равны, возвращают хэш-коды, равные. Однако обратная неверно: равные хэш-коды не подразумевают равенство объектов, так как разные (неравные) объекты могут иметь одинаковые хэш-коды. Более того, .NET не гарантирует реализацию <xref:System.Object.GetHashCode%2A> метода по умолчанию, и значение, возвращаемое этим методом, может отличаться между реализациями .NET, такими как разные версии .NET Framework и .NET Core, и платформы, такие как 32-разрядная и 64-разрядные платформы. По этим причинам не следует использовать реализацию этого метода по умолчанию в качестве уникального идентификатора объекта для хэширования. Ниже приведено два последствия.  
  
-   Не следует рассчитывать, что равные хэш-коды подразумевают равенство объектов.  
  
-   Никогда не следует сохранять или использовать хэш-код вне домена приложения, в котором он был создан, так как один и тот же объект может быть хэширован между доменами приложений, процессами и платформами.  
  
> [!WARNING]
>  Хэш-код предназначен для эффективной вставки и уточняющего запроса в коллекциях, основанных на хэш-таблице. Хэш-код не является постоянным значением. По этой причине:  
>   
> -   Не сериализуются значения хэш-кода или не сохраняйте их в базах данных.  
> -   Не используйте хэш-код в качестве ключа для получения объекта из коллекции с ключом.  
> -   Не отправляйте хэш-коды между доменами приложений или процессами. В некоторых случаях хэш-коды могут быть вычислены отдельно для каждого процесса или домена приложения.  
> -   Не используйте хэш-код вместо значения, возвращаемого криптографической функцией хэширования, если требуется криптографически надежный хэш. Для криптографических хэшей используйте класс, производный от <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> класса или. <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>  
> -   Не проверяйте равенство хэш-кодов, чтобы определить, равны ли два объекта. (Неравные объекты могут иметь идентичные хэш-коды.) Чтобы проверить равенство, вызовите <xref:System.Object.ReferenceEquals%2A> метод <xref:System.Object.Equals%2A> или.  
  
 <xref:System.Object.GetHashCode%2A> Метод может быть переопределен производным типом. Если <xref:System.Object.GetHashCode%2A> не переопределен, хэш-коды для ссылочных типов вычисляются путем <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> вызова метода базового класса, который выполняет вычисление хэш-кода на основе ссылки на объект; дополнительные сведения см. в разделе <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. Иными словами, два объекта, для которых <xref:System.Object.ReferenceEquals%2A> метод возвращает `true` одинаковые хэш-коды, имеют одинаковые значения. Если типы значений не переопределяются <xref:System.Object.GetHashCode%2A> <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> , метод базового класса использует отражение для вычисления хэш-кода на основе значений полей типа. Иными словами, типы значений, поля которых имеют одинаковые значения, имеют одинаковые хэш-коды. Дополнительные сведения о переопределении <xref:System.Object.GetHashCode%2A>см. в разделе "Примечания к наследникам".  
  
> [!WARNING]
>  При переопределении <xref:System.Object.GetHashCode%2A> метода следует также переопределить <xref:System.Object.Equals%2A>и наоборот. Если переопределенный <xref:System.Object.Equals%2A> метод возвращает `true` , когда два объекта проверяются на равенство, переопределенный <xref:System.Object.GetHashCode%2A> метод должен возвращать одно и то же значение для двух объектов.  
  
 Если объект, используемый в качестве ключа в хэш-таблице <xref:System.Object.GetHashCode%2A>, не предоставляет полезную реализацию, можно указать поставщик хэш-кода, предоставив <xref:System.Collections.IEqualityComparer> реализацию одной из перегрузок <xref:System.Collections.Hashtable> конструктора класса.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Примечания для[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 При вызове <xref:System.Object.GetHashCode%2A> метода класса [!INCLUDE[wrt](~/includes/wrt-md.md)]в он предоставляет поведение по умолчанию для классов, которые не переопределяются <xref:System.Object.GetHashCode%2A>. Это является частью поддержки, предоставляемой .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. раздел [поддержка .NET Framework для приложений Магазина Windows и среда выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] классе не наследуют <xref:System.Object> <xref:System.Object.GetHashCode%2A>и в настоящее время не реализуют. Однако <xref:System.Object.ToString%2A>они выглядят как методы, <xref:System.Object.Equals%28System.Object%29>и <xref:System.Object.GetHashCode%2A> при их использовании в коде C# или Visual Basic, а .NET Framework предоставляет поведение по умолчанию для этих методов.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]классы, написанные на C# языке или Visual Basic могут переопределять <xref:System.Object.GetHashCode%2A> метод.  
  
   
  
## Examples  
 Один из самых простых способов вычисления хэш-кода для числового значения, имеющего тот же или меньший диапазон, чем <xref:System.Int32> тип, — просто вернуть это значение. В следующем примере показана такая реализация для `Number` структуры.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Часто тип имеет несколько полей данных, которые могут участвовать в формировании хэш-кода. Один из способов создания хэш-кода заключается в объединении этих полей с `XOR (eXclusive OR)` помощью операции, как показано в следующем примере.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 Предыдущий пример возвращает один и тот же хэш-код для (N1, N2) и (N2, N1), и поэтому может создавать больше конфликтов, чем желательно. Доступно несколько решений, чтобы хэш-коды в этих случаях не совпадали. Один из них — возврат хэш-кода `Tuple` объекта, который отражает порядок каждого поля. В следующем примере показана возможная реализация, использующая <xref:System.Tuple%602> класс. Однако обратите внимание, что снижение производительности при создании экземпляра `Tuple` объекта может значительно повлиять на общую производительность приложения, в котором хранится большое число объектов в хэш-таблицах.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Второе альтернативное решение включает в себя весовые значения для отдельных хэш-кодов, сдвигяя хэш-коды последовательных полей двумя или более битами. В отличие от отклонения, биты, сдвинутые за пределы 31 бита, должны быть заключены в оболочку, а не удаляться. Поскольку биты отбрасываются операторами сдвига влево как в, так C# и в Visual Basic, для этого требуется создать метод сдвига влево, как в следующем примере:  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 В следующем примере используется этот метод сдвига и переноса для вычисления хэш-кода `Point` структуры, используемой в предыдущих примерах.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Хэш-функция используется для быстрого создания числа (хэш-кода), соответствующего значению объекта. Хэш-функции обычно относятся к каждому типу, и для уникальности в качестве входных данных должно использоваться хотя бы одно из полей экземпляра. Хэш-коды не должны вычисляться с помощью значений статических полей.  
  
Для классов <see cref="T:System.Object" /> <see cref="M:System.Object.GetHashCode" /> , производных от, методможетделегироватьреализациюбазовогоклассатольковтомслучае,еслипроизводныйклассопределяетравенствонаравенствоссылок.<see langword="GetHashCode" /> Реализация <see cref="M:System.Object.GetHashCode" /> по умолчанию для ссылочных типов возвращает хэш-код, эквивалентный тому, который возвращается <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> методом. Для неизменяемых ссылочных типов можно переопределить <see cref="M:System.Object.GetHashCode" /> . Как правило, для изменяемых ссылочных типов следует переопределить <see cref="M:System.Object.GetHashCode" /> только в том случае, если: 
— Хэш-код можно вычислить из полей, которые не являются изменяемыми. ни 
— Можно гарантировать, что хэш-код изменяемого объекта не изменится, пока объект содержится в коллекции, зависящей от его хэш-кода.  
  
В противном случае может показаться, что изменяемый объект будет потерян в хэш-таблице. Если выбрать переопределение <see cref="M:System.Object.GetHashCode" /> для изменяемого ссылочного типа, в документации должна быть ясно, что пользователи вашего типа не должны изменять значения объектов, пока объект хранится в хэш-таблице.  
  
Для типов <see cref="M:System.ValueType.GetHashCode" /> значений предоставляет реализацию хэш-кода по умолчанию, использующую отражение. Рекомендуется переопределять его для повышения производительности.  
  
 <block subset="none" type="note"><para>  
 Дополнительные сведения и примеры, которые вычисляют хэш-коды различными способами, см. в разделе "примеры".  
  
</para></block>  
  
 Хэш-функция должна иметь следующие свойства: 
— Если два объекта сравнивают как равные, <see cref="M:System.Object.GetHashCode" /> метод для каждого объекта должен возвращать одно и то же значение. Однако если два объекта не равны как равные, то <see cref="M:System.Object.GetHashCode" /> методы для этих двух объектов не должны возвращать разные значения.  
  
— Метод для объекта должен постоянно возвращать тот же хэш-код, если в состоянии объекта нет изменений, определяющих возвращаемое значение метода [System. Object. Equals объекта.](xref:System.Object.Equals*) <see cref="M:System.Object.GetHashCode" /> Обратите внимание, что это справедливо только для текущего выполнения приложения. при повторном запуске приложения может возвращаться другой хэш-код.  
  
Для лучшей производительности хэш-функция должна создать равномерное распределение для всех входных данных, включая входные данные, которые сильно кластеризованы. Следствием является то, что небольшие изменения в состоянии объекта должны привести к значительным изменениям в результирующем хэш-коде для лучшей производительности хэш-таблицы.  
  
-Функции хэширования должны быть недорогими для вычислений.  
  
<see cref="M:System.Object.GetHashCode" /> — Метод не должен создавать исключения.  
  
Например, реализация <see cref="M:System.String.GetHashCode" /> метода, предоставляемого <see cref="T:System.String" /> классом, возвращает идентичные хэш-коды для одинаковых строковых значений. Поэтому два <see cref="T:System.String" /> объекта возвращают один и тот же хэш-код, если они представляют одно и то же строковое значение. Кроме того, метод использует все символы в строке для создания разумного случайного распределения выходных данных, даже если входные данные кластеризованы в определенные диапазоны (например, многие пользователи могут иметь строки, содержащие только младшие символы ASCII 128, хотя Строка может содержать любой из 65 535 символов Юникода).  
  
Предоставление хорошей хэш-функции для класса может значительно повлиять на производительность при добавлении этих объектов в хэш-таблицу. В хэш-таблице с ключами, обеспечивающими хорошую реализацию хэш-функции, поиск элемента занимает постоянное время (например, операция O (1)). В хэш-таблице с плохой реализацией хэш-функции производительность поиска зависит от числа элементов в хэш-таблице (например, операции O (`n`), где `n` — число элементов в хэш-таблице). Пользователь-злоумышленник может вводить данные, увеличивающие количество конфликтов, что может значительно снизить производительность приложений, зависящих от хэш-таблиц, при следующих условиях. 
— Когда хэш-функции вызывают частые конфликты.  
  
— Когда большая часть объектов в хэш-таблице создает хэш-коды, которые равны или приблизительно равны друг другу.  
  
— При вводе пользователями данных, из которых вычисляются хэш-код.  
  
Производные классы, <see cref="M:System.Object.GetHashCode" /> переопределяющие <see cref="M:System.Object.Equals(System.Object)" /> , также должны переопределяться, чтобы убедиться, что два объекта считаются равными <see cref="T:System.Collections.Hashtable" /> , имеют одинаковый хэш-код. в противном случае тип может работать неправильно.</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" /> для текущего экземпляра.</summary>
        <returns>Точный тип текущего экземпляра в среде выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поскольку <xref:System.Object?displayProperty=nameWithType> является базовым классом для всех типов в системе типов .NET <xref:System.Object.GetType%2A> , метод можно использовать для возврата <xref:System.Type> объектов, представляющих все типы .NET. .NET распознает следующие пять категорий типов:  
  
-   Классы, являющиеся производными от <xref:System.Object?displayProperty=nameWithType>класса,  
  
-   Типы значений, являющиеся производными от <xref:System.ValueType?displayProperty=nameWithType>.  
  
-   Интерфейсы, которые являются производными <xref:System.Object?displayProperty=nameWithType> от, начиная с .NET Framework 2,0.  
  
-   Перечисления, которые являются производными от <xref:System.Enum?displayProperty=nameWithType>.  
  
-   Делегаты, которые являются производными от <xref:System.MulticastDelegate?displayProperty=nameWithType>.  
  
 Для двух объектов `x` `y` с одинаковыми типами `Object.ReferenceEquals(x.GetType(),y.GetType())` среды выполнения возвращает `true`. В следующем примере <xref:System.Object.GetType%2A> метод используется <xref:System.Object.ReferenceEquals%2A> с методом для определения того, является ли одно числовое значение тем же типом, что и два других числовых значения.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Чтобы определить, является ли объект конкретным типом, можно использовать ключевое слово или конструкцию для сравнения типов языка. Например, можно использовать `TypeOf…Is` конструкцию в Visual Basic `is` или ключевое слово в. C#  
  
 Метод наследуется всеми типами, производными от <xref:System.Object>. <xref:System.Object.GetType%2A> Это означает, что в дополнение к использованию ключевого слова сравнения собственного языка можно использовать <xref:System.Object.GetType%2A> метод для определения типа конкретного объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 Объект предоставляет метаданные, связанные с классом текущего <xref:System.Object>объекта. <xref:System.Type>  
  
   
  
## Examples  
 В следующем примере кода показано, <xref:System.Object.GetType%2A> как возвращает тип среды выполнения текущего экземпляра.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает неполную копию текущего объекта <see cref="T:System.Object" />.</summary>
        <returns>Неполная копия объекта <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A> Метод создает неполную копию путем создания нового объекта, а затем копирует нестатические поля текущего объекта в новый объект. Если поле является типом значения, выполняется побитовая копия поля. Если поле является ссылочным типом, то ссылка копируется, но на объект, на который указывает ссылка, нет; Таким образом, исходный объект и его клон ссылаются на один и тот же объект.  
  
 Например, рассмотрим объект с именем X, который ссылается на объекты A и B. объект B, в свою очередь, ссылается на объект C. Поверхностная копия X создает новый объект x2, который также ссылается на объекты A и B. В отличие от этого, при глубоком копировании X создается новый объект x2, который ссылается на новые объекты a2 и B2, которые являются копиями A и B. B2, в свою очередь, ссылается на новый объект C2, который является копией C. В примере показана разница между неполной и глубокой операцией копирования.  
  
 Существует множество способов реализации операции глубокого копирования, если неполная операция копирования, <xref:System.Object.MemberwiseClone%2A> выполняемая методом, не соответствует вашим потребностям. В число этих требований входят следующие:  
  
-   Вызовите конструктор класса копируемого объекта, чтобы создать второй объект со значениями свойств, взятыми из первого объекта. Предполагается, что значения объекта полностью определяются его конструктором класса.  
  
-   Вызовите <xref:System.Object.MemberwiseClone%2A> метод, чтобы создать неполную копию объекта, а затем назначьте новые объекты, значения которых совпадают с исходным объектом, с любыми свойствами или полями, значения которых являются ссылочными типами. `DeepCopy` Метод в примере иллюстрирует этот подход.  
  
-   Выполните сериализацию объекта для глубокого копирования, а затем восстановите сериализованные данные в другую объектную переменную.  
  
-   Используйте отражение с рекурсией для выполнения операции глубокого копирования.  
  
   
  
## Examples  
 В следующем примере показан <xref:System.Object.MemberwiseClone%2A> метод. Он определяет `ShallowCopy` метод, который <xref:System.Object.MemberwiseClone%2A> вызывает метод для выполнения `Person` неполной операции копирования на объекте. Он также определяет `DeepCopy` метод, выполняющий операцию глубокого копирования `Person` для объекта.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 В этом примере `Person.IdInfo` свойство `IdInfo` возвращает объект. Как видно из выходных данных `Person` в примере, при клонировании объекта путем <xref:System.Object.MemberwiseClone%2A> вызова `Person` метода клонированный объект является независимой копией исходного объекта, за исключением того, что они совместно используют одну и ту `Person.IdInfo` же ссылку на объект. В результате изменение `Person.IdInfo` свойства клона изменяет `Person.IdInfo` свойство исходного объекта. С другой стороны, при выполнении операции глубокого копирования клонированный `Person` объект, включая его `Person.IdInfo` свойство, можно изменить, не влияя на исходный объект.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Первый из сравниваемых объектов.</param>
        <param name="objB">Второй из сравниваемых объектов.</param>
        <summary>Определяет, совпадают ли указанные экземпляры <see cref="T:System.Object" />.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="objA" /> соответствует тому же экземпляру, что и параметр <paramref name="objB" />, или же оба они имеют значение **NULL**; в противном случае значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Equals%2A> В<xref:System.Object.ReferenceEquals%2A> отличие от метода и оператора равенства, метод не может быть переопределен. Поэтому, если нужно проверить две ссылки на объекты на равенство и вы не уверены в реализации `Equals` метода, можно <xref:System.Object.ReferenceEquals%2A> вызвать метод.  
  
 Однако возвращаемое значение <xref:System.Object.ReferenceEquals%2A> метода может показаться аномальным в этих двух сценариях:  
  
-   При сравнении типов значений. Если `objA` <xref:System.Object.ReferenceEquals%2A> и `objB` являются типами значений, они упаковываются перед передачей в метод. Это означает, что если `objA` и `objB` , и представляют один и тот же экземпляр типа значения <xref:System.Object.ReferenceEquals%2A> , метод, `false`тем не менее, возвращает, как показано в следующем примере.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Дополнительные сведения о типах значений упаковки см. в разделе [Упаковка и](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)распаковка.  
  
-   При сравнении строк. Если `objA` <xref:System.Object.ReferenceEquals%2A> `true` и `objB` являются строками, метод возвращает значение, если строка интернирована. Он не выполняет проверку на равенство значений.  В следующем примере и `s1` `s2` равны, так как они являются двумя экземплярами одной интернированной строки. `s3` Однако и `s4` не равны, поскольку хотя они имеют одинаковые строковые значения, эта строка не интернирована.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Дополнительные сведения об интернировании строк см. в <xref:System.String.IsInterned%2A?displayProperty=nameWithType>разделе.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Object.ReferenceEquals%2A> , чтобы определить, являются ли два объекта одним и тем же экземпляром.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строку, представляющую текущий объект.</summary>
        <returns>Строка, представляющая текущий объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType>является основным методом форматирования в .NET Framework. Он преобразует объект в строковое представление, чтобы его можно было отображать. (Сведения о поддержке форматирования в .NET Framework см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).) Реализации <xref:System.Object.ToString%2A?displayProperty=nameWithType> метода по умолчанию возвращают полное имя типа объекта.  
  
> [!IMPORTANT]
>  Возможно, вы достигли этой страницы, следуя ссылке из списка участников другого типа. Это обусловлено тем, что этот тип <xref:System.Object.ToString%2A?displayProperty=nameWithType>не переопределяется. Вместо этого он наследует функциональность <xref:System.Object.ToString%2A?displayProperty=nameWithType> метода.  
  
 Типы часто переопределяют <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, чтобы предоставить более подходящее строковое представление определенного типа. Типы также часто перегружают <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, чтобы обеспечить поддержку для строк формата или форматирования с учетом языка и региональных параметров.  
  
 Содержание  
  
 [Метод Object. ToString () по умолчанию](#Default)   
 [Переопределение метода Object. ToString ()](#Overriding)   
 [Перегрузка метода ToString](#Overloading)   
 [Расширение метода Object. ToString](#Extending)   
 [Примечания для среда выполнения Windows](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>Метод Object. ToString () по умолчанию  
 Реализация <xref:System.Object.ToString%2A> метода по умолчанию возвращает полное имя типа <xref:System.Object>, как показано в следующем примере.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Поскольку <xref:System.Object> является базовым классом всех ссылочных типов в .NET Framework, это поведение наследуется ссылочными типами, которые не <xref:System.Object.ToString%2A> переопределяют метод. Это показано в следующем примере. Он определяет класс с именем `Object1` , который принимает реализацию по умолчанию <xref:System.Object> для всех элементов. Его <xref:System.Object.ToString%2A> метод возвращает полное имя типа объекта.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Переопределение метода Object. ToString ()  
 Типы обычно переопределяют <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод для возврата строки, представляющей экземпляр объекта. Например, базовые типы, такие <xref:System.Char>как, <xref:System.Int32>и <xref:System.String> , предоставляют <xref:System.Object.ToString%2A> реализации, возвращающие строковое представление значения, представляемого объектом. В следующем примере определяется класс, `Object2`который <xref:System.Object.ToString%2A> переопределяет метод для возврата имени типа вместе со значением.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 В следующей таблице перечислены категории типов в .NET и указано, переопределяются <xref:System.Object.ToString%2A?displayProperty=nameWithType> ли они методом.  
  
|Категория типа|Переопределяет Object. ToString ()|Поведение|  
|-------------------|-----------------------------------|--------------|  
|Класс|Н/Д|Н/Д|  
|Структура|Да (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Аналогично `Object.ToString()`|  
|Перечисление|Да (<xref:System.Enum.ToString?displayProperty=nameWithType>)|Имя элемента|  
|Интерфейс|Нет|Н/Д|  
|делегат|Нет|Н/Д|  
  
 Дополнительные сведения о переопределении <xref:System.Object.ToString%2A>см. в разделе Примечания к наследникам.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>Перегрузка метода ToString  
 Помимо переопределения <xref:System.Object.ToString?displayProperty=nameWithType> метода без параметров, многие типы `ToString` перегружают метод для предоставления версий метода, принимающих параметры. Чаще всего это делается для обеспечения поддержки форматирования переменных и форматирования с учетом языка и региональных параметров.  
  
 В следующем примере `ToString` метод перегружается для возврата результирующей строки, содержащей значения различных полей `Automobile` класса. Он определяет четыре строки формата: G, который возвращает имя модели и год; D, возвращающее имя модели, год и число дверей; C, возвращающее имя модели, год и число цилиндров; и, который возвращает строку со всеми четырьмя значениями полей.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 В следующем примере вызывается перегруженный <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод для вывода форматирования значения валюты с учетом языка и региональных параметров.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Дополнительные сведения о строках форматирования и форматировании с учетом языка и региональных параметров см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md). Строки формата, поддерживаемые числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Сведения о строках формата, поддерживаемых значениями даты и времени, см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Расширение метода Object. ToString  
 Поскольку тип наследует метод по умолчанию <xref:System.Object.ToString%2A?displayProperty=nameWithType> , его поведение может оказаться нежелательным и нужно изменить его. Это особенно справедливо для массивов и классов коллекций. Несмотря на то, что `ToString` метод массива или класса коллекции может отображать значения его членов, вместо него отображается полное имя типа, как показано в следующем примере.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Есть несколько вариантов для создания результирующей строки, которая вам нужна.  
  
-   Если тип <xref:System.Collections.IEnumerable> является массивом, объектом коллекции или объектом, реализующим интерфейсы или <xref:System.Collections.Generic.IEnumerable%601> , можно перечислить `foreach` его элементы с помощью инструкции в C# или `For Each...Next` конструкции в Visual Basic.  
  
-   Если класс `sealed` не является (in C#) или `NotInheritable` (в Visual Basic), можно разработать класс-оболочку, который <xref:System.Object.ToString%2A?displayProperty=nameWithType> наследует от базового класса, метод которого необходимо настроить. Как минимум, для этого необходимо выполнить следующие действия.  
  
    1.  Реализуйте все необходимые конструкторы. Производные классы не наследуют конструкторы базовых классов.  
  
    2.  Переопределите <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, чтобы вернуть результирующую строку, которая вам нужна.  
  
     В следующем примере определяется класс-оболочка для <xref:System.Collections.Generic.List%601> класса. Он переопределяет <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод для вывода значения каждого метода коллекции, а не полного имени типа.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Разрабатывайте [метод расширения](~/docs/standard/design-guidelines/extension-methods.md) , который возвращает нужную результирующую строку. Обратите внимание, что метод по <xref:System.Object.ToString%2A?displayProperty=nameWithType> умолчанию нельзя переопределить таким образом (т. е. класс расширения C#(в) или модуль (в Visual Basic) не может иметь метод без `ToString` параметров именования, который вызывается вместо исходного типа `ToString`метод. Вам потребуется указать другое имя для `ToString` замены без параметров.  
  
     В <xref:System.Collections.Generic.List%601> следующем примере определяются два метода, расширяющие класс: `ToString2` метод без параметров, <xref:System.String> а также `ToString` метод с параметром, представляющим строку формата.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Примечания для[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 При вызове <xref:System.Object.ToString%2A> метода класса [!INCLUDE[wrt](~/includes/wrt-md.md)]в он предоставляет поведение по умолчанию для классов, которые не переопределяются <xref:System.Object.ToString%2A>. Это является частью поддержки, предоставляемой .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. раздел [поддержка .NET Framework для приложений Магазина Windows и среда выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] классе не наследуют <xref:System.Object> <xref:System.Object.ToString%2A>и не всегда реализуют. Однако <xref:System.Object.ToString%2A>они всегда имеют методы, <xref:System.Object.Equals%28System.Object%29>и <xref:System.Object.GetHashCode%2A> при их использовании в коде C# или Visual Basic, а .NET Framework предоставляет поведение по умолчанию для этих методов.  
  
 Начиная с [!INCLUDE[net_v451](~/includes/net-v451-md.md)], среда CLR будет использовать [IStringable.](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) [!INCLUDE[wrt](~/includes/wrt-md.md)] ToString для объекта, прежде чем вернуться к реализации <xref:System.Object.ToString%2A?displayProperty=nameWithType>по умолчанию.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]классы, написанные на C# языке или Visual Basic могут переопределять <xref:System.Object.ToString%2A> метод.  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>Интерфейс [!INCLUDE[wrt](~/includes/wrt-md.md)] и IStringable  
 Начиная с [!INCLUDE[win81](~/includes/win81-md.md)] <xref:System.Object.ToString%2A?displayProperty=nameWithType> [](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) [](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), компонент включаетинтерфейсIStringable,единственныйметодкоторогоIStringable.ToStringобеспечиваетбазовуюподдержкуформатирования[!INCLUDE[wrt](~/includes/wrt-md.md)] , сравнимую с, обеспечиваемую. Чтобы предотвратить неоднозначность, не следует реализовывать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) для управляемых типов.  
  
 Если управляемые объекты вызываются машинным кодом или кодом, написанным на языках, таких как C++JavaScript или/CX, они выглядят как реализующие [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). Среда CLR автоматически направит вызовы из [IStringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) <xref:System.Object.ToString%2A?displayProperty=nameWithType> в в случае, если событие [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) не реализовано в управляемом объекте.  
  
> [!WARNING]
>  Так как среда CLR Auto реализует [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) для всех управляемых типов в [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] приложениях, рекомендуется не предоставлять собственную реализацию [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) . Реализация [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) может привести к непредвиденному поведению при `ToString` вызове [!INCLUDE[wrt](~/includes/wrt-md.md)]из C++,/CX или JavaScript.  
  
 Если вы решили реализовать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) в общедоступном управляемом типе, экспортированном в [!INCLUDE[wrt](~/includes/wrt-md.md)] компоненте, применяются следующие ограничения.  
  
-   Интерфейс [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) можно определить только в связи «класс реализует», например  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     в C# или  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     в Visual Basic.  
  
-   Невозможно реализовать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) в интерфейсе.  
  
-   Нельзя объявить параметр типа [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) не может быть типом возвращаемого значения метода, свойства или поля.  
  
-   Невозможно скрыть реализацию [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) из базовых классов с помощью определения метода, как показано ниже:  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     Вместо этого реализация [IStringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) должна всегда переопределять реализацию базового класса. Реализацию `ToString` можно скрыть только путем вызова этого метода в строго типизированном экземпляре класса.  
  
 Обратите внимание, что при различных условиях вызовы из машинного кода в управляемый тип, реализующий [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) или скрывая его реализацию [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) , могут привести к непредвиденному поведению.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При реализации собственных типов следует переопределить метод, чтобы он <see cref="M:System.Object.ToString" /> возвращал значения, имеющие смысл для этих типов. Производные классы, которым требуется больший контроль над <see cref="M:System.Object.ToString" /> форматированием, чем <see cref="T:System.IFormattable" /> предоставляет, могут реализовывать интерфейс. Его <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> метод позволяет определять строки формата, управляющие форматированием, и <see cref="T:System.IFormatProvider" /> использовать объект, который может обеспечить форматирование для определенного языка и региональных параметров.  
  
<see cref="M:System.Object.ToString" /> Переопределения метода должны соответствовать следующим рекомендациям: 
— Возвращаемая строка должна быть понятной и удобочитаемой для людей.  
  
— Возвращаемая строка должна уникальным образом идентифицировать значение экземпляра объекта.  
  
-Возвращаемая строка должна быть максимально короткой, чтобы ее можно было отображать с помощью отладчика.  
  
-Переопределение не должно возвращать <see cref="F:System.String.Empty" /> строку или значение null. <see cref="M:System.Object.ToString" />  
  
<see cref="M:System.Object.ToString" /> -Переопределение не должно вызывать исключение.  
  
— Если строковое представление экземпляра зависит от языка и региональных параметров или может быть отформатировано несколькими способами, реализуйте <see cref="T:System.IFormattable" /> интерфейс.  
  
— Если возвращаемая строка содержит конфиденциальную информацию, необходимо сначала запросить соответствующее разрешение. Если запрос проходит удачно, вы можете вернуть конфиденциальную информацию. в противном случае следует вернуть строку, которая исключается из конфиденциальной информации.  
  
<see cref="M:System.Object.ToString" /> -Переопределение не должно иметь наблюдаемых побочных эффектов, чтобы избежать сложностей при отладке. Например, вызов <see cref="M:System.Object.ToString" /> метода не должен изменять значение полей экземпляра.  
  
— Если тип реализует метод синтаксического анализа (или <see langword="Parse" /> <see langword="TryParse" /> метод, конструктор или какой-либо другой статический метод, который создает экземпляр типа из строки), следует убедиться, что строка, возвращаемая <see cref="M:System.Object.ToString" /> методом, может быть преобразуется в экземпляр объекта.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
