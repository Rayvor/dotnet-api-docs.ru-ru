<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1712c4257543163b0bf3c5ed7c94aa080d7b45b8" /><Meta Name="ms.sourcegitcommit" Value="97dd2e4ee16a6215aef37f928d45e872fc816c6f" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="01/02/2020" /><Meta Name="ms.locfileid" Value="75615219" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Поддерживает все классы в иерархии классов .NET и предоставляет низкоуровневые службы для производных классов. Является исходным базовым классом для всех классов .NET и корнем иерархии типов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве языков не требуется объявлять для классов наследование от <xref:System.Object>, так как они наследуют его неявно.  
  
 Поскольку все классы в .NET являются производными от <xref:System.Object>, каждый метод, определенный в классе <xref:System.Object>, доступен во всех объектах системы. Производные классы могут переопределять некоторые из этих методов, включая:  
  
-   <xref:System.Object.Equals%2A> — поддерживает сравнение объектов.  
  
-   <xref:System.Object.Finalize%2A> — выполняет операции очистки до автоматического освобождения объекта.  
  
-   <xref:System.Object.GetHashCode%2A> — создает число, соответствующее значению объекта для поддержки использования хэш-таблицы.  
  
-   <xref:System.Object.ToString%2A> создает понятную для человека текстовую строку, описывающую экземпляр класса.  
  
## <a name="performance-considerations"></a>Особенности производительности  
 При разработке класса, например коллекции, который должен обрабатывать объекты любого типа, вы можете создавать члены класса, принимающие экземпляры класса <xref:System.Object>. Однако процесс упаковки-преобразования и распаковки-преобразования для типа требует вычислительных затрат. Если вы знаете, что новый класс будет часто обрабатывать определенные типы значений, для минимизации затрат на упаковку-преобразование можно использовать две тактики.  
  
-   Создание общего метода, принимающего тип <xref:System.Object>, и набора специализированных перегрузок метода для каждого из типов значений, которые, как предполагается, будут часто обрабатываться классом. Если существует специализированный метод, который принимает указанный при вызове тип параметра, упаковка-преобразование не выполняется и вызывается специализированный метод. Если у метода отсутствует аргумент, который соответствует указанному при вызове типу параметра, выполняется упаковка-преобразование параметра и вызывается общий метод.  
  
-   Использование универсальных шаблонов при разработке метода и его членов. Среда CLR создает закрытый универсальный тип при создании экземпляра класса с указанием аргумента универсального типа. Универсальный метод принимает аргумент определенного типа, и его можно вызывать без упаковки-преобразования параметра.  
  
 Несмотря на то, что иногда бывает необходимо создавать классы общего назначения, которые принимают и возвращают типы <xref:System.Object>, можно повысить производительность, создав также специализированный класс для обработки определенного часто используемого типа. Например, наличие специализированного класса для задания и получения логических значений позволяет избежать затрат на их упаковку-преобразование и распаковку-преобразование.  
  
   
  
## Examples  
 В следующем примере определяется тип Point, производный от класса <xref:System.Object>, и переопределяются многие виртуальные методы класса <xref:System.Object>. Кроме того, в примере показано, как вызывать многие из статических методов и методов экземпляра класса <xref:System.Object>.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Открытые статические (<see langword="Shared" /> в Visual Basic) члены этого типа являются потокобезопасными. Для членов экземпляра потокобезопасность не гарантируется.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Object" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор вызывается конструкторами в производных классах, но его также можно использовать для непосредственного создания экземпляра класса <xref:System.Object>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, равны ли два экземпляра объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, который требуется сравнить с текущим объектом.</param>
        <summary>Определяет, равен ли заданный объект текущему объекту.</summary>
        <returns>Значение <see langword="true" />, если указанный объект равен текущему объекту; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип сравнения текущего экземпляра и параметра `obj` зависит от того, является ли текущий экземпляр ссылочным типом или типом значения.  

-   Если текущий экземпляр является ссылочным типом, то метод <xref:System.Object.Equals%28System.Object%29> проверяет равенство ссылок, а вызов метода <xref:System.Object.Equals%28System.Object%29> эквивалентен вызову метода <xref:System.Object.ReferenceEquals%2A>. Равенство ссылок означает, что сравниваемые объектные переменные ссылаются на один и тот же объект. В следующем примере показан результат такого сравнения. Он определяет класс `Person`, который является ссылочным типом, и вызывает конструктор класса `Person` для создания экземпляров двух новых `Person` объектов, `person1a` и `person2`, имеющих одно и то же значение. Он также назначает `person1a` другой объектной переменной `person1b`. Как видно из выходных данных в примере, `person1a` и `person1b` равны, так как они ссылаются на один и тот же объект. Однако `person1a` и `person2` не равны, хотя они имеют одинаковое значение.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Если текущий экземпляр является типом значения, то метод <xref:System.Object.Equals%28System.Object%29> проверяет равенство значений. Равенство значений означает следующее:  
  
    -   Два объекта имеют один и тот же тип. Как показано в следующем примере, объект <xref:System.Byte> со значением 12 не равен <xref:System.Int32> объекту со значением 12, поскольку два объекта имеют разные типы времени выполнения.  
  
         [!code-csharp-interactive[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   Значения открытого и закрытого полей двух объектов равны. В следующем примере проверяется равенство значений. Он определяет структуру `Person`, которая является типом значения, и вызывает конструктор `Person` класса для создания экземпляров двух новых `Person` объектов, `person1` и `person2`, имеющих одно и то же значение. Как видно из выходных данных примера, две объектные переменные ссылаются на разные объекты, `person1` и `person2` равны, так как они имеют одинаковое значение для поля Private `personName`.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Поскольку класс <xref:System.Object> является базовым классом для всех типов в .NET Framework, метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> предоставляет сравнение на равенство по умолчанию для всех остальных типов. Однако типы часто переопределяют метод <xref:System.Object.Equals%2A> для реализации равенства значений. Дополнительные сведения см. в примечаниях для вызывающих объектов и примечаний для разделов наследников.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Примечания для [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 При вызове перегрузки метода <xref:System.Object.Equals%28System.Object%29> для класса в [!INCLUDE[wrt](~/includes/wrt-md.md)]он предоставляет поведение по умолчанию для классов, которые не переопределяют <xref:System.Object.Equals%28System.Object%29>. Это является частью поддержки, предоставляемой .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. раздел [поддержка .NET Framework для приложений Магазина Windows и среда выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] не наследуют <xref:System.Object>и в настоящее время не реализуют метод <xref:System.Object.Equals%28System.Object%29>. Однако они имеют методы <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>и <xref:System.Object.GetHashCode%2A>, когда они используются в коде C# или Visual Basic, а .NET Framework предоставляет поведение по умолчанию для этих методов.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] классы, написанные на C# или Visual Basic, могут переопределять перегрузку метода <xref:System.Object.Equals%28System.Object%29>.  
  
## <a name="notes-for-callers"></a>Примечания для вызывающих объектов  
 Производные классы часто переопределяют метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> для реализации равенства значений. Кроме того, типы часто предоставляют дополнительную строго типизированную перегрузку методу `Equals`, как правило, путем реализации интерфейса <xref:System.IEquatable%601>. При вызове метода `Equals` для проверки на равенство следует знать, переопределяется ли текущий экземпляр <xref:System.Object.Equals%2A?displayProperty=nameWithType> и понять, как разрешается определенный вызов метода `Equals`. В противном случае вы можете выполнить проверку на равенство, отличное от предполагаемого, и метод может вернуть непредвиденное значение.  
  
 Ниже приведен пример. Он создает три объекта <xref:System.Text.StringBuilder> с одинаковыми строками, а затем выполняет четыре вызова методов `Equals`. Первый вызов метода возвращает `true`, а оставшиеся три возвращаемые `false`.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 В первом случае вызывается строго типизированная перегрузка метода <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>, которая проверяет равенство значений. Поскольку строки, назначенные двум <xref:System.Text.StringBuilder>ным объектам, равны, метод возвращает `true`. Однако <xref:System.Text.StringBuilder> не переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. По этой причине, когда объект <xref:System.Text.StringBuilder> приводится к <xref:System.Object>, когда экземпляр <xref:System.Text.StringBuilder> присваивается переменной типа <xref:System.Object>и когда метод <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> передает два <xref:System.Text.StringBuilder> объекта, вызывается метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> по умолчанию. Поскольку <xref:System.Text.StringBuilder> является ссылочным типом, это эквивалентно передаче двух <xref:System.Text.StringBuilder> объектов в метод <xref:System.Object.ReferenceEquals%2A>. Хотя все три <xref:System.Text.StringBuilder> объектов содержат одинаковые строки, они ссылаются на три различных объекта. В результате эти три вызова метода возвращают `false`.  
  
 Можно сравнить текущий объект с другим объектом для равенства ссылок, вызвав метод <xref:System.Object.ReferenceEquals%2A>. В Visual Basic также можно использовать ключевое слово `is` (например, `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Примечания для наследников  
 При определении собственного типа этот тип наследует функциональность, определенную методом `Equals` его базового типа. В следующей таблице приведена реализация метода `Equals` по умолчанию для основных категорий типов в .NET Framework.  
  
|Категория типа|Равенство, определенное|Комментарии|  
|-------------------|-------------------------|--------------|  
|Класс, производный непосредственно от <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Равенство ссылок; эквивалентно вызову <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|structure|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Равенство значений; прямое побайтовое сравнение или Сравнение полей по полям с помощью отражения.|  
|Перечисление|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|Значения должны иметь одинаковый тип перечисления и одно и то же базовое значение.|  
|делегат|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|Делегаты должны иметь одинаковый тип с одинаковыми списками вызовов.|  
|Интерфейс|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Равенство ссылок.|  
  
 Для типа значения следует всегда переопределять <xref:System.Object.Equals%2A>, так как тесты на равенство, основанные на отражении, имеют низкую производительность. Можно также переопределить реализацию <xref:System.Object.Equals%2A> по умолчанию для ссылочных типов, чтобы проверить равенство значений, а не равенство ссылок и определить точное значение равенства значений. Такие реализации <xref:System.Object.Equals%2A> возвращают `true`, если два объекта имеют одинаковое значение, даже если они не являются одним и тем же экземпляром. Разработчик типа принимает решение, что составляет значение объекта, но обычно это некоторые или все данные, хранящиеся в переменных экземпляра объекта. Например, значение объекта <xref:System.String> основано на символах строки; метод <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> переопределяет метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, который возвращает `true` для всех экземпляров строк, содержащих одни и те же символы в том же порядке.  
  
 В следующем примере показано, как переопределить метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> для проверки на равенство значений. Он переопределяет метод <xref:System.Object.Equals%2A> для класса `Person`. Если `Person` принял свою реализацию равенства базового класса, два объекта `Person` будут равны, только если они ссылались на один объект. Однако в этом случае два объекта `Person` равны, если они имеют одинаковое значение для свойства `Person.Id`.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Помимо переопределения <xref:System.Object.Equals%2A>можно реализовать интерфейс <xref:System.IEquatable%601>, чтобы обеспечить строго типизированный тест на равенство.  
  
 Следующие инструкции должны быть истинными для всех реализаций метода <xref:System.Object.Equals%28System.Object%29>. В списке `x`, `y`и `z` представляют ссылки на объекты, которые не равны **null**.  
  
-   `x.Equals(x)` возвращает `true`, за исключением случаев, в которых задействованы типы с плавающей запятой. См. статью [ISO/IEC/IEEE 60559:2011, информационные технологии — системы микропроцессора — арифметические операции с плавающей запятой](https://www.iso.org/standard/57469.html).  
  
-   `x.Equals(y)` возвращает то же значение, что и `y.Equals(x)`.  
  
-   `x.Equals(y)` возвращает `true`, если `NaN`и `x`, и `y`.  
  
-   Если `(x.Equals(y) && y.Equals(z))` возвращает `true`, `x.Equals(z)` возвращает `true`.  
  
-   Последовательные вызовы `x.Equals(y)` возвращают одно и то же значение, если объекты, на которые ссылаются `x` и `y`, не изменяются.  
  
-   `x.Equals(null)` возвращает `false`.  
  
 Реализации <xref:System.Object.Equals%2A> не должны вызывать исключения. они всегда должны возвращать значение. Например, если `obj` `null`, метод <xref:System.Object.Equals%2A> должен возвращать `false` вместо создания <xref:System.ArgumentNullException>.  
  
 При переопределении <xref:System.Object.Equals%28System.Object%29>следуйте приведенным ниже рекомендациям.  
  
-   Типы, реализующие <xref:System.IComparable>, должны переопределять <xref:System.Object.Equals%28System.Object%29>.  
  
-   Типы, переопределяющие <xref:System.Object.Equals%28System.Object%29>, также должны переопределять <xref:System.Object.GetHashCode%2A>; в противном случае хэш-таблицы могут работать неправильно.  
  
-   Рекомендуется реализовать интерфейс <xref:System.IEquatable%601> для поддержки строго типизированных тестов на равенство. Реализация <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> должна возвращать результаты, которые соответствуют <xref:System.Object.Equals%2A>.  
  
-   Если ваш язык программирования поддерживает перегрузку операторов и вы передаете оператор равенства для заданного типа, необходимо также переопределить <xref:System.Object.Equals%28System.Object%29> метод, чтобы он возвращал тот же результат, что и оператор равенства. Это позволяет гарантировать, что код библиотеки классов, использующий <xref:System.Object.Equals%2A> (например, <xref:System.Collections.ArrayList> и <xref:System.Collections.Hashtable>) ведет себя таким образом, который соответствует способу, который код приложения использует оператор равенства.  
  
### <a name="guidelines-for-reference-types"></a>Рекомендации по ссылочным типам  
 Следующие рекомендации применяются для переопределения <xref:System.Object.Equals%28System.Object%29> для ссылочного типа:  
  
-   Рассмотрите возможность переопределения <xref:System.Object.Equals%2A> Если семантика типа основана на том, что тип представляет некоторые значения.  
  
-   Большинство ссылочных типов не должны перегружать оператор равенства, даже если они переопределяют <xref:System.Object.Equals%2A>. Однако при реализации ссылочного типа, который должен иметь семантику значений, например тип комплексного числа, необходимо переопределить оператор равенства.  
  
-   Не следует переопределять <xref:System.Object.Equals%2A> для изменяемого ссылочного типа. Это обусловлено тем, что переопределение <xref:System.Object.Equals%2A> требует также переопределения метода <xref:System.Object.GetHashCode%2A>, как описано в предыдущем разделе. Это означает, что хэш-код экземпляра изменяемого ссылочного типа может измениться в течение своего времени существования, что может привести к потере объекта в хэш-таблице.  
  
### <a name="guidelines-for-value-types"></a>Рекомендации по типам значений  
 Следующие рекомендации применяются для переопределения <xref:System.Object.Equals%28System.Object%29> для типа значения.  
  
-   При определении типа значения, включающего одно или несколько полей, значения которых являются ссылочными типами, следует переопределить <xref:System.Object.Equals%28System.Object%29>. Реализация <xref:System.Object.Equals%28System.Object%29>, предоставляемая <xref:System.ValueType>, выполняет побайтовое сравнение для типов значений, поля которых являются типами значений, но использует отражение для выполнения сравнения по полям значений, поля которых включают ссылочные типы.  
  
-   Если переопределение <xref:System.Object.Equals%2A> и язык разработки поддерживает перегрузку операторов, необходимо перегрузить оператор равенства.  
  
-   Необходимо реализовать интерфейс <xref:System.IEquatable%601>. Вызов строго типизированного <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> метода позволяет избежать упаковки-преобразования аргумента `obj`.  
  
   
  
## Examples  
 В следующем примере показан класс `Point`, который переопределяет метод <xref:System.Object.Equals%2A>, чтобы обеспечить равенство значений, и класс `Point3D`, производный от `Point`. Поскольку `Point` переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> для проверки равенства значений, метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> не вызывается. Однако `Point3D.Equals` вызывает `Point.Equals`, так как `Point` реализует <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> способом, обеспечивающим равенство значений.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 Метод `Point.Equals` проверяет, что аргумент `obj` не равен **null** и ссылается на экземпляр того же типа, что и этот объект. Если проверка завершается ошибкой, метод возвращает `false`.  
  
 Метод `Point.Equals` вызывает метод <xref:System.Object.GetType%2A>, чтобы определить, идентичны ли типы времени выполнения двух объектов. Если метод использовал проверку формы `obj is Point` в C# или `TryCast(obj, Point)` в Visual Basic, проверка будет возвращать `true` в случаях, когда `obj` является экземпляром производного класса `Point`, даже если `obj` и текущий экземпляр имеют разные типы времени выполнения. Убедившись, что оба объекта имеют одинаковый тип, метод приводит `obj` к типу `Point` и возвращает результат сравнения полей экземпляров двух объектов.  
  
 В `Point3D.Equals`унаследованный метод `Point.Equals`, который переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, вызывается до того, как все еще выполняется. Поскольку `Point3D` является запечатанным классом (`NotInheritable` в Visual Basic), проверка формы `obj is Point` в C# или `TryCast(obj, Point)` в Visual Basic является достаточной, чтобы гарантировать, что `obj` является объектом `Point3D`. Если это объект `Point3D`, он приводится к `Point` объекту и передается в реализацию базового класса <xref:System.Object.Equals%2A>. Только когда наследуемый метод `Point.Equals` возвращает `true` метод сравнивает поля `z` экземпляра, представленные в производном классе.  
  
 В следующем примере определяется класс `Rectangle`, который внутренне реализует прямоугольник как два объекта `Point`. Класс `Rectangle` также переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, чтобы обеспечить равенство значений.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Некоторые языки, такие C# как и Visual Basic, поддерживают перегрузку операторов. Если тип перегружает оператор равенства, он также должен переопределять метод <xref:System.Object.Equals%28System.Object%29>, чтобы обеспечить ту же функциональность. Обычно это достигается путем написания метода <xref:System.Object.Equals%28System.Object%29> в терминах перегруженного оператора равенства, как показано в следующем примере.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Поскольку `Complex` является типом значения, он не может быть производным от.  Поэтому методу override для <xref:System.Object.Equals%28System.Object%29> не требуется вызывать <xref:System.Object.GetType%2A>, чтобы определить точный тип времени выполнения каждого объекта, но вместо этого можно использовать оператор `is` в C# или оператор `TypeOf` в Visual Basic, чтобы проверить тип параметра `obj`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Первый из сравниваемых объектов.</param>
        <param name="objB">Второй из сравниваемых объектов.</param>
        <summary>Определяет, считаются ли равными указанные экземпляры объектов.</summary>
        <returns><see langword="true" />, если указанные объекты равны; в противном случае — <see langword="false" />. Если оба параметра <paramref name="objA" /> и <paramref name="objB" /> имеют значение **NULL**, метод возвращает значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статический метод <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> указывает, равны ли два объекта, `objA` и `objB`. Он также позволяет тестировать объекты, значение которых равно **null** , для проверки на равенство. Он сравнивает `objA` и `objB` на равенство следующим образом:  
  
-   Он определяет, представляют ли два объекта одну и ту же ссылку на объект. В противном случае метод возвращает `true`. Этот тест эквивалентен вызову метода <xref:System.Object.ReferenceEquals%2A>. Кроме того, если оба `objA` и `objB` имеют **значение NULL**, метод возвращает `true`.  
  
-   Он определяет, имеет ли `objA` или `objB` **значение NULL**. Если да, то возвращается `false`.  
  
-   Если два объекта не представляют одну и ту же ссылку на объект и ни один из них не имеет **значения NULL**, то вызывается `objA`.`Equals`(`objB`) и возвращает результат. Это означает, что если `objA` переопределяет метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, вызывается это переопределение.  
  
   
  
## Examples  
 В следующем примере показан метод <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> и сравнивается с методом <xref:System.Object.ReferenceEquals%2A>.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Finalize() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Позволяет объекту попытаться освободить ресурсы и выполнить другие операции очистки, перед тем как он будет уничтожен во время сборки мусора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Object.Finalize%2A> используется для выполнения операций очистки неуправляемых ресурсов, хранящихся в текущем объекте, до уничтожения объекта. Этот метод защищен и поэтому доступен только через этот класс или производный класс.  
  
 Содержание  
  
-   [Принцип работы финализации](#How)  
  
-   [Примечания для разработчиков](#Notes)  
  
-   [Альтернатива SafeHandle](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Принцип работы финализации  
 Класс <xref:System.Object> не предоставляет реализации метода <xref:System.Object.Finalize%2A>, а сборщик мусора не помечает типы, производные от <xref:System.Object>, для финализации, если только они не переопределят метод <xref:System.Object.Finalize%2A>.  
  
 Если тип переопределяет метод <xref:System.Object.Finalize%2A>, сборщик мусора добавляет запись для каждого экземпляра типа во внутреннюю структуру, называемую очередью финализации. Очередь финализации содержит записи для всех объектов в управляемой куче, код завершения которых должен быть выполнен до освобождения памяти сборщиком мусора. Сборщик мусора затем вызывает метод <xref:System.Object.Finalize%2A> автоматически при выполнении следующих условий:  
  
-   После того как сборщик мусора обнаружит, что объект недоступен, за исключением случаев, когда объект был исключен из финализации путем вызова метода <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>.  
  
-   **Только в .NET Framework**, во время завершения работы домена приложения, если только объект не исключен из финализации. Во время завершения работы, даже объекты, которые по-прежнему доступны, завершаются.  
  
 <xref:System.Object.Finalize%2A> автоматически вызывается только один раз для данного экземпляра, если только объект не будет повторно зарегистрирован с помощью механизма, такого как <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType>, а метод <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> не вызывался впоследствии.  
  
 <xref:System.Object.Finalize%2A> операции имеют следующие ограничения.  
  
-   Точное время выполнения метода завершения не определено. Чтобы обеспечить детерминированный выпуск ресурсов для экземпляров класса, реализуйте `Close` метод или предоставьте реализацию <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.  
  
-   Методы завершения двух объектов не гарантированно выполняются в каком бы то ни было определенном порядке, даже если один объект ссылается на другой. То есть если объект A имеет ссылку на объект B и оба метода имеют методы завершения, то объект B может быть уже завершен при запуске метода завершения объекта A.  
  
-   Поток, в котором выполняется метод завершения, не определен.  
  
 Метод <xref:System.Object.Finalize%2A> может не выполняться до завершения или может не выполняться вообще при следующих исключительных обстоятельствах:  
  
-   Если другой метод завершения блокируется неограниченно (переходит в бесконечный цикл, пытается получить блокировку, которую он никогда не может получить и т. д.). Поскольку среда выполнения пытается выполнить методы завершения до завершения, другие методы завершения могут не вызываться, если метод завершения блокирует неограниченное время.  
  
-   Значение, если процесс завершается без предоставления среде выполнения возможности очистки. В этом случае первое уведомление среды выполнения о завершении процесса — это DLL_PROCESS_DETACH уведомление.  
  
 Среда выполнения продолжит завершать объекты во время завершения работы только в тот момент, когда число объектов, которые можно завершить, будет уменьшаться.  
  
 Если <xref:System.Object.Finalize%2A> или переопределение <xref:System.Object.Finalize%2A> вызывает исключение, а среда выполнения не размещается приложением, переопределяющим политику по умолчанию, среда выполнения прерывает процесс и не выполняет активные `try`/`finally` блоки или методы завершения. Такое поведение обеспечивает целостность процессов, если финализатор не может освободить или уничтожить ресурсы.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Переопределение метода Finalize 
 Необходимо переопределить <xref:System.Object.Finalize%2A> для класса, использующего неуправляемые ресурсы, такие как дескрипторы файлов или подключения к базе данных, которые должны быть освобождены, когда управляемый объект, использующий их, будет удален во время сборки мусора. Не следует реализовывать метод <xref:System.Object.Finalize%2A> для управляемых объектов, так как сборщик мусора вывысвобождает управляемые ресурсы автоматически.  
  
> [!IMPORTANT]
>  Если доступен объект <xref:System.Runtime.InteropServices.SafeHandle>, который создает оболочку для неуправляемого ресурса, рекомендуемым альтернативом является реализация шаблона удаления с помощью безопасного маркера, а не переопределение <xref:System.Object.Finalize%2A>. Дополнительные сведения см. [в разделе альтернатива SafeHandle](#SafeHandle) .  
  
 По умолчанию метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType> не выполняет никаких действий, но следует переопределять <xref:System.Object.Finalize%2A> только при необходимости и освобождать неуправляемые ресурсы. Освобождение памяти обычно занимает намного больше времени, если выполняется операция финализации, так как для нее требуется как минимум две сборки мусора. Кроме того, следует переопределить метод <xref:System.Object.Finalize%2A> только для ссылочных типов. Среда CLR завершает только ссылочные типы. Он игнорирует методы завершения для типов значений.  

Областью действия метода <xref:System.Object.Finalize%2A?displayProperty=nameWithType> является `protected`. Эту ограниченную область следует поддерживать при переопределении метода в классе. Сохраняя защищенный метод <xref:System.Object.Finalize%2A>, пользователи приложения не смогут напрямую вызывать метод <xref:System.Object.Finalize%2A> объекта.
  
 Каждая реализация <xref:System.Object.Finalize%2A> в производном типе должна вызывать реализацию <xref:System.Object.Finalize%2A>его базового типа. Это единственный случай, когда коду приложения разрешено вызывать <xref:System.Object.Finalize%2A>. Метод <xref:System.Object.Finalize%2A> объекта не должен вызывать метод для любых объектов, отличных от базового класса. Это связано с тем, что другие вызываемые объекты могут собираться одновременно с вызывающим объектом, например в случае завершения работы среды CLR. 
  
> [!NOTE]
>  C# Компилятор не позволяет переопределить метод <xref:System.Object.Finalize%2A>. Вместо этого метод завершения предоставляется путем реализации [деструктора](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) для класса. C# Деструктор автоматически вызывает деструктор своего базового класса.  
>   
>  Visual C++ также предоставляет собственный синтаксис для реализации метода <xref:System.Object.Finalize%2A>. Дополнительные сведения см. в подразделе "деструкторы и методы завершения" раздела [инструкции: определение и использование классов и структурC++(/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Поскольку сборка мусора является недетерминированной, вы точно не узнаете, когда сборщик мусора выполняет завершение. Для немедленного освобождения ресурсов можно также выбрать реализацию [шаблона удаления](~/docs/standard/garbage-collection/implementing-dispose.md) и интерфейса <xref:System.IDisposable>. Реализация <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> может быть вызвана потребителями класса для освобождения неуправляемых ресурсов, и метод <xref:System.Object.Finalize%2A> можно использовать для высвобождения неуправляемых ресурсов в случае, если метод <xref:System.IDisposable.Dispose%2A> не вызывается.  
  
 <xref:System.Object.Finalize%2A> может выполнять практически любое действие, включая восстановление объекта (т. е. сделать объект доступным снова) после его очистки во время сборки мусора. Однако объект может быть восстановлен только один раз. <xref:System.Object.Finalize%2A> нельзя вызвать для восстановленных объектов во время сборки мусора.
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>Альтернативный вариант с использованием SafeHandle  
 Создание надежных методов завершения зачастую сложно, так как вы не можете делать предположения о состоянии приложения, а так как необработанные системные исключения, такие как <xref:System.OutOfMemoryException> и <xref:System.StackOverflowException>, завершают метод завершения. Вместо реализации метода завершения для класса для освобождения неуправляемых ресурсов можно использовать объект, производный от класса <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>, чтобы создать оболочку для неуправляемых ресурсов, а затем реализовать шаблон Dispose без метода завершения. .NET Framework предоставляет следующие классы в пространстве имен <xref:Microsoft.Win32?displayProperty=nameWithType>, которые являются производными от <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> является классом-оболочкой для маркера файла.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> является классом-оболочкой для дескрипторов размещенных в памяти файлов.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> является классом-оболочкой для указателя на блок неуправляемой памяти.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>и <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> являются классами-оболочками для криптографических дескрипторов.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> является классом-оболочкой для дескрипторов канала.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> — это класс-оболочка для маркера в разделе реестра.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> — это класс-оболочка для обработчика ожидания.  
  
 В следующем примере [шаблон Dispose](~/docs/standard/garbage-collection/implementing-dispose.md) используется с надежными дескрипторами вместо переопределения метода <xref:System.Object.Finalize%2A>. Он определяет класс `FileAssociation`, который заключает в реестр сведения о приложении, обрабатывающем файлы с определенным расширением. Два дескриптора реестра, возвращаемые вызовом функции Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) как `out` параметры, передаются в конструктор <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>. После этого метод защищенного `Dispose` типа вызывает метод `SafeRegistryHandle.Dispose`, чтобы освободить эти два маркера.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 В следующем примере проверяется, вызывается ли метод <xref:System.Object.Finalize%2A> при уничтожении объекта, переопределяющего <xref:System.Object.Finalize%2A>. Обратите внимание, что в рабочем приложении метод <xref:System.Object.Finalize%2A> будет переопределен, чтобы освободить неуправляемые ресурсы, удерживаемые объектом. Также обратите внимание C# , что в примере вместо переопределения метода <xref:System.Object.Finalize%2A> предоставляется деструктор.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Дополнительный пример переопределения метода <xref:System.Object.Finalize%2A> см. в описании метода <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Служит хэш-функцией по умолчанию.</summary>
        <returns>Хэш-код для текущего объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Хэш-код — это числовое значение, которое используется для вставки и обнаружения объекта в коллекции на основе хэша, такой как класс <xref:System.Collections.Generic.Dictionary%602>, класс <xref:System.Collections.Hashtable> или тип, производный от класса <xref:System.Collections.DictionaryBase>. Метод <xref:System.Object.GetHashCode%2A> предоставляет этот хэш-код для алгоритмов, требующих быстрых проверок равенства объектов.  
  
> [!NOTE]
>  Сведения о том, как хэш-коды используются в хэш-таблицах и некоторых дополнительных алгоритмах хэш-кода, см. в записи [хэш-функции](https://en.wikipedia.org/wiki/Hash_function) в Википедии.  
  
 Два объекта, которые равны, возвращают хэш-коды, равные. Однако обратная неверно: равные хэш-коды не подразумевают равенство объектов, так как разные (неравные) объекты могут иметь одинаковые хэш-коды. Более того, .NET не гарантирует реализацию метода <xref:System.Object.GetHashCode%2A> по умолчанию, и значение, возвращаемое этим методом, может отличаться между реализациями .NET, такими как различные версии .NET Framework и .NET Core, а также платформы, такие как 32-разрядные и 64-разрядные платформы. По этим причинам не следует использовать реализацию этого метода по умолчанию в качестве уникального идентификатора объекта для хэширования. Ниже приведено два последствия.  
  
-   Не следует рассчитывать, что равные хэш-коды подразумевают равенство объектов.  
  
-   Никогда не следует сохранять или использовать хэш-код вне домена приложения, в котором он был создан, так как один и тот же объект может быть хэширован между доменами приложений, процессами и платформами.  
  
> [!WARNING]
>  Хэш-код предназначен для эффективной вставки и уточняющего запроса в коллекциях, основанных на хэш-таблице. Хэш-код не является постоянным значением. По этой причине:  
>   
> -   Не сериализуются значения хэш-кода или не сохраняйте их в базах данных.  
> -   Не используйте хэш-код в качестве ключа для получения объекта из коллекции с ключом.  
> -   Не отправляйте хэш-коды между доменами приложений или процессами. В некоторых случаях хэш-коды могут быть вычислены отдельно для каждого процесса или домена приложения.  
> -   Не используйте хэш-код вместо значения, возвращаемого криптографической функцией хэширования, если требуется криптографически надежный хэш. Для криптографических хэшей используйте класс, производный от класса <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> или <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>.  
> -   Не проверяйте равенство хэш-кодов, чтобы определить, равны ли два объекта. (Неравные объекты могут иметь идентичные хэш-коды.) Чтобы проверить на равенство, вызовите метод <xref:System.Object.ReferenceEquals%2A> или <xref:System.Object.Equals%2A>.  
  
 Метод <xref:System.Object.GetHashCode%2A> может быть переопределен производным типом. Если <xref:System.Object.GetHashCode%2A> не переопределяется, хэш-коды для ссылочных типов вычисляются путем вызова метода <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> базового класса, который выполняет вычисление хэш-кода на основе ссылки на объект; Дополнительные сведения см. в разделе <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. Иными словами, два объекта, для которых метод <xref:System.Object.ReferenceEquals%2A> возвращает `true`, имеют одинаковые хэш-коды. Если типы значений не переопределяют <xref:System.Object.GetHashCode%2A>, метод <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> базового класса использует отражение для вычисления хэш-кода на основе значений полей типа. Иными словами, типы значений, поля которых имеют одинаковые значения, имеют одинаковые хэш-коды. Дополнительные сведения о переопределении <xref:System.Object.GetHashCode%2A>см. в разделе "Примечания к наследникам".  
  
> [!WARNING]
>  При переопределении метода <xref:System.Object.GetHashCode%2A> следует также переопределить <xref:System.Object.Equals%2A>и наоборот. Если переопределенный метод <xref:System.Object.Equals%2A> возвращает `true` при проверке на равенство двух объектов, переопределенный метод <xref:System.Object.GetHashCode%2A> должен возвращать одно и то же значение для двух объектов.  
  
 Если объект, используемый в качестве ключа в хэш-таблице, не предоставляет полезной реализации <xref:System.Object.GetHashCode%2A>, можно указать поставщик хэш-кода, предоставив реализацию <xref:System.Collections.IEqualityComparer> одной из перегрузок конструктора <xref:System.Collections.Hashtable> класса.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Примечания для [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 При вызове метода <xref:System.Object.GetHashCode%2A> для класса в [!INCLUDE[wrt](~/includes/wrt-md.md)]он предоставляет поведение по умолчанию для классов, которые не переопределяют <xref:System.Object.GetHashCode%2A>. Это является частью поддержки, предоставляемой .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. раздел [поддержка .NET Framework для приложений Магазина Windows и среда выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] не наследуют <xref:System.Object>и в настоящее время не реализуют <xref:System.Object.GetHashCode%2A>. Однако они имеют методы <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>и <xref:System.Object.GetHashCode%2A>, когда они используются в коде C# или Visual Basic, а .NET Framework предоставляет поведение по умолчанию для этих методов.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] классы, написанные на C# или Visual Basic, могут переопределять метод <xref:System.Object.GetHashCode%2A>.  
  
   
  
## Examples  
 Один из самых простых способов вычисления хэш-кода для числового значения, имеющего тот же или меньший диапазон, чем тип <xref:System.Int32>, просто возвращает это значение. В следующем примере показана такая реализация для структуры `Number`.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Часто тип имеет несколько полей данных, которые могут участвовать в формировании хэш-кода. Один из способов создания хэш-кода заключается в объединении этих полей с помощью операции `XOR (eXclusive OR)`, как показано в следующем примере.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 Предыдущий пример возвращает один и тот же хэш-код для (N1, N2) и (N2, N1), и поэтому может создавать больше конфликтов, чем желательно. Доступно несколько решений, чтобы хэш-коды в этих случаях не совпадали. Один из них — возврат хэш-кода объекта `Tuple`, который отражает порядок каждого поля. В следующем примере показана возможная реализация, использующая класс <xref:System.Tuple%602>. Однако обратите внимание, что затраты на производительность при создании экземпляра объекта `Tuple` могут существенно повлиять на общую производительность приложения, в котором хранятся большие числа объектов в хэш-таблицах.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Второе альтернативное решение включает в себя весовые значения для отдельных хэш-кодов, сдвигяя хэш-коды последовательных полей двумя или более битами. В отличие от отклонения, биты, сдвинутые за пределы 31 бита, должны быть заключены в оболочку, а не удаляться. Поскольку биты отбрасываются операторами сдвига влево как в, так C# и в Visual Basic, для этого требуется создать метод сдвига влево, как в следующем примере:  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 В следующем примере используется этот метод сдвига и переноса для вычисления хэш-кода структуры `Point`, используемой в предыдущих примерах.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Хэш-функция используется для быстрого создания числа (хэш-кода), соответствующего значению объекта. Хэш-функции обычно относятся к каждому типу, и для уникальности в качестве входных данных должно использоваться хотя бы одно из полей экземпляра. Хэш-коды не должны вычисляться с помощью значений статических полей.  
  
Для классов, производных от <see cref="T:System.Object" />, метод <see langword="GetHashCode" /> может делегировать базовому классу <see cref="M:System.Object.GetHashCode" /> реализацию только в том случае, если производный класс определяет равенство на равенство ссылок. Реализация <see cref="M:System.Object.GetHashCode" /> по умолчанию для ссылочных типов возвращает хэш-код, эквивалентный тому, который возвращается методом <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />. Можно переопределить <see cref="M:System.Object.GetHashCode" /> для неизменяемых ссылочных типов. Как правило, для изменяемых ссылочных типов следует переопределить <see cref="M:System.Object.GetHashCode" /> только в том случае, если: 
— Хэш-код можно вычислить из полей, которые не являются изменяемыми. ни 
— Можно гарантировать, что хэш-код изменяемого объекта не изменится, пока объект содержится в коллекции, зависящей от его хэш-кода.  
  
В противном случае может показаться, что изменяемый объект будет потерян в хэш-таблице. Если вы решите переопределить <see cref="M:System.Object.GetHashCode" /> для изменяемого ссылочного типа, в документации должен быть ясно, что пользователи вашего типа не должны изменять значения объектов, пока объект хранится в хэш-таблице.  
  
Для типов значений <see cref="M:System.ValueType.GetHashCode" /> предоставляет реализацию хэш-кода по умолчанию, использующую отражение. Рекомендуется переопределять его для повышения производительности.  
  
 <block subset="none" type="note"><para>  
 Дополнительные сведения и примеры, которые вычисляют хэш-коды различными способами, см. в разделе "примеры".  
  
</para></block>  
  
 Хэш-функция должна иметь следующие свойства: 
— Если два объекта сравнивают как равные, то метод <see cref="M:System.Object.GetHashCode" /> для каждого объекта должен возвращать одно и то же значение. Однако если два объекта не считаются равными, то методы <see cref="M:System.Object.GetHashCode" /> для этих двух объектов не должны возвращать разные значения.  
  
— Метод <see cref="M:System.Object.GetHashCode" /> для объекта должен постоянно возвращать тот же хэш-код, если в состоянии объекта нет изменений, определяющих возвращаемое значение метода [System. Object. Equals](xref:System.Object.Equals*) объекта. Обратите внимание, что это справедливо только для текущего выполнения приложения. при повторном запуске приложения может возвращаться другой хэш-код.  
  
Для лучшей производительности хэш-функция должна создать равномерное распределение для всех входных данных, включая входные данные, которые сильно кластеризованы. Следствием является то, что небольшие изменения в состоянии объекта должны привести к значительным изменениям в результирующем хэш-коде для лучшей производительности хэш-таблицы.  
  
-Функции хэширования должны быть недорогими для вычислений.  
  
— Метод <see cref="M:System.Object.GetHashCode" /> не должен вызывать исключения.  
  
Например, реализация метода <see cref="M:System.String.GetHashCode" />, предоставляемого классом <see cref="T:System.String" />, возвращает идентичные хэш-коды для одинаковых строковых значений. Поэтому два объекта <see cref="T:System.String" /> возвращают один и тот же хэш-код, если они представляют одно и то же строковое значение. Кроме того, метод использует все символы в строке для создания разумного случайного распределения выходных данных, даже если входные данные кластеризованы в определенные диапазоны (например, многие пользователи могут иметь строки, содержащие только младшие символы ASCII 128, хотя Строка может содержать любой из 65 535 символов Юникода).  
  
Предоставление хорошей хэш-функции для класса может значительно повлиять на производительность при добавлении этих объектов в хэш-таблицу. В хэш-таблице с ключами, обеспечивающими хорошую реализацию хэш-функции, поиск элемента занимает постоянное время (например, операция O (1)). В хэш-таблице с плохой реализацией хэш-функции производительность поиска зависит от числа элементов в хэш-таблице (например, операции O (`n`), где `n` — число элементов в хэш-таблице). Пользователь-злоумышленник может вводить данные, увеличивающие количество конфликтов, что может значительно снизить производительность приложений, зависящих от хэш-таблиц, при следующих условиях. 
— Когда хэш-функции вызывают частые конфликты.  
  
— Когда большая часть объектов в хэш-таблице создает хэш-коды, которые равны или приблизительно равны друг другу.  
  
— При вводе пользователями данных, из которых вычисляются хэш-код.  
  
Производные классы, переопределяющие <see cref="M:System.Object.GetHashCode" />, должны также переопределять <see cref="M:System.Object.Equals(System.Object)" />, чтобы гарантировать, что два объекта считаются равными и имеют одинаковый хэш-код. в противном случае тип <see cref="T:System.Collections.Hashtable" /> может работать неправильно.</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" /> для текущего экземпляра.</summary>
        <returns>Точный тип текущего экземпляра в среде выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поскольку <xref:System.Object?displayProperty=nameWithType> является базовым классом для всех типов в системе типов .NET, метод <xref:System.Object.GetType%2A> можно использовать для возврата <xref:System.Type> объектов, представляющих все типы .NET. .NET распознает следующие пять категорий типов:  
  
-   Классы, которые являются производными от <xref:System.Object?displayProperty=nameWithType>,  
  
-   Типы значений, которые являются производными от <xref:System.ValueType?displayProperty=nameWithType>.  
  
-   Интерфейсы, которые являются производными от <xref:System.Object?displayProperty=nameWithType>, начиная с .NET Framework 2,0.  
  
-   Перечисления, которые являются производными от <xref:System.Enum?displayProperty=nameWithType>.  
  
-   Делегаты, которые являются производными от <xref:System.MulticastDelegate?displayProperty=nameWithType>.  
  
 Для двух объектов `x` и `y`, имеющих идентичные типы среды выполнения, `Object.ReferenceEquals(x.GetType(),y.GetType())` возвращает `true`. В следующем примере используется метод <xref:System.Object.GetType%2A> с методом <xref:System.Object.ReferenceEquals%2A>, чтобы определить, является ли одно числовое значение тем же типом, что и два других числовых значения.  
  
 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 [!code-csharp-interactive[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Чтобы определить, является ли объект конкретным типом, можно использовать ключевое слово или конструкцию для сравнения типов языка. Например, можно использовать конструкцию `TypeOf…Is` в Visual Basic или ключевое слово `is` в C#.  
  
 Метод <xref:System.Object.GetType%2A> наследуется всеми типами, производными от <xref:System.Object>. Это означает, что в дополнение к использованию ключевого слова сравнения собственного языка можно использовать метод <xref:System.Object.GetType%2A> для определения типа конкретного объекта, как показано в следующем примере.  
  
 [!code-csharp-interactive[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 Объект <xref:System.Type> предоставляет метаданные, связанные с классом текущего <xref:System.Object>.  
  
   
  
## Examples  

 В следующем примере кода показано, что <xref:System.Object.GetType%2A> Возвращает тип текущего экземпляра среды выполнения.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает неполную копию текущего объекта <see cref="T:System.Object" />.</summary>
        <returns>Неполная копия объекта <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Object.MemberwiseClone%2A> создает неполную копию путем создания нового объекта, а затем копирует нестатические поля текущего объекта в новый объект. Если поле является типом значения, выполняется побитовая копия поля. Если поле является ссылочным типом, то ссылка копируется, но на объект, на который указывает ссылка, нет; Таким образом, исходный объект и его клон ссылаются на один и тот же объект.  
  
 Например, рассмотрим объект с именем X, который ссылается на объекты A и B. объект B, в свою очередь, ссылается на объект C. Поверхностная копия X создает новый объект x2, который также ссылается на объекты A и B. В отличие от этого, при глубоком копировании X создается новый объект x2, который ссылается на новые объекты a2 и B2, которые являются копиями A и B. B2, в свою очередь, ссылается на новый объект C2, который является копией C. В примере показана разница между неполной и глубокой операцией копирования.  
  
 Существует множество способов реализации операции глубокого копирования, если неполная операция копирования, выполняемая методом <xref:System.Object.MemberwiseClone%2A>, не соответствует вашим потребностям. В число этих требований входят следующие:  
  
-   Вызовите конструктор класса копируемого объекта, чтобы создать второй объект со значениями свойств, взятыми из первого объекта. Предполагается, что значения объекта полностью определяются его конструктором класса.  
  
-   Вызовите метод <xref:System.Object.MemberwiseClone%2A>, чтобы создать неполную копию объекта, а затем назначьте новые объекты, значения которых совпадают с исходным объектом, с любыми свойствами или полями, значения которых являются ссылочными типами. Метод `DeepCopy` в примере иллюстрирует этот подход.  
  
-   Выполните сериализацию объекта для глубокого копирования, а затем восстановите сериализованные данные в другую объектную переменную.  
  
-   Используйте отражение с рекурсией для выполнения операции глубокого копирования.  
  
   
  
## Examples  
 В следующем примере показан метод <xref:System.Object.MemberwiseClone%2A>. Он определяет `ShallowCopy` метод, который вызывает метод <xref:System.Object.MemberwiseClone%2A> для выполнения неполной операции копирования объекта `Person`. Он также определяет метод `DeepCopy`, выполняющий операцию глубокого копирования объекта `Person`.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 В этом примере свойство `Person.IdInfo` возвращает объект `IdInfo`. Как видно из выходных данных в примере, когда объект `Person` клонируется путем вызова метода <xref:System.Object.MemberwiseClone%2A>, клонированный `Person` объект является независимой копией исходного объекта, за исключением того, что они совместно используют одну и ту же ссылку на объект `Person.IdInfo`. В результате изменение свойства `Person.IdInfo` клона изменяет свойство `Person.IdInfo` исходного объекта. С другой стороны, при выполнении операции глубокого копирования клонированный `Person` объект, включая его свойство `Person.IdInfo`, можно изменить, не влияя на исходный объект.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Первый из сравниваемых объектов.</param>
        <param name="objB">Второй из сравниваемых объектов.</param>
        <summary>Определяет, совпадают ли указанные экземпляры <see cref="T:System.Object" />.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="objA" /> соответствует тому же экземпляру, что и параметр <paramref name="objB" />, или же оба они имеют значение **NULL**; в противном случае значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от метода <xref:System.Object.Equals%2A> и оператора равенства, метод <xref:System.Object.ReferenceEquals%2A> не может быть переопределен. Поэтому, если нужно проверить две ссылки на объекты на равенство и вы не уверены в реализации метода `Equals`, можно вызвать метод <xref:System.Object.ReferenceEquals%2A>.  
  
 Однако возвращаемое значение метода <xref:System.Object.ReferenceEquals%2A> может показаться аномальным в этих двух сценариях:  
  
-   При сравнении типов значений. Если `objA` и `objB` являются типами значений, они упаковываются перед передачей в метод <xref:System.Object.ReferenceEquals%2A>. Это означает, что если оба `objA` и `objB` представляют один и тот же экземпляр типа значения, метод <xref:System.Object.ReferenceEquals%2A>, тем не менее, возвратит `false`, как показано в следующем примере.  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Дополнительные сведения о типах значений упаковки см. в разделе [Упаковка и](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)распаковка.  
  
-   При сравнении строк. Если `objA` и `objB` являются строками, метод <xref:System.Object.ReferenceEquals%2A> возвращает `true`, если строка интернирована. Он не выполняет проверку на равенство значений.  В следующем примере `s1` и `s2` равны, так как они являются двумя экземплярами одной интернированной строки. Однако `s3` и `s4` не равны, так как несмотря на то, что они имеют одинаковые строковые значения, эта строка не интернирована.  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Дополнительные сведения об интернировании строк см. в разделе <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

 В следующем примере <xref:System.Object.ReferenceEquals%2A> используется для определения того, являются ли два объекта одним и тем же экземпляром.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp-interactive[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строку, представляющую текущий объект.</summary>
        <returns>Строка, представляющая текущий объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> является основным методом форматирования в .NET Framework. Он преобразует объект в строковое представление, чтобы его можно было отображать. (Сведения о поддержке форматирования в .NET Framework см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).) Реализации <xref:System.Object.ToString%2A?displayProperty=nameWithType> метода по умолчанию возвращают полное имя типа объекта.  
  
> [!IMPORTANT]
>  Возможно, вы достигли этой страницы, следуя ссылке из списка участников другого типа. Это происходит потому, что этот тип не переопределяет <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Вместо этого он наследует функциональность метода <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
 Типы часто переопределяют метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, чтобы предоставить более подходящее строковое представление определенного типа. Типы также часто перегружают метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, чтобы обеспечить поддержку для строк формата или форматирования с учетом языка и региональных параметров.  

 Содержание  
  
 [Метод Object. ToString () по умолчанию](#Default)   
 [Переопределение метода Object. ToString ()](#Overriding)   
 [Перегрузка метода ToString](#Overloading)   
 [Расширение метода Object. ToString](#Extending)   
 [Примечания для среда выполнения Windows](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>Метод Object. ToString () по умолчанию  
 Реализация метода <xref:System.Object.ToString%2A> по умолчанию возвращает полное имя типа <xref:System.Object>, как показано в следующем примере.  
  
 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp-interactive[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Поскольку <xref:System.Object> является базовым классом всех ссылочных типов в .NET Framework, это поведение наследуется ссылочными типами, которые не переопределяют метод <xref:System.Object.ToString%2A>. Это показано в следующем примере. Он определяет класс с именем `Object1`, который принимает реализацию по умолчанию всех членов <xref:System.Object>. Его <xref:System.Object.ToString%2A> метод возвращает полное имя типа объекта.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Переопределение метода Object. ToString ()  
 Типы обычно переопределяют метод <xref:System.Object.ToString%2A?displayProperty=nameWithType> для возврата строки, представляющей экземпляр объекта. Например, базовые типы, такие как <xref:System.Char>, <xref:System.Int32>и <xref:System.String>, предоставляют <xref:System.Object.ToString%2A> реализации, возвращающие строковое представление значения, представляемого объектом. В следующем примере определяется класс `Object2`, который переопределяет метод <xref:System.Object.ToString%2A>, который возвращает имя типа и его значение.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 В следующей таблице перечислены категории типов в .NET и указано, переопределять ли их метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
|Категория типа|Переопределяет Object. ToString ()|Поведение|  
|-------------------|-----------------------------------|--------------|  
|Класс|Н/Д|Н/Д|  
|structure|Да (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Аналогично `Object.ToString()`|  
|Перечисление|Да (<xref:System.Enum.ToString?displayProperty=nameWithType>)|Имя элемента|  
|Интерфейс|Нет|Н/Д|  
|делегат|Нет|Н/Д|  
  
 Дополнительные сведения о переопределении <xref:System.Object.ToString%2A>см. в разделе Примечания к наследникам.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>Перегрузка метода ToString  
 Помимо переопределения метода <xref:System.Object.ToString?displayProperty=nameWithType> без параметров, многие типы перегружают метод `ToString`, чтобы предоставить версии метода, принимающего параметры. Чаще всего это делается для обеспечения поддержки форматирования переменных и форматирования с учетом языка и региональных параметров.  
  
 В следующем примере перегружается метод `ToString` для возврата результирующей строки, содержащей значения различных полей класса `Automobile`. Он определяет четыре строки формата: G, которая возвращает имя модели и год; D, возвращающее имя модели, год и число дверей; C, возвращающее имя модели, год и число цилиндров; и, который возвращает строку со всеми четырьмя значениями полей.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 В следующем примере вызывается перегруженный метод <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> для просмотра форматирования значения валюты с учетом языка и региональных параметров.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Дополнительные сведения о строках форматирования и форматировании с учетом языка и региональных параметров см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md). Строки формата, поддерживаемые числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Сведения о строках формата, поддерживаемых значениями даты и времени, см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Расширение метода Object. ToString  
 Поскольку тип наследует метод <xref:System.Object.ToString%2A?displayProperty=nameWithType> по умолчанию, его поведение может оказаться нежелательным и его нужно изменить. Это особенно справедливо для массивов и классов коллекций. Хотя в методе `ToString` класса Array или Collection может быть отображено значение его членов, вместо этого отображается полное имя типа, как показано в следующем примере.  
  
 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 [!code-csharp-interactive[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Есть несколько вариантов для создания результирующей строки, которая вам нужна.  
  
-   Если тип является массивом, объектом коллекции или объектом, реализующим интерфейсы <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601>, можно перечислить его элементы с помощью инструкции `foreach` в C# среде или конструкции `For Each...Next` в Visual Basic.  
  
-   Если класс не `sealed` (в C#) или `NotInheritable` (в Visual Basic), можно разработать класс-оболочку, который наследуется от базового класса, для которого нужно настроить <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод. Как минимум, для этого необходимо выполнить следующие действия.  
  
    1.  Реализуйте все необходимые конструкторы. Производные классы не наследуют конструкторы базовых классов.  
  
    2.  Переопределите метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, чтобы возвращалась нужная строка.  
  
     В следующем примере определяется класс-оболочка для класса <xref:System.Collections.Generic.List%601>. Он переопределяет метод <xref:System.Object.ToString%2A?displayProperty=nameWithType> для вывода значения каждого метода коллекции, а не полного имени типа.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Разрабатывайте [метод расширения](~/docs/standard/design-guidelines/extension-methods.md) , который возвращает нужную результирующую строку. Обратите внимание, что метод <xref:System.Object.ToString%2A?displayProperty=nameWithType> по умолчанию нельзя переопределить таким образом (т. е. класс расширения C#(в) или модуль (в Visual Basic) не может иметь метод без параметров с именем `ToString`, который вызывается вместо метода `ToString` исходного типа. Вам потребуется указать другое имя для `ToString` замены без параметров.  
  
     В следующем примере определяются два метода, расширяющие класс <xref:System.Collections.Generic.List%601>: метод `ToString2` без параметров, а также метод `ToString` с параметром <xref:System.String>, который представляет строку формата.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Примечания для [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 При вызове метода <xref:System.Object.ToString%2A> для класса в [!INCLUDE[wrt](~/includes/wrt-md.md)]он предоставляет поведение по умолчанию для классов, которые не переопределяют <xref:System.Object.ToString%2A>. Это является частью поддержки, предоставляемой .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. раздел [поддержка .NET Framework для приложений Магазина Windows и среда выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] не наследуют <xref:System.Object>и не всегда реализуют <xref:System.Object.ToString%2A>. Однако они всегда имеют методы <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>и <xref:System.Object.GetHashCode%2A>, когда они используются в коде C# или Visual Basic, а .NET Framework предоставляет поведение по умолчанию для этих методов.  
  
 Начиная с [!INCLUDE[net_v451](~/includes/net-v451-md.md)], среда CLR будет использовать [IStringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) для объекта [!INCLUDE[wrt](~/includes/wrt-md.md)], прежде чем вернуться к реализации по умолчанию <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] классы, написанные на C# или Visual Basic, могут переопределять метод <xref:System.Object.ToString%2A>.  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] и интерфейс IStringable  
 Начиная с [!INCLUDE[win81](~/includes/win81-md.md)][!INCLUDE[wrt](~/includes/wrt-md.md)] включает интерфейс [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) , единственный метод которого [IStringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)обеспечивает базовую поддержку форматирования, сравнимую с <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Чтобы предотвратить неоднозначность, не следует реализовывать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) для управляемых типов.  
  
 Если управляемые объекты вызываются машинным кодом или кодом, написанным на языках, таких как C++JavaScript или/CX, они выглядят как реализующие [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). Среда CLR автоматически направит вызовы из [IStringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) в <xref:System.Object.ToString%2A?displayProperty=nameWithType> в событии [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) не реализовано в управляемом объекте.  
  
> [!WARNING]
>  Так как среда CLR Auto реализует [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) для всех управляемых типов в [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] приложениях, рекомендуется не предоставлять собственную реализацию [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) . Реализация [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) может привести к непредвиденному поведению при вызове `ToString` из [!INCLUDE[wrt](~/includes/wrt-md.md)]C++,/CX или JavaScript.  
  
 Если вы решили реализовать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) в общедоступном управляемом типе, экспортированном в [!INCLUDE[wrt](~/includes/wrt-md.md)] компоненте, применяются следующие ограничения.  
  
-   Интерфейс [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) можно определить только в связи «класс реализует», например  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     в C# или  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     в Visual Basic.  
  
-   Невозможно реализовать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) в интерфейсе.  
  
-   Нельзя объявить параметр типа [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) не может быть типом возвращаемого значения метода, свойства или поля.  
  
-   Невозможно скрыть реализацию [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) из базовых классов с помощью определения метода, как показано ниже:  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     Вместо этого реализация [IStringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) должна всегда переопределять реализацию базового класса. Реализацию `ToString` можно скрыть только путем вызова этого метода в строго типизированном экземпляре класса.  
  
 Обратите внимание, что при различных условиях вызовы из машинного кода в управляемый тип, реализующий [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) или скрывая его реализацию [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) , могут привести к непредвиденному поведению.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При реализации собственных типов следует переопределить метод <see cref="M:System.Object.ToString" /> для возврата значений, которые являются значимыми для этих типов. Производные классы, которым требуется больший контроль над форматированием, чем <see cref="M:System.Object.ToString" /> предоставляет возможность реализовать интерфейс <see cref="T:System.IFormattable" />. Его метод <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> позволяет определять строки формата, которые управляют форматированием, и использовать объект <see cref="T:System.IFormatProvider" />, который может обеспечить форматирование для определенного языка и региональных параметров.  
  
Переопределения метода <see cref="M:System.Object.ToString" /> должны соответствовать следующим рекомендациям: 
— Возвращаемая строка должна быть понятной и удобочитаемой для людей.  
  
— Возвращаемая строка должна уникальным образом идентифицировать значение экземпляра объекта.  
  
-Возвращаемая строка должна быть максимально короткой, чтобы ее можно было отображать с помощью отладчика.  
  
-Переопределение <see cref="M:System.Object.ToString" /> не должно возвращать <see cref="F:System.String.Empty" /> или строку со значением NULL.  
  
— Переопределение <see cref="M:System.Object.ToString" /> не должно вызывать исключение.  
  
— Если строковое представление экземпляра зависит от языка и региональных параметров или может быть отформатировано несколькими способами, реализуйте интерфейс <see cref="T:System.IFormattable" />.  
  
— Если возвращаемая строка содержит конфиденциальную информацию, необходимо сначала запросить соответствующее разрешение. Если запрос проходит удачно, вы можете вернуть конфиденциальную информацию. в противном случае следует вернуть строку, которая исключается из конфиденциальной информации.  
  
-Переопределение <see cref="M:System.Object.ToString" /> не должно иметь наблюдаемых побочных эффектов, чтобы избежать сложностей при отладке. Например, вызов метода <see cref="M:System.Object.ToString" /> не должен изменять значение полей экземпляра.  
  
— Если тип реализует метод анализа (или <see langword="Parse" /> или <see langword="TryParse" /> метод, конструктор или какой-либо другой статический метод, который создает экземпляр типа из строки), следует убедиться, что строка, возвращаемая методом <see cref="M:System.Object.ToString" />, может быть преобразована в экземпляр объекта.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
