<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e6a978c9ab41e0a864fa39bc466a70175c79ff6f" /><Meta Name="ms.sourcegitcommit" Value="2b0967e04b047f6709322418d97215dfcef6a938" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/20/2019" /><Meta Name="ms.locfileid" Value="74237963" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="4d5a4-101">Поддерживает все классы в иерархии классов .NET и предоставляет низкоуровневые службы для производных классов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-101">Supports all classes in the .NET class hierarchy and provides low-level services to derived classes.</span></span> <span data-ttu-id="4d5a4-102">Является исходным базовым классом для всех классов .NET и корнем иерархии типов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-102">This is the ultimate base class of all .NET classes; it is the root of the type hierarchy.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4d5a4-103">В большинстве языков не требуется объявлять для классов наследование от <xref:System.Object>, так как они наследуют его неявно.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="4d5a4-104">Поскольку все классы в .NET являются производными от <xref:System.Object>, каждый метод, определенный в классе <xref:System.Object>, доступен во всех объектах системы.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-104">Because all classes in .NET are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="4d5a4-105">Производные классы могут переопределять некоторые из этих методов, включая:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="4d5a4-106"><xref:System.Object.Equals%2A> — поддерживает сравнение объектов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="4d5a4-107"><xref:System.Object.Finalize%2A> — выполняет операции очистки до автоматического освобождения объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="4d5a4-108"><xref:System.Object.GetHashCode%2A> — создает число, соответствующее значению объекта для поддержки использования хэш-таблицы.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="4d5a4-109"><xref:System.Object.ToString%2A> создает понятную для человека текстовую строку, описывающую экземпляр класса.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="4d5a4-110">Особенности производительности</span><span class="sxs-lookup"><span data-stu-id="4d5a4-110">Performance Considerations</span></span>  
 <span data-ttu-id="4d5a4-111">При разработке класса, например коллекции, который должен обрабатывать объекты любого типа, вы можете создавать члены класса, принимающие экземпляры класса <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="4d5a4-112">Однако процесс упаковки-преобразования и распаковки-преобразования для типа требует вычислительных затрат.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="4d5a4-113">Если вы знаете, что новый класс будет часто обрабатывать определенные типы значений, для минимизации затрат на упаковку-преобразование можно использовать две тактики.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="4d5a4-114">Создание общего метода, принимающего тип <xref:System.Object>, и набора специализированных перегрузок метода для каждого из типов значений, которые, как предполагается, будут часто обрабатываться классом.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="4d5a4-115">Если существует специализированный метод, который принимает указанный при вызове тип параметра, упаковка-преобразование не выполняется и вызывается специализированный метод.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="4d5a4-116">Если у метода отсутствует аргумент, который соответствует указанному при вызове типу параметра, выполняется упаковка-преобразование параметра и вызывается общий метод.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="4d5a4-117">Использование универсальных шаблонов при разработке метода и его членов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="4d5a4-118">Среда CLR создает закрытый универсальный тип при создании экземпляра класса с указанием аргумента универсального типа.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="4d5a4-119">Универсальный метод принимает аргумент определенного типа, и его можно вызывать без упаковки-преобразования параметра.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="4d5a4-120">Несмотря на то, что иногда бывает необходимо создавать классы общего назначения, которые принимают и возвращают типы <xref:System.Object>, можно повысить производительность, создав также специализированный класс для обработки определенного часто используемого типа.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="4d5a4-121">Например, наличие специализированного класса для задания и получения логических значений позволяет избежать затрат на их упаковку-преобразование и распаковку-преобразование.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4d5a4-122">В следующем примере определяется тип Point, производный от класса <xref:System.Object>, и переопределяются многие виртуальные методы класса <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="4d5a4-123">Кроме того, в примере показано, как вызывать многие из статических методов и методов экземпляра класса <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="4d5a4-124">Открытые статические (<see langword="Shared" /> в Visual Basic) члены этого типа являются потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="4d5a4-125">Для членов экземпляра потокобезопасность не гарантируется.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-125">Instance members are not guaranteed to be thread-safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4d5a4-126">Инициализирует новый экземпляр класса <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4d5a4-127">Этот конструктор вызывается конструкторами в производных классах, но его также можно использовать для непосредственного создания экземпляра класса <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4d5a4-128">Определяет, равны ли два экземпляра объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-128">Determines whether two object instances are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="4d5a4-129">Объект, сравниваемый с текущим объектом.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-129">The object to compare with the current object.</span></span></param>
        <summary><span data-ttu-id="4d5a4-130">Определяет, равен ли указанный объект текущему объекту.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-130">Determines whether the specified object is equal to the current object.</span></span></summary>
        <returns><span data-ttu-id="4d5a4-131">Значение <see langword="true" />, если указанный объект равен текущему объекту; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-131"><see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4d5a4-132">Тип сравнения текущего экземпляра и параметра `obj` зависит от того, является ли текущий экземпляр ссылочным типом или типом значения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  
  
-   <span data-ttu-id="4d5a4-133">Если текущий экземпляр является ссылочным типом, то метод <xref:System.Object.Equals%28System.Object%29> проверяет равенство ссылок, а вызов метода <xref:System.Object.Equals%28System.Object%29> эквивалентен вызову метода <xref:System.Object.ReferenceEquals%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="4d5a4-134">Равенство ссылок означает, что сравниваемые объектные переменные ссылаются на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="4d5a4-135">В следующем примере показан результат такого сравнения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="4d5a4-136">Он определяет класс `Person`, который является ссылочным типом, и вызывает конструктор класса `Person` для создания экземпляров двух новых `Person` объектов, `person1a` и `person2`, имеющих одно и то же значение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="4d5a4-137">Он также назначает `person1a` другой объектной переменной `person1b`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="4d5a4-138">Как видно из выходных данных в примере, `person1a` и `person1b` равны, так как они ссылаются на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="4d5a4-139">Однако `person1a` и `person2` не равны, хотя они имеют одинаковое значение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="4d5a4-140">Если текущий экземпляр является типом значения, то метод <xref:System.Object.Equals%28System.Object%29> проверяет равенство значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="4d5a4-141">Равенство значений означает следующее:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="4d5a4-142">Два объекта имеют один и тот же тип.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-142">The two objects are of the same type.</span></span> <span data-ttu-id="4d5a4-143">Как показано в следующем примере, объект <xref:System.Byte> со значением 12 не равен <xref:System.Int32> объекту со значением 12, поскольку два объекта имеют разные типы времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="4d5a4-144">Значения открытого и закрытого полей двух объектов равны.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="4d5a4-145">В следующем примере проверяется равенство значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-145">The following example tests for value equality.</span></span> <span data-ttu-id="4d5a4-146">Он определяет структуру `Person`, которая является типом значения, и вызывает конструктор `Person` класса для создания экземпляров двух новых `Person` объектов, `person1` и `person2`, имеющих одно и то же значение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="4d5a4-147">Как видно из выходных данных примера, две объектные переменные ссылаются на разные объекты, `person1` и `person2` равны, так как они имеют одинаковое значение для поля Private `personName`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="4d5a4-148">Поскольку класс <xref:System.Object> является базовым классом для всех типов в .NET Framework, метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> предоставляет сравнение на равенство по умолчанию для всех остальных типов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="4d5a4-149">Однако типы часто переопределяют метод <xref:System.Object.Equals%2A> для реализации равенства значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="4d5a4-150">Дополнительные сведения см. в примечаниях для вызывающих объектов и примечаний для разделов наследников.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="4d5a4-151">Примечания для [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="4d5a4-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="4d5a4-152">При вызове перегрузки метода <xref:System.Object.Equals%28System.Object%29> для класса в [!INCLUDE[wrt](~/includes/wrt-md.md)]он предоставляет поведение по умолчанию для классов, которые не переопределяют <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="4d5a4-153">Это является частью поддержки, предоставляемой .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. раздел [поддержка .NET Framework для приложений Магазина Windows и среда выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="4d5a4-154">Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] не наследуют <xref:System.Object>и в настоящее время не реализуют метод <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="4d5a4-155">Однако они имеют методы <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>и <xref:System.Object.GetHashCode%2A>, когда они используются в коде C# или Visual Basic, а .NET Framework предоставляет поведение по умолчанию для этих методов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="4d5a4-156">классы, написанные на C# или Visual Basic, могут переопределять перегрузку метода <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-156">classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="4d5a4-157">Примечания для вызывающих объектов</span><span class="sxs-lookup"><span data-stu-id="4d5a4-157">Notes for Callers</span></span>  
 <span data-ttu-id="4d5a4-158">Производные классы часто переопределяют метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> для реализации равенства значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="4d5a4-159">Кроме того, типы часто предоставляют дополнительную строго типизированную перегрузку методу `Equals`, как правило, путем реализации интерфейса <xref:System.IEquatable%601>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="4d5a4-160">При вызове метода `Equals` для проверки на равенство следует знать, переопределяется ли текущий экземпляр <xref:System.Object.Equals%2A?displayProperty=nameWithType> и понять, как разрешается определенный вызов метода `Equals`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="4d5a4-161">В противном случае вы можете выполнить проверку на равенство, отличное от предполагаемого, и метод может вернуть непредвиденное значение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="4d5a4-162">Ниже приведен пример.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-162">The following example provides an illustration.</span></span> <span data-ttu-id="4d5a4-163">Он создает три объекта <xref:System.Text.StringBuilder> с одинаковыми строками, а затем выполняет четыре вызова методов `Equals`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="4d5a4-164">Первый вызов метода возвращает `true`, а оставшиеся три возвращаемые `false`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="4d5a4-165">В первом случае вызывается строго типизированная перегрузка метода <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>, которая проверяет равенство значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="4d5a4-166">Поскольку строки, назначенные двум <xref:System.Text.StringBuilder>ным объектам, равны, метод возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="4d5a4-167">Однако <xref:System.Text.StringBuilder> не переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4d5a4-168">В связи с этим, когда объект <xref:System.Text.StringBuilder> приводится к <xref:System.Object>, когда экземпляр <xref:System.Text.StringBuilder> присваивается переменной типа <xref:System.Object>и когда метод <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> передается двумя <xref:System.Text.StringBuilder>ными объектами. , вызывается метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="4d5a4-169">Поскольку <xref:System.Text.StringBuilder> является ссылочным типом, это эквивалентно передаче двух <xref:System.Text.StringBuilder> объектов в метод <xref:System.Object.ReferenceEquals%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="4d5a4-170">Хотя все три <xref:System.Text.StringBuilder> объектов содержат одинаковые строки, они ссылаются на три различных объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="4d5a4-171">В результате эти три вызова метода возвращают `false`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="4d5a4-172">Можно сравнить текущий объект с другим объектом для равенства ссылок, вызвав метод <xref:System.Object.ReferenceEquals%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="4d5a4-173">В Visual Basic также можно использовать ключевое слово `is` (например, `If Me Is otherObject Then ...`).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="4d5a4-174">Примечания для наследников</span><span class="sxs-lookup"><span data-stu-id="4d5a4-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="4d5a4-175">При определении собственного типа этот тип наследует функциональность, определенную методом `Equals` его базового типа.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="4d5a4-176">В следующей таблице приведена реализация метода `Equals` по умолчанию для основных категорий типов в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="4d5a4-177">Категория типа</span><span class="sxs-lookup"><span data-stu-id="4d5a4-177">Type category</span></span>|<span data-ttu-id="4d5a4-178">Равенство, определенное</span><span class="sxs-lookup"><span data-stu-id="4d5a4-178">Equality defined by</span></span>|<span data-ttu-id="4d5a4-179">Comments</span><span class="sxs-lookup"><span data-stu-id="4d5a4-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="4d5a4-180">Класс, производный непосредственно от <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="4d5a4-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="4d5a4-181">Равенство ссылок; эквивалентно вызову <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="4d5a4-182">Структура</span><span class="sxs-lookup"><span data-stu-id="4d5a4-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="4d5a4-183">Равенство значений; прямое побайтовое сравнение или Сравнение полей по полям с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="4d5a4-184">Перечисление</span><span class="sxs-lookup"><span data-stu-id="4d5a4-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="4d5a4-185">Значения должны иметь одинаковый тип перечисления и одно и то же базовое значение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="4d5a4-186">Делегат</span><span class="sxs-lookup"><span data-stu-id="4d5a4-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="4d5a4-187">Делегаты должны иметь одинаковый тип с одинаковыми списками вызовов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="4d5a4-188">Интерфейс</span><span class="sxs-lookup"><span data-stu-id="4d5a4-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="4d5a4-189">Равенство ссылок.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="4d5a4-190">Для типа значения следует всегда переопределять <xref:System.Object.Equals%2A>, так как тесты на равенство, основанные на отражении, имеют низкую производительность.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="4d5a4-191">Можно также переопределить реализацию <xref:System.Object.Equals%2A> по умолчанию для ссылочных типов, чтобы проверить равенство значений, а не равенство ссылок и определить точное значение равенства значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="4d5a4-192">Такие реализации <xref:System.Object.Equals%2A> возвращают `true`, если два объекта имеют одинаковое значение, даже если они не являются одним и тем же экземпляром.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="4d5a4-193">Разработчик типа принимает решение, что составляет значение объекта, но обычно это некоторые или все данные, хранящиеся в переменных экземпляра объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="4d5a4-194">Например, значение объекта <xref:System.String> основано на символах строки; метод <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> переопределяет метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, который возвращает `true` для всех экземпляров строк, содержащих одни и те же символы в том же порядке.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="4d5a4-195">В следующем примере показано, как переопределить метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> для проверки на равенство значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="4d5a4-196">Он переопределяет метод <xref:System.Object.Equals%2A> для класса `Person`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="4d5a4-197">Если `Person` принял свою реализацию равенства базового класса, два объекта `Person` будут равны, только если они ссылались на один объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="4d5a4-198">Однако в этом случае два объекта `Person` равны, если они имеют одинаковое значение для свойства `Person.Id`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="4d5a4-199">Помимо переопределения <xref:System.Object.Equals%2A>можно реализовать интерфейс <xref:System.IEquatable%601>, чтобы обеспечить строго типизированный тест на равенство.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="4d5a4-200">Следующие инструкции должны быть истинными для всех реализаций метода <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="4d5a4-201">В списке `x`, `y`и `z` представляют ссылки на объекты, которые не равны **null**.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="4d5a4-202">`x.Equals(x)` возвращает `true`, за исключением случаев, в которых задействованы типы с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="4d5a4-203">См. статью [ISO/IEC/IEEE 60559:2011, информационные технологии — системы микропроцессора — арифметические операции с плавающей запятой](https://www.iso.org/standard/57469.html).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-203">See [ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic](https://www.iso.org/standard/57469.html).</span></span>  
  
-   <span data-ttu-id="4d5a4-204">`x.Equals(y)` возвращает то же значение, что и `y.Equals(x)`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="4d5a4-205">`x.Equals(y)` возвращает `true`, если `NaN`и `x`, и `y`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="4d5a4-206">Если `(x.Equals(y) && y.Equals(z))` возвращает `true`, `x.Equals(z)` возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="4d5a4-207">Последовательные вызовы `x.Equals(y)` возвращают одно и то же значение, если объекты, на которые ссылаются `x` и `y`, не изменяются.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="4d5a4-208">`x.Equals(null)` возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="4d5a4-209">Реализации <xref:System.Object.Equals%2A> не должны вызывать исключения. они всегда должны возвращать значение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="4d5a4-210">Например, если `obj` `null`, метод <xref:System.Object.Equals%2A> должен возвращать `false` вместо создания <xref:System.ArgumentNullException>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="4d5a4-211">При переопределении <xref:System.Object.Equals%28System.Object%29>следуйте приведенным ниже рекомендациям.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="4d5a4-212">Типы, реализующие <xref:System.IComparable>, должны переопределять <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="4d5a4-213">Типы, переопределяющие <xref:System.Object.Equals%28System.Object%29>, также должны переопределять <xref:System.Object.GetHashCode%2A>; в противном случае хэш-таблицы могут работать неправильно.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="4d5a4-214">Рекомендуется реализовать интерфейс <xref:System.IEquatable%601> для поддержки строго типизированных тестов на равенство.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="4d5a4-215">Реализация <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> должна возвращать результаты, которые соответствуют <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="4d5a4-216">Если ваш язык программирования поддерживает перегрузку операторов и вы передаете оператор равенства для заданного типа, необходимо также переопределить <xref:System.Object.Equals%28System.Object%29> метод, чтобы он возвращал тот же результат, что и оператор равенства.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="4d5a4-217">Это позволяет гарантировать, что код библиотеки классов, использующий <xref:System.Object.Equals%2A> (например, <xref:System.Collections.ArrayList> и <xref:System.Collections.Hashtable>) ведет себя таким образом, который соответствует способу, который код приложения использует оператор равенства.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="4d5a4-218">Рекомендации по ссылочным типам</span><span class="sxs-lookup"><span data-stu-id="4d5a4-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="4d5a4-219">Следующие рекомендации применяются для переопределения <xref:System.Object.Equals%28System.Object%29> для ссылочного типа:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="4d5a4-220">Рассмотрите возможность переопределения <xref:System.Object.Equals%2A> Если семантика типа основана на том, что тип представляет некоторые значения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="4d5a4-221">Большинство ссылочных типов не должны перегружать оператор равенства, даже если они переопределяют <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="4d5a4-222">Однако при реализации ссылочного типа, который должен иметь семантику значений, например тип комплексного числа, необходимо переопределить оператор равенства.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="4d5a4-223">Не следует переопределять <xref:System.Object.Equals%2A> для изменяемого ссылочного типа.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="4d5a4-224">Это обусловлено тем, что переопределение <xref:System.Object.Equals%2A> требует также переопределения метода <xref:System.Object.GetHashCode%2A>, как описано в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="4d5a4-225">Это означает, что хэш-код экземпляра изменяемого ссылочного типа может измениться в течение своего времени существования, что может привести к потере объекта в хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="4d5a4-226">Рекомендации по типам значений</span><span class="sxs-lookup"><span data-stu-id="4d5a4-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="4d5a4-227">Следующие рекомендации применяются для переопределения <xref:System.Object.Equals%28System.Object%29> для типа значения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="4d5a4-228">При определении типа значения, включающего одно или несколько полей, значения которых являются ссылочными типами, следует переопределить <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="4d5a4-229">Реализация <xref:System.Object.Equals%28System.Object%29>, предоставляемая <xref:System.ValueType>, выполняет побайтовое сравнение для типов значений, поля которых являются типами значений, но использует отражение для выполнения сравнения по полям значений, поля которых включают ссылочные типы.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="4d5a4-230">Если переопределение <xref:System.Object.Equals%2A> и язык разработки поддерживает перегрузку операторов, необходимо перегрузить оператор равенства.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="4d5a4-231">Необходимо реализовать интерфейс <xref:System.IEquatable%601>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="4d5a4-232">Вызов строго типизированного <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> метода позволяет избежать упаковки-преобразования аргумента `obj`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4d5a4-233">В следующем примере показан класс `Point`, который переопределяет метод <xref:System.Object.Equals%2A>, чтобы обеспечить равенство значений, и класс `Point3D`, производный от `Point`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="4d5a4-234">Поскольку `Point` переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> для проверки равенства значений, метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="4d5a4-235">Однако `Point3D.Equals` вызывает `Point.Equals`, так как `Point` реализует <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> способом, обеспечивающим равенство значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="4d5a4-236">Метод `Point.Equals` проверяет, что аргумент `obj` не равен **null** и ссылается на экземпляр того же типа, что и этот объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="4d5a4-237">Если проверка завершается ошибкой, метод возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="4d5a4-238">Метод `Point.Equals` вызывает метод <xref:System.Object.GetType%2A>, чтобы определить, идентичны ли типы времени выполнения двух объектов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="4d5a4-239">Если метод использовал проверку формы `obj is Point` в C# или `TryCast(obj, Point)` в Visual Basic, проверка вернет `true` в случаях, когда `obj` является экземпляром производного класса `Point`, хотя `obj` и текущий экземпляр не того же типа времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="4d5a4-240">Убедившись, что оба объекта имеют одинаковый тип, метод приводит `obj` к типу `Point` и возвращает результат сравнения полей экземпляров двух объектов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="4d5a4-241">В `Point3D.Equals`унаследованный метод `Point.Equals`, который переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, вызывается до того, как все еще выполняется.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="4d5a4-242">Поскольку `Point3D` является запечатанным классом (`NotInheritable` в Visual Basic), проверка формы `obj is Point` в C# или `TryCast(obj, Point)` в Visual Basic является достаточной, чтобы гарантировать, что `obj` является объектом `Point3D`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="4d5a4-243">Если это объект `Point3D`, он приводится к `Point` объекту и передается в реализацию базового класса <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="4d5a4-244">Только когда наследуемый метод `Point.Equals` возвращает `true` метод сравнивает поля `z` экземпляра, представленные в производном классе.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="4d5a4-245">В следующем примере определяется класс `Rectangle`, который внутренне реализует прямоугольник как два объекта `Point`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="4d5a4-246">Класс `Rectangle` также переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, чтобы обеспечить равенство значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="4d5a4-247">Некоторые языки, такие C# как и Visual Basic, поддерживают перегрузку операторов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="4d5a4-248">Если тип перегружает оператор равенства, он также должен переопределять метод <xref:System.Object.Equals%28System.Object%29>, чтобы обеспечить ту же функциональность.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="4d5a4-249">Обычно это достигается путем написания метода <xref:System.Object.Equals%28System.Object%29> в терминах перегруженного оператора равенства, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="4d5a4-250">Поскольку `Complex` является типом значения, он не может быть производным от.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="4d5a4-251">Поэтому методу override для <xref:System.Object.Equals%28System.Object%29> не требуется вызывать <xref:System.Object.GetType%2A>, чтобы определить точный тип времени выполнения каждого объекта, но вместо этого можно использовать оператор `is` в C# или оператор `TypeOf` в Visual Basic, чтобы проверить тип параметра `obj`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="4d5a4-252">Первый сравниваемый объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-252">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="4d5a4-253">Второй сравниваемый объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-253">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="4d5a4-254">Определяет, считаются ли равными указанные экземпляры объектов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-254">Determines whether the specified object instances are considered equal.</span></span></summary>
        <returns><span data-ttu-id="4d5a4-255"><see langword="true" />, если указанные объекты равны; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-255"><see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4d5a4-256">Если оба параметра <paramref name="objA" /> и <paramref name="objB" /> имеют значение **NULL**, метод возвращает значение <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4d5a4-257">Статический метод <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> указывает, равны ли два объекта, `objA` и `objB`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="4d5a4-258">Он также позволяет тестировать объекты, значение которых равно **null** , для проверки на равенство.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="4d5a4-259">Он сравнивает `objA` и `objB` на равенство следующим образом:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="4d5a4-260">Он определяет, представляют ли два объекта одну и ту же ссылку на объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="4d5a4-261">В противном случае метод возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="4d5a4-262">Этот тест эквивалентен вызову метода <xref:System.Object.ReferenceEquals%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="4d5a4-263">Кроме того, если оба `objA` и `objB` имеют **значение NULL**, метод возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="4d5a4-264">Он определяет, имеет ли `objA` или `objB` **значение NULL**.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="4d5a4-265">Если да, то возвращается `false`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="4d5a4-266">Если два объекта не представляют одну и ту же ссылку на объект и ни один из них не имеет **значения NULL**, то вызывается `objA`.`Equals`(`objB`) и возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="4d5a4-267">Это означает, что если `objA` переопределяет метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, вызывается это переопределение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4d5a4-268">В следующем примере показан метод <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> и сравнивается с методом <xref:System.Object.ReferenceEquals%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Finalize() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4d5a4-269">Позволяет объекту попытаться освободить ресурсы и выполнить другие операции очистки, перед тем как он будет уничтожен во время сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4d5a4-270">Метод <xref:System.Object.Finalize%2A> используется для выполнения операций очистки неуправляемых ресурсов, хранящихся в текущем объекте, до уничтожения объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="4d5a4-271">Этот метод защищен и поэтому доступен только через этот класс или производный класс.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="4d5a4-272">Содержание</span><span class="sxs-lookup"><span data-stu-id="4d5a4-272">In this section:</span></span>  
  
-   [<span data-ttu-id="4d5a4-273">Принцип работы финализации</span><span class="sxs-lookup"><span data-stu-id="4d5a4-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="4d5a4-274">Примечания для разработчиков</span><span class="sxs-lookup"><span data-stu-id="4d5a4-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="4d5a4-275">Альтернатива SafeHandle</span><span class="sxs-lookup"><span data-stu-id="4d5a4-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="4d5a4-276">Принцип работы финализации</span><span class="sxs-lookup"><span data-stu-id="4d5a4-276">How finalization works</span></span>  
 <span data-ttu-id="4d5a4-277">Класс <xref:System.Object> не предоставляет реализации метода <xref:System.Object.Finalize%2A>, а сборщик мусора не помечает типы, производные от <xref:System.Object>, для финализации, если только они не переопределят метод <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="4d5a4-278">Если тип переопределяет метод <xref:System.Object.Finalize%2A>, сборщик мусора добавляет запись для каждого экземпляра типа во внутреннюю структуру, называемую очередью финализации.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="4d5a4-279">Очередь финализации содержит записи для всех объектов в управляемой куче, код завершения которых должен быть выполнен до освобождения памяти сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="4d5a4-280">Сборщик мусора затем вызывает метод <xref:System.Object.Finalize%2A> автоматически при выполнении следующих условий:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="4d5a4-281">После того как сборщик мусора обнаружит, что объект недоступен, за исключением случаев, когда объект был исключен из финализации путем вызова метода <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="4d5a4-282">**Только в .NET Framework**, во время завершения работы домена приложения, если только объект не исключен из финализации.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-282">**On .NET Framework only**, during shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="4d5a4-283">Во время завершения работы, даже объекты, которые по-прежнему доступны, завершаются.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="4d5a4-284"><xref:System.Object.Finalize%2A> автоматически вызывается только один раз для данного экземпляра, если только объект не будет повторно зарегистрирован с помощью механизма, такого как <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType>, а метод <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> не вызывался впоследствии.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="4d5a4-285"><xref:System.Object.Finalize%2A> операции имеют следующие ограничения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="4d5a4-286">Точное время выполнения метода завершения не определено.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="4d5a4-287">Чтобы обеспечить детерминированный выпуск ресурсов для экземпляров класса, реализуйте `Close` метод или предоставьте реализацию <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="4d5a4-288">Методы завершения двух объектов не гарантированно выполняются в каком бы то ни было определенном порядке, даже если один объект ссылается на другой.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="4d5a4-289">То есть если объект A имеет ссылку на объект B и оба метода имеют методы завершения, то объект B может быть уже завершен при запуске метода завершения объекта A.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="4d5a4-290">Поток, в котором выполняется метод завершения, не определен.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="4d5a4-291">Метод <xref:System.Object.Finalize%2A> может не выполняться до завершения или может не выполняться вообще при следующих исключительных обстоятельствах:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="4d5a4-292">Если другой метод завершения блокируется неограниченно (переходит в бесконечный цикл, пытается получить блокировку, которую он никогда не может получить и т. д.).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="4d5a4-293">Поскольку среда выполнения пытается выполнить методы завершения до завершения, другие методы завершения могут не вызываться, если метод завершения блокирует неограниченное время.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="4d5a4-294">Значение, если процесс завершается без предоставления среде выполнения возможности очистки.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="4d5a4-295">В этом случае первое уведомление среды выполнения о завершении процесса — это DLL_PROCESS_DETACH уведомление.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="4d5a4-296">Среда выполнения продолжит завершать объекты во время завершения работы только в тот момент, когда число объектов, которые можно завершить, будет уменьшаться.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="4d5a4-297">Если <xref:System.Object.Finalize%2A> или переопределение <xref:System.Object.Finalize%2A> вызывает исключение, а среда выполнения не размещается приложением, переопределяющим политику по умолчанию, среда выполнения прерывает процесс и не выполняет активные `try`/`finally` блоки или методы завершения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="4d5a4-298">Такое поведение обеспечивает целостность процессов, если финализатор не может освободить или уничтожить ресурсы.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="4d5a4-299">Переопределение метода Finalize</span><span class="sxs-lookup"><span data-stu-id="4d5a4-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="4d5a4-300">Необходимо переопределить <xref:System.Object.Finalize%2A> для класса, использующего неуправляемые ресурсы, такие как дескрипторы файлов или подключения к базе данных, которые должны быть освобождены, когда управляемый объект, использующий их, будет удален во время сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="4d5a4-301">Не следует реализовывать метод <xref:System.Object.Finalize%2A> для управляемых объектов, так как сборщик мусора вывысвобождает управляемые ресурсы автоматически.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4d5a4-302">Если доступен объект <xref:System.Runtime.InteropServices.SafeHandle>, который создает оболочку для неуправляемого ресурса, рекомендуемым альтернативом является реализация шаблона удаления с помощью безопасного маркера, а не переопределение <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="4d5a4-303">Дополнительные сведения см. [в разделе альтернатива SafeHandle](#SafeHandle) .</span><span class="sxs-lookup"><span data-stu-id="4d5a4-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="4d5a4-304">По умолчанию метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType> не выполняет никаких действий, но следует переопределять <xref:System.Object.Finalize%2A> только при необходимости и освобождать неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="4d5a4-305">Освобождение памяти обычно занимает намного больше времени, если выполняется операция финализации, так как для нее требуется как минимум две сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="4d5a4-306">Кроме того, следует переопределить метод <xref:System.Object.Finalize%2A> только для ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="4d5a4-307">Среда CLR завершает только ссылочные типы.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="4d5a4-308">Он игнорирует методы завершения для типов значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="4d5a4-309">Областью действия метода <xref:System.Object.Finalize%2A?displayProperty=nameWithType> является `protected`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="4d5a4-310">Эту ограниченную область следует поддерживать при переопределении метода в классе.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="4d5a4-311">Сохраняя защищенный метод <xref:System.Object.Finalize%2A>, пользователи приложения не смогут напрямую вызывать метод <xref:System.Object.Finalize%2A> объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="4d5a4-312">Каждая реализация <xref:System.Object.Finalize%2A> в производном типе должна вызывать реализацию <xref:System.Object.Finalize%2A>его базового типа.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="4d5a4-313">Это единственный случай, когда коду приложения разрешено вызывать <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="4d5a4-314">Метод <xref:System.Object.Finalize%2A> объекта не должен вызывать метод для любых объектов, отличных от базового класса.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="4d5a4-315">Это связано с тем, что другие вызываемые объекты могут собираться одновременно с вызывающим объектом, например в случае завершения работы среды CLR.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="4d5a4-316">C# Компилятор не позволяет переопределить метод <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="4d5a4-317">Вместо этого метод завершения предоставляется путем реализации [деструктора](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) для класса.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="4d5a4-318">C# Деструктор автоматически вызывает деструктор своего базового класса.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="4d5a4-319">Visual C++ также предоставляет собственный синтаксис для реализации метода <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="4d5a4-320">Дополнительные сведения см. в подразделе "деструкторы и методы завершения" раздела [инструкции: определение и использование классов и структурC++(/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="4d5a4-321">Поскольку сборка мусора является недетерминированной, вы точно не узнаете, когда сборщик мусора выполняет завершение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="4d5a4-322">Для немедленного освобождения ресурсов можно также выбрать реализацию [шаблона удаления](~/docs/standard/garbage-collection/implementing-dispose.md) и интерфейса <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="4d5a4-323">Реализация <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> может быть вызвана потребителями класса для освобождения неуправляемых ресурсов, и метод <xref:System.Object.Finalize%2A> можно использовать для высвобождения неуправляемых ресурсов в случае, если метод <xref:System.IDisposable.Dispose%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="4d5a4-324"><xref:System.Object.Finalize%2A> может выполнять практически любое действие, включая восстановление объекта (т. е. сделать объект доступным снова) после его очистки во время сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="4d5a4-325">Однако объект может быть восстановлен только один раз. <xref:System.Object.Finalize%2A> нельзя вызвать для восстановленных объектов во время сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span>
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="4d5a4-326">Альтернативный вариант с использованием SafeHandle</span><span class="sxs-lookup"><span data-stu-id="4d5a4-326">The SafeHandle alternative</span></span>  
 <span data-ttu-id="4d5a4-327">Создание надежных методов завершения зачастую сложно, так как вы не можете делать предположения о состоянии приложения, а так как необработанные системные исключения, такие как <xref:System.OutOfMemoryException> и <xref:System.StackOverflowException>, завершают метод завершения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-327">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="4d5a4-328">Вместо реализации метода завершения для класса для освобождения неуправляемых ресурсов можно использовать объект, производный от класса <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>, чтобы создать оболочку для неуправляемых ресурсов, а затем реализовать шаблон Dispose без метода завершения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-328">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="4d5a4-329">.NET Framework предоставляет следующие классы в пространстве имен <xref:Microsoft.Win32?displayProperty=nameWithType>, которые являются производными от <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-329">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="4d5a4-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> является классом-оболочкой для маркера файла.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="4d5a4-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> является классом-оболочкой для дескрипторов размещенных в памяти файлов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="4d5a4-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> является классом-оболочкой для указателя на блок неуправляемой памяти.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="4d5a4-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>и <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> являются классами-оболочками для криптографических дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="4d5a4-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> является классом-оболочкой для дескрипторов канала.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="4d5a4-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> — это класс-оболочка для маркера в разделе реестра.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="4d5a4-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> — это класс-оболочка для обработчика ожидания.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="4d5a4-337">В следующем примере [шаблон Dispose](~/docs/standard/garbage-collection/implementing-dispose.md) используется с надежными дескрипторами вместо переопределения метода <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-337">The following example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="4d5a4-338">Он определяет класс `FileAssociation`, который заключает в реестр сведения о приложении, обрабатывающем файлы с определенным расширением.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-338">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="4d5a4-339">Два дескриптора реестра, возвращаемые вызовом функции Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) как `out` параметры, передаются в конструктор <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-339">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="4d5a4-340">После этого метод защищенного `Dispose` типа вызывает метод `SafeRegistryHandle.Dispose`, чтобы освободить эти два маркера.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-340">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="4d5a4-341">В следующем примере проверяется, вызывается ли метод <xref:System.Object.Finalize%2A> при уничтожении объекта, переопределяющего <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-341">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="4d5a4-342">Обратите внимание, что в рабочем приложении метод <xref:System.Object.Finalize%2A> будет переопределен, чтобы освободить неуправляемые ресурсы, удерживаемые объектом.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-342">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="4d5a4-343">Также обратите внимание C# , что в примере вместо переопределения метода <xref:System.Object.Finalize%2A> предоставляется деструктор.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-343">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="4d5a4-344">Дополнительный пример переопределения метода <xref:System.Object.Finalize%2A> см. в описании метода <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-344">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4d5a4-345">Служит в качестве хэш-функции по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-345">Serves as the default hash function.</span></span></summary>
        <returns><span data-ttu-id="4d5a4-346">Хэш-код для текущего объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-346">A hash code for the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4d5a4-347">Хэш-код — это числовое значение, которое используется для вставки и обнаружения объекта в коллекции на основе хэша, такой как класс <xref:System.Collections.Generic.Dictionary%602>, класс <xref:System.Collections.Hashtable> или тип, производный от класса <xref:System.Collections.DictionaryBase>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-347">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="4d5a4-348">Метод <xref:System.Object.GetHashCode%2A> предоставляет этот хэш-код для алгоритмов, требующих быстрых проверок равенства объектов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-348">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4d5a4-349">Сведения о том, как хэш-коды используются в хэш-таблицах и некоторых дополнительных алгоритмах хэш-кода, см. в записи [хэш-функции](https://en.wikipedia.org/wiki/Hash_function) в Википедии.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-349">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="4d5a4-350">Два объекта, которые равны, возвращают хэш-коды, равные.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-350">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="4d5a4-351">Однако обратная неверно: равные хэш-коды не подразумевают равенство объектов, так как разные (неравные) объекты могут иметь одинаковые хэш-коды.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-351">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="4d5a4-352">Более того, .NET не гарантирует реализацию метода <xref:System.Object.GetHashCode%2A> по умолчанию, и значение, возвращаемое этим методом, может различаться между реализациями .NET, такими как разные версии .NET Framework и .NET Core, а также платформы, такие как 32-и 64-bit. платформ.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-352">Furthermore, .NET does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET implementations, such as different versions of .NET Framework and .NET Core, and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="4d5a4-353">По этим причинам не следует использовать реализацию этого метода по умолчанию в качестве уникального идентификатора объекта для хэширования.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-353">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="4d5a4-354">Ниже приведено два последствия.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-354">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="4d5a4-355">Не следует рассчитывать, что равные хэш-коды подразумевают равенство объектов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-355">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="4d5a4-356">Никогда не следует сохранять или использовать хэш-код вне домена приложения, в котором он был создан, так как один и тот же объект может быть хэширован между доменами приложений, процессами и платформами.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-356">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="4d5a4-357">Хэш-код предназначен для эффективной вставки и уточняющего запроса в коллекциях, основанных на хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-357">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="4d5a4-358">Хэш-код не является постоянным значением.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-358">A hash code is not a permanent value.</span></span> <span data-ttu-id="4d5a4-359">По этой причине:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-359">For this reason:</span></span>  
>   
> -   <span data-ttu-id="4d5a4-360">Не сериализуются значения хэш-кода или не сохраняйте их в базах данных.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-360">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="4d5a4-361">Не используйте хэш-код в качестве ключа для получения объекта из коллекции с ключом.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-361">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="4d5a4-362">Не отправляйте хэш-коды между доменами приложений или процессами.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-362">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="4d5a4-363">В некоторых случаях хэш-коды могут быть вычислены отдельно для каждого процесса или домена приложения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-363">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="4d5a4-364">Не используйте хэш-код вместо значения, возвращаемого криптографической функцией хэширования, если требуется криптографически надежный хэш.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-364">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="4d5a4-365">Для криптографических хэшей используйте класс, производный от класса <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> или <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-365">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="4d5a4-366">Не проверяйте равенство хэш-кодов, чтобы определить, равны ли два объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-366">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="4d5a4-367">(Неравные объекты могут иметь идентичные хэш-коды.) Чтобы проверить на равенство, вызовите метод <xref:System.Object.ReferenceEquals%2A> или <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-367">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="4d5a4-368">Метод <xref:System.Object.GetHashCode%2A> может быть переопределен производным типом.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-368">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="4d5a4-369">Если <xref:System.Object.GetHashCode%2A> не переопределяется, хэш-коды для ссылочных типов вычисляются путем вызова метода <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> базового класса, который выполняет вычисление хэш-кода на основе ссылки на объект; Дополнительные сведения см. в разделе <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-369">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4d5a4-370">Иными словами, два объекта, для которых метод <xref:System.Object.ReferenceEquals%2A> возвращает `true`, имеют одинаковые хэш-коды.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-370">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="4d5a4-371">Если типы значений не переопределяют <xref:System.Object.GetHashCode%2A>, метод <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> базового класса использует отражение для вычисления хэш-кода на основе значений полей типа.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-371">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="4d5a4-372">Иными словами, типы значений, поля которых имеют одинаковые значения, имеют одинаковые хэш-коды.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-372">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="4d5a4-373">Дополнительные сведения о переопределении <xref:System.Object.GetHashCode%2A>см. в разделе "Примечания к наследникам".</span><span class="sxs-lookup"><span data-stu-id="4d5a4-373">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="4d5a4-374">При переопределении метода <xref:System.Object.GetHashCode%2A> следует также переопределить <xref:System.Object.Equals%2A>и наоборот.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-374">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="4d5a4-375">Если переопределенный метод <xref:System.Object.Equals%2A> возвращает `true` при проверке на равенство двух объектов, переопределенный метод <xref:System.Object.GetHashCode%2A> должен возвращать одно и то же значение для двух объектов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-375">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="4d5a4-376">Если объект, используемый в качестве ключа в хэш-таблице, не предоставляет полезной реализации <xref:System.Object.GetHashCode%2A>, можно указать поставщик хэш-кода, предоставив реализацию <xref:System.Collections.IEqualityComparer> одной из перегрузок конструктора <xref:System.Collections.Hashtable> класса.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-376">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="4d5a4-377">Примечания для [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="4d5a4-377">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="4d5a4-378">При вызове метода <xref:System.Object.GetHashCode%2A> для класса в [!INCLUDE[wrt](~/includes/wrt-md.md)]он предоставляет поведение по умолчанию для классов, которые не переопределяют <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-378">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="4d5a4-379">Это является частью поддержки, предоставляемой .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. раздел [поддержка .NET Framework для приложений Магазина Windows и среда выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-379">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="4d5a4-380">Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] не наследуют <xref:System.Object>и в настоящее время не реализуют <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-380">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="4d5a4-381">Однако они имеют методы <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>и <xref:System.Object.GetHashCode%2A>, когда они используются в коде C# или Visual Basic, а .NET Framework предоставляет поведение по умолчанию для этих методов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-381">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="4d5a4-382">классы, написанные на C# или Visual Basic, могут переопределять метод <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-382">classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4d5a4-383">Один из самых простых способов вычисления хэш-кода для числового значения, имеющего тот же или меньший диапазон, чем тип <xref:System.Int32>, просто возвращает это значение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-383">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="4d5a4-384">В следующем примере показана такая реализация для структуры `Number`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-384">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="4d5a4-385">Часто тип имеет несколько полей данных, которые могут участвовать в формировании хэш-кода.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-385">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="4d5a4-386">Один из способов создания хэш-кода заключается в объединении этих полей с помощью операции `XOR (eXclusive OR)`, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-386">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="4d5a4-387">Предыдущий пример возвращает один и тот же хэш-код для (N1, N2) и (N2, N1), и поэтому может создавать больше конфликтов, чем желательно.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-387">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="4d5a4-388">Доступно несколько решений, чтобы хэш-коды в этих случаях не совпадали.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-388">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="4d5a4-389">Один из них — возврат хэш-кода объекта `Tuple`, который отражает порядок каждого поля.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-389">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="4d5a4-390">В следующем примере показана возможная реализация, использующая класс <xref:System.Tuple%602>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-390">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="4d5a4-391">Однако обратите внимание, что затраты на производительность при создании экземпляра объекта `Tuple` могут существенно повлиять на общую производительность приложения, в котором хранятся большие числа объектов в хэш-таблицах.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-391">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="4d5a4-392">Второе альтернативное решение включает в себя весовые значения для отдельных хэш-кодов, сдвигяя хэш-коды последовательных полей двумя или более битами.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-392">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="4d5a4-393">В отличие от отклонения, биты, сдвинутые за пределы 31 бита, должны быть заключены в оболочку, а не удаляться.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-393">Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="4d5a4-394">Поскольку биты отбрасываются операторами сдвига влево как в, так C# и в Visual Basic, для этого требуется создать метод сдвига влево, как в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-394">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="4d5a4-395">В следующем примере используется этот метод сдвига и переноса для вычисления хэш-кода структуры `Point`, используемой в предыдущих примерах.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-395">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4d5a4-396">Хэш-функция используется для быстрого создания числа (хэш-кода), соответствующего значению объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-396">A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</span></span> <span data-ttu-id="4d5a4-397">Хэш-функции обычно относятся к каждому типу, и для уникальности в качестве входных данных должно использоваться хотя бы одно из полей экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-397">Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</span></span> <span data-ttu-id="4d5a4-398">Хэш-коды не должны вычисляться с помощью значений статических полей.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-398">Hash codes should not be computed by using the values of static fields.</span></span>  
  
<span data-ttu-id="4d5a4-399">Для классов, производных от <see cref="T:System.Object" />, метод <see langword="GetHashCode" /> может делегировать базовому классу <see cref="M:System.Object.GetHashCode" /> реализацию только в том случае, если производный класс определяет равенство на равенство ссылок.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-399">For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality.</span></span> <span data-ttu-id="4d5a4-400">Реализация <see cref="M:System.Object.GetHashCode" /> по умолчанию для ссылочных типов возвращает хэш-код, эквивалентный тому, который возвращается методом <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-400">The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method.</span></span> <span data-ttu-id="4d5a4-401">Можно переопределить <see cref="M:System.Object.GetHashCode" /> для неизменяемых ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-401">You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types.</span></span> <span data-ttu-id="4d5a4-402">Как правило, для изменяемых ссылочных типов следует переопределить <see cref="M:System.Object.GetHashCode" /> только в том случае, если:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-402">In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:</span></span> 
<span data-ttu-id="4d5a4-403">— Хэш-код можно вычислить из полей, которые не являются изменяемыми. ни</span><span class="sxs-lookup"><span data-stu-id="4d5a4-403">-   You can compute the hash code from fields that are not mutable; or</span></span> 
<span data-ttu-id="4d5a4-404">— Можно гарантировать, что хэш-код изменяемого объекта не изменится, пока объект содержится в коллекции, зависящей от его хэш-кода.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-404">-   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</span></span>  
  
<span data-ttu-id="4d5a4-405">В противном случае может показаться, что изменяемый объект будет потерян в хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-405">Otherwise, you might think that the mutable object is lost in the hash table.</span></span> <span data-ttu-id="4d5a4-406">Если вы решите переопределить <see cref="M:System.Object.GetHashCode" /> для изменяемого ссылочного типа, в документации должен быть ясно, что пользователи вашего типа не должны изменять значения объектов, пока объект хранится в хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-406">If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</span></span>  
  
<span data-ttu-id="4d5a4-407">Для типов значений <see cref="M:System.ValueType.GetHashCode" /> предоставляет реализацию хэш-кода по умолчанию, использующую отражение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-407">For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection.</span></span> <span data-ttu-id="4d5a4-408">Рекомендуется переопределять его для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-408">You should consider overriding it for better performance.</span></span>  
  
 <block subset="none" type="note"><para>  
 <span data-ttu-id="4d5a4-409">Дополнительные сведения и примеры, которые вычисляют хэш-коды различными способами, см. в разделе "примеры".</span><span class="sxs-lookup"><span data-stu-id="4d5a4-409">For more information and examples that compute hash codes in a variety of ways, see the Examples section.</span></span>  
  
</para></block>  
  
 <span data-ttu-id="4d5a4-410">Хэш-функция должна иметь следующие свойства:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-410">A hash function must have the following properties:</span></span> 
<span data-ttu-id="4d5a4-411">— Если два объекта сравнивают как равные, то метод <see cref="M:System.Object.GetHashCode" /> для каждого объекта должен возвращать одно и то же значение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-411">-   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value.</span></span> <span data-ttu-id="4d5a4-412">Однако если два объекта не считаются равными, то методы <see cref="M:System.Object.GetHashCode" /> для этих двух объектов не должны возвращать разные значения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-412">However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.</span></span>  
  
<span data-ttu-id="4d5a4-413">— Метод <see cref="M:System.Object.GetHashCode" /> для объекта должен постоянно возвращать тот же хэш-код, если в состоянии объекта нет изменений, определяющих возвращаемое значение метода [System. Object. Equals](xref:System.Object.Equals*) объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-413">-   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method.</span></span> <span data-ttu-id="4d5a4-414">Обратите внимание, что это справедливо только для текущего выполнения приложения. при повторном запуске приложения может возвращаться другой хэш-код.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-414">Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</span></span>  
  
<span data-ttu-id="4d5a4-415">Для лучшей производительности хэш-функция должна создать равномерное распределение для всех входных данных, включая входные данные, которые сильно кластеризованы.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-415">-   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</span></span> <span data-ttu-id="4d5a4-416">Следствием является то, что небольшие изменения в состоянии объекта должны привести к значительным изменениям в результирующем хэш-коде для лучшей производительности хэш-таблицы.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-416">An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</span></span>  
  
<span data-ttu-id="4d5a4-417">-Функции хэширования должны быть недорогими для вычислений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-417">-   Hash functions should be inexpensive to compute.</span></span>  
  
<span data-ttu-id="4d5a4-418">— Метод <see cref="M:System.Object.GetHashCode" /> не должен вызывать исключения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-418">-   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.</span></span>  
  
<span data-ttu-id="4d5a4-419">Например, реализация метода <see cref="M:System.String.GetHashCode" />, предоставляемого классом <see cref="T:System.String" />, возвращает идентичные хэш-коды для одинаковых строковых значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-419">For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values.</span></span> <span data-ttu-id="4d5a4-420">Поэтому два объекта <see cref="T:System.String" /> возвращают один и тот же хэш-код, если они представляют одно и то же строковое значение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-420">Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value.</span></span> <span data-ttu-id="4d5a4-421">Кроме того, метод использует все символы в строке для создания разумного случайного распределения выходных данных, даже если входные данные кластеризованы в определенные диапазоны (например, многие пользователи могут иметь строки, содержащие только младшие символы ASCII 128, хотя Строка может содержать любой из 65 535 символов Юникода).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-421">Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</span></span>  
  
<span data-ttu-id="4d5a4-422">Предоставление хорошей хэш-функции для класса может значительно повлиять на производительность при добавлении этих объектов в хэш-таблицу.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-422">Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</span></span> <span data-ttu-id="4d5a4-423">В хэш-таблице с ключами, обеспечивающими хорошую реализацию хэш-функции, поиск элемента занимает постоянное время (например, операция O (1)).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-423">In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</span></span> <span data-ttu-id="4d5a4-424">В хэш-таблице с плохой реализацией хэш-функции производительность поиска зависит от числа элементов в хэш-таблице (например, операции O (`n`), где `n` — число элементов в хэш-таблице).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-424">In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table).</span></span> <span data-ttu-id="4d5a4-425">Пользователь-злоумышленник может вводить данные, увеличивающие количество конфликтов, что может значительно снизить производительность приложений, зависящих от хэш-таблиц, при следующих условиях.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-425">A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</span></span> 
<span data-ttu-id="4d5a4-426">— Когда хэш-функции вызывают частые конфликты.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-426">-   When hash functions produce frequent collisions.</span></span>  
  
<span data-ttu-id="4d5a4-427">— Когда большая часть объектов в хэш-таблице создает хэш-коды, которые равны или приблизительно равны друг другу.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-427">-   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</span></span>  
  
<span data-ttu-id="4d5a4-428">— При вводе пользователями данных, из которых вычисляются хэш-код.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-428">-   When users input the data from which the hash code is computed.</span></span>  
  
<span data-ttu-id="4d5a4-429">Производные классы, переопределяющие <see cref="M:System.Object.GetHashCode" />, должны также переопределять <see cref="M:System.Object.Equals(System.Object)" />, чтобы гарантировать, что два объекта считаются равными и имеют одинаковый хэш-код. в противном случае тип <see cref="T:System.Collections.Hashtable" /> может работать неправильно.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-429">Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</span></span></para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4d5a4-430">Возвращает объект <see cref="T:System.Type" /> для текущего экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-430">Gets the <see cref="T:System.Type" /> of the current instance.</span></span></summary>
        <returns><span data-ttu-id="4d5a4-431">Точный тип текущего экземпляра в среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-431">The exact runtime type of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4d5a4-432">Поскольку <xref:System.Object?displayProperty=nameWithType> является базовым классом для всех типов в системе типов .NET, метод <xref:System.Object.GetType%2A> можно использовать для возврата <xref:System.Type> объектов, представляющих все типы .NET.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-432">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET types.</span></span> <span data-ttu-id="4d5a4-433">.NET распознает следующие пять категорий типов:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-433">.NET recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="4d5a4-434">Классы, которые являются производными от <xref:System.Object?displayProperty=nameWithType>,</span><span class="sxs-lookup"><span data-stu-id="4d5a4-434">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="4d5a4-435">Типы значений, которые являются производными от <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-435">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="4d5a4-436">Интерфейсы, которые являются производными от <xref:System.Object?displayProperty=nameWithType>, начиная с .NET Framework 2,0.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-436">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="4d5a4-437">Перечисления, которые являются производными от <xref:System.Enum?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-437">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="4d5a4-438">Делегаты, которые являются производными от <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-438">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="4d5a4-439">Для двух объектов `x` и `y`, имеющих идентичные типы среды выполнения, `Object.ReferenceEquals(x.GetType(),y.GetType())` возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-439">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="4d5a4-440">В следующем примере используется метод <xref:System.Object.GetType%2A> с методом <xref:System.Object.ReferenceEquals%2A>, чтобы определить, является ли одно числовое значение тем же типом, что и два других числовых значения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-440">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="4d5a4-441">Чтобы определить, является ли объект конкретным типом, можно использовать ключевое слово или конструкцию для сравнения типов языка.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-441">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="4d5a4-442">Например, можно использовать конструкцию `TypeOf…Is` в Visual Basic или ключевое слово `is` в C#.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-442">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="4d5a4-443">Метод <xref:System.Object.GetType%2A> наследуется всеми типами, производными от <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-443">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="4d5a4-444">Это означает, что в дополнение к использованию ключевого слова сравнения собственного языка можно использовать метод <xref:System.Object.GetType%2A> для определения типа конкретного объекта, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-444">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <span data-ttu-id="4d5a4-445">Объект <xref:System.Type> предоставляет метаданные, связанные с классом текущего <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-445">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4d5a4-446">В следующем примере кода показано, что <xref:System.Object.GetType%2A> Возвращает тип текущего экземпляра среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-446">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4d5a4-447">Создает неполную копию текущего объекта <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-447">Creates a shallow copy of the current <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="4d5a4-448">Неполная копия объекта <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-448">A shallow copy of the current <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4d5a4-449">Метод <xref:System.Object.MemberwiseClone%2A> создает неполную копию путем создания нового объекта, а затем копирует нестатические поля текущего объекта в новый объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-449">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="4d5a4-450">Если поле является типом значения, выполняется побитовая копия поля.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-450">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="4d5a4-451">Если поле является ссылочным типом, то ссылка копируется, но на объект, на который указывает ссылка, нет; Таким образом, исходный объект и его клон ссылаются на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-451">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="4d5a4-452">Например, рассмотрим объект с именем X, который ссылается на объекты A и B. объект B, в свою очередь, ссылается на объект C. Поверхностная копия X создает новый объект x2, который также ссылается на объекты A и B. В отличие от этого, при глубоком копировании X создается новый объект x2, который ссылается на новые объекты a2 и B2, которые являются копиями A и B. B2, в свою очередь, ссылается на новый объект C2, который является копией C. В примере показана разница между неполной и глубокой операцией копирования.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-452">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="4d5a4-453">Существует множество способов реализации операции глубокого копирования, если неполная операция копирования, выполняемая методом <xref:System.Object.MemberwiseClone%2A>, не соответствует вашим потребностям.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-453">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="4d5a4-454">К ним относятся следующие:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-454">These include the following:</span></span>  
  
-   <span data-ttu-id="4d5a4-455">Вызовите конструктор класса копируемого объекта, чтобы создать второй объект со значениями свойств, взятыми из первого объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-455">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="4d5a4-456">Предполагается, что значения объекта полностью определяются его конструктором класса.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-456">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="4d5a4-457">Вызовите метод <xref:System.Object.MemberwiseClone%2A>, чтобы создать неполную копию объекта, а затем назначьте новые объекты, значения которых совпадают с исходным объектом, с любыми свойствами или полями, значения которых являются ссылочными типами.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-457">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="4d5a4-458">Метод `DeepCopy` в примере иллюстрирует этот подход.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-458">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="4d5a4-459">Выполните сериализацию объекта для глубокого копирования, а затем восстановите сериализованные данные в другую объектную переменную.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-459">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="4d5a4-460">Используйте отражение с рекурсией для выполнения операции глубокого копирования.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-460">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4d5a4-461">В следующем примере показан метод <xref:System.Object.MemberwiseClone%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-461">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="4d5a4-462">Он определяет `ShallowCopy` метод, который вызывает метод <xref:System.Object.MemberwiseClone%2A> для выполнения неполной операции копирования объекта `Person`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-462">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="4d5a4-463">Он также определяет метод `DeepCopy`, выполняющий операцию глубокого копирования объекта `Person`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-463">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="4d5a4-464">В этом примере свойство `Person.IdInfo` возвращает объект `IdInfo`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-464">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="4d5a4-465">Как видно из выходных данных в примере, когда объект `Person` клонируется путем вызова метода <xref:System.Object.MemberwiseClone%2A>, клонированный `Person` объект является независимой копией исходного объекта, за исключением того, что они совместно используют одну и ту же ссылку на объект `Person.IdInfo`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-465">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="4d5a4-466">В результате изменение свойства `Person.IdInfo` клона изменяет свойство `Person.IdInfo` исходного объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-466">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="4d5a4-467">С другой стороны, при выполнении операции глубокого копирования клонированный `Person` объект, включая его свойство `Person.IdInfo`, можно изменить, не влияя на исходный объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-467">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="4d5a4-468">Первый сравниваемый объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-468">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="4d5a4-469">Второй из сравниваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-469">The second object  to compare.</span></span></param>
        <summary><span data-ttu-id="4d5a4-470">Определяет, совпадают ли указанные экземпляры <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-470">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span></span></summary>
        <returns><span data-ttu-id="4d5a4-471">Значение <see langword="true" />, если параметр <paramref name="objA" /> соответствует тому же экземпляру, что и параметр <paramref name="objB" />, или же оба они имеют значение **NULL**; в противном случае значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-471"><see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4d5a4-472">В отличие от метода <xref:System.Object.Equals%2A> и оператора равенства, метод <xref:System.Object.ReferenceEquals%2A> не может быть переопределен.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-472">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="4d5a4-473">Поэтому, если нужно проверить две ссылки на объекты на равенство и вы не уверены в реализации метода `Equals`, можно вызвать метод <xref:System.Object.ReferenceEquals%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-473">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="4d5a4-474">Однако возвращаемое значение метода <xref:System.Object.ReferenceEquals%2A> может показаться аномальным в этих двух сценариях:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-474">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="4d5a4-475">При сравнении типов значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-475">When comparing value types.</span></span> <span data-ttu-id="4d5a4-476">Если `objA` и `objB` являются типами значений, они упаковываются перед передачей в метод <xref:System.Object.ReferenceEquals%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-476">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="4d5a4-477">Это означает, что если оба `objA` и `objB` представляют один и тот же экземпляр типа значения, метод <xref:System.Object.ReferenceEquals%2A>, тем не менее, возвратит `false`, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-477">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="4d5a4-478">Дополнительные сведения о типах значений упаковки см. в разделе [Упаковка и](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)распаковка.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-478">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="4d5a4-479">При сравнении строк.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-479">When comparing strings.</span></span> <span data-ttu-id="4d5a4-480">Если `objA` и `objB` являются строками, метод <xref:System.Object.ReferenceEquals%2A> возвращает `true`, если строка интернирована.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-480">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="4d5a4-481">Он не выполняет проверку на равенство значений.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-481">It does not perform a test for value equality.</span></span>  <span data-ttu-id="4d5a4-482">В следующем примере `s1` и `s2` равны, так как они являются двумя экземплярами одной интернированной строки.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-482">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="4d5a4-483">Однако `s3` и `s4` не равны, так как несмотря на то, что они имеют одинаковые строковые значения, эта строка не интернирована.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-483">However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="4d5a4-484">Дополнительные сведения об интернировании строк см. в разделе <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-484">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4d5a4-485">В следующем примере <xref:System.Object.ReferenceEquals%2A> используется для определения того, являются ли два объекта одним и тем же экземпляром.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-485">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4d5a4-486">Возвращает строку, представляющую текущий объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-486">Returns a string that represents the current object.</span></span></summary>
        <returns><span data-ttu-id="4d5a4-487">Строка, представляющая текущий объект.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-487">A string that represents the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4d5a4-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> является основным методом форматирования в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="4d5a4-489">Он преобразует объект в строковое представление, чтобы его можно было отображать.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-489">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="4d5a4-490">(Сведения о поддержке форматирования в .NET Framework см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).) Реализации <xref:System.Object.ToString%2A?displayProperty=nameWithType> метода по умолчанию возвращают полное имя типа объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-490">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4d5a4-491">Возможно, вы достигли этой страницы, следуя ссылке из списка участников другого типа.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-491">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="4d5a4-492">Это происходит потому, что этот тип не переопределяет <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-492">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4d5a4-493">Вместо этого он наследует функциональность метода <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-493">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="4d5a4-494">Типы часто переопределяют метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, чтобы предоставить более подходящее строковое представление определенного типа.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-494">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="4d5a4-495">Типы также часто перегружают метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, чтобы обеспечить поддержку для строк формата или форматирования с учетом языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-495">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 <span data-ttu-id="4d5a4-496">Содержание</span><span class="sxs-lookup"><span data-stu-id="4d5a4-496">In this section:</span></span>  
  
 <span data-ttu-id="4d5a4-497">[Метод Object. ToString () по умолчанию](#Default) </span><span class="sxs-lookup"><span data-stu-id="4d5a4-497">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="4d5a4-498">[Переопределение метода Object. ToString ()](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="4d5a4-498">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="4d5a4-499">[Перегрузка метода ToString](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="4d5a4-499">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="4d5a4-500">[Расширение метода Object. ToString](#Extending) </span><span class="sxs-lookup"><span data-stu-id="4d5a4-500">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="4d5a4-501">Примечания для среда выполнения Windows</span><span class="sxs-lookup"><span data-stu-id="4d5a4-501">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="4d5a4-502">Метод Object. ToString () по умолчанию</span><span class="sxs-lookup"><span data-stu-id="4d5a4-502">The default Object.ToString() method</span></span>  
 <span data-ttu-id="4d5a4-503">Реализация метода <xref:System.Object.ToString%2A> по умолчанию возвращает полное имя типа <xref:System.Object>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-503">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp-interactive[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="4d5a4-504">Поскольку <xref:System.Object> является базовым классом всех ссылочных типов в .NET Framework, это поведение наследуется ссылочными типами, которые не переопределяют метод <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-504">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="4d5a4-505">Это показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-505">The following example illustrates this.</span></span> <span data-ttu-id="4d5a4-506">Он определяет класс с именем `Object1`, который принимает реализацию по умолчанию всех членов <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-506">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="4d5a4-507">Его <xref:System.Object.ToString%2A> метод возвращает полное имя типа объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-507">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="4d5a4-508">Переопределение метода Object. ToString ()</span><span class="sxs-lookup"><span data-stu-id="4d5a4-508">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="4d5a4-509">Типы обычно переопределяют метод <xref:System.Object.ToString%2A?displayProperty=nameWithType> для возврата строки, представляющей экземпляр объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-509">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="4d5a4-510">Например, базовые типы, такие как <xref:System.Char>, <xref:System.Int32>и <xref:System.String>, предоставляют <xref:System.Object.ToString%2A> реализации, возвращающие строковое представление значения, представляемого объектом.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-510">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="4d5a4-511">В следующем примере определяется класс `Object2`, который переопределяет метод <xref:System.Object.ToString%2A>, который возвращает имя типа и его значение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-511">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="4d5a4-512">В следующей таблице перечислены категории типов в .NET и указано, переопределять ли их метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-512">The following table lists the type categories in .NET and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="4d5a4-513">Категория типа</span><span class="sxs-lookup"><span data-stu-id="4d5a4-513">Type category</span></span>|<span data-ttu-id="4d5a4-514">Переопределяет Object. ToString ()</span><span class="sxs-lookup"><span data-stu-id="4d5a4-514">Overrides Object.ToString()</span></span>|<span data-ttu-id="4d5a4-515">Поведение</span><span class="sxs-lookup"><span data-stu-id="4d5a4-515">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="4d5a4-516">Class</span><span class="sxs-lookup"><span data-stu-id="4d5a4-516">Class</span></span>|<span data-ttu-id="4d5a4-517">н/д</span><span class="sxs-lookup"><span data-stu-id="4d5a4-517">n/a</span></span>|<span data-ttu-id="4d5a4-518">н/д</span><span class="sxs-lookup"><span data-stu-id="4d5a4-518">n/a</span></span>|  
|<span data-ttu-id="4d5a4-519">Структура</span><span class="sxs-lookup"><span data-stu-id="4d5a4-519">Structure</span></span>|<span data-ttu-id="4d5a4-520">Да (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="4d5a4-520">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="4d5a4-521">Аналогично `Object.ToString()`</span><span class="sxs-lookup"><span data-stu-id="4d5a4-521">Same as `Object.ToString()`</span></span>|  
|<span data-ttu-id="4d5a4-522">Перечисление</span><span class="sxs-lookup"><span data-stu-id="4d5a4-522">Enumeration</span></span>|<span data-ttu-id="4d5a4-523">Да (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="4d5a4-523">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="4d5a4-524">Имя элемента</span><span class="sxs-lookup"><span data-stu-id="4d5a4-524">The member name</span></span>|  
|<span data-ttu-id="4d5a4-525">Интерфейс</span><span class="sxs-lookup"><span data-stu-id="4d5a4-525">Interface</span></span>|<span data-ttu-id="4d5a4-526">Нет</span><span class="sxs-lookup"><span data-stu-id="4d5a4-526">No</span></span>|<span data-ttu-id="4d5a4-527">н/д</span><span class="sxs-lookup"><span data-stu-id="4d5a4-527">n/a</span></span>|  
|<span data-ttu-id="4d5a4-528">Делегат</span><span class="sxs-lookup"><span data-stu-id="4d5a4-528">Delegate</span></span>|<span data-ttu-id="4d5a4-529">Нет</span><span class="sxs-lookup"><span data-stu-id="4d5a4-529">No</span></span>|<span data-ttu-id="4d5a4-530">н/д</span><span class="sxs-lookup"><span data-stu-id="4d5a4-530">n/a</span></span>|  
  
 <span data-ttu-id="4d5a4-531">Дополнительные сведения о переопределении <xref:System.Object.ToString%2A>см. в разделе Примечания к наследникам.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-531">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="4d5a4-532">Перегрузка метода ToString</span><span class="sxs-lookup"><span data-stu-id="4d5a4-532">Overloading the ToString method</span></span>  
 <span data-ttu-id="4d5a4-533">Помимо переопределения метода <xref:System.Object.ToString?displayProperty=nameWithType> без параметров, многие типы перегружают метод `ToString`, чтобы предоставить версии метода, принимающего параметры.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-533">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="4d5a4-534">Чаще всего это делается для обеспечения поддержки форматирования переменных и форматирования с учетом языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-534">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="4d5a4-535">В следующем примере перегружается метод `ToString` для возврата результирующей строки, содержащей значения различных полей класса `Automobile`.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-535">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="4d5a4-536">Он определяет четыре строки формата: G, которая возвращает имя модели и год; D, возвращающее имя модели, год и число дверей; C, возвращающее имя модели, год и число цилиндров; и, который возвращает строку со всеми четырьмя значениями полей.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-536">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="4d5a4-537">В следующем примере вызывается перегруженный метод <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> для просмотра форматирования значения валюты с учетом языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-537">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="4d5a4-538">Дополнительные сведения о строках форматирования и форматировании с учетом языка и региональных параметров см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-538">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="4d5a4-539">Строки формата, поддерживаемые числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-539">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="4d5a4-540">Сведения о строках формата, поддерживаемых значениями даты и времени, см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-540">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="4d5a4-541">Расширение метода Object. ToString</span><span class="sxs-lookup"><span data-stu-id="4d5a4-541">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="4d5a4-542">Поскольку тип наследует метод <xref:System.Object.ToString%2A?displayProperty=nameWithType> по умолчанию, его поведение может оказаться нежелательным и его нужно изменить.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-542">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="4d5a4-543">Это особенно справедливо для массивов и классов коллекций.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-543">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="4d5a4-544">Хотя в методе `ToString` класса Array или Collection может быть отображено значение его членов, вместо этого отображается полное имя типа, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-544">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="4d5a4-545">Есть несколько вариантов для создания результирующей строки, которая вам нужна.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-545">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="4d5a4-546">Если тип является массивом, объектом коллекции или объектом, реализующим интерфейсы <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601>, можно перечислить его элементы с помощью инструкции `foreach` в C# среде или конструкции `For Each...Next` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-546">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="4d5a4-547">Если класс не `sealed` (в C#) или `NotInheritable` (в Visual Basic), можно разработать класс-оболочку, который наследуется от базового класса, для которого нужно настроить <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-547">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="4d5a4-548">Как минимум, для этого необходимо выполнить следующие действия.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-548">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="4d5a4-549">Реализуйте все необходимые конструкторы.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-549">Implement any necessary constructors.</span></span> <span data-ttu-id="4d5a4-550">Производные классы не наследуют конструкторы базовых классов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-550">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="4d5a4-551">Переопределите метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, чтобы возвращалась нужная строка.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-551">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="4d5a4-552">В следующем примере определяется класс-оболочка для класса <xref:System.Collections.Generic.List%601>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-552">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="4d5a4-553">Он переопределяет метод <xref:System.Object.ToString%2A?displayProperty=nameWithType> для вывода значения каждого метода коллекции, а не полного имени типа.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-553">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="4d5a4-554">Разрабатывайте [метод расширения](~/docs/standard/design-guidelines/extension-methods.md) , который возвращает нужную результирующую строку.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-554">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="4d5a4-555">Обратите внимание, что метод <xref:System.Object.ToString%2A?displayProperty=nameWithType> по умолчанию нельзя переопределить таким образом (т. е. класс расширения C#(в) или модуль (в Visual Basic) не может иметь метод без параметров с именем `ToString`, который вызывается вместо метода `ToString` исходного типа.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-555">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="4d5a4-556">Вам потребуется указать другое имя для `ToString` замены без параметров.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-556">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="4d5a4-557">В следующем примере определяются два метода, расширяющие класс <xref:System.Collections.Generic.List%601>: метод `ToString2` без параметров, а также метод `ToString` с параметром <xref:System.String>, который представляет строку формата.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-557">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="4d5a4-558">Примечания для [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="4d5a4-558">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="4d5a4-559">При вызове метода <xref:System.Object.ToString%2A> для класса в [!INCLUDE[wrt](~/includes/wrt-md.md)]он предоставляет поведение по умолчанию для классов, которые не переопределяют <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-559">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="4d5a4-560">Это является частью поддержки, предоставляемой .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. раздел [поддержка .NET Framework для приложений Магазина Windows и среда выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-560">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="4d5a4-561">Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] не наследуют <xref:System.Object>и не всегда реализуют <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-561">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and don't always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="4d5a4-562">Однако они всегда имеют методы <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>и <xref:System.Object.GetHashCode%2A>, когда они используются в коде C# или Visual Basic, а .NET Framework предоставляет поведение по умолчанию для этих методов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-562">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="4d5a4-563">Начиная с [!INCLUDE[net_v451](~/includes/net-v451-md.md)], среда CLR будет использовать [IStringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) для объекта [!INCLUDE[wrt](~/includes/wrt-md.md)], прежде чем вернуться к реализации по умолчанию <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-563">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="4d5a4-564">классы, написанные на C# или Visual Basic, могут переопределять метод <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-564">classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a><span data-ttu-id="4d5a4-565">[!INCLUDE[wrt](~/includes/wrt-md.md)] и интерфейс IStringable</span><span class="sxs-lookup"><span data-stu-id="4d5a4-565">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="4d5a4-566">Начиная с [!INCLUDE[win81](~/includes/win81-md.md)][!INCLUDE[wrt](~/includes/wrt-md.md)] включает интерфейс [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) , единственный метод которого [IStringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)обеспечивает базовую поддержку форматирования, сравнимую с <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-566">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4d5a4-567">Чтобы предотвратить неоднозначность, не следует реализовывать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) для управляемых типов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-567">To prevent ambiguity, you should not implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="4d5a4-568">Если управляемые объекты вызываются машинным кодом или кодом, написанным на языках, таких как C++JavaScript или/CX, они выглядят как реализующие [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-568">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="4d5a4-569">Среда CLR автоматически направит вызовы из [IStringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) в <xref:System.Object.ToString%2A?displayProperty=nameWithType> в событии [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) не реализовано в управляемом объекте.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-569">The common language runtime will automatically route calls from [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="4d5a4-570">Так как среда CLR Auto реализует [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) для всех управляемых типов в [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] приложениях, рекомендуется не предоставлять собственную реализацию [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) .</span><span class="sxs-lookup"><span data-stu-id="4d5a4-570">Because the common language runtime auto-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="4d5a4-571">Реализация [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) может привести к непредвиденному поведению при вызове `ToString` из [!INCLUDE[wrt](~/includes/wrt-md.md)]C++,/CX или JavaScript.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-571">Implementing [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="4d5a4-572">Если вы решили реализовать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) в общедоступном управляемом типе, экспортированном в [!INCLUDE[wrt](~/includes/wrt-md.md)] компоненте, применяются следующие ограничения.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-572">If you do choose to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="4d5a4-573">Интерфейс [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) можно определить только в связи «класс реализует», например</span><span class="sxs-lookup"><span data-stu-id="4d5a4-573">You can define the [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="4d5a4-574">в C# или</span><span class="sxs-lookup"><span data-stu-id="4d5a4-574">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="4d5a4-575">в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-575">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="4d5a4-576">Невозможно реализовать [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) в интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-576">You cannot implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="4d5a4-577">Нельзя объявить параметр типа [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="4d5a4-577">You cannot declare a parameter to be of type [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="4d5a4-578">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) не может быть типом возвращаемого значения метода, свойства или поля.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-578">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="4d5a4-579">Невозможно скрыть реализацию [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) из базовых классов с помощью определения метода, как показано ниже:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-579">You cannot hide your [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="4d5a4-580">Вместо этого реализация [IStringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) должна всегда переопределять реализацию базового класса.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-580">Instead, the [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="4d5a4-581">Реализацию `ToString` можно скрыть только путем вызова этого метода в строго типизированном экземпляре класса.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-581">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="4d5a4-582">Обратите внимание, что при различных условиях вызовы из машинного кода в управляемый тип, реализующий [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) или скрывая его реализацию [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) , могут привести к непредвиденному поведению.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-582">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4d5a4-583">При реализации собственных типов следует переопределить метод <see cref="M:System.Object.ToString" /> для возврата значений, которые являются значимыми для этих типов.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-583">When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types.</span></span> <span data-ttu-id="4d5a4-584">Производные классы, которым требуется больший контроль над форматированием, чем <see cref="M:System.Object.ToString" /> предоставляет возможность реализовать интерфейс <see cref="T:System.IFormattable" />.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-584">Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface.</span></span> <span data-ttu-id="4d5a4-585">Его метод <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> позволяет определять строки формата, которые управляют форматированием, и использовать объект <see cref="T:System.IFormatProvider" />, который может обеспечить форматирование для определенного языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-585">Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.</span></span>  
  
<span data-ttu-id="4d5a4-586">Переопределения метода <see cref="M:System.Object.ToString" /> должны соответствовать следующим рекомендациям:</span><span class="sxs-lookup"><span data-stu-id="4d5a4-586">Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:</span></span> 
<span data-ttu-id="4d5a4-587">— Возвращаемая строка должна быть понятной и удобочитаемой для людей.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-587">-   The returned string should be friendly and readable by humans.</span></span>  
  
<span data-ttu-id="4d5a4-588">— Возвращаемая строка должна уникальным образом идентифицировать значение экземпляра объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-588">-   The returned string should uniquely identify the value of the object instance.</span></span>  
  
<span data-ttu-id="4d5a4-589">-Возвращаемая строка должна быть максимально короткой, чтобы ее можно было отображать с помощью отладчика.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-589">-   The returned string should be as short as possible so that it is suitable for display by a debugger.</span></span>  
  
<span data-ttu-id="4d5a4-590">-Переопределение <see cref="M:System.Object.ToString" /> не должно возвращать <see cref="F:System.String.Empty" /> или строку со значением NULL.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-590">-   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.</span></span>  
  
<span data-ttu-id="4d5a4-591">— Переопределение <see cref="M:System.Object.ToString" /> не должно вызывать исключение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-591">-   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.</span></span>  
  
<span data-ttu-id="4d5a4-592">— Если строковое представление экземпляра зависит от языка и региональных параметров или может быть отформатировано несколькими способами, реализуйте интерфейс <see cref="T:System.IFormattable" />.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-592">-   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.</span></span>  
  
<span data-ttu-id="4d5a4-593">— Если возвращаемая строка содержит конфиденциальную информацию, необходимо сначала запросить соответствующее разрешение.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-593">-   If the returned string includes sensitive information, you should first demand an appropriate permission.</span></span> <span data-ttu-id="4d5a4-594">Если запрос проходит удачно, вы можете вернуть конфиденциальную информацию. в противном случае следует вернуть строку, которая исключается из конфиденциальной информации.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-594">If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</span></span>  
  
<span data-ttu-id="4d5a4-595">-Переопределение <see cref="M:System.Object.ToString" /> не должно иметь наблюдаемых побочных эффектов, чтобы избежать сложностей при отладке.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-595">-   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging.</span></span> <span data-ttu-id="4d5a4-596">Например, вызов метода <see cref="M:System.Object.ToString" /> не должен изменять значение полей экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-596">For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.</span></span>  
  
<span data-ttu-id="4d5a4-597">— Если тип реализует метод анализа (или <see langword="Parse" /> или <see langword="TryParse" /> метод, конструктор или какой-либо другой статический метод, который создает экземпляр типа из строки), следует убедиться, что строка, возвращаемая методом <see cref="M:System.Object.ToString" />, может быть преобразована в экземпляр объекта.</span><span class="sxs-lookup"><span data-stu-id="4d5a4-597">-   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</span></span></para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="4d5a4-598">Типы форматирования в .NET</span><span class="sxs-lookup"><span data-stu-id="4d5a4-598">Formatting Types in .NET</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
