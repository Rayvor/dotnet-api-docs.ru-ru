<Type Name="MarshalByRefObject" FullName="System.MarshalByRefObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="66121a0bbdf3675b76e4b3d623fa06eeefeaac4d" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69405624" /></Metadata><TypeSignature Language="C#" Value="public abstract class MarshalByRefObject" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit MarshalByRefObject extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MarshalByRefObject" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MarshalByRefObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class MarshalByRefObject abstract" />
  <TypeSignature Language="F#" Value="type MarshalByRefObject = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="fe73e-101">Разрешает доступ к объектам через границы доменов приложения в приложениях, поддерживающих удаленное взаимодействие.</span><span class="sxs-lookup"><span data-stu-id="fe73e-101">Enables access to objects across application domain boundaries in applications that support remoting.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fe73e-102">Домен приложения — это раздел в процессе операционной системы, в котором находятся одно или несколько приложений.</span><span class="sxs-lookup"><span data-stu-id="fe73e-102">An application domain is a partition in an operating system process where one or more applications reside.</span></span> <span data-ttu-id="fe73e-103">Объекты в одном домене приложения взаимодействуют напрямую.</span><span class="sxs-lookup"><span data-stu-id="fe73e-103">Objects in the same application domain communicate directly.</span></span> <span data-ttu-id="fe73e-104">Объекты в разных доменах приложений взаимодействуют либо посредством передачи копий объектов через границы домена приложения, либо с помощью прокси-сервера для обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="fe73e-104">Objects in different application domains communicate either by transporting copies of objects across application domain boundaries, or by using a proxy to exchange messages.</span></span>  
  
 <span data-ttu-id="fe73e-105"><xref:System.MarshalByRefObject>является базовым классом для объектов, взаимодействующих через границы доменов приложений путем обмена сообщениями с помощью прокси-сервера.</span><span class="sxs-lookup"><span data-stu-id="fe73e-105"><xref:System.MarshalByRefObject> is the base class for objects that communicate across application domain boundaries by exchanging messages using a proxy.</span></span> <span data-ttu-id="fe73e-106">Объекты, которые не наследуют <xref:System.MarshalByRefObject> от, неявно маршалируются по значению.</span><span class="sxs-lookup"><span data-stu-id="fe73e-106">Objects that do not inherit from <xref:System.MarshalByRefObject> are implicitly marshal by value.</span></span> <span data-ttu-id="fe73e-107">Если удаленное приложение ссылается на объект Marshal по значению, то копия объекта передается через границы домена приложения.</span><span class="sxs-lookup"><span data-stu-id="fe73e-107">When a remote application references a marshal by value object, a copy of the object is passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="fe73e-108"><xref:System.MarshalByRefObject>доступ к объектам осуществляется непосредственно в границах локального домена приложения.</span><span class="sxs-lookup"><span data-stu-id="fe73e-108"><xref:System.MarshalByRefObject> objects are accessed directly within the boundaries of the local application domain.</span></span> <span data-ttu-id="fe73e-109">Когда приложение в удаленном домене приложения получает доступ <xref:System.MarshalByRefObject>к, прокси-сервер передается удаленному приложению.</span><span class="sxs-lookup"><span data-stu-id="fe73e-109">The first time an application in a remote application domain accesses a <xref:System.MarshalByRefObject>, a proxy is passed to the remote application.</span></span> <span data-ttu-id="fe73e-110">Последующие вызовы прокси-сервера маршалируются обратно в объект, находящийся в локальном домене приложения.</span><span class="sxs-lookup"><span data-stu-id="fe73e-110">Subsequent calls on the proxy are marshaled back to the object residing in the local application domain.</span></span>  
  
 <span data-ttu-id="fe73e-111">Типы должны наследоваться от <xref:System.MarshalByRefObject> , если тип используется через границы домена приложения, а состояние объекта не должно быть скопировано, так как члены объекта не могут использоваться вне домена приложения, в котором они были созданы.</span><span class="sxs-lookup"><span data-stu-id="fe73e-111">Types must inherit from <xref:System.MarshalByRefObject> when the type is used across application domain boundaries, and the state of the object must not be copied because the members of the object are not usable outside the application domain where they were created.</span></span>  
  
 <span data-ttu-id="fe73e-112">При наследовании объекта из <xref:System.MarshalByRefObject> для использования в границах домена приложения не следует переопределять ни один из его членов, а также не следует вызывать его методы напрямую.</span><span class="sxs-lookup"><span data-stu-id="fe73e-112">When you derive an object from <xref:System.MarshalByRefObject> for use across application domain boundaries, you should not override any of its members, nor should you call its methods directly.</span></span> <span data-ttu-id="fe73e-113">Среда выполнения распознает, что классы <xref:System.MarshalByRefObject> , производные от, должны быть упакованы через границы домена приложения.</span><span class="sxs-lookup"><span data-stu-id="fe73e-113">The runtime recognizes that classes derived from  <xref:System.MarshalByRefObject> should be marshaled across app domain boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fe73e-114">Этот раздел содержит два примера кода.</span><span class="sxs-lookup"><span data-stu-id="fe73e-114">This section contains two code examples.</span></span> <span data-ttu-id="fe73e-115">В первом примере кода показано, как создать экземпляр класса в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="fe73e-115">The first code example shows how to create an instance of a class in another application domain.</span></span> <span data-ttu-id="fe73e-116">Во втором примере кода показан простой класс, который можно использовать для удаленного взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="fe73e-116">The second code example shows a simple class that can be used for remoting.</span></span>  
  
 <span data-ttu-id="fe73e-117">**Пример 1**</span><span class="sxs-lookup"><span data-stu-id="fe73e-117">**Example 1**</span></span>  
  
 <span data-ttu-id="fe73e-118">В следующем примере кода показан самый простой способ выполнения кода в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="fe73e-118">The following code example shows the simplest way to execute code in another application domain.</span></span> <span data-ttu-id="fe73e-119">В примере определяется класс с именем `Worker` , <xref:System.MarshalByRefObject>наследуемый с помощью метода, который отображает имя домена приложения, в котором оно выполняется.</span><span class="sxs-lookup"><span data-stu-id="fe73e-119">The example defines a class named `Worker` that inherits <xref:System.MarshalByRefObject>, with a method that displays the name of the application domain in which it is executing.</span></span> <span data-ttu-id="fe73e-120">В примере создаются экземпляры `Worker` в домене приложения по умолчанию и в новом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="fe73e-120">The example creates instances of `Worker` in the default application domain and in a new application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fe73e-121">Сборка, которая содержит `Worker` , должна быть загружена в оба домена приложений, но может загружать другие сборки, которые будут существовать только в новом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="fe73e-121">The assembly that contains `Worker` must be loaded into both application domains, but it could load other assemblies that would exist only in the new application domain.</span></span>  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 <span data-ttu-id="fe73e-122">**Пример 2**</span><span class="sxs-lookup"><span data-stu-id="fe73e-122">**Example 2**</span></span>  
  
 <span data-ttu-id="fe73e-123">В следующем примере показан класс, производный <xref:System.MarshalByRefObject> от, который используется позже в удаленном взаимодействии.</span><span class="sxs-lookup"><span data-stu-id="fe73e-123">The following example demonstrates a class derived from <xref:System.MarshalByRefObject> that is used later in remoting.</span></span>  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fe73e-124">Инициализирует новый экземпляр класса <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="fe73e-124">Initializes a new instance of the <see cref="T:System.MarshalByRefObject" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjRef">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.ObjRef CreateObjRef (Type requestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjRef CreateObjRef(class System.Type requestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.CreateObjRef(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateObjRef (requestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjRef ^ CreateObjRef(Type ^ requestedType);" />
      <MemberSignature Language="F#" Value="abstract member CreateObjRef : Type -&gt; System.Runtime.Remoting.ObjRef&#xA;override this.CreateObjRef : Type -&gt; System.Runtime.Remoting.ObjRef" Usage="marshalByRefObject.CreateObjRef requestedType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedType" Type="System.Type" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="requestedType"><span data-ttu-id="fe73e-125">Класс <see cref="T:System.Type" /> объекта, на который будет ссылаться новый объект <see cref="T:System.Runtime.Remoting.ObjRef" />.</span><span class="sxs-lookup"><span data-stu-id="fe73e-125">The <see cref="T:System.Type" /> of the object that the new <see cref="T:System.Runtime.Remoting.ObjRef" /> will reference.</span></span></param>
        <summary><span data-ttu-id="fe73e-126">Создает объект, который содержит всю необходимую информацию для создания прокси-сервера, используемого для взаимодействия с удаленным объектом.</span><span class="sxs-lookup"><span data-stu-id="fe73e-126">Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object.</span></span></summary>
        <returns><span data-ttu-id="fe73e-127">Информация, необходимая для создания прокси-сервера.</span><span class="sxs-lookup"><span data-stu-id="fe73e-127">Information required to generate a proxy.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fe73e-128">Метод вызывается удаленными методами создания объектов, такими <xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType> как <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>и. <xref:System.MarshalByRefObject.CreateObjRef%2A></span><span class="sxs-lookup"><span data-stu-id="fe73e-128">The <xref:System.MarshalByRefObject.CreateObjRef%2A> method is called by remote object creation methods such as <xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fe73e-129">В большинстве случаев переопределение этого метода не требуется.</span><span class="sxs-lookup"><span data-stu-id="fe73e-129">In most cases, there is no need to override this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><span data-ttu-id="fe73e-130">Этот экземпляр не является допустимым объектом удаленного взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="fe73e-130">This instance is not a valid remoting object.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="fe73e-131">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="fe73e-131">The immediate caller does not have infrastructure permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="fe73e-132">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="fe73e-132">requires full trust for the immediate caller.</span></span> <span data-ttu-id="fe73e-133">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="fe73e-133">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public object GetLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.GetLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetLifetimeService();" />
      <MemberSignature Language="F#" Value="abstract member GetLifetimeService : unit -&gt; obj&#xA;override this.GetLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.GetLifetimeService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fe73e-134">Извлекает объект обслуживания во время существования, который управляет политикой времени существования данного экземпляра.</span><span class="sxs-lookup"><span data-stu-id="fe73e-134">Retrieves the current lifetime service object that controls the lifetime policy for this instance.</span></span></summary>
        <returns><span data-ttu-id="fe73e-135">Объект типа <see cref="T:System.Runtime.Remoting.Lifetime.ILease" />, используемый для управления политикой времени существования данного экземпляра.</span><span class="sxs-lookup"><span data-stu-id="fe73e-135">An object of type <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> used to control the lifetime policy for this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fe73e-136">Дополнительные сведения о службах времени существования см <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> . в разделе класс.</span><span class="sxs-lookup"><span data-stu-id="fe73e-136">For more information about lifetime services, see the <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="fe73e-137">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="fe73e-137">The immediate caller does not have infrastructure permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="fe73e-138">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="fe73e-138">requires full trust for the immediate caller.</span></span> <span data-ttu-id="fe73e-139">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="fe73e-139">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public virtual object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="abstract member InitializeLifetimeService : unit -&gt; obj&#xA;override this.InitializeLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fe73e-140">Получает объект службы времени существования для управления политикой времени существования для этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="fe73e-140">Obtains a lifetime service object to control the lifetime policy for this instance.</span></span></summary>
        <returns><span data-ttu-id="fe73e-141">Объект типа <see cref="T:System.Runtime.Remoting.Lifetime.ILease" />, используемый для управления политикой времени существования данного экземпляра.</span><span class="sxs-lookup"><span data-stu-id="fe73e-141">An object of type <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> used to control the lifetime policy for this instance.</span></span> <span data-ttu-id="fe73e-142">Этот объект является текущим объектом обслуживания времени существования для данного экземпляра, если таковой существует; в противном случае он является новым объектом обслуживания времени существования, инициализированным значением свойства <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime" />.</span><span class="sxs-lookup"><span data-stu-id="fe73e-142">This is the current lifetime service object for this instance if one exists; otherwise, a new lifetime service object initialized to the value of the <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime" /> property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fe73e-143">Дополнительные сведения о службах времени существования см <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> . в разделе класс.</span><span class="sxs-lookup"><span data-stu-id="fe73e-143">For more information about lifetime services, see the <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fe73e-144">В следующем примере кода показано создание аренды.</span><span class="sxs-lookup"><span data-stu-id="fe73e-144">The following code example demonstrates creating a lease.</span></span>  
  
 [!code-cpp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CS/source.cs#1)]
 [!code-vb[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="fe73e-145">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="fe73e-145">The immediate caller does not have infrastructure permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="fe73e-146">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="fe73e-146">requires full trust for the immediate caller.</span></span> <span data-ttu-id="fe73e-147">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="fe73e-147">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberwiseClone">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="fe73e-148">Создает неполную копию текущего объекта.</span><span class="sxs-lookup"><span data-stu-id="fe73e-148">Creates a shallow copy of the current object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject MemberwiseClone (bool cloneIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.MarshalByRefObject MemberwiseClone(bool cloneIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.MemberwiseClone(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone (cloneIdentity As Boolean) As MarshalByRefObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject ^ MemberwiseClone(bool cloneIdentity);" />
      <MemberSignature Language="F#" Value="override this.MemberwiseClone : bool -&gt; MarshalByRefObject" Usage="marshalByRefObject.MemberwiseClone cloneIdentity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.MarshalByRefObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cloneIdentity" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cloneIdentity"><span data-ttu-id="fe73e-149">Значение <see langword="false" />, чтобы удалить удостоверение текущего объекта <see cref="T:System.MarshalByRefObject" />, в результате чего при маршалинге объектов через удаленные границы будет присвоено новое удостоверение.</span><span class="sxs-lookup"><span data-stu-id="fe73e-149"><see langword="false" /> to delete the current <see cref="T:System.MarshalByRefObject" /> object's identity, which will cause the object to be assigned a new identity when it is marshaled across a remoting boundary.</span></span> <span data-ttu-id="fe73e-150">В большинстве случаев можно использовать значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="fe73e-150">A value of <see langword="false" /> is usually appropriate.</span></span> <span data-ttu-id="fe73e-151">Значение <see langword="true" /> для копирования удостоверения текущего объекта <see cref="T:System.MarshalByRefObject" /> в его клон, в результате чего вызовы удаленного клиента будут перенаправляться на объект удаленного сервера.</span><span class="sxs-lookup"><span data-stu-id="fe73e-151"><see langword="true" /> to copy the current <see cref="T:System.MarshalByRefObject" /> object's identity to its clone, which will cause remoting client calls to be routed to the remote server object.</span></span></param>
        <summary><span data-ttu-id="fe73e-152">Создает неполную копию текущего объекта <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="fe73e-152">Creates a shallow copy of the current <see cref="T:System.MarshalByRefObject" /> object.</span></span></summary>
        <returns><span data-ttu-id="fe73e-153">Неполная копия текущего объекта <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="fe73e-153">A shallow copy of the current <see cref="T:System.MarshalByRefObject" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fe73e-154">Метод создает неполную копию путем создания нового <xref:System.MarshalByRefObject> объекта, а затем копирует нестатические поля текущего <xref:System.MarshalByRefObject> объекта в новый объект. <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29></span><span class="sxs-lookup"><span data-stu-id="fe73e-154">The <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> method creates a shallow copy by creating a new <xref:System.MarshalByRefObject> object, and then copying the nonstatic fields of the current <xref:System.MarshalByRefObject> object to the new object.</span></span> <span data-ttu-id="fe73e-155">Если поле является типом значения, выполняется побитовая копия поля.</span><span class="sxs-lookup"><span data-stu-id="fe73e-155">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="fe73e-156">Если поле является ссылочным типом, то ссылка копируется, но на объект, на который указывает ссылка, нет; Таким образом, исходный объект и его клон ссылаются на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="fe73e-156">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="fe73e-157">Например, рассмотрим <xref:System.MarshalByRefObject> объект с именем X, который ссылается на объекты a и b. объект B, в свою очередь, ссылается на объект C. Поверхностная копия X создает новый объект x2, который также ссылается на объекты A и B. В отличие от этого, при глубоком копировании X создается новый объект x2, который ссылается на новые объекты a2 и B2, которые являются копиями a и B. B2, в свою очередь, ссылается на новый объект C2, который является копией c. Используйте класс <xref:System.ICloneable> , реализующий интерфейс для выполнения глубокой или полной версии c OPY объекта.</span><span class="sxs-lookup"><span data-stu-id="fe73e-157">For example, consider a <xref:System.MarshalByRefObject> object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy C. Use a class that implements the <xref:System.ICloneable> interface to perform a deep or shallow copy of an object.</span></span>  
  
 <span data-ttu-id="fe73e-158">Удостоверение <xref:System.MarshalByRefObject> объекта определяется как удаленный серверный объект, являющийся целевым объектом удаленного вызова клиента.</span><span class="sxs-lookup"><span data-stu-id="fe73e-158">The identity of a <xref:System.MarshalByRefObject> object is defined as the remote server object that is the target of a remoting client call.</span></span> <span data-ttu-id="fe73e-159">По умолчанию клон <xref:System.MarshalByRefObject> почленном объекта имеет то же удостоверение, что и исходный объект, что обычно не является правильным поведением для клонов серверных объектов, которые маршалируются через границу удаленного взаимодействия на сторону клиента.</span><span class="sxs-lookup"><span data-stu-id="fe73e-159">By default, the memberwise clone of a <xref:System.MarshalByRefObject> object has the same identity as the original object, which is typically not the correct behavior for clones of server-side objects that are marshaled across a remoting boundary to the client side.</span></span> <span data-ttu-id="fe73e-160">Чтобы `false`удалить удостоверение клона и создать новое удостоверение, которое будет назначено при маршалинге клона через границу удаленного взаимодействия, или сделать так `true` , чтобы клон сохранил идентификатор исходного объекта,следуетуказать,чтообычноподходит.<xref:System.MarshalByRefObject> объект.</span><span class="sxs-lookup"><span data-stu-id="fe73e-160">Specify `false`, which is usually appropriate, to delete the identity of the clone and cause a new identity to be assigned when the clone is marshaled across a remoting boundary, or `true` to cause the clone to retain the identity of the original <xref:System.MarshalByRefObject> object.</span></span> <span data-ttu-id="fe73e-161"><xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> Метод предназначен для использования разработчиками, реализующими объекты удаленных серверов.</span><span class="sxs-lookup"><span data-stu-id="fe73e-161">The <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> method is intended to be used by developers implementing remote server objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
