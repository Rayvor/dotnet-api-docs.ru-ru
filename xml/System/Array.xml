<Type Name="Array" FullName="System.Array">
  <Metadata><Meta Name="ms.openlocfilehash" Value="999887affdc0a76811fd7d2ef33dedec742223a7" /><Meta Name="ms.sourcegitcommit" Value="97dd2e4ee16a6215aef37f928d45e872fc816c6f" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="01/02/2020" /><Meta Name="ms.locfileid" Value="75615242" /></Metadata><TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет методы для создания, изменения, поиска и сортировки массивов, то есть выступает в роли базового класса для всех массивов в среде CLR.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Array> не является частью пространства имен <xref:System.Collections>. Тем не менее, он все равно считается коллекцией, так как он основан на интерфейсе <xref:System.Collections.IList>.  
  
 Класс <xref:System.Array> является базовым классом для реализаций языков, поддерживающих массивы. Однако только система и компиляторы могут явно наследовать от класса <xref:System.Array>. Пользователи должны применять конструкции массивов, предоставляемые языком.  
  
 Элемент — это значение в <xref:System.Array>. Длина <xref:System.Array> — общее количество элементов, которое может содержать массив. Нижняя граница <xref:System.Array> — это индекс его первого элемента. <xref:System.Array> может иметь любую нижнюю границу, но по умолчанию его нижняя граница равна нулю. Другая нижняя граница может быть определена при создании экземпляра <xref:System.Array> с помощью <xref:System.Array.CreateInstance%2A>. Многомерный массив <xref:System.Array> может иметь разные границы в каждом измерении. Массив может иметь не более 32 измерений.  
  
 В отличие от классов в пространстве имен <xref:System.Collections>, <xref:System.Array> имеет фиксированную емкость. Чтобы увеличить емкость, необходимо создать новый объект <xref:System.Array> с требуемой емкостью, скопировать элементы из старого объекта <xref:System.Array> в новый, а затем удалить старый <xref:System.Array>.  

 Размер массива ограничен максимальным количеством элементов — 4 миллиарда, а также максимальным индексом 0X7FEFFFFF в любом заданном измерении (0X7FFFFFC7 для массивов байтов и однобайтовых структур).
  
 **.NET framework:** По умолчанию максимальный размер <xref:System.Array> составляет 2 гигабайта (ГБ). В 64-разрядной среде можно избежать ограничения на размер, установив значение атрибута `enabled` элемента конфигурации [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) равным `true` в среде выполнения.
  
 Одномерные массивы реализуют универсальные интерфейсы <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> и <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType>. Реализации предоставляются массивам во время выполнения, и таким образом, универсальные интерфейсы не отображаются в синтаксисе объявления класса <xref:System.Array>. Кроме того, не существует справочных разделов для членов интерфейса, которые доступны только путем приведения массива к типу универсального интерфейса (явные реализации интерфейса). Ключевой момент, который необходимо учитывать при приведении массива к одному из этих интерфейсов, заключается в том, что члены, которые добавляют, вставляют или удаляют элементы, вызывают исключение <xref:System.NotSupportedException>.  
  
 Объекты <xref:System.Type> предоставляют сведения об объявлениях типов массивов. Объекты <xref:System.Array> с тем же типом массива имеют одинаковые объекты <xref:System.Type>.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> и <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> могут не возвращать ожидаемые результаты с <xref:System.Array>, потому что при приведении массива к типу <xref:System.Array> результат — это объект, который не является массивом. То есть `typeof(System.Array).IsArray` возвращает `false`, а `typeof(System.Array).GetElementType` возвращает `null`.  
  
 Метод <xref:System.Array.Copy%2A?displayProperty=nameWithType> копирует элементы не только между массивами одного типа, но и между стандартными массивами различных типов; он автоматически осуществляет приведение типов.  
  
 Некоторые методы, например <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A> и <xref:System.Array.SetValue%2A>, предоставляют перегрузки, принимающие 64-разрядные целые числа в качестве параметров, для обеспечения возможности работы с массивами большой емкости. <xref:System.Array.LongLength%2A> и <xref:System.Array.GetLongLength%2A> возвращают 64-разрядные целые числа, указывающие длину массива.  
  
 Сортировка <xref:System.Array> не гарантируется.  Перед выполнением операций, для которых требуется сортировка <xref:System.Array> (например, <xref:System.Array.BinarySearch%2A>), <xref:System.Array> нужно предварительно отсортировать.  
  
 Использование объектов <xref:System.Array> указателей в машинном коде не поддерживается и вызывает исключение <xref:System.NotSupportedException> для нескольких методов.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]
 
 В следующем примере кода показано использование <xref:System.Array.Copy%2A?displayProperty=nameWithType> для копирования элементов между массивом целочисленного типа и массивом объектов типа <xref:System.Object>.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 В следующем примере кода создается и инициализируется <xref:System.Array> и отображаются его свойства и элементы.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp-interactive[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Открытые статические (<see langword="Shared" /> в Visual Basic) члены этого типа являются потокобезопасными. Потокобезопасность членов экземпляров не гарантируется.  
  
Эта реализация не предоставляет синхронизированную (потокобезопасную) оболочку для <see cref="T:System.Array" />, однако классы .NET Framework, основанные на <see cref="T:System.Array" />, предоставляют собственную синхронизированную версию коллекции с помощью свойства <see cref="P:System.Array.SyncRoot" />.  
  
Перечисление коллекции не является потокобезопасной процедурой. Даже если коллекция синхронизирована, другие потоки могут ее изменить, что приведет к тому, что перечислитель создаст исключение. Для обеспечения потокобезопасности при перечислении можно либо заблокировать коллекцию на все время перечисления, либо перехватывать исключения, возникающие в результате изменений, внесенных другими потоками.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">Массивы (Руководство по программированию на C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Массивы в Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный индексируемый от нуля массив, для которого создается доступная только для чтения программа-оболочка <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</param>
        <summary>Возвращает для заданного массива доступную только для чтения программу-оболочку.</summary>
        <returns>Доступная только для чтения оболочка <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> для указанного массива.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы предотвратить любые изменения в массиве, предоставляйте массив только через эту оболочку.  
  
 Коллекция, доступная только для чтения, — это просто коллекция с оболочкой, которая предотвращает изменение коллекции. Таким образом, если в базовую коллекцию вносятся изменения, то эти изменения отражаются в коллекции только для чтения.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере массив переносится в <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>только для чтения.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск значения в отсортированном одномерном массиве <see cref="T:System.Array" />, используя для этого алгоритм двоичного поиска.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, в котором выполняется поиск.</param>
        <param name="value">Объект, который нужно найти.</param>
        <summary>Выполняет поиск заданного элемента во всем отсортированном одномерном массиве, используя интерфейс <see cref="T:System.IComparable" />, реализуемый каждым элементом массива и заданным объектом.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивов, содержащих отрицательные индексы. перед вызовом этого метода необходимо выполнить сортировку `array`.  
  
 Если <xref:System.Array> не содержит указанное значение, метод возвращает отрицательное целое число. Оператор побитового дополнения (~ в C#, `Not` в Visual Basic) можно применить к отрицательному результату для создания индекса. Если этот индекс больше, чем верхняя граница массива, в массиве отсутствуют элементы, превышающие `value`. В противном случае это индекс первого элемента, размер которого больше `value`.  
  
 Либо `value`, либо каждый элемент `array` должен реализовывать интерфейс <xref:System.IComparable>, который используется для сравнений. Элементы `array` должны уже быть отсортированы по возрастанию в соответствии с порядком сортировки, определяемым реализацией <xref:System.IComparable>. в противном случае результат может быть неверным.  
  
> [!NOTE]
>  Если`value` не реализует интерфейс <xref:System.IComparable>, перед началом поиска элементы `array` не проверяются на <xref:System.IComparable>. Если при поиске обнаруживается элемент, который не реализует <xref:System.IComparable>, возникает исключение.  
  
 Допускаются дублирующиеся элементы. Если <xref:System.Array> содержит более одного элемента, равного `value`, метод возвращает индекс только одного из вхождений, а не обязательно первого.  
  
 `null` всегда можно сравнивать с любым другим ссылочным типом; Поэтому сравнения с `null` не создают исключение.  
  
> [!NOTE]
>  Для каждого протестированного элемента `value` передается в соответствующую реализацию <xref:System.IComparable>, даже если `value` `null`. Это значит, что <xref:System.IComparable> реализация определяет, как заданный элемент сравнивается с `null`.  
  
 Этот метод является операцией O (log `n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Array.BinarySearch%2A> для нахождение определенного объекта в <xref:System.Array>.  
  
> [!NOTE]
>  Массив создается с его элементами в порядке сортировки по возрастанию. Для метода <xref:System.Array.BinarySearch%2A> требуется, чтобы массив был отсортирован в возрастающем порядке.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> относится к типу, который несовместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> не реализует интерфейс <see cref="T:System.IComparable" />, и поиск обнаруживает элемент, который не реализует интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, в котором выполняется поиск.</param>
        <param name="value">Объект, который нужно найти.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Выполняет поиск значения во всем отсортированном одномерном массиве, используя указанный универсальный интерфейс <see cref="T:System.Collections.IComparer" />.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивов, содержащих отрицательные индексы. перед вызовом этого метода необходимо выполнить сортировку `array`.  
  
 Если <xref:System.Array> не содержит указанное значение, метод возвращает отрицательное целое число. Оператор побитового дополнения (~ в C#, `Not` в Visual Basic) можно применить к отрицательному результату для создания индекса. Если этот индекс больше, чем верхняя граница массива, в массиве отсутствуют элементы, превышающие `value`. В противном случае это индекс первого элемента, размер которого больше `value`.  
  
 Функция сравнения позволяет настроить сравнение элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> в качестве компаратора для выполнения поиска строк без учета регистра.  
  
 Если `comparer` не `null`, элементы `array` сравниваются с указанным значением, используя указанную реализацию <xref:System.Collections.IComparer>. Элементы `array` должны уже быть отсортированы по возрастанию значений в соответствии с порядком сортировки, определенным `comparer`; в противном случае результат может быть неверным.  
  
 Если`comparer` `null`, сравнение выполняется с помощью реализации <xref:System.IComparable>, предоставляемой самим элементом или указанным значением. Элементы `array` должны уже быть отсортированы по возрастанию в соответствии с порядком сортировки, определяемым реализацией <xref:System.IComparable>. в противном случае результат может быть неверным.  
  
> [!NOTE]
>  Если `comparer` имеет `null` и `value` не реализует интерфейс <xref:System.IComparable>, то перед началом поиска элементы `array` не проверяются на <xref:System.IComparable>. Если при поиске обнаруживается элемент, который не реализует <xref:System.IComparable>, возникает исключение.  
  
 Допускаются дублирующиеся элементы. Если <xref:System.Array> содержит более одного элемента, равного `value`, метод возвращает индекс только одного из вхождений, а не обязательно первого.  
  
 `null` всегда можно сравнивать с любым другим ссылочным типом; Поэтому сравнения с `null` не создают исключение.  
  
> [!NOTE]
>  Для каждого протестированного элемента `value` передается в соответствующую реализацию <xref:System.IComparable>, даже если `value` `null`. Это значит, что <xref:System.IComparable> реализация определяет, как заданный элемент сравнивается с `null`.  
  
 Этот метод является операцией O (log `n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> имеет значение <see langword="null" />, и <paramref name="value" /> относится к типу, который несовместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, <paramref name="value" /> не реализует интерфейс <see cref="T:System.IComparable" />, а при поиске обнаруживается элемент, который не реализует интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, в котором выполняется поиск.</param>
        <param name="index">Начальный индекс диапазона поиска.</param>
        <param name="length">Длина диапазона поиска.</param>
        <param name="value">Объект, который нужно найти.</param>
        <summary>Выполняет поиск значения в диапазоне элементов отсортированного одномерного массива, используя интерфейс <see cref="T:System.IComparable" />, реализуемый каждым элементом массива и заданным значением.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивов, содержащих отрицательные индексы. перед вызовом этого метода необходимо выполнить сортировку `array`.  
  
 Если <xref:System.Array> не содержит указанное значение, метод возвращает отрицательное целое число. Оператор побитового дополнения (~ в C#, `Not` в Visual Basic) можно применить к отрицательному результату для создания индекса. Если этот индекс больше, чем верхняя граница массива, в массиве отсутствуют элементы, превышающие `value`. В противном случае это индекс первого элемента, размер которого больше `value`.  
  
 Либо `value`, либо каждый элемент `array` должен реализовывать интерфейс <xref:System.IComparable>, который используется для сравнений. Элементы `array` должны уже быть отсортированы по возрастанию в соответствии с порядком сортировки, определяемым реализацией <xref:System.IComparable>. в противном случае результат может быть неверным.  
  
> [!NOTE]
>  Если `value` не реализует интерфейс <xref:System.IComparable>, перед началом поиска элементы `array` не проверяются на <xref:System.IComparable>. Если при поиске обнаруживается элемент, который не реализует <xref:System.IComparable>, возникает исключение.  
  
 Допускаются дублирующиеся элементы. Если <xref:System.Array> содержит более одного элемента, равного `value`, метод возвращает индекс только одного из вхождений, а не обязательно первого.  
  
 `null` всегда можно сравнивать с любым другим ссылочным типом; Поэтому сравнения с `null` не создают исключение.  
  
> [!NOTE]
>  Для каждого протестированного элемента `value` передается в соответствующую реализацию <xref:System.IComparable>, даже если `value` `null`. Это значит, что <xref:System.IComparable> реализация определяет, как заданный элемент сравнивается с `null`.  
  
 Этот метод является операцией O (log `n`), где `n` `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.  
  
-или- 
 <paramref name="value" /> относится к типу, который не совместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> не реализует интерфейс <see cref="T:System.IComparable" />, и поиск обнаруживает элемент, который не реализует интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, в котором выполняется поиск.</param>
        <param name="index">Начальный индекс диапазона поиска.</param>
        <param name="length">Длина диапазона поиска.</param>
        <param name="value">Объект, который нужно найти.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Выполняет поиск значения в диапазоне элементов отсортированного одномерного массива, используя указанный интерфейс <see cref="T:System.Collections.IComparer" />.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивов, содержащих отрицательные индексы. перед вызовом этого метода необходимо выполнить сортировку `array`.  
  
 Если <xref:System.Array> не содержит указанное значение, метод возвращает отрицательное целое число. Оператор побитового дополнения (~ в C#, `Not` в Visual Basic) можно применить к отрицательному результату для создания индекса. Если этот индекс больше, чем верхняя граница массива, в массиве отсутствуют элементы, превышающие `value`. В противном случае это индекс первого элемента, размер которого больше `value`.  
  
 Функция сравнения позволяет настроить сравнение элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> в качестве компаратора для выполнения поиска строк без учета регистра.  
  
 Если `comparer` не `null`, элементы `array` сравниваются с указанным значением, используя указанную реализацию <xref:System.Collections.IComparer>. Элементы `array` должны уже быть отсортированы по возрастанию значений в соответствии с порядком сортировки, определенным `comparer`; в противном случае результат может быть неверным.  
  
 Если `comparer` `null`, сравнение выполняется с помощью реализации <xref:System.IComparable>, предоставляемой самим элементом или указанным значением. Элементы `array` должны уже быть отсортированы по возрастанию в соответствии с порядком сортировки, определяемым реализацией <xref:System.IComparable>. в противном случае результат может быть неверным.  
  
> [!NOTE]
>  Если `comparer` имеет `null` и `value` не реализует интерфейс <xref:System.IComparable>, то перед началом поиска элементы `array` не проверяются на <xref:System.IComparable>. Если при поиске обнаруживается элемент, который не реализует <xref:System.IComparable>, возникает исключение.  
  
 Допускаются дублирующиеся элементы. Если <xref:System.Array> содержит более одного элемента, равного `value`, метод возвращает индекс только одного из вхождений, а не обязательно первого.  
  
 `null` всегда можно сравнивать с любым другим ссылочным типом; Поэтому при использовании <xref:System.IComparable>сравнения с `null` не создают исключение.  
  
> [!NOTE]
>  Для каждого протестированного элемента `value` передается в соответствующую реализацию <xref:System.IComparable>, даже если `value` `null`. Это значит, что <xref:System.IComparable> реализация определяет, как заданный элемент сравнивается с `null`.  
  
 Этот метод является операцией O (log `n`), где `n` `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.  
  
-или- 
 <paramref name="comparer" /> имеет значение <see langword="null" />, и <paramref name="value" /> относится к типу, который несовместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, <paramref name="value" /> не реализует интерфейс <see cref="T:System.IComparable" />, а при поиске обнаруживается элемент, который не реализует интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором выполняется поиск.</param>
        <param name="value">Объект, который нужно найти.</param>
        <summary>Выполняет поиск заданного элемента во всем отсортированном одномерном массиве, используя для этого универсальный интерфейс <see cref="T:System.IComparable`1" />, реализуемый каждым элементом массива <see cref="T:System.Array" /> и заданным объектом.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивов, содержащих отрицательные индексы. перед вызовом этого метода необходимо выполнить сортировку `array`.  
  
 Если `array` не содержит указанное значение, метод возвращает отрицательное целое число. Оператор побитового дополнения (~ в C#, `Not` в Visual Basic) можно применить к отрицательному результату для создания индекса. Если этот индекс равен размеру массива, в массиве отсутствуют элементы, превышающие `value`. В противном случае это индекс первого элемента, размер которого больше `value`.  
  
 `T` должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, который используется для сравнений. Элементы `array` должны уже быть отсортированы по возрастанию в соответствии с порядком сортировки, определяемым реализацией <xref:System.IComparable%601>. в противном случае результат может быть неверным.  
  
 Допускаются дублирующиеся элементы. Если <xref:System.Array> содержит более одного элемента, равного `value`, метод возвращает индекс только одного из вхождений, а не обязательно первого.  
  
 `null` всегда можно сравнивать с любым другим ссылочным типом; Поэтому сравнения с `null` не создают исключение.  
  
> [!NOTE]
>  Для каждого протестированного элемента `value` передается в соответствующую реализацию <xref:System.IComparable%601>, даже если `value` `null`. Это значит, что <xref:System.IComparable%601> реализация определяет, как заданный элемент сравнивается с `null`.  
  
 Этот метод является операцией O (log `n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется перегрузка универсального метода <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ная перегрузка универсального метода. Создается массив строк без определенного порядка.  
  
 Массив отображается, сортируется и отображается снова. Для использования метода <xref:System.Array.BinarySearch%2A> массивы должны быть отсортированы.  
  
> [!NOTE]
>  Вызовы методов <xref:System.Array.Sort%2A> и <xref:System.Array.BinarySearch%2A> не отличаются от вызовов к неуниверсальным аналогам, поскольку Visual Basic, C#и C++ определяют тип параметра универсального типа из типа первого аргумента. Если вы используете [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы изучить MSIL, можно увидеть, что вызываемые универсальные методы вызываются.  
  
 Перегрузка <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> универсального метода затем используется для поиска двух строк, которые не находятся в массиве, а другая —. Массив и возвращаемое значение метода <xref:System.Array.BinarySearch%2A> передаются в `ShowWhere` универсальный метод, который отображает значение индекса, если строка найдена, и в противном случае элементы, которые строка поиска попадают в массив. Индекс является отрицательным, если строка не находится в массиве, поэтому `ShowWhere` метод принимает побитовое дополнение (оператор ~ в C# и Visual C++, `Xor`-1 в Visual Basic) для получения индекса первого элемента в списке, который больше, чем строка поиска.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> не реализует универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором выполняется поиск.</param>
        <param name="value">Объект, который нужно найти.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable`1" /> каждого элемента.</param>
        <summary>Выполняет поиск значения во всем отсортированном одномерном массиве, используя указанный универсальный интерфейс <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивов, содержащих отрицательные индексы. перед вызовом этого метода необходимо выполнить сортировку `array`.  
  
 Если <xref:System.Array> не содержит указанное значение, метод возвращает отрицательное целое число. Оператор побитового дополнения (~ в C#, `Not` в Visual Basic) можно применить к отрицательному результату для создания индекса. Если этот индекс равен размеру массива, в массиве отсутствуют элементы, превышающие `value`. В противном случае это индекс первого элемента, размер которого больше `value`.  
  
 Функция сравнения позволяет настроить сравнение элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> в качестве компаратора для выполнения поиска строк без учета регистра.  
  
 Если `comparer` не `null`, элементы `array` сравниваются с указанным значением с использованием указанного <xref:System.Collections.Generic.IComparer%601> реализации универсального интерфейса. Элементы `array` должны уже быть отсортированы по возрастанию значений в соответствии с порядком сортировки, определенным `comparer`; в противном случае результат может быть неверным.  
  
 Если `comparer` `null`, сравнение выполняется с помощью <xref:System.IComparable%601> реализации универсального интерфейса, предоставляемой `T`. Элементы `array` должны уже быть отсортированы по возрастанию в соответствии с порядком сортировки, определяемым реализацией <xref:System.IComparable%601>. в противном случае результат может быть неверным.  
  
> [!NOTE]
>  Если `comparer` имеет `null` и `value` не реализует универсальный интерфейс <xref:System.IComparable%601>, элементы `array` не проверяются на <xref:System.IComparable%601> перед началом поиска. Если при поиске обнаруживается элемент, который не реализует <xref:System.IComparable%601>, возникает исключение.  
  
 Допускаются дублирующиеся элементы. Если <xref:System.Array> содержит более одного элемента, равного `value`, метод возвращает индекс только одного из вхождений, а не обязательно первого.  
  
 `null` всегда можно сравнивать с любым другим ссылочным типом; Поэтому сравнения с `null` не создают исключение.  
  
> [!NOTE]
>  Для каждого протестированного элемента `value` передается в соответствующую реализацию <xref:System.IComparable%601>, даже если `value` `null`. Это значит, что <xref:System.IComparable%601> реализация определяет, как заданный элемент сравнивается с `null`.  
  
 Этот метод является операцией O (log `n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере демонстрируется перегрузка универсального метода <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ная перегрузка универсального метода.  
  
 В примере кода определяется альтернативный компаратор для строк с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальном интерфейсе. Функция сравнения вызывает метод <xref:System.String.CompareTo%28System.String%29>, отменяя порядок сравниваемых строк таким образом, чтобы строки были в высоком и низком уровне, а не в высоком.  
  
 Массив отображается, сортируется и отображается снова. Для использования метода <xref:System.Array.BinarySearch%2A> массивы должны быть отсортированы.  
  
> [!NOTE]
>  Вызовы методов <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> не отличаются от вызовов к неуниверсальным аналогам, поскольку Visual Basic, C#и C++ определяют тип параметра универсального типа из типа первого аргумента. Если вы используете [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы изучить MSIL, можно увидеть, что вызываемые универсальные методы вызываются.  
  
 Перегрузка <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> универсального метода затем используется для поиска двух строк, которые не находятся в массиве, а другая —. Массив и возвращаемое значение метода <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> передаются в `ShowWhere` универсальный метод, который отображает значение индекса, если строка найдена, и в противном случае элементы, которые строка поиска попадают в массив. Индекс является отрицательным, если строка не является n массивом, поэтому `ShowWhere` метод принимает побитовое дополнение (оператор ~ в C# и Visual C++, `Xor`-1 в Visual Basic) для получения индекса первого элемента в списке, который больше, чем строка поиска.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> имеет значение <see langword="null" />, а <paramref name="value" /> относится к типу, который несовместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, а <paramref name="T" /> не реализует универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором выполняется поиск.</param>
        <param name="index">Начальный индекс диапазона поиска.</param>
        <param name="length">Длина диапазона поиска.</param>
        <param name="value">Объект, который нужно найти.</param>
        <summary>Выполняет поиск значения в диапазоне элементов отсортированного одномерного массива, используя для этого универсальный интерфейс <see cref="T:System.IComparable`1" />, реализуемый каждым элементом массива <see cref="T:System.Array" /> и заданным значением.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивов, содержащих отрицательные индексы. перед вызовом этого метода необходимо выполнить сортировку `array`.  
  
 Если массив не содержит указанное значение, метод возвращает отрицательное целое число. Оператор побитового дополнения (~ в C#, `Not` в Visual Basic) можно применить к отрицательному результату для создания индекса. Если этот индекс равен размеру массива, в массиве отсутствуют элементы, превышающие `value`. В противном случае это индекс первого элемента, размер которого больше `value`.  
  
 `T` должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, который используется для сравнений. Элементы `array` должны уже быть отсортированы по возрастанию в соответствии с порядком сортировки, определяемым реализацией <xref:System.IComparable%601>. в противном случае результат может быть неверным.  
  
 Допускаются дублирующиеся элементы. Если <xref:System.Array> содержит более одного элемента, равного `value`, метод возвращает индекс только одного из вхождений, а не обязательно первого.  
  
 `null` всегда можно сравнивать с любым другим ссылочным типом; Поэтому сравнения с `null` не создают исключение.  
  
> [!NOTE]
>  Для каждого протестированного элемента `value` передается в соответствующую реализацию <xref:System.IComparable%601>, даже если `value` `null`. Это значит, что <xref:System.IComparable%601> реализация определяет, как заданный элемент сравнивается с `null`.  
  
 Этот метод является операцией O (log `n`), где `n` `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.  
  
-или- 
 <paramref name="value" /> относится к типу, который не совместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> не реализует универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором выполняется поиск.</param>
        <param name="index">Начальный индекс диапазона поиска.</param>
        <param name="length">Длина диапазона поиска.</param>
        <param name="value">Объект, который нужно найти.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable`1" /> каждого элемента.</param>
        <summary>Выполняет поиск значения в диапазоне элементов отсортированного одномерного массива, используя указанный универсальный интерфейс <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивов, содержащих отрицательные индексы. перед вызовом этого метода необходимо выполнить сортировку `array`.  
  
 Если массив не содержит указанное значение, метод возвращает отрицательное целое число. Оператор побитового дополнения (~ в C#, `Not` в Visual Basic) можно применить к отрицательному результату для создания индекса. Если этот индекс равен размеру массива, в массиве отсутствуют элементы, превышающие `value`. В противном случае это индекс первого элемента, размер которого больше `value`.  
  
 Функция сравнения позволяет настроить сравнение элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> в качестве компаратора для выполнения поиска строк без учета регистра.  
  
 Если `comparer` не `null`, элементы `array` сравниваются с указанным значением с использованием указанного <xref:System.Collections.Generic.IComparer%601> реализации универсального интерфейса. Элементы `array` должны уже быть отсортированы по возрастанию значений в соответствии с порядком сортировки, определенным `comparer`; в противном случае результат может быть неверным.  
  
 Если `comparer` `null`, сравнение выполняется с помощью <xref:System.IComparable%601> реализации универсального интерфейса, предоставляемой для типа `T`. Элементы `array` должны уже быть отсортированы по возрастанию в соответствии с порядком сортировки, определяемым реализацией <xref:System.IComparable%601>. в противном случае результат может быть неверным.  
  
 Допускаются дублирующиеся элементы. Если <xref:System.Array> содержит более одного элемента, равного `value`, метод возвращает индекс только одного из вхождений, а не обязательно первого.  
  
 `null` всегда можно сравнивать с любым другим ссылочным типом; Поэтому при использовании <xref:System.IComparable%601>сравнения с `null` не создают исключение.  
  
> [!NOTE]
>  Для каждого протестированного элемента `value` передается в соответствующую реализацию <xref:System.IComparable%601>, даже если `value` `null`. Это значит, что <xref:System.IComparable%601> реализация определяет, как заданный элемент сравнивается с `null`.  
  
 Этот метод является операцией O (log `n`), где `n` `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.  
  
-или- 
 <paramref name="comparer" /> имеет значение <see langword="null" />, и <paramref name="value" /> относится к типу, который несовместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, и <paramref name="T" /> не реализует универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Массив, элементы которого необходимо очистить.</param>
        <param name="index">Начальный индекс диапазона элементов, которые необходимо очистить.</param>
        <param name="length">Число элементов, подлежащих очистке.</param>
        <summary>Задает для диапазона элементов в массиве значение, предусмотренное по умолчанию для каждого типа элементов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод сбрасывает каждый элемент массива в значение по умолчанию для типа элемента. Он устанавливает элементы ссылочных типов (включая <xref:System.String> элементы) в `null`и задает для элементов типов значений значения по умолчанию, приведенные в следующей таблице.  
  
|Type|Значение|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Все числовые типы целочисленных и плавающих точек|Ноль (0)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Другие типы значений|Значения по умолчанию для полей типа|  
  
 Диапазон отключенных элементов переносится по словам от строки к строке в многомерном массиве.  
  
 Этот метод очищает только значения элементов. Он не удаляет сами элементы. Массив имеет фиксированный размер; Поэтому элементы не могут быть добавлены или удалены.  
  
 Этот метод является операцией O (`n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере метод <xref:System.Array.Clear%2A> используется для сброса целочисленных значений в одномерном, двухмерный и трехмерном массиве.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 В следующем примере определяется структура `TimeZoneTime`, которая включает поле <xref:System.TimeZoneInfo> и поле <xref:System.DateTimeOffset>. Затем он вызывает метод <xref:System.Array.Clear%2A>, чтобы очистить один элемент в массиве из двух элементов `TimeZoneTime` значений. Метод задает значение элемента с очисткой по умолчанию для объекта <xref:System.TimeZoneInfo>, который `null`, и значение по умолчанию для объекта <xref:System.DateTimeOffset>, который <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.  
  
-или- 
Сумма <paramref name="index" /> и <paramref name="length" /> больше, чем размер <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Clone() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Clone();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; obj" Usage="array.Clone " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual object Clone ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает неполную копию <see cref="T:System.Array" />.</summary>
        <returns>Неполная копия <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неполная копия <xref:System.Array> копирует только элементы <xref:System.Array>, являются ли они ссылочными типами или типами значений, но не копирует объекты, на которые ссылаются ссылки. Ссылки в новой <xref:System.Array> указывают на те же объекты, на которые ссылки в исходной <xref:System.Array> указывают на.  
  
 В отличие от этого, глубокая копия <xref:System.Array> копирует элементы и все, на которые прямо или косвенно ссылаются элементы.  
  
 Клон имеет тот же <xref:System.Type>, что и исходный <xref:System.Array>.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Array.Length%2A>.  
  
   
  
## Examples  
 В следующем примере кода выполняется клонирование массива <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> и демонстрируется поведение неполной копии.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Массив <see cref="T:System.Array" />, содержащий данные, которые требуется скопировать.</param>
        <param name="sourceIndex">32-разрядное целое число, представляющее индекс в массиве <paramref name="sourceArray" />, с которого начинается копирование.</param>
        <param name="destinationArray">Массив <see cref="T:System.Array" />, принимающий данные.</param>
        <param name="destinationIndex">32-разрядное целое число, представляющее индекс в массиве <paramref name="destinationArray" />, с которого начинается сохранение.</param>
        <param name="length">32-битовое целое число, представляющее число копируемых элементов.</param>
        <summary>Копирует диапазон элементов из массива <see cref="T:System.Array" />, начиная с заданного индекса источника, и вставляет его в другой массив <see cref="T:System.Array" />, начиная с заданного индекса назначения.  Гарантирует, что в случае невозможности успешно скопировать весь диапазон, все изменения будут отменены.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры `sourceArray` и `destinationArray` должны иметь одинаковое число измерений.  Тип `sourceArray` должен быть таким же, как или производный от типа `destinationArray`; в противном случае создается <xref:System.ArrayTypeMismatchException>.  В отличие от <xref:System.Array.Copy%2A><xref:System.Array.ConstrainedCopy%2A> проверяет совместимость типов массивов перед выполнением любой операции.  
  
 При копировании между многомерными массивами массив ведет себя подобно длинному одномерному массиву, где строки (или столбцы) концептуально располагаются сквозно. Например, если массив содержит три строки (или столбца) с четырьмя элементами, то при копировании шести элементов из начала массива будут скопированы все четыре элемента первой строки (или столбца) и первые два элемента второй строки (или столбца). Чтобы начать копирование со второго элемента третьей строки (или столбца), `sourceIndex` должен быть верхней границей первой строки (или столбца) и длиной второй строки (или столбца) плюс два.  
  
 Если `sourceArray` и `destinationArray` перекрываются, этот метод ведет себя так, как будто исходные значения `sourceArray` были сохранены во временном расположении перед перезазаписью `destinationArray`.  
  
 [C++]  
  
 Этот метод эквивалентен стандарту `memmove`C/C++ Function, но не `memcpy`.  
  
 Массивы могут быть массивами ссылочного типа или массивами значений.  Если `sourceArray` и `destinationArray` являются массивами ссылочного типа или оба массива типа <xref:System.Object>, выполняется неполная копия. Неполная копия <xref:System.Array> — это новый <xref:System.Array>, содержащий ссылки на те же элементы, что и исходный <xref:System.Array>. Сами элементы или все, на которые ссылаются элементы, не копируются. В отличие от этого, глубокая копия <xref:System.Array> копирует элементы и все, на которые прямо или косвенно ссылаются элементы.  
  
 Если этот метод вызывает исключение при копировании, `destinationArray` остается без изменений; Таким образом, <xref:System.Array.ConstrainedCopy%2A> можно использовать в области ограниченного выполнения (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 Этот метод является операцией O (`n`), где `n` `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="destinationArray" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют различные ранги.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Тип <paramref name="sourceArray" /> не совпадает с типом <paramref name="destinationArray" /> и не является производным от него.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в <paramref name="sourceArray" /> не может быть приведен к типу <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> меньше, чем нижняя граница первого измерения массива <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="destinationIndex" /> меньше, чем нижняя граница первого измерения массива <paramref name="destinationArray" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> больше числа элементов с <paramref name="sourceIndex" /> до конца <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="length" /> больше числа элементов с <paramref name="destinationIndex" /> до конца <paramref name="destinationArray" />.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Тип элементов исходного массива.</typeparam>
        <typeparam name="TOutput">Тип элементов массива назначения.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и который преобразуется в целевой тип.</param>
        <param name="converter">Объект <see cref="T:System.Converter`2" />, преобразующий каждый элемент из одного типа в другой.</param>
        <summary>Преобразует массив одного типа в массив другого типа.</summary>
        <returns>Массив целевого типа, содержащий преобразованные элементы исходного массива.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> является делегатом для метода, который преобразует объект в целевой тип.  Элементы `array` по отдельности передаются <xref:System.Converter%602>, а преобразованные элементы сохраняются в новом массиве.  
  
 Исходный `array` остается неизменным.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере кода определяется метод с именем `PointFToPoint`, который преобразует структуру <xref:System.Drawing.PointF> в структуру <xref:System.Drawing.Point>. Затем в примере создается массив структур <xref:System.Drawing.PointF>, создается `Converter<PointF, Point>` делегат (`Converter(Of PointF, Point)` в Visual Basic) для представления метода `PointFToPoint` и передает делегат в метод <xref:System.Array.ConvertAll%2A>. Метод <xref:System.Array.ConvertAll%2A> передает каждый элемент входного списка методу `PointFToPoint` и помещает преобразованные элементы в новый список структур <xref:System.Drawing.Point>. Отобразятся оба списка.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="converter" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует диапазон элементов из одного массива <see cref="T:System.Array" /> в другой массив <see cref="T:System.Array" /> и при необходимости выполняет приведение типов и упаковку-преобразование.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Массив <see cref="T:System.Array" />, содержащий данные, которые требуется скопировать.</param>
        <param name="destinationArray">Массив <see cref="T:System.Array" />, принимающий данные.</param>
        <param name="length">32-битовое целое число, представляющее число копируемых элементов.</param>
        <summary>Копирует диапазон элементов из массива <see cref="T:System.Array" />, начиная с первого элемента, и вставляет его в другой массив <see cref="T:System.Array" />, также начиная с первого элемента. Длина задается как 32-битовое целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры `sourceArray` и `destinationArray` должны иметь одинаковое число измерений. Кроме того, `destinationArray` уже должен быть измерен и должен иметь достаточное количество элементов для размещения скопированных данных.  
  
 При копировании между многомерными массивами массив ведет себя как длинный одномерный массив, где строки (или столбцы) концептуально располагаются в конечном итоге. Например, если массив содержит три строки (или столбца) с четырьмя элементами, то при копировании шести элементов из начала массива будут скопированы все четыре элемента первой строки (или столбца) и первые два элемента второй строки (или столбца).  
  
 Если `sourceArray` и `destinationArray` перекрываются, этот метод ведет себя так, как будто исходные значения `sourceArray` были сохранены во временном расположении перед перезазаписью `destinationArray`.  
  
 [C++]  
  
 Этот метод эквивалентен стандарту `memmove`C/C++ Function, но не `memcpy`.  
  
 Массивы могут быть массивами ссылочного типа или массивами значений. При необходимости выполняется приведение типов.  
  
-   При копировании из массива ссылочного типа в массив типа значения каждый элемент распаковывается, а затем копируется. При копировании из массива типа значения в массив ссылочного типа каждый элемент упаковывается, а затем копируется.  
  
-   При копировании из массива ссылочного типа или типа значений в массив <xref:System.Object> создается <xref:System.Object> для хранения каждого значения или ссылки, а затем копируется. При копировании из массива <xref:System.Object> в массив ссылочного типа или типа значений, и присваивание невозможно, создается <xref:System.InvalidCastException>.  
  
-   Если `sourceArray` и `destinationArray` являются массивами ссылочного типа или оба массива типа <xref:System.Object>, выполняется неполная копия. Неполная копия <xref:System.Array> — это новый <xref:System.Array>, содержащий ссылки на те же элементы, что и исходный <xref:System.Array>. Сами элементы или все, на которые ссылаются элементы, не копируются. В отличие от этого, глубокая копия <xref:System.Array> копирует элементы и все, на которые прямо или косвенно ссылаются элементы.  
  
 Если массивы имеют несовместимые типы, возникает исключение <xref:System.ArrayTypeMismatchException>. Совместимость типов определяется следующим образом:  
  
-   Тип является совместимым с самим собой.  
  
-   Тип значения совместим с <xref:System.Object> и с типом интерфейса, реализованным этим типом значения. Тип значения считается подключенным к интерфейсу только в том случае, если он реализует этот интерфейс напрямую. Отключенные типы несовместимы.  
  
-   Два встроенных (предопределенные) типа значений совместимы, если копирование из исходного типа в целевой тип является расширяющим преобразованием. Расширяющее преобразование никогда не теряет информацию, в то время как понижающие преобразования могут потерять информацию. Например, преобразование 32-разрядного целого числа со знаком в 64-разрядное целое число со знаком является расширяющим преобразованием, а преобразование 64-разрядного целого числа со знаком в 32-разрядное целое число — это понижающие преобразования. Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
-   Невстроенный тип значения (определяемый пользователем) совместим только с самим собой.  
  
-   Перечисления имеют неявное преобразование в <xref:System.Enum> и их базовый тип.  
  
 Если каждому элементу в `sourceArray` требуется наследование (например, от базового класса до производного класса или от интерфейса к объекту), а один или несколько элементов не могут быть приведены к соответствующему типу в `destinationArray`, создается исключение <xref:System.InvalidCastException>.  
  
 Если при копировании этот метод вызывает исключение, состояние `destinationArray` не определено.  
  
 Этот метод является операцией O (`n`), где `n` `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="destinationArray" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют различные ранги.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют несовместимые типы.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в <paramref name="sourceArray" /> не может быть приведен к типу <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> больше числа элементов в <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="length" /> больше числа элементов в <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Массив <see cref="T:System.Array" />, содержащий данные, которые требуется скопировать.</param>
        <param name="destinationArray">Массив <see cref="T:System.Array" />, принимающий данные.</param>
        <param name="length">64-битовое целое число, представляющее число копируемых элементов. Целое число должно лежать в диапазоне от 0 до <see cref="F:System.Int32.MaxValue" /> включительно.</param>
        <summary>Копирует диапазон элементов из массива <see cref="T:System.Array" />, начиная с первого элемента, и вставляет его в другой массив <see cref="T:System.Array" />, также начиная с первого элемента. Длина задается как 64-битовое целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры `sourceArray` и `destinationArray` должны иметь одинаковое число измерений. Кроме того, `destinationArray` уже должен быть измерен и должен иметь достаточное количество элементов для размещения скопированных данных.  
  
 При копировании между многомерными массивами массив ведет себя как длинный одномерный массив, где строки (или столбцы) концептуально располагаются в конечном итоге. Например, если массив содержит три строки (или столбца) с четырьмя элементами, то при копировании шести элементов из начала массива будут скопированы все четыре элемента первой строки (или столбца) и первые два элемента второй строки (или столбца).  
  
 Если `sourceArray` и `destinationArray` перекрываются, этот метод ведет себя так, как будто исходные значения `sourceArray` были сохранены во временном расположении перед перезазаписью `destinationArray`.  
  
 [C++]  
  
 Этот метод эквивалентен стандарту `memmove`C/C++ Function, но не `memcpy`.  
  
 Массивы могут быть массивами ссылочного типа или массивами значений. При необходимости выполняется приведение типов.  
  
-   При копировании из массива ссылочного типа в массив типа значения каждый элемент распаковывается, а затем копируется. При копировании из массива типа значения в массив ссылочного типа каждый элемент упаковывается, а затем копируется.  
  
-   При копировании из массива ссылочного типа или типа значений в массив <xref:System.Object> создается <xref:System.Object> для хранения каждого значения или ссылки, а затем копируется. При копировании из массива <xref:System.Object> в массив ссылочного типа или типа значений, и присваивание невозможно, создается <xref:System.InvalidCastException>.  
  
-   Если `sourceArray` и `destinationArray` являются массивами ссылочного типа или оба массива типа <xref:System.Object>, выполняется неполная копия. Неполная копия <xref:System.Array> — это новый <xref:System.Array>, содержащий ссылки на те же элементы, что и исходный <xref:System.Array>. Сами элементы или все, на которые ссылаются элементы, не копируются. В отличие от этого, глубокая копия <xref:System.Array> копирует элементы и все, на которые прямо или косвенно ссылаются элементы.  
  
 Если массивы имеют несовместимые типы, возникает исключение <xref:System.ArrayTypeMismatchException>. Совместимость типов определяется следующим образом:  
  
-   Тип является совместимым с самим собой.  
  
-   Тип значения совместим с <xref:System.Object> и с типом интерфейса, реализованным этим типом значения. Тип значения считается подключенным к интерфейсу только в том случае, если он реализует этот интерфейс напрямую. Отключенные типы несовместимы.  
  
-   Два встроенных (предопределенные) типа значений совместимы, если копирование из исходного типа в целевой тип является расширяющим преобразованием. Расширяющее преобразование никогда не теряет информацию, в то время как понижающие преобразования могут потерять информацию. Например, преобразование 32-разрядного целого числа со знаком в 64-разрядное целое число со знаком является расширяющим преобразованием, а преобразование 64-разрядного целого числа со знаком в 32-разрядное целое число — это понижающие преобразования. Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
-   Невстроенный тип значения (определяемый пользователем) совместим только с самим собой.  
  
-   Перечисления имеют неявное преобразование в <xref:System.Enum> и их базовый тип.  
  
 Если каждому элементу в `sourceArray` требуется наследование (например, от базового класса до производного класса или от интерфейса к объекту), а один или несколько элементов не могут быть приведены к соответствующему типу в `destinationArray`, создается исключение <xref:System.InvalidCastException>.  
  
 Если при копировании этот метод вызывает исключение, состояние `destinationArray` не определено.  
  
 Этот метод является операцией O (`n`), где `n` `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="destinationArray" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют различные ранги.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют несовместимые типы.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в <paramref name="sourceArray" /> не может быть приведен к типу <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="length" /> имеет значение меньше 0 или больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> больше числа элементов в <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="length" /> больше числа элементов в <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Массив <see cref="T:System.Array" />, содержащий данные, которые требуется скопировать.</param>
        <param name="sourceIndex">32-разрядное целое число, представляющее индекс в массиве <paramref name="sourceArray" />, с которого начинается копирование.</param>
        <param name="destinationArray">Массив <see cref="T:System.Array" />, принимающий данные.</param>
        <param name="destinationIndex">32-разрядное целое число, представляющее индекс в массиве <paramref name="destinationArray" />, с которого начинается сохранение.</param>
        <param name="length">32-битовое целое число, представляющее число копируемых элементов.</param>
        <summary>Копирует диапазон элементов из массива <see cref="T:System.Array" />, начиная с заданного индекса источника, и вставляет его в другой массив <see cref="T:System.Array" />, начиная с заданного индекса назначения. Длина и индексы задаются как 32-битовые целые числа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры `sourceArray` и `destinationArray` должны иметь одинаковое число измерений. Кроме того, `destinationArray` должны уже быть изменены в измерении и иметь достаточное количество элементов, начиная от расположения `destinationIndex`, чтобы разместить скопированные данные.  
  
 При копировании между многомерными массивами массив ведет себя подобно длинному одномерному массиву, где строки (или столбцы) концептуально располагаются сквозно. Например, если массив содержит три строки (или столбца) с четырьмя элементами, то при копировании шести элементов из начала массива будут скопированы все четыре элемента первой строки (или столбца) и первые два элемента второй строки (или столбца). Чтобы начать копирование со второго элемента третьей строки (или столбца), `sourceIndex` должен быть верхней границей первой строки (или столбца) и длиной второй строки (или столбца) плюс два.  
  
 Если `sourceArray` и `destinationArray` перекрываются, этот метод ведет себя так, как будто исходные значения `sourceArray` были сохранены во временном расположении перед перезазаписью `destinationArray`.  
  
 [C++]  
  
 Этот метод эквивалентен стандарту `memmove`C/C++ Function, но не `memcpy`.  
  
 Массивы могут быть массивами ссылочного типа или массивами значений. При необходимости выполняется приведение типов.  
  
-   При копировании из массива ссылочного типа в массив типа значения каждый элемент распаковывается, а затем копируется. При копировании из массива типа значения в массив ссылочного типа каждый элемент упаковывается, а затем копируется.  
  
-   При копировании из массива ссылочного типа или типа значений в массив <xref:System.Object> создается <xref:System.Object> для хранения каждого значения или ссылки, а затем копируется. При копировании из массива <xref:System.Object> в массив ссылочного типа или типа значений, и присваивание невозможно, создается <xref:System.InvalidCastException>.  
  
-   Если `sourceArray` и `destinationArray` являются массивами ссылочного типа или оба массива типа <xref:System.Object>, выполняется неполная копия. Неполная копия <xref:System.Array> — это новый <xref:System.Array>, содержащий ссылки на те же элементы, что и исходный <xref:System.Array>. Сами элементы или все, на которые ссылаются элементы, не копируются. В отличие от этого, глубокая копия <xref:System.Array> копирует элементы и все, на которые прямо или косвенно ссылаются элементы.  
  
 Если массивы имеют несовместимые типы, возникает исключение <xref:System.ArrayTypeMismatchException>. Совместимость типов определяется следующим образом:  
  
-   Тип является совместимым с самим собой.  
  
-   Тип значения совместим с <xref:System.Object> и с типом интерфейса, реализованным этим типом значения. Тип значения считается подключенным к интерфейсу только в том случае, если он реализует этот интерфейс напрямую. Отключенные типы несовместимы.  
  
-   Два встроенных (предопределенные) типа значений совместимы, если копирование из исходного типа в целевой тип является расширяющим преобразованием. Расширяющее преобразование никогда не теряет информацию, в то время как понижающие преобразования могут потерять информацию. Например, преобразование 32-разрядного целого числа со знаком в 64-разрядное целое число со знаком является расширяющим преобразованием, а преобразование 64-разрядного целого числа со знаком в 32-разрядное целое число — это понижающие преобразования. Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
-   Невстроенный тип значения (определяемый пользователем) совместим только с самим собой.  
  
-   Перечисления имеют неявное преобразование в <xref:System.Enum> и их базовый тип.  
  
 Если каждому элементу в `sourceArray` требуется наследование (например, от базового класса до производного класса или от интерфейса к объекту), а один или несколько элементов не могут быть приведены к соответствующему типу в `destinationArray`, создается исключение <xref:System.InvalidCastException>.  
  
 Если при копировании этот метод вызывает исключение, состояние `destinationArray` не определено.  
  
 Этот метод является операцией O (`n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как скопировать из одного <xref:System.Array> типа <xref:System.Object> в другой <xref:System.Array> типа Integer.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="destinationArray" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют различные ранги.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют несовместимые типы.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в <paramref name="sourceArray" /> не может быть приведен к типу <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> меньше, чем нижняя граница первого измерения массива <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="destinationIndex" /> меньше, чем нижняя граница первого измерения массива <paramref name="destinationArray" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> больше числа элементов с <paramref name="sourceIndex" /> до конца <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="length" /> больше числа элементов с <paramref name="destinationIndex" /> до конца <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="sourceIndex" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destinationIndex" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length" Type="System.Int64" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Массив <see cref="T:System.Array" />, содержащий данные, которые требуется скопировать.</param>
        <param name="sourceIndex">64-разрядное целое число, представляющее индекс в массиве <paramref name="sourceArray" />, с которого начинается копирование.</param>
        <param name="destinationArray">Массив <see cref="T:System.Array" />, принимающий данные.</param>
        <param name="destinationIndex">64-разрядное целое число, представляющее индекс в массиве <paramref name="destinationArray" />, с которого начинается сохранение.</param>
        <param name="length">64-битовое целое число, представляющее число копируемых элементов. Целое число должно лежать в диапазоне от 0 до <see cref="F:System.Int32.MaxValue" /> включительно.</param>
        <summary>Копирует диапазон элементов из массива <see cref="T:System.Array" />, начиная с заданного индекса источника, и вставляет его в другой массив <see cref="T:System.Array" />, начиная с заданного индекса назначения. Длина и индексы задаются как 64-разрядные целые числа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры `sourceArray` и `destinationArray` должны иметь одинаковое число измерений. Кроме того, `destinationArray` должны уже быть изменены в измерении и иметь достаточное количество элементов, начиная от расположения `destinationIndex`, чтобы разместить скопированные данные.  
  
 При копировании между многомерными массивами массив ведет себя подобно длинному одномерному массиву, где строки (или столбцы) концептуально располагаются сквозно. Например, если массив содержит три строки (или столбца) с четырьмя элементами, то при копировании шести элементов из начала массива будут скопированы все четыре элемента первой строки (или столбца) и первые два элемента второй строки (или столбца). Чтобы начать копирование со второго элемента третьей строки (или столбца), `sourceIndex` должен быть верхней границей первой строки (или столбца) и длиной второй строки (или столбца) плюс два.  
  
 Если `sourceArray` и `destinationArray` перекрываются, этот метод ведет себя так, как будто исходные значения `sourceArray` были сохранены во временном расположении перед перезазаписью `destinationArray`.  
  
 [C++]  
  
 Этот метод эквивалентен стандарту `memmove`C/C++ Function, но не `memcpy`.  
  
 Массивы могут быть массивами ссылочного типа или массивами значений. При необходимости выполняется приведение типов.  
  
-   При копировании из массива ссылочного типа в массив типа значения каждый элемент распаковывается, а затем копируется. При копировании из массива типа значения в массив ссылочного типа каждый элемент упаковывается, а затем копируется.  
  
-   При копировании из массива ссылочного типа или типа значений в массив <xref:System.Object> создается <xref:System.Object> для хранения каждого значения или ссылки, а затем копируется. При копировании из массива <xref:System.Object> в массив ссылочного типа или типа значений, и присваивание невозможно, создается <xref:System.InvalidCastException>.  
  
-   Если `sourceArray` и `destinationArray` являются массивами ссылочного типа или оба массива типа <xref:System.Object>, выполняется неполная копия. Неполная копия <xref:System.Array> — это новый <xref:System.Array>, содержащий ссылки на те же элементы, что и исходный <xref:System.Array>. Сами элементы или все, на которые ссылаются элементы, не копируются. В отличие от этого, глубокая копия <xref:System.Array> копирует элементы и все, на которые прямо или косвенно ссылаются элементы.  
  
 Если массивы имеют несовместимые типы, возникает исключение <xref:System.ArrayTypeMismatchException>. Совместимость типов определяется следующим образом:  
  
-   Тип является совместимым с самим собой.  
  
-   Тип значения совместим с <xref:System.Object> и с типом интерфейса, реализованным этим типом значения. Тип значения считается подключенным к интерфейсу только в том случае, если он реализует этот интерфейс напрямую. Отключенные типы несовместимы.  
  
-   Два встроенных (предопределенные) типа значений совместимы, если копирование из исходного типа в целевой тип является расширяющим преобразованием. Расширяющее преобразование никогда не теряет информацию, в то время как понижающие преобразования могут потерять информацию. Например, преобразование 32-разрядного целого числа со знаком в 64-разрядное целое число со знаком является расширяющим преобразованием, а преобразование 64-разрядного целого числа со знаком в 32-разрядное целое число — это понижающие преобразования. Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
-   Невстроенный тип значения (определяемый пользователем) совместим только с самим собой.  
  
-   Перечисления имеют неявное преобразование в <xref:System.Enum> и их базовый тип.  
  
 Если каждому элементу в `sourceArray` требуется наследование (например, от базового класса до производного класса или от интерфейса к объекту), а один или несколько элементов не могут быть приведены к соответствующему типу в `destinationArray`, создается исключение <xref:System.InvalidCastException>.  
  
 Если при копировании этот метод вызывает исключение, состояние `destinationArray` не определено.  
  
 Этот метод является операцией O (`n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как скопировать из одного <xref:System.Array> типа <xref:System.Object> в другой <xref:System.Array> типа Integer.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="destinationArray" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют различные ранги.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют несовместимые типы.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в <paramref name="sourceArray" /> не может быть приведен к типу <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> находится вне диапазона допустимых индексов для <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="destinationIndex" /> находится вне диапазона допустимых индексов для <paramref name="destinationArray" />.  
  
-или- 
 Параметр <paramref name="length" /> имеет значение меньше 0 или больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> больше числа элементов с <paramref name="sourceIndex" /> до конца <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="length" /> больше числа элементов с <paramref name="destinationIndex" /> до конца <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует все элементы текущего одномерного массива в заданный одномерный массив.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int index);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив, который является массивом назначения для элементов, скопированных из текущего массива.</param>
        <param name="index">32-разрядное целое число, представляющее индекс в массиве <paramref name="array" />, с которого начинается копирование.</param>
        <summary>Копирует все элементы текущего одномерного массива в заданный одномерный массив начиная с указанного индекса в массиве назначения. Индекс задается как 32-битовое целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует все элементы текущего экземпляра массива в массив назначения `array`, начиная с индекса `index`. Массив назначения `array` уже должен быть измеренным и должен иметь достаточное количество элементов для размещения скопированных элементов. В противном случае метод создает исключение.  
  
 Этот метод поддерживает интерфейс <xref:System.Collections.ICollection?displayProperty=nameWithType>. Если реализация <xref:System.Collections.ICollection?displayProperty=nameWithType> не требуется явно, используйте <xref:System.Array.Copy%2A>, чтобы избежать дополнительного косвенного обращения.  
  
 Если при копировании этот метод вызывает исключение, состояние `array` не определено.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Array.Length%2A>. Он выполняет только неполную копию.  
  
   
  
## Examples  
 В следующем примере кода показано, как скопировать <xref:System.Array> в другой <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 В следующем примере кода показано, как скопировать <xref:System.Array> в другой <xref:System.Array> с ненулевой нижней границей. Обратите внимание, что копируется весь исходный <xref:System.Array>, включая пустые элементы, которые перезаписывают существующие элементы в целевом <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="array" /> является многомерным.  
  
-или- 
Число элементов в исходном массиве больше доступного числа элементов от индекса <paramref name="index" /> до конца массива назначения <paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Тип исходного массива <see cref="T:System.Array" /> не может быть автоматически приведен к типу массива назначения <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Исходный массив — многомерный.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в исходном массиве <see cref="T:System.Array" /> нельзя привести к типу массива назначения <paramref name="array" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, long index);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int64 index) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, long index);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int64 -&gt; unit&#xA;override this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив, который является массивом назначения для элементов, скопированных из текущего массива.</param>
        <param name="index">64-разрядное целое число, представляющее индекс в массиве <paramref name="array" />, с которого начинается копирование.</param>
        <summary>Копирует все элементы текущего одномерного массива в заданный одномерный массив начиная с указанного индекса в массиве назначения. Индекс задается как 64-битовое целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует все элементы текущего экземпляра массива в массив назначения `array`, начиная с индекса `index`. Массив назначения `array` уже должен быть измеренным и должен иметь достаточное количество элементов для размещения скопированных элементов. В противном случае метод создает исключение.  
  
 Этот метод поддерживает интерфейс <xref:System.Collections.ICollection?displayProperty=nameWithType>. Если реализация <xref:System.Collections.ICollection?displayProperty=nameWithType> не требуется явно, используйте <xref:System.Array.Copy%2A>, чтобы избежать дополнительного косвенного обращения.  
  
 Если при копировании этот метод вызывает исключение, состояние `array` не определено.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Array.Length%2A>. Он выполняет только неполную копию.  
  
   
  
## Examples  
 В следующем примере кода показано, как скопировать <xref:System.Array> в другой <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 В следующем примере кода показано, как скопировать <xref:System.Array> в другой <xref:System.Array> с ненулевой нижней границей. Обратите внимание, что копируется весь исходный <xref:System.Array>, включая пустые элементы, которые перезаписывают существующие элементы в целевом <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="array" /> является многомерным.  
  
-или- 
Число элементов в исходном массиве больше доступного числа элементов от индекса <paramref name="index" /> до конца массива назначения <paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Тип исходного массива <see cref="T:System.Array" /> не может быть автоматически приведен к типу массива назначения <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Исходный массив <see cref="T:System.Array" /> — многомерный.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в исходном массиве <see cref="T:System.Array" /> нельзя привести к типу массива назначения <paramref name="array" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Type" /> массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="length">Размер массива <see cref="T:System.Array" />, который требуется создать.</param>
        <summary>Создает одномерный массив <see cref="T:System.Array" /> указанного типа <see cref="T:System.Type" /> и длины, индексация которого начинается с нуля.</summary>
        <returns>Новый одномерный массив <see cref="T:System.Array" /> указанного типа <see cref="T:System.Type" /> и длины, индексация которого начинается с нуля.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от большинства классов <xref:System.Array> предоставляет метод <xref:System.Array.CreateInstance%2A>, а не открытые конструкторы, чтобы обеспечить доступ с поздним связыванием.  
  
 Элементы ссылочного типа инициализируются значением `null`. Элементы типа значения инициализируются нулем.  
  
 Этот метод является операцией O (`n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать одномерный <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> не является допустимым <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="elementType" /> не поддерживается. Например, <see cref="T:System.Void" /> не поддерживается.  
  
-или- 
 <paramref name="elementType" /> представляет собой открытый универсальный тип.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="length" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Type" /> массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="lengths">Массив 32-разрядных целых чисел, представляющих размер каждого измерения массива <see cref="T:System.Array" />, который нужно создать.</param>
        <summary>Создает многомерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> с заданными длинами по измерениям и индексацией, начинающейся с нуля. Длины по измерениям задаются в массиве 32-битовых целых чисел.</summary>
        <returns>Новый многомерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> с заданной для каждого измерения длиной и индексацией, начинающейся с нуля.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от большинства классов <xref:System.Array> предоставляет метод <xref:System.Array.CreateInstance%2A>, а не открытые конструкторы, чтобы обеспечить доступ с поздним связыванием.  
  
 Число элементов в массиве `lengths` должно равняться числу измерений в новом <xref:System.Array>. Каждый элемент массива `lengths` должен указывать длину соответствующего измерения в новом <xref:System.Array>.  
  
 Элементы ссылочного типа инициализируются значением `null`. Элементы типа значения инициализируются нулем.  
  
 Этот метод является операцией O (`n`), где `n` — это произведение всех значений в `lengths`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать многомерный <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="lengths" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> не является допустимым <see cref="T:System.Type" />.  
  
-или- 
Массив <paramref name="lengths" /> содержит менее одного элемента.</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="elementType" /> не поддерживается. Например, <see cref="T:System.Void" /> не поддерживается.  
  
-или- 
 <paramref name="elementType" /> представляет собой открытый универсальный тип.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Любое значение в <paramref name="lengths" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="lengths" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Type" /> массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="lengths">Массив 64-разрядных целых чисел, представляющих размер каждого измерения массива <see cref="T:System.Array" />, который нужно создать. Каждое целое число в массиве должно лежать в диапазоне от нуля до <see cref="F:System.Int32.MaxValue" /> включительно.</param>
        <summary>Создает многомерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> с заданными длинами по измерениям и индексацией, начинающейся с нуля. Длины по измерениям задаются в массиве 64-разрядных целых чисел.</summary>
        <returns>Новый многомерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> с заданной для каждого измерения длиной и индексацией, начинающейся с нуля.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от большинства классов <xref:System.Array> предоставляет метод <xref:System.Array.CreateInstance%2A>, а не открытые конструкторы, чтобы обеспечить доступ с поздним связыванием.  
  
 Число элементов в массиве `lengths` должно равняться числу измерений в новом <xref:System.Array>. Каждый элемент массива `lengths` должен указывать длину соответствующего измерения в новом <xref:System.Array>.  
  
 Элементы ссылочного типа инициализируются значением `null`. Элементы типа значения инициализируются нулем.  
  
 Этот метод является операцией O (`n`), где `n` — это произведение всех значений в `lengths`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать многомерный <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="lengths" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> не является допустимым <see cref="T:System.Type" />.  
  
-или- 
Массив <paramref name="lengths" /> содержит менее одного элемента.</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="elementType" /> не поддерживается. Например, <see cref="T:System.Void" /> не поддерживается.  
  
-или- 
 <paramref name="elementType" /> представляет собой открытый универсальный тип.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в <paramref name="lengths" /> меньше нуля или больше <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Type" /> массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="length1">Размер первого измерения создаваемого массива <see cref="T:System.Array" />.</param>
        <param name="length2">Размер второго измерения создаваемого массива <see cref="T:System.Array" />.</param>
        <summary>Создает двумерный массив <see cref="T:System.Array" /> указанного типа <see cref="T:System.Type" /> с заданными длинами измерений и индексацией, начинающейся с нуля.</summary>
        <returns>Новый двумерный массив <see cref="T:System.Array" /> указанного типа <see cref="T:System.Type" /> с заданной для каждого измерения длиной и индексацией, начинающейся с нуля.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от большинства классов <xref:System.Array> предоставляет метод <xref:System.Array.CreateInstance%2A>, а не открытые конструкторы, чтобы обеспечить доступ с поздним связыванием.  
  
 Элементы ссылочного типа инициализируются значением `null`. Элементы типа значения инициализируются нулем.  
  
 Этот метод является операцией O (`n`), где `n` — это произведение `length1` и `length2`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать двухмерный <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> не является допустимым <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="elementType" /> не поддерживается. Например, <see cref="T:System.Void" /> не поддерживается.  
  
-или- 
 <paramref name="elementType" /> представляет собой открытый универсальный тип.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="length1" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="length2" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Type" /> массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="lengths">Одномерный массив, содержащий размер всех измерений массива <see cref="T:System.Array" />, который необходимо создать.</param>
        <param name="lowerBounds">Одномерный массив, содержащий нижние границы (начальные индексы) всех измерений массива <see cref="T:System.Array" />, который необходимо создать.</param>
        <summary>Создает многомерный массив <see cref="T:System.Array" /> с указанным типом <see cref="T:System.Type" /> и длиной по измерениям и с заданными нижними границами.</summary>
        <returns>Новый многомерный массив <see cref="T:System.Array" /> указанного типа <see cref="T:System.Type" /> с заданной длиной и нижней границей каждого измерения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от большинства классов <xref:System.Array> предоставляет метод <xref:System.Array.CreateInstance%2A>, а не открытые конструкторы, чтобы обеспечить доступ с поздним связыванием.  
  
 Массивы `lengths` и `lowerBounds` должны иметь одинаковое количество элементов. Число элементов в массиве `lengths` должно равняться числу измерений в новом <xref:System.Array>.  
  
 Каждый элемент массива `lengths` должен указывать длину соответствующего измерения в новом <xref:System.Array>.  
  
 Каждый элемент массива `lowerBounds` должен указывать нижнюю границу соответствующего измерения в новом <xref:System.Array>. Как правило, Библиотека классов .NET Framework и многие языки программирования не обрабатывали ненулевые нижние границы.  
  
 Элементы ссылочного типа инициализируются значением `null`. Элементы типа значения инициализируются нулем.  
  
 Этот метод является операцией O (`n`), где `n` — это произведение всех значений в `lengths`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать многомерный <xref:System.Array> с указанными нижними границами.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="lengths" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="lowerBounds" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> не является допустимым <see cref="T:System.Type" />.  
  
-или- 
Массив <paramref name="lengths" /> содержит менее одного элемента.  
  
-или- 
Массивы <paramref name="lengths" /> и <paramref name="lowerBounds" /> содержат разное число элементов.</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="elementType" /> не поддерживается. Например, <see cref="T:System.Void" /> не поддерживается.  
  
-или- 
 <paramref name="elementType" /> представляет собой открытый универсальный тип.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Любое значение в <paramref name="lengths" /> меньше нуля.  
  
-или- 
Какое-либо значение в <paramref name="lowerBounds" /> очень велико, вследствие чего сумма нижней границы измерения и длины превышает значение <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Type" /> массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="length1">Размер первого измерения создаваемого массива <see cref="T:System.Array" />.</param>
        <param name="length2">Размер второго измерения создаваемого массива <see cref="T:System.Array" />.</param>
        <param name="length3">Размер третьего измерения массива <see cref="T:System.Array" />, который требуется создать.</param>
        <summary>Создает трехмерный массив <see cref="T:System.Array" /> указанного типа <see cref="T:System.Type" /> с заданными длинами по измерениям и индексацией, начинающейся с нуля.</summary>
        <returns>Новый трехмерный массив <see cref="T:System.Array" /> указанного типа <see cref="T:System.Type" /> с заданной для каждого измерения длиной и индексацией, начинающейся с нуля.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от большинства классов <xref:System.Array> предоставляет метод <xref:System.Array.CreateInstance%2A>, а не открытые конструкторы, чтобы обеспечить доступ с поздним связыванием.  
  
 Элементы ссылочного типа инициализируются значением `null`. Элементы типа значения инициализируются нулем.  
  
 Этот метод является операцией O (`n`), где `n` — это произведение `length1`, `length2`и `length3`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать трехмерный <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> не является допустимым <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="elementType" /> не поддерживается. Например, <see cref="T:System.Void" /> не поддерживается.  
  
-или- 
 <paramref name="elementType" /> представляет собой открытый универсальный тип.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="length1" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="length2" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="length3" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <summary>Возвращает пустой массив.</summary>
        <returns>Пустой массив.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элементов.</param>
        <summary>Определяет, содержит ли заданный массив элементы, удовлетворяющие условиям указанного предиката.</summary>
        <returns>Значение <see langword="true" />, если массив <paramref name="array" /> содержит один или несколько элементов, удовлетворяющих условиям указанного предиката; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> является делегатом для метода, который возвращает `true`, если переданный ему объект соответствует условиям, определенным в делегате.  Элементы `array` по отдельности передаются <xref:System.Predicate%601>, а обработка останавливается при обнаружении соответствия.  
  
> [!NOTE]
>  В C# и Visual Basic нет необходимости явно создавать делегат <xref:System.Predicate%601>. Эти языки выводят правильный делегат из контекста и создают его автоматически.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере задаются условия соответствия для метода <xref:System.Array.Exists%2A> с помощью лямбда-выражений, чтобы проверить, начинается ли Планета с заданной буквы или обнаружена ли планета в данном массиве.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 В следующем примере используется метод <xref:System.Array.Exists%2A> для указания, начинаются ли любые имена в массиве строк с указанного символа. В примере создается экземпляр `StringSearcher` объекта путем передачи строки для поиска в конструктор класса. Метод `StringSearcher.StartsWith` имеет ту же сигнатуру, что и делегат <xref:System.Predicate%601>. При вызове метода <xref:System.Array.Exists%2A> каждый элемент массива передается в делегат, пока он не вернет `true` или не перебирает все элементы массива.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 Можно также использовать лямбда-выражение вместо явного определения метода, сигнатура которого соответствует свойству делегата. В следующем примере класс `StringSearcher` и его метод `StartsWith` заменяются лямбда-выражением.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Лямбда-выражения (Руководство по программированию в C#)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">Лямбда-выражения (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Заполняемый массив.</param>
        <param name="value">Значение, присваиваемое каждому элементу массива.</param>
        <summary>Присваивает заданное <paramref name="value" /> типа <typeparamref name="T" /> каждому элементу указанного <paramref name="array" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array"><see cref="T:System.Array" /> для заполнения.</param>
        <param name="value">Новое значение для элементов в указанном диапазоне.</param>
        <param name="startIndex">32-разрядное целое число, представляющее индекс в массиве <see cref="T:System.Array" />, с которого начинается заполнение.</param>
        <param name="count">Число элементов для копирования.</param>
        <summary>Присваивает заданное <paramref name="value" /> типа <typeparamref name="T" /> элементам указанного <paramref name="array" />, которые находятся в диапазоне <paramref name="startIndex" /> (включительно) и следующем количестве <paramref name="count" /> индексов.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Индексируемый от нуля одномерный массив, в котором выполняется поиск.</param>
        <param name="match">Предикат, определяющий условия элемента, который требуется найти.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает первое найденное вхождение в пределах всего списка <see cref="T:System.Array" />.</summary>
        <returns>Первый элемент, удовлетворяющий условиям указанного предиката, если такой элемент найден; в противном случае — значение по умолчанию для типа <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> является делегатом метода или лямбда-выражения, которое возвращает `true`, если переданный ему объект соответствует условиям, определенным в делегате или лямбда-выражении.  Элементы `array` по отдельности передаются в <xref:System.Predicate%601>, начиная с первого элемента и заканчивая последним элементом.  Обработка останавливается при обнаружении соответствия.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере используется делегат <xref:System.Predicate%601> с универсальным методом <xref:System.Array.Find%2A> для поиска в массиве структур <xref:System.Drawing.Point>. Метод, который представляет делегат, `ProductGT10`, возвращает `true`, если произведение полей X и Y превышает 100 000. Метод <xref:System.Array.Find%2A> вызывает делегат для каждого элемента массива, возвращая первую точку, удовлетворяющую условию теста.  
  
> [!NOTE]
>  Visual Basic и C# пользователям не нужно явно создавать делегат или указывать аргумент типа для универсального метода. Компиляторы определяют необходимые типы из предоставленных аргументов метода.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Вместо явного определения метода с необходимой сигнатурой, создания экземпляра делегата <xref:System.Predicate%601> и передачи делегата в метод <xref:System.Array.Find%2A>, пользователь может использовать лямбда-выражение. Следующий пример идентичен предыдущему, за исключением того, что в качестве аргумента `match` используется лямбда-выражение.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элементов.</param>
        <summary>Извлекает все элементы, удовлетворяющие условиям указанного предиката.</summary>
        <returns>Список <see cref="T:System.Array" />, содержащий все элементы, удовлетворяющие условиям указанного предиката, если такие элементы найдены; в противном случае — пустой список <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> является делегатом для метода, который возвращает `true`, если переданный ему объект соответствует условиям, определенным в делегате.  Элементы `array` по отдельности передаются <xref:System.Predicate%601>, а элементы, соответствующие условиям, сохраняются в возвращаемом массиве.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере создается массив из 50 случайных чисел со значениями, которые могут находиться в диапазоне от 0 до 1 000. Затем он вызывает метод <xref:System.Array.FindAll%2A> с лямбда-выражением, возвращающим значения в диапазоне от 300 до 600. Обратите внимание, что лямбда-выражение передает параметр с именем `x`;  Это представляет отдельный элемент массива, который передается в <xref:System.Predicate%601>. Также обратите внимание, что локальные переменные `lBound` и `uBound` доступны в лямбда-выражении.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 В следующем примере кода демонстрируются универсальные методы <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>и <xref:System.Array.FindAll%2A>. Создается массив строк, содержащий 8 названий динозавров, два из которых (в позициях 1 и 5) заканчиваются на "саурус". В примере кода также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, заканчивается ли входная строка в "саурус".  
  
 <xref:System.Array.Find%2A> универсальный метод проходит по массиву с самого начала, передавая каждый элемент в свою очередь методу `EndsWithSaurus`. Поиск останавливается, когда метод `EndsWithSaurus` возвращает `true` для элемента «Амаргасаурус».  
  
> [!NOTE]
>  В C# и Visual Basic нет необходимости явно создавать делегат `Predicate<string>` (`Predicate(Of String)` в Visual Basic). Эти языки выводят правильный делегат из контекста и создают его автоматически.  
  
 <xref:System.Array.FindLast%2A> универсальный метод используется для поиска в массиве по обратной стороне. Он находит элемент «Дилофосаурус» в позиции 5. <xref:System.Array.FindAll%2A> универсальный метод используется для возврата массива, содержащего все элементы, заканчивающиеся на "саурус". Элементы отображаются.  
  
 В примере кода также показаны универсальные методы <xref:System.Array.Exists%2A> и <xref:System.Array.TrueForAll%2A>.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого вхождения в пределах всего массива <see cref="T:System.Array" /> или его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого найденного вхождения в пределах всего списка <see cref="T:System.Array" />.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента, отвечающего условиям предиката <paramref name="match" />, если такой элемент найден. В противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Array> выполняется в прямом направлении, начиная с первого элемента и заканчивая последним элементом.  
  
 <xref:System.Predicate%601> является делегатом для метода, который возвращает `true`, если переданный ему объект соответствует условиям, определенным в делегате.  Элементы `array` по отдельности передаются в <xref:System.Predicate%601>.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере кода показаны все три перегрузки <xref:System.Array.FindIndex%2A> универсального метода. Создается массив строк, содержащий 8 названий динозавров, два из которых (в позициях 1 и 5) заканчиваются на "саурус". В примере кода также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, заканчивается ли входная строка в "саурус".  
  
 Перегрузка метода <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> проходит по массиву с начала, передавая каждый элемент в свою очередь методу `EndsWithSaurus`. Поиск останавливается, когда метод `EndsWithSaurus` возвращает `true` для элемента в позиции 1.  
  
> [!NOTE]
>  В C# и Visual Basic нет необходимости явно создавать делегат `Predicate<string>` (`Predicate(Of String)` в Visual Basic). Эти языки выводят правильный делегат из контекста и создают его автоматически.  
  
 Перегрузка метода <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> используется для поиска в массиве, начиная с позиции 2, и продолжается до конца массива. Он находит элемент в позиции 5. Наконец, перегрузка метода <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> используется для поиска диапазона трех элементов, начиная с позиции 2. Он возвращает значение-1, так как в этом диапазоне нет названий динозавров, заканчивающихся на "саурус".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Array" />, начиная с заданного индекса и заканчивая последним элементом.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента, отвечающего условиям предиката <paramref name="match" />, если такой элемент найден. В противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> ищется в прямом направлении, начиная с `startIndex` и заканчивая последним элементом.  
  
 <xref:System.Predicate%601> является делегатом для метода, который возвращает `true`, если переданный ему объект соответствует условиям, определенным в делегате.  Элементы `array` по отдельности передаются в <xref:System.Predicate%601>.  
  
 Этот метод является операцией O (`n`), где `n` — число элементов с `startIndex` до конца `array`.  
  
   
  
## Examples  
 В следующем примере кода показаны все три перегрузки <xref:System.Array.FindIndex%2A> универсального метода. Создается массив строк, содержащий 8 названий динозавров, два из которых (в позициях 1 и 5) заканчиваются на "саурус". В примере кода также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, заканчивается ли входная строка в "саурус".  
  
 Перегрузка метода <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> проходит по массиву с начала, передавая каждый элемент в свою очередь методу `EndsWithSaurus`. Поиск останавливается, когда метод `EndsWithSaurus` возвращает `true` для элемента в позиции 1.  
  
> [!NOTE]
>  В C# и Visual Basic нет необходимости явно создавать делегат `Predicate<string>` (`Predicate(Of String)` в Visual Basic). Эти языки выводят правильный делегат из контекста и создают его автоматически.  
  
 Перегрузка метода <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> используется для поиска в массиве, начиная с позиции 2, и продолжается до конца массива. Он находит элемент в позиции 5. Наконец, перегрузка метода <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> используется для поиска диапазона трех элементов, начиная с позиции 2. Он возвращает значение-1, так как в этом диапазоне нет названий динозавров, заканчивающихся на "саурус".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Array" />, начинающемся с заданного индекса и содержащем указанное число элементов.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента, отвечающего условиям предиката <paramref name="match" />, если такой элемент найден. В противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> ищется в прямом направлении, начиная с `startIndex` и заканчивая на `startIndex` Plus `count` минус 1, если `count` больше 0.  
  
 <xref:System.Predicate%601> является делегатом для метода, который возвращает `true`, если переданный ему объект соответствует условиям, определенным в делегате.  Элементы `array` по отдельности передаются в <xref:System.Predicate%601>.  
  
 Этот метод является операцией O (`n`), где `n` `count`.  
  
   
  
## Examples  
 В следующем примере кода показаны все три перегрузки <xref:System.Array.FindIndex%2A> универсального метода. Создается массив строк, содержащий 8 названий динозавров, два из которых (в позициях 1 и 5) заканчиваются на "саурус". В примере кода также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, заканчивается ли входная строка в "саурус".  
  
 Перегрузка метода <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> проходит по массиву с начала, передавая каждый элемент в свою очередь методу `EndsWithSaurus`. Поиск останавливается, когда метод `EndsWithSaurus` возвращает `true` для элемента в позиции 1.  
  
> [!NOTE]
>  В C# и Visual Basic нет необходимости явно создавать делегат `Predicate<string>` (`Predicate(Of String)` в Visual Basic). Эти языки выводят правильный делегат из контекста и создают его автоматически.  
  
 Перегрузка метода <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> используется для поиска в массиве, начиная с позиции 2, и продолжается до конца массива. Он находит элемент в позиции 5. Наконец, перегрузка метода <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> используется для поиска диапазона трех элементов, начиная с позиции 2. Он возвращает значение-1, так как в этом диапазоне нет названий динозавров, заканчивающихся на "саурус".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает последнее найденное вхождение в пределах всего списка <see cref="T:System.Array" />.</summary>
        <returns>Последний элемент, удовлетворяющий условиям указанного предиката, если такой элемент найден; в противном случае — значение по умолчанию для типа <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> является делегатом для метода, который возвращает `true`, если переданный ему объект соответствует условиям, определенным в делегате.  Элементы `array` по отдельности передаются в <xref:System.Predicate%601>, перемещаясь назад в <xref:System.Array>, начиная с последнего элемента и заканчивая первым.  Обработка останавливается при обнаружении соответствия.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируются универсальные методы <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>и <xref:System.Array.FindAll%2A>. Создается массив строк, содержащий 8 названий динозавров, два из которых (в позициях 1 и 5) заканчиваются на "саурус". В примере кода также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, заканчивается ли входная строка в "саурус".  
  
 <xref:System.Array.Find%2A> универсальный метод проходит по массиву с самого начала, передавая каждый элемент в свою очередь методу `EndsWithSaurus`. Поиск останавливается, когда метод `EndsWithSaurus` возвращает `true` для элемента «Амаргасаурус».  
  
> [!NOTE]
>  В C# и Visual Basic нет необходимости явно создавать делегат`Predicate<string>` (`Predicate(Of String)` в Visual Basic). Эти языки выводят правильный делегат из контекста и создают его автоматически.  
  
 <xref:System.Array.FindLast%2A> универсальный метод используется для поиска в массиве по обратной стороне. Он находит элемент «Дилофосаурус» в позиции 5. <xref:System.Array.FindAll%2A> универсальный метод используется для возврата массива, содержащего все элементы, заканчивающиеся на "саурус". Элементы отображаются.  
  
 В примере кода также показаны универсальные методы <xref:System.Array.Exists%2A> и <xref:System.Array.TrueForAll%2A>.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям, определенным указанным предикатом, и возвращает отсчитываемый от нуля индекс последнего вхождения в пределах всего массива <see cref="T:System.Array" /> или его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего найденного вхождения в пределах всего списка <see cref="T:System.Array" />.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск в <xref:System.Array> осуществляется в обратном направлении, начиная с последнего элемента и заканчивая первым элементом.  
  
 <xref:System.Predicate%601> является делегатом для метода, который возвращает `true`, если переданный ему объект соответствует условиям, определенным в делегате.  Элементы `array` по отдельности передаются в <xref:System.Predicate%601>.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере кода показаны все три перегрузки <xref:System.Array.FindLastIndex%2A> универсального метода. Создается массив строк, содержащий 8 названий динозавров, два из которых (в позициях 1 и 5) заканчиваются на "саурус". В примере кода также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, заканчивается ли входная строка в "саурус".  
  
 Перегрузка метода <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> проходит по массиву в обратном направлении, передавая каждый элемент в свою очередь методу `EndsWithSaurus`. Поиск останавливается, когда метод `EndsWithSaurus` возвращает `true` для элемента в позиции 5.  
  
> [!NOTE]
>  В C# и Visual Basic нет необходимости явно создавать делегат `Predicate<string>` (`Predicate(Of String)` в Visual Basic). Эти языки выводят правильный делегат из контекста и создают его автоматически.  
  
 Перегрузка метода <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> используется для поиска в массиве, начиная с позиции 4, и продолжается назад до начала массива. Он находит элемент в позиции 1. Наконец, перегрузка метода <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> используется для поиска диапазона трех элементов, начиная с позиции 4 и заканчивая началом работы (то есть элементы 4, 3 и 2). Он возвращает значение-1, так как в этом диапазоне нет названий динозавров, заканчивающихся на "саурус".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Array" />, начиная с первого элемента и заканчивая элементом с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск в <xref:System.Array> осуществляется в обратном направлении, начиная с `startIndex` и заканчивая первым элементом.  
  
 <xref:System.Predicate%601> является делегатом для метода, который возвращает `true`, если переданный ему объект соответствует условиям, определенным в делегате.  Элементы `array` по отдельности передаются в <xref:System.Predicate%601>.  
  
 Этот метод является операцией O (`n`), где `n` — число элементов от начала `array` до `startIndex`.  
  
   
  
## Examples  
 В следующем примере кода показаны все три перегрузки <xref:System.Array.FindLastIndex%2A> универсального метода. Создается массив строк, содержащий 8 названий динозавров, два из которых (в позициях 1 и 5) заканчиваются на "саурус". В примере кода также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, заканчивается ли входная строка в "саурус".  
  
 Перегрузка метода <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> проходит по массиву в обратном направлении, передавая каждый элемент в свою очередь методу `EndsWithSaurus`. Поиск останавливается, когда метод `EndsWithSaurus` возвращает `true` для элемента в позиции 5.  
  
> [!NOTE]
>  В C# и Visual Basic нет необходимости явно создавать делегат `Predicate<string>` (`Predicate(Of String)` в Visual Basic). Эти языки выводят правильный делегат из контекста и создают его автоматически.  
  
 Перегрузка метода <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> используется для поиска в массиве, начиная с позиции 4, и продолжается назад до начала массива. Он находит элемент в позиции 1. Наконец, перегрузка метода <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> используется для поиска диапазона трех элементов, начиная с позиции 4 и заканчивая началом работы (то есть элементы 4, 3 и 2). Он возвращает значение-1, так как в этом диапазоне нет названий динозавров, заканчивающихся на "саурус".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Array" />, содержащем указанное число элементов и заканчивающемся элементом с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск в <xref:System.Array> осуществляется в обратном направлении, начиная с `startIndex` и заканчивая на `startIndex` минус `count` плюс 1, если `count` больше 0.  
  
 <xref:System.Predicate%601> является делегатом для метода, который возвращает `true`, если переданный ему объект соответствует условиям, определенным в делегате.  Элементы `array` по отдельности передаются в <xref:System.Predicate%601>.  
  
 Этот метод является операцией O (`n`), где `n` `count`.  
  
   
  
## Examples  
 В следующем примере кода показаны все три перегрузки <xref:System.Array.FindLastIndex%2A> универсального метода. Создается массив строк, содержащий 8 названий динозавров, два из которых (в позициях 1 и 5) заканчиваются на "саурус". В примере кода также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, заканчивается ли входная строка в "саурус".  
  
 Перегрузка метода <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> проходит по массиву в обратном направлении, передавая каждый элемент в свою очередь методу `EndsWithSaurus`. Поиск останавливается, когда метод `EndsWithSaurus` возвращает `true` для элемента в позиции 5.  
  
> [!NOTE]
>  В C# и Visual Basic нет необходимости явно создавать делегат `Predicate<string>` (`Predicate(Of String)` в Visual Basic). Эти языки выводят правильный делегат из контекста и создают его автоматически.  
  
 Перегрузка метода <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> используется для поиска в массиве, начиная с позиции 4, и продолжается назад до начала массива. Он находит элемент в позиции 1. Наконец, перегрузка метода <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> используется для поиска диапазона трех элементов, начиная с позиции 4 и заканчивая началом работы (то есть элементы 4, 3 и 2). Он возвращает значение-1, так как в этом диапазоне нет названий динозавров, заканчивающихся на "саурус".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и для элементов которого нужно выполнить данное действие.</param>
        <param name="action">Действие <see cref="T:System.Action`1" />, выполняемое для каждого элемента массива <paramref name="array" />.</param>
        <summary>Выполняет указанное действие с каждым элементом указанного массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> является делегатом метода, который выполняет действие с объектом, переданным ему.  Элементы `array` по отдельности передаются в <xref:System.Action%601>.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Array.ForEach%2A> для отображения квадратов каждого элемента в массиве целых чисел.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="action" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Collections.IEnumerator" /> для <see cref="T:System.Array" />.</summary>
        <returns>Интерфейс <see cref="T:System.Collections.IEnumerator" /> для <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 Оператор `foreach` C# языка (`for each` в C++`For Each` в Visual Basic) скрывает сложность перечислителей. Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. Метод <xref:System.Collections.IEnumerator.Reset%2A> также переводит перечислитель в эту позицию.  В этой позиции значение свойства <xref:System.Collections.IEnumerator.Current%2A> не определено. Поэтому необходимо вызвать метод <xref:System.Collections.IEnumerator.MoveNext%2A>, чтобы переместить перечислитель к первому элементу коллекции до считывания значения свойства <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> возвращает тот же объект, пока не будет вызван метод <xref:System.Collections.IEnumerator.MoveNext%2A> или <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> задает <xref:System.Collections.IEnumerator.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.IEnumerator.MoveNext%2A> передает конец коллекции, перечислитель размещается после последнего элемента в коллекции и <xref:System.Collections.IEnumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.IEnumerator.MoveNext%2A> также возвращают `false`. Если последний вызов <xref:System.Collections.IEnumerator.MoveNext%2A> вернул `false`, <xref:System.Collections.IEnumerator.Current%2A> не определено. Чтобы снова задать в качестве значения свойства <xref:System.Collections.IEnumerator.Current%2A> первый элемент коллекции, можно последовательно вызвать методы <xref:System.Collections.IEnumerator.Reset%2A> и<xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если в коллекцию вносятся изменения, например добавляются, изменяются или удаляются элементы, перечислитель становится недействительным без возможности восстановление, а его поведение не определено.  
  
 Перечислитель не имеет монопольного доступа к коллекции, поэтому перечисление элементов коллекции само по себе не является потокобезопасной процедурой.  Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Array.GetEnumerator%2A> для перечисления элементов массива.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Измерение массива <see cref="T:System.Array" />, индексация которого начинается с нуля, для которого требуется определить длину.</param>
        <summary>Возвращает 32-разрядное целое число, представляющее количество элементов в заданном измерении массива <see cref="T:System.Array" />.</summary>
        <returns>32-битовое целое число, представляющее количество элементов в заданном измерении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Примером <xref:System.Array.GetLength%2A> является `GetLength(0)`, который возвращает количество элементов в первом измерении <xref:System.Array>.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Array.GetLength%2A> для отображения измерений двух массивов с разными рангами.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="dimension" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="dimension" /> больше или равно значению свойства <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="dimension">Измерение массива <see cref="T:System.Array" />, индексация которого начинается с нуля, для которого требуется определить длину.</param>
        <summary>Возвращает 64-разрядное целое число, представляющее количество элементов в заданном измерении массива <see cref="T:System.Array" />.</summary>
        <returns>64-разрядное целое число, представляющее количество элементов в заданном измерении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Примером <xref:System.Array.GetLongLength%2A> является `GetLongLength(0)`, который возвращает количество элементов в первом измерении <xref:System.Array>.  
  
 Этот метод является операцией O (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="dimension" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="dimension" /> больше или равно значению свойства <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Измерение массива основанное на нуле, для которого необходимо определить индекс начала.</param>
        <summary>Получает Индекс первого элемента заданного измерения в массиве.</summary>
        <returns>Индекс первого элемента заданного измерения в массиве.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` Возвращает начальный индекс первого измерения массива, а `GetLowerBound(Rank - 1)` Возвращает начальный индекс последнего измерения массива.  
  
 Метод <xref:System.Array.GetLowerBound%2A> всегда возвращает значение, указывающее индекс нижней границы массива, даже если массив пуст.  
  
 Обратите внимание, что несмотря на то, что большинство массивов в .NET Framework отсчитываются от нуля (то есть метод <xref:System.Array.GetLowerBound%2A> возвращает ноль для каждого измерения массива), .NET Framework поддерживает массивы, которые не отсчитываются от нуля. Такие массивы могут быть созданы с помощью метода <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29>, а также могут возвращаться из неуправляемого кода.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере используются методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> для вывода границ одномерного и двумерного массива, а также для вывода значений их элементов массива.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="dimension" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="dimension" /> больше или равно значению свойства <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Измерение массива, индексация которого начинается с нуля, и для которого необходимо определить верхнюю границу.</param>
        <summary>Получает Индекс последнего элемента заданного измерения в массиве.</summary>
        <returns>Индекс последнего элемента указанного измерения в массиве или -1, если указанное измерение пусто.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` Возвращает последний индекс в первом измерении массива, а `GetUpperBound(Rank - 1)` Возвращает последний индекс последнего измерения массива.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере используются методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> для вывода границ одномерного и двумерного массива, а также для вывода значений их элементов массива.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="dimension" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="dimension" /> больше или равно значению свойства <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение указанного элемента в текущем массиве <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="index">32-разрядное целое, представляющее позицию получаемого элемента <see cref="T:System.Array" />.</param>
        <summary>Возвращает значение, хранящееся в указанной позиции одномерного массива <see cref="T:System.Array" />. Индекс задается как 32-битовое целое число.</summary>
        <returns>Значение, хранящееся в указанной позиции одномерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находится ли значение `index` вне допустимого диапазона.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно одного измерения.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> находится вне диапазона допустимых индексов для текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Одномерный массив 32-битовых целых чисел, представляющий индексы, которые задают позицию получаемого элемента <see cref="T:System.Array" />.</param>
        <summary>Получает значение, находящееся в указанной позиции многомерного массива <see cref="T:System.Array" />. Индексы задаются как массив 32-битовых целых чисел.</summary>
        <returns>Значение, находящееся в указанной позиции многомерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Число элементов в `indices` должно равняться числу измерений в <xref:System.Array>. Все элементы массива `indices` должны совместно указывать расположение требуемого элемента в многомерном <xref:System.Array>.  
  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находятся ли индексы вне допустимого диапазона.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Число измерений в текущем массиве <see cref="T:System.Array" /> не равно числу элементов в <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Любой элемент в <paramref name="indices" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="index">64-разрядное целое число, представляющее позицию возвращаемого элемента <see cref="T:System.Array" />.</param>
        <summary>Возвращает значение, хранящееся в указанной позиции одномерного массива <see cref="T:System.Array" />. Индекс задается как 64-битовое целое число.</summary>
        <returns>Значение, хранящееся в указанной позиции одномерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находится ли значение `index` вне допустимого диапазона.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно одного измерения.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> находится вне диапазона допустимых индексов для текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Одномерный массив 64-разрядных целых чисел, представляющих индексы, которые определяют позицию возвращаемого элемента <see cref="T:System.Array" />.</param>
        <summary>Получает значение, находящееся в указанной позиции многомерного массива <see cref="T:System.Array" />. Индексы задаются как массив 64-битовых целых чисел.</summary>
        <returns>Значение, находящееся в указанной позиции многомерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Число элементов в `indices` должно равняться числу измерений в <xref:System.Array>. Все элементы массива `indices` должны совместно указывать расположение требуемого элемента в многомерном <xref:System.Array>.  
  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находятся ли индексы вне допустимого диапазона.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Число измерений в текущем массиве <see cref="T:System.Array" /> не равно числу элементов в <paramref name="indices" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Любой элемент в <paramref name="indices" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="index1">32-разрядное целое число, представляющее индекс получаемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">32-разрядное целое число, представляющее индекс получаемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <summary>Получает значение в заданной позиции двумерного массива <see cref="T:System.Array" />. Индексы задаются в виде 32-битовых целых чисел.</summary>
        <returns>Значение, находящееся в указанной позиции двумерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находятся ли индексы вне допустимого диапазона.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно два измерения.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> или <paramref name="index2" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="index1">64-разрядное целое число, представляющее индекс возвращаемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">64-разрядное целое число, представляющее индекс возвращаемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <summary>Получает значение в заданной позиции двумерного массива <see cref="T:System.Array" />. Индексы задаются в виде 64-битовых целых чисел.</summary>
        <returns>Значение, находящееся в указанной позиции двумерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находятся ли индексы вне допустимого диапазона.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно два измерения.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> или <paramref name="index2" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index3" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="index1">32-разрядное целое число, представляющее индекс получаемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">32-разрядное целое число, представляющее индекс получаемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <param name="index3">32-разрядное целое число, представляющее индекс получаемого элемента в третьем измерении массива <see cref="T:System.Array" />.</param>
        <summary>Получает значение, хранящееся в указанной позиции трехмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 32-битовых целых чисел.</summary>
        <returns>Значение, хранящееся в указанной позиции трехмерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находятся ли индексы вне допустимого диапазона.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно трех измерений.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" />, <paramref name="index2" /> или <paramref name="index3" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index3" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="index1">64-разрядное целое число, представляющее индекс возвращаемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">64-разрядное целое число, представляющее индекс возвращаемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <param name="index3">64-разрядное целое число, представляющее индекс возвращаемого элемента в третьем измерении массива <see cref="T:System.Array" />.</param>
        <summary>Получает значение, хранящееся в указанной позиции трехмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 64-битовых целых чисел.</summary>
        <returns>Значение, хранящееся в указанной позиции трехмерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находятся ли индексы вне допустимого диапазона.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно трех измерений.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" />, <paramref name="index2" /> или <paramref name="index3" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск указанного объекта и возвращает индекс первого найденного совпадения в одномерном массиве или диапазоне элементов массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив для поиска.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <summary>Выполняет поиск указанного объекта внутри всего одномерного массива и возвращает индекс его первого вхождения.</summary>
        <returns>Индекс первого вхождения <paramref name="value" /> в массиве <paramref name="array" />, если найден. В противном случае — нижняя граница массива минус 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск `value`в всех элементах одномерного массива. Чтобы определить, существует ли `value` в `array`, метод выполняет сравнение на равенство путем вызова метода `Equals` каждого элемента до тех пор, пока не будет найдено совпадение. Это означает, что если элемент переопределяет метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, вызывается это переопределение.  
  
 Так как большинство массивов имеют нижнюю границу, равную нулю, этот метод обычно возвращает значение-1, если`value` не найден. В редких случаях, когда нижняя граница массива равна <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) и `value` не найдена, этот метод возвращает <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В примере вызываются следующие три перегрузки метода <xref:System.Array.IndexOf%2A> для поиска индекса строки в массиве строк:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, чтобы определить первое вхождение строки «The» в массив строк.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>для определения первого вхождения строки "The" в четвертой части к последним элементам массива строк.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, чтобы определить первое вхождение строки «The» в массив строк из элемента, следующего за последним успешным сопоставлением с концом массива.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив для поиска.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Начальный индекс поиска. Значение 0 (ноль) действительно в пустом массиве.</param>
        <summary>Выполняет поиск указанного объекта в диапазоне элементов одномерного массива и возвращает индекс первого найденного совпадения. Диапазон начинается с указанного индекса и заканчивается концом массива.</summary>
        <returns>Индекс первого вхождения значения <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, начинающемся с элемента с индексом <paramref name="startIndex" /> и заканчивающемся последним элементом, если значение найдено; в противном случае нижняя граница массива минус 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск одномерного массива из элемента по индексу `startIndex` к последнему элементу. Чтобы определить, существует ли `value` в `array`, метод выполняет сравнение на равенство, вызывая метод `Equals` каждого элемента до тех пор, пока не будет найдено совпадение. Это означает, что если элемент переопределяет метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, вызывается это переопределение.  
  
 Так как большинство массивов имеют нижнюю границу, равную нулю, этот метод обычно возвращает значение-1, если `value` не найден. В редких случаях, когда нижняя граница массива равна <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) и `value` не найдена, этот метод возвращает <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Если `startIndex` равно <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод возвращает значение-1. Если `startIndex` больше <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод создает исключение <xref:System.ArgumentOutOfRangeException>.  
  
 Этот метод является операцией O (`n`), где `n` — число элементов с `startIndex` до конца `array`.  
  
   
  
## Examples  
 В примере вызываются следующие три перегрузки метода <xref:System.Array.IndexOf%2A> для поиска индекса строки в массиве строк:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, чтобы определить первое вхождение строки «The» в массив строк.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>для определения первого вхождения строки "The" в четвертой части к последним элементам массива строк.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, чтобы определить первое вхождение строки «The» в массив строк из элемента, следующего за последним успешным сопоставлением с концом массива.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив для поиска.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Начальный индекс поиска. Значение 0 (ноль) действительно в пустом массиве.</param>
        <param name="count">Число искомых элементов.</param>
        <summary>Выполняет поиск указанного объекта в диапазоне элементов одномерного массива и возвращает индекс первого найденного совпадения. Диапазон расширяется от указанного индекса заданного числа элементов.</summary>
        <returns>Индекс первого вхождения значения <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, начинающемся с индекса <paramref name="startIndex" /> и заканчивающемся элементом с индексом <paramref name="startIndex" /> + <paramref name="count" /> — 1, если значение найдено. В противном случае нижняя граница массива минус 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск элементов одномерного массива от `startIndex` до `startIndex` плюс `count` минус 1, если `count` больше 0. Чтобы определить, существует ли `value` в `array`, метод выполняет сравнение на равенство, вызывая метод `Equals` каждого элемента до тех пор, пока не будет найдено совпадение. Это означает, что если элемент переопределяет метод <xref:System.Object.Equals%2A?displayProperty=nameWithType>, вызывается это переопределение.  
  
 Так как большинство массивов имеют нижнюю границу, равную нулю, этот метод обычно возвращает значение-1, если `value` не найден. В редких случаях, когда нижняя граница массива равна <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) и `value` не найдена, этот метод возвращает <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Если `startindex` равно <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод возвращает значение-1. Если `startIndex` больше <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод создает исключение <xref:System.ArgumentOutOfRangeException>.  
  
 Этот метод является операцией O (`n`), где `n` `count`.  
  
   
  
## Examples  
 В примере вызываются следующие три перегрузки метода <xref:System.Array.IndexOf%2A> для поиска индекса строки в массиве строк:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, чтобы определить первое вхождение строки «The» в массив строк.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>для определения первого вхождения строки "The" в четвертой части к последним элементам массива строк.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, чтобы определить первое вхождение строки «The» в массив строк из элемента, следующего за последним успешным сопоставлением с концом массива. Чтобы определить значение аргумента `count`, он вычитает верхнюю границу массива из начального индекса и добавляет его.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Индексируемый от нуля одномерный массив, в котором выполняется поиск.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <summary>Выполняет поиск указанного объекта внутри всего одномерного массива и возвращает индекс его первого вхождения.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения объекта <paramref name="value" /> во всем массиве <paramref name="array" />; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск `value`в всех элементах одномерного массива. Чтобы определить, существует ли `value` в `array`, метод выполняет сравнение на равенство, вызывая метод `T.Equals` для каждого элемента. Это означает, что если `T` переопределяет метод <xref:System.Object.Equals%2A>, вызывается это переопределение.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере показаны все три универсальных перегрузки метода <xref:System.Array.IndexOf%2A>. Создается массив строк с одной записью, которая появляется дважды, в позиции индекса 0 и позиции индекса 5. Перегрузка метода <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> выполняет поиск в массиве начиная с начала и находит первое вхождение строки. Перегрузка метода <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> используется для поиска массива, начинающегося с позиции индекса 3, и продолжения до конца массива и находит второе вхождение строки. Наконец, перегрузка метода <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> используется для поиска в диапазоне двух записей, начиная с позиции индекса два; Он возвращает значение-1, поскольку в этом диапазоне отсутствуют экземпляры строки поиска.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Индексируемый от нуля одномерный массив, в котором выполняется поиск.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска. Значение 0 (ноль) действительно в пустом массиве.</param>
        <summary>Выполняет поиск указанного объекта в диапазоне элементов одномерного массива и возвращает индекс первого найденного совпадения. Диапазон расширяется от указанного индекса до конца массива.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента <paramref name="value" /> в диапазоне элементов списка <paramref name="array" />, начиная с позиции <paramref name="startIndex" /> и до конца списка, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск одномерного массива из элемента в `startIndex` до конца массива. Чтобы определить, существует ли `value` в `array`, метод выполняет сравнение на равенство, вызывая метод `T.Equals` для каждого элемента. Это означает, что если `T` переопределяет метод <xref:System.Object.Equals%2A>, вызывается это переопределение.  
  
 Если `startIndex` равно <xref:System.Array.Length%2A>, метод возвращает -1. Если `startIndex` больше <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод выдает исключение <xref:System.ArgumentOutOfRangeException>.  
  
 Этот метод является операцией O (`n`), где `n` — число элементов с `startIndex` до конца `array`.  
  
   
  
## Examples  
 В следующем примере показаны все три универсальных перегрузки метода <xref:System.Array.IndexOf%2A>. Создается массив строк с одной записью, которая появляется дважды, в позиции индекса 0 и позиции индекса 5. Перегрузка метода <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> выполняет поиск в массиве начиная с начала и находит первое вхождение строки. Перегрузка метода <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> используется для поиска массива, начинающегося с позиции индекса 3, и продолжения до конца массива и находит второе вхождение строки. Наконец, перегрузка метода <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> используется для поиска в диапазоне двух записей, начиная с позиции индекса два; Он возвращает значение-1, поскольку в этом диапазоне отсутствуют экземпляры строки поиска.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Индексируемый от нуля одномерный массив, в котором выполняется поиск.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска. Значение 0 (ноль) действительно в пустом массиве.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <summary>Выполняет поиск указанного объекта в диапазоне элементов одномерного массива и возвращает индекс первого найденного совпадения. Диапазон расширяется от указанного индекса заданного числа элементов.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, который начинается с позиции <paramref name="startIndex" /> и содержит количество элементов, указанное в <paramref name="count" />, если искомый объект найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск элементов одномерного массива от `startIndex` до `startIndex` плюс `count` минус 1, если `count` больше 0. Чтобы определить, существует ли `value` в `array`, метод выполняет сравнение на равенство, вызывая метод `T.Equals` для каждого элемента. Это означает, что если `T` переопределяет метод <xref:System.Object.Equals%2A>, вызывается это переопределение.  
  
 Если `startIndex` равно <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод возвращает значение-1.  Если `startIndex` больше <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод создает исключение <xref:System.ArgumentOutOfRangeException>.  
  
 Этот метод является операцией O (`n`), где `n` `count`.  
  
   
  
## Examples  
 В следующем примере показаны все три универсальных перегрузки метода <xref:System.Array.IndexOf%2A>. Создается массив строк с одной записью, которая появляется дважды, в позиции индекса 0 и позиции индекса 5. Перегрузка метода <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> выполняет поиск в массиве начиная с начала и находит первое вхождение строки. Перегрузка метода <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> используется для поиска массива, начинающегося с позиции индекса 3, и продолжения до конца массива и находит второе вхождение строки. Наконец, перегрузка метода <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> используется для поиска в диапазоне двух записей, начиная с позиции индекса два; Он возвращает значение-1, поскольку в этом диапазоне отсутствуют экземпляры строки поиска.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует каждый элемент массива <see cref="T:System.Array" /> типа значения путем вызова конструктора без параметров для типа значений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод разработан, чтобы помочь компиляторам поддерживать массивы типов значений; большинству пользователей этот метод не нужен. Он не должен использоваться для массивов ссылочного типа.  
  
 Если <xref:System.Array> не является типом значения <xref:System.Array> или если тип значения не имеет конструктора без параметров, <xref:System.Array> не изменяется.  
  
 Тип значения <xref:System.Array> может иметь любую нижнюю границу и любое количество измерений.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Array.Length%2A>.  
  
> [!CAUTION]
>  Этот метод можно использовать только для типов значений, имеющих конструкторы. Однако типы значений, являющиеся собственными для C# , не имеют конструкторов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, имеет ли список <see cref="T:System.Array" /> фиксированный размер.</summary>
        <value>Данное свойство для всех массивов всегда имеет значение <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> реализует свойство <xref:System.Array.IsFixedSize%2A>, так как оно требуется для интерфейса <xref:System.Collections.IList?displayProperty=nameWithType>.  
  
 Массив с фиксированным размером не допускает добавление или удаление элементов после создания массива, но позволяет изменять существующие элементы.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли объект <see cref="T:System.Array" /> доступным только для чтения.</summary>
        <value>Данное свойство для всех массивов всегда имеет значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> реализует свойство <xref:System.Array.IsReadOnly%2A>, так как оно требуется для интерфейса <xref:System.Collections.IList?displayProperty=nameWithType>. Массив, который доступен только для чтения, не допускает добавление, удаление или изменение элементов после создания массива.  
  
 Если требуется доступная только для чтения коллекция, используйте класс <xref:System.Collections>, реализующий интерфейс <xref:System.Collections.IList?displayProperty=nameWithType>.  
  
 При приведении или преобразовании массива в объект <xref:System.Collections.IList> Interface свойство <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> возвращает `false`. Однако при приведении или преобразовании массива в интерфейс <xref:System.Collections.Generic.IList%601> свойство `IsReadOnly` возвращает `true`.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, является ли доступ к коллекции <see cref="T:System.Array" /> синхронизированным (потокобезопасным).</summary>
        <value>Данное свойство для всех массивов всегда имеет значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> реализует свойство <xref:System.Array.IsSynchronized%2A>, так как оно требуется для интерфейса <xref:System.Collections.ICollection?displayProperty=nameWithType>.  
  
 .NET Framework классы, основанные на <xref:System.Array>, предоставляют собственную синхронизированную версию коллекции с помощью свойства <xref:System.Array.SyncRoot%2A>.  
  
 Классы, использующие массивы, могут также реализовать собственную синхронизацию с помощью свойства <xref:System.Array.SyncRoot%2A>. Синхронизирующий код должен выполнять операции с `SyncRoot` коллекции, а не непосредственно в коллекции. Это обеспечивает правильную работу коллекций, являющихся производными других объектов. В частности, он поддерживает правильную синхронизацию с другими потоками, которые могут одновременно изменять коллекцию. Обратите внимание, что некоторые реализации <xref:System.Array.SyncRoot%2A> могут возвращать сам <xref:System.Array>.  
  
 Перечисление по коллекции не является потокобезопасной процедурой. Даже если коллекция синхронизирована, другие потоки могут ее изменить, что приведет к тому, что перечислитель создаст исключение. Для обеспечения потокобезопасности при перечислении можно либо заблокировать коллекцию на все время перечисления, либо перехватывать исключения, возникающие в результате изменений, внесенных другими потоками.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как заблокировать массив во время перечисления во всем перечислении с помощью свойства <xref:System.Array.SyncRoot%2A>.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает индекс последнего вхождения значения в одномерном массиве <see cref="T:System.Array" /> или в части массива <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> для поиска.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <summary>Выполняет поиск заданного объекта и возвращает индекс его последнего вхождения внутри всего одномерного массива <see cref="T:System.Array" />.</summary>
        <returns>Индекс последнего вхождения <paramref name="value" /> в массиве <paramref name="array" />, если найден; в противном случае — нижняя граница массива минус 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Одномерный <xref:System.Array> ищется в обратном направлении, начиная с последнего элемента и заканчивая первым элементом.  
  
 Элементы сравниваются с указанным значением с помощью метода <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Если тип элемента является невстроенным (определяемым пользователем) типом, используется `Equals` реализация этого типа.  
  
 Так как большинство массивов будет иметь нижнюю границу, равную нулю, этот метод обычно возвращает значение-1, если `value` не найден. В редких случаях, когда нижняя граница массива равна <xref:System.Int32.MinValue?displayProperty=nameWithType> и `value` не найдена, этот метод возвращает <xref:System.Int32.MaxValue?displayProperty=nameWithType>, который `System.Int32.MinValue - 1`.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
 В .NET Framework версии 2,0 этот метод использует методы <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> <xref:System.Array>, чтобы определить, существует ли <xref:System.Object>, заданный параметром `value`. В более ранних версиях .NET Framework это определение было произведено с помощью методов <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> `value`<xref:System.Object>.  
  
 <xref:System.IComparable.CompareTo%2A> методов параметра `item` для объектов в коллекции.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить индекс последнего вхождения указанного элемента в массиве.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> для поиска.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Начальный индекс обратного поиска.</param>
        <summary>Выполняет поиск указанного объекта и возвращает индекс его последнего вхождения в диапазоне элементов одномерного массива <see cref="T:System.Array" />, который начинается с первого элемента и заканчивается элементом с заданным индексом.</summary>
        <returns>Индекс последнего вхождения значения <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, который начинается с первого элемента и заканчивается элементом с индексом <paramref name="startIndex" />, если объект найден; в противном случае — нижняя граница массива минус 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Одномерный <xref:System.Array> ищется в обратном направлении, начиная с `startIndex` и заканчивая первым элементом.  
  
 Элементы сравниваются с указанным значением с помощью метода <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Если тип элемента является невстроенным (определяемым пользователем) типом, используется `Equals` реализация этого типа.  
  
 Так как большинство массивов будет иметь нижнюю границу, равную нулю, этот метод обычно возвращает значение-1, если `value` не найден. В редких случаях, когда нижняя граница массива равна <xref:System.Int32.MinValue?displayProperty=nameWithType> и `value` не найдена, этот метод возвращает <xref:System.Int32.MaxValue?displayProperty=nameWithType>, который `System.Int32.MinValue - 1`.  
  
 Этот метод является операцией O (`n`), где `n` — число элементов от начала `array` до `startIndex`.  
  
 В .NET Framework версии 2,0 этот метод использует методы <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> <xref:System.Array>, чтобы определить, существует ли <xref:System.Object>, заданный параметром `value`. В более ранних версиях .NET Framework это определение было произведено с помощью методов <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> `value`<xref:System.Object>.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить индекс последнего вхождения указанного элемента в массиве.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> для поиска.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Начальный индекс обратного поиска.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <summary>Выполняет поиск указанного объекта и возвращает индекс последнего вхождения в диапазоне элементов одномерного массива <see cref="T:System.Array" />, который содержит указанное число элементов и заканчивается элементом с заданным индексом.</summary>
        <returns>Индекс последнего вхождения значения <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, который содержит число элементов, заданных в параметре <paramref name="count" />, и заканчивается элементом с индексом <paramref name="startIndex" />, если объект найден; в противном случае — нижняя граница массива минус 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Одномерный <xref:System.Array> ищется в обратном направлении, начиная с `startIndex` и заканчивая на `startIndex` минус `count` плюс 1, если `count` больше 0.  
  
 Элементы сравниваются с указанным значением с помощью метода <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Если тип элемента является невстроенным (определяемым пользователем) типом, используется`Equals` реализация этого типа.  
  
 Так как большинство массивов будет иметь нижнюю границу, равную нулю, этот метод обычно возвращает значение-1, если `value` не найден. В редких случаях, когда нижняя граница массива равна <xref:System.Int32.MinValue?displayProperty=nameWithType> и `value` не найдена, этот метод возвращает <xref:System.Int32.MaxValue?displayProperty=nameWithType>, который `System.Int32.MinValue - 1`.  
  
 Этот метод является операцией O (`n`), где `n` `count`.  
  
 В .NET Framework версии 2,0 этот метод использует методы <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> <xref:System.Array>, чтобы определить, существует ли <xref:System.Object>, заданный параметром `value`. В более ранних версиях .NET Framework это определение было произведено с помощью методов <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> `value`<xref:System.Object>.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить индекс последнего вхождения указанного элемента в массиве. Обратите внимание, что метод <xref:System.Array.LastIndexOf%2A> является обратным поиском. Таким образом, `count` должно быть меньше или равно (`startIndex` минус Нижняя граница массива плюс 1).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <summary>Выполняет поиск указанного объекта и возвращает индекс последнего вхождения во всем массиве <see cref="T:System.Array" />.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения <paramref name="value" /> в пределах всего массива <paramref name="array" />, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск в <xref:System.Array> осуществляется в обратном направлении, начиная с последнего элемента и заканчивая первым элементом.  
  
 Элементы сравниваются с указанным значением с помощью метода <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Если тип элемента является невстроенным (определяемым пользователем) типом, используется `Equals` реализация этого типа.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере кода показаны все три универсальных перегрузки метода <xref:System.Array.LastIndexOf%2A>. Создается массив строк с одной записью, которая появляется дважды, в позиции индекса 0 и позиции индекса 5. Перегрузка метода <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> выполняет поиск всего массива в конце и находит второе вхождение строки. Перегрузка метода <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> используется для поиска в массиве в обратном направлении, начинающемся с индекса 3 и заканчивая началом массива, и находит первое вхождение строки. Наконец, перегрузка метода <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> используется для поиска диапазона из четырех записей, начиная с позиции индекса 4 и расширяя обратно (т. е. он ищет элементы в расположениях 4, 3, 2 и 1); Этот поиск возвращает значение-1, так как в этом диапазоне отсутствуют экземпляры строки поиска.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <summary>Выполняет поиск указанного объекта и возвращает индекс последнего вхождения в диапазоне элементов массива <see cref="T:System.Array" />, начиная с первого элемента и заканчивая элементом с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, начиная с первого элемента и до позиции <paramref name="startIndex" />, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск в <xref:System.Array> осуществляется в обратном направлении, начиная с `startIndex` и заканчивая первым элементом.  
  
 Элементы сравниваются с указанным значением с помощью метода <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Если тип элемента является невстроенным (определяемым пользователем) типом, используется `Equals` реализация этого типа.  
  
 Этот метод является операцией O (`n`), где `n` — число элементов от начала `array` до `startIndex`.  
  
   
  
## Examples  
 В следующем примере кода показаны все три универсальных перегрузки метода <xref:System.Array.LastIndexOf%2A>. Создается массив строк с одной записью, которая появляется дважды, в позиции индекса 0 и позиции индекса 5. Перегрузка метода <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> выполняет поиск всего массива в конце и находит второе вхождение строки. Перегрузка метода <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> используется для поиска в массиве в обратном направлении, начинающемся с индекса 3 и заканчивая началом массива, и находит первое вхождение строки. Наконец, перегрузка метода <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> используется для поиска диапазона из четырех записей, начиная с позиции индекса 4 и расширяя обратно (т. е. он ищет элементы в расположениях 4, 3, 2 и 1); Этот поиск возвращает значение-1, так как в этом диапазоне отсутствуют экземпляры строки поиска.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <summary>Выполняет поиск указанного объекта и возвращает индекс последнего вхождения в диапазоне элементов массива <see cref="T:System.Array" />, содержащем указанное число элементов и заканчивающемся в позиции с указанным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, состоящем из элементов, заданных в <paramref name="count" />, и заканчивающемся в позиции <paramref name="startIndex" />, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск в <xref:System.Array> осуществляется в обратном направлении, начиная с `startIndex` и заканчивая на `startIndex` минус `count` плюс 1, если `count` больше 0.  
  
 Элементы сравниваются с указанным значением с помощью метода <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Если тип элемента является невстроенным (определяемым пользователем) типом, используется `Equals` реализация этого типа.  
  
 Этот метод является операцией O (`n`), где `n` `count`.  
  
   
  
## Examples  
 В следующем примере кода показаны все три универсальных перегрузки метода <xref:System.Array.LastIndexOf%2A>. Создается массив строк с одной записью, которая появляется дважды, в позиции индекса 0 и позиции индекса 5. Перегрузка метода <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> выполняет поиск всего массива в конце и находит второе вхождение строки. Перегрузка метода <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> используется для поиска в массиве в обратном направлении, начинающемся с индекса 3 и заканчивая началом массива, и находит первое вхождение строки. Наконец, перегрузка метода <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> используется для поиска диапазона из четырех записей, начиная с позиции индекса 4 и расширяя обратно (т. е. он ищет элементы в расположениях 4, 3, 2 и 1); Этот поиск возвращает значение-1, так как в этом диапазоне отсутствуют экземпляры строки поиска.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает общее число элементов во всех измерениях массива <see cref="T:System.Array" />.</summary>
        <value>Общее число элементов во всех измерениях массива <see cref="T:System.Array" />; ноль, если в массиве нет элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере используется свойство <xref:System.Array.Length%2A> для получения общего числа элементов в массиве. Он также использует метод <xref:System.Array.GetUpperBound%2A> для определения количества элементов в каждом измерении многомерного массива.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Массив является многомерным и содержит больше элементов, чем задано в <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает 64-разрядное целое число, представляющее общее число элементов во всех измерениях массива <see cref="T:System.Array" />.</summary>
        <value>64-разрядное целое число, представляющее общее число элементов во всех измерениях массива <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает ранг (число измерений) массива <see cref="T:System.Array" />. Например, одномерный массив возвращает 1, двухмерный массив возвращает 2 и т д</summary>
        <value>Ранг (число измерений) массива <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например, код Visual Basic  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 и C# код  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 Создайте массив из трех измерений со свойством <xref:System.Array.Rank%2A>, значение которого равно 3.  
  
 Массив массива (массив массивов) является одномерным массивом; значение свойства <xref:System.Array.Rank%2A> равно 1.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере инициализируется одномерный массив, двухмерный массив и массив массива, а также извлекается свойство <xref:System.Array.Rank%2A> для каждого из них.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize : T[] * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="newSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Подлежащий изменению размера одномерный массив, индексация которого начинается с нуля, или значение <see langword="null" /> для создания нового массива заданного размера.</param>
        <param name="newSize">Размер нового массива.</param>
        <summary>Изменяет количество элементов в одномерном массиве до указанной величины.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выделяет новый массив с заданным размером, копирует элементы из старого массива в новый, а затем заменяет старый массив новым. `array` должен быть одномерным массивом.  
  
 Если `array` `null`, этот метод создает новый массив с указанным размером.  
  
 Если `newSize` больше, чем <xref:System.Array.Length%2A> старого массива, выделяется новый массив, а все элементы копируются из старого массива в новый.  Если `newSize` меньше, чем <xref:System.Array.Length%2A> старого массива, выделяется новый массив, а элементы копируются из старого массива в новый, пока новый не будет заполнен. остальные элементы в старом массиве игнорируются.  Если `newSize` равно <xref:System.Array.Length%2A> старого массива, этот метод ничего не делает.  
  
 Этот метод является операцией O (`n`), где `n` `newSize`.  
  
 Метод <xref:System.Array.Resize%2A> изменяет размер только одномерного массива. Класс <xref:System.Array> не включает метод для изменения размера многомерных массивов. Для этого необходимо либо предоставить собственный код, либо вызвать Специальный метод в библиотеке стороннего производителя. В следующем коде показана одна возможная реализация метода, который изменяет размер массива из *n* измерений.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 В следующем примере показано, как изменение размера влияет на массив.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="newSize" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Изменяет порядок элементов в одномерном массиве <see cref="T:System.Array" /> или в части массива <see cref="T:System.Array" /> на обратный.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, порядок элементов которого нужно изменить на обратный.</param>
        <summary>Изменяет порядок элементов во всем одномерном массиве <see cref="T:System.Array" /> на обратный.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После вызова этого метода элемент в `myArray[i]`, где `i` является любым индексом в массиве, перемещается в `myArray[j]`, где `j` равно `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
 Как показано в следующем примере, метод <xref:System.Array.Reverse%2A> можно использовать для отмены массива массивов. Он инициализирует массив массива с одним элементом для каждого месяца текущего года в календаре текущего языка и региональных параметров. Каждый элемент содержит массив с количеством элементов, число которых в этом месяце — дней. В примере выводится содержимое массива, вызывается метод <xref:System.Array.Reverse%2A>, а затем отображается содержимое обращенного массива.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 В следующем примере кода показано, как изменить порядок сортировки значений в <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, порядок элементов которого нужно изменить на обратный.</param>
        <param name="index">Начальный индекс той части массива, порядок элементов которой необходимо изменить на обратный.</param>
        <param name="length">Число элементов в части массива, порядок которых нужно изменить на обратный.</param>
        <summary>Изменяет порядок подмножества элементов в одномерном массиве <see cref="T:System.Array" /> на обратный.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После вызова этого метода элемент в `myArray[i]`, где `i` является любым индексом в массиве, перемещается в `myArray[j]`, где `j` равно `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Метод <xref:System.Array.Reverse%2A> можно использовать для отмены массива массивов.  
  
 Этот метод является операцией O (`n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как изменить порядок сортировки значений в диапазоне элементов в <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов в объекте <paramref name="array" />.</typeparam>
        <param name="array">Одномерный массив элементов для изменения порядка на обратный.</param>
        <summary>Изменяет порядок последовательности элементов в одномерном общем массиве на обратный.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов в объекте <paramref name="array" />.</typeparam>
        <param name="array">Одномерный массив элементов для изменения порядка на обратный.</param>
        <param name="index">Начальный индекс той части массива, порядок элементов которой необходимо изменить на обратный.</param>
        <param name="length">Число элементов в части массива, порядок которых нужно изменить на обратный.</param>
        <summary>Изменяет порядок последовательности подмножества элементов в одномерном общем массиве на обратный.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Присваивает заданному элементу текущего массива <see cref="T:System.Array" /> заданное значение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="index">32-разрядное целое число, представляющее позицию элемента в массиве <see cref="T:System.Array" />, для которого требуется установить значение.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции одномерного массива <see cref="T:System.Array" />. Индекс задается как 32-битовое целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находится ли значение `index` вне допустимого диапазона.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией O (1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` элементу массива типов значений, все поля элемента инициализируются значением 0. Значение элемента не является пустой ссылкой и не может быть найдено путем поиска пустой ссылки.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно одного измерения.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> не может быть приведен к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> находится вне диапазона допустимых индексов для текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="indices">Одномерный массив 32-битовых целых чисел, представляющий индексы, которые задают позицию задаваемого элемента в массиве.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции многомерного массива <see cref="T:System.Array" />. Индексы задаются как массив 32-битовых целых чисел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Число элементов в `indices` должно равняться числу измерений в <xref:System.Array>. Все элементы массива `indices` должны совместно указывать расположение требуемого элемента в многомерном <xref:System.Array>.  
  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находятся ли какие-либо значения в массиве `indices` вне допустимого диапазона.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией O (1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` элементу массива типов значений, все поля элемента инициализируются значением 0. Значение элемента не является пустой ссылкой и не может быть найдено путем поиска пустой ссылки.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Число измерений в текущем массиве <see cref="T:System.Array" /> не равно числу элементов в <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> не может быть приведен к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Любой элемент в <paramref name="indices" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="index">64-разрядное целое число, представляющее позицию элемента в массиве <see cref="T:System.Array" />, для которого требуется установить значение.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции одномерного массива <see cref="T:System.Array" />. Индекс задается как 64-битовое целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находится ли значение `index` вне допустимого диапазона.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией O (1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` элементу массива типов значений, все поля элемента инициализируются значением 0. Значение элемента не является пустой ссылкой и не может быть найдено путем поиска пустой ссылки.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно одного измерения.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> не может быть приведен к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> находится вне диапазона допустимых индексов для текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="indices" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="indices">Одномерный массив 64-разрядных целых чисел, представляющий индексы, которые указывают позицию задаваемого элемента в массиве.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции многомерного массива <see cref="T:System.Array" />. Индексы задаются как массив 64-разрядных целых чисел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Число элементов в `indices` должно равняться числу измерений в <xref:System.Array>. Все элементы массива `indices` должны совместно указывать расположение требуемого элемента в многомерном <xref:System.Array>.  
  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находятся ли какие-либо значения в массиве `indices` вне допустимого диапазона.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией O (1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` элементу массива типов значений, все поля элемента инициализируются значением 0. Значение элемента не является пустой ссылкой и не может быть найдено путем поиска пустой ссылки.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Число измерений в текущем массиве <see cref="T:System.Array" /> не равно числу элементов в <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> не может быть приведен к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Любой элемент в <paramref name="indices" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="index1">32-разрядное целое число, представляющее индекс задаваемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">32-разрядное целое число, представляющее индекс задаваемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции двухмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 32-битовых целых чисел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находятся ли индексы вне допустимого диапазона.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией O (1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` элементу массива типов значений, все поля элемента инициализируются значением 0. Значение элемента не является пустой ссылкой и не может быть найдено путем поиска пустой ссылки.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно два измерения.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> не может быть приведен к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> или <paramref name="index2" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="index1">64-разрядное целое число, представляющее индекс задаваемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">64-разрядное целое число, представляющее индекс задаваемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции двухмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 64-битовых целых чисел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находятся ли индексы вне допустимого диапазона.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией O (1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` элементу массива типов значений, все поля элемента инициализируются значением 0. Значение элемента не является пустой ссылкой и не может быть найдено путем поиска пустой ссылки.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно два измерения.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> не может быть приведен к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> или <paramref name="index2" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="index1">32-разрядное целое число, представляющее индекс задаваемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">32-разрядное целое число, представляющее индекс задаваемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <param name="index3">32-разрядное целое число, представляющее индекс задаваемого элемента в третьем измерении массива <see cref="T:System.Array" />.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции трехмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 32-битовых целых чисел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находятся ли индексы вне допустимого диапазона.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией O (1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` элементу массива типов значений, все поля элемента инициализируются значением 0. Значение элемента не является пустой ссылкой и не может быть найдено путем поиска пустой ссылки.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно трех измерений.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> не может быть приведен к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" />, <paramref name="index2" /> или <paramref name="index3" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index3" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="index1">64-разрядное целое число, представляющее индекс задаваемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">64-разрядное целое число, представляющее индекс задаваемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <param name="index3">64-разрядное целое число, представляющее индекс задаваемого элемента в третьем измерении массива <see cref="T:System.Array" />.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции трехмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 64-разрядных целых чисел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> могут определить, находятся ли индексы вне допустимого диапазона.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией O (1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` элементу массива типов значений, все поля элемента инициализируются значением 0. Значение элемента не является пустой ссылкой и не может быть найдено путем поиска пустой ссылки.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерном или многомерном массиве.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно трех измерений.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> не может быть приведен к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" />, <paramref name="index2" /> или <paramref name="index3" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сортирует элементы в одномерном массиве.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> для сортировки.</param>
        <summary>Сортирует элементы во всем одномерном массиве <see cref="T:System.Array" />, используя реализацию интерфейса <see cref="T:System.IComparable" /> каждого элемента массива <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый элемент `array` должен реализовывать интерфейс <xref:System.IComparable>, чтобы иметь возможность сравнения с любым другим элементом в `array`.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` — <xref:System.Array.Length%2A> `array`.  
  
   
  
## Examples  
 В следующем примере кода показано, как сортировать значения в <xref:System.Array> с помощью компаратора по умолчанию и пользовательского компаратора, который изменяет порядок сортировки на обратный. Обратите внимание, что результат может отличаться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в <paramref name="array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Одномерный массив <see cref="T:System.Array" />, который содержит элементы, соответствующие ключам в массиве <paramref name="keys" /><see cref="T:System.Array" />.  
  
-или- 
 Значение <see langword="null" /> для сортировки только массива <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <summary>Сортирует пару одномерных объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя реализацию интерфейса <see cref="T:System.IComparable" /> каждого ключа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys`<xref:System.Array> имеет соответствующий элемент в `items`<xref:System.Array>. При перемещении ключа во время сортировки соответствующий элемент в `items`<xref:System.Array> аналогичным образом перемещается. Таким образом, <xref:System.Array> `items`сортируются в соответствии с расположением соответствующих ключей в `keys`<xref:System.Array>.  
  
 Каждый ключ в `keys`<xref:System.Array> должен реализовывать интерфейс <xref:System.IComparable>, чтобы иметь возможность сравнения с любым другим ключом.  
  
 Если число элементов больше, чем ключей, можно выполнить сортировку, но элементы, не имеющие соответствующих ключей, не будут отсортированы. Невозможно выполнить сортировку, если количество ключей превышает число элементов; Это вызовет исключение <xref:System.ArgumentException>.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` — <xref:System.Array.Length%2A> `keys`.  
  
   
  
## Examples  
 В следующем примере показано, как сортировать два связанных массива, где первый массив содержит ключи, а второй массив содержит значения. Сортировка выполняется с помощью компаратора по умолчанию и пользовательского компаратора, который изменяет порядок сортировки на обратный. Обратите внимание, что результат может отличаться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="keys" /><see cref="T:System.Array" /> является многомерным.  
  
-или- 
<paramref name="items" /><see cref="T:System.Array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> не равно <see langword="null" />, а длина <paramref name="keys" /> больше длины <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в <paramref name="keys" /><see cref="T:System.Array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив для сортировки.</param>
        <param name="comparer">Реализация интерфейса, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Сортирует элементы в одномерном массиве <see cref="T:System.Array" />, используя указанный интерфейс <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` `null`, каждый элемент `array` должен реализовывать интерфейс <xref:System.IComparable>, чтобы иметь возможность сравнения с каждым другим элементом в `array`.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` — <xref:System.Array.Length%2A> `array`.  
  
 .NET Framework включает предопределенные реализации <xref:System.Collections.IComparer>, перечисленные в следующей таблице.  
  
|Реализация|Описание|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Сравнивает все два объекта, но выполняет сравнение строк без учета регистра.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Сравнивает все два объекта с помощью правил сортировки текущего языка и региональных параметров.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Сравнивает все два объекта, используя соглашения о сортировке инвариантного языка и региональных параметров.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Сравнивает два объекта типа `T` с использованием порядка сортировки по умолчанию для типа.|  
  
 Можно также поддерживать пользовательские сравнения, предоставляя экземпляр собственной реализации <xref:System.Collections.IComparer> в параметре `comparer`. В этом примере определяется класс `ReverseComparer`, который изменяет порядок сортировки по умолчанию для экземпляров типа и выполняет сравнение строк без учета регистра.  
  
   
  
## Examples  
 В следующем примере значения в массиве строк сортируются с помощью компаратора по умолчанию. Он также определяет пользовательскую реализацию <xref:System.Collections.IComparer> с именем `ReverseComparer`, которая изменяет порядок сортировки объекта по умолчанию при выполнении сравнения строк без учета регистра. Обратите внимание, что выходные данные могут различаться в зависимости от текущего языка и региональных параметров.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, и один или несколько элементов в <paramref name="array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.ArgumentException">Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <block subset="none" type="usage"><para>В .NET Framework 4 и более ранних версиях использовался только алгоритм QuickSort. QuickSort определяет недопустимые компараторы в некоторых ситуациях, в которых операция сортировки создает исключение <see cref="T:System.IndexOutOfRangeException" /> и вызывает исключение <see cref="T:System.ArgumentException" /> вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, операции сортировки, которые ранее выбросили <see cref="T:System.ArgumentException" />, не вызовут исключение, так как алгоритмы сортировки и хеапсорт не обнаруживают недопустимый компаратор. В большинстве случаев это относится к массивам, количество элементов в которых меньше или равно 16.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Одномерный массив <see cref="T:System.Array" />, который содержит элементы, соответствующие ключам в массиве <paramref name="keys" /><see cref="T:System.Array" />.  
  
-или- 
 Значение <see langword="null" /> для сортировки только массива <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Сортирует пару одномерных объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя указанный интерфейс <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys`<xref:System.Array> имеет соответствующий элемент в `items`<xref:System.Array>. При перемещении ключа во время сортировки соответствующий элемент в `items`<xref:System.Array> аналогичным образом перемещается. Таким образом, <xref:System.Array> `items`сортируются в соответствии с расположением соответствующих ключей в `keys`<xref:System.Array>.  
  
 Если `comparer` `null`, каждый ключ в `keys`<xref:System.Array> должен реализовывать интерфейс <xref:System.IComparable>, чтобы иметь возможность сравнения с любыми другими ключами.  
  
 Если число элементов больше, чем ключей, можно выполнить сортировку, но элементы, не имеющие соответствующих ключей, не будут отсортированы. Невозможно выполнить сортировку, если количество ключей превышает число элементов; Это вызовет исключение <xref:System.ArgumentException>.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 .NET Framework включает предопределенные реализации <xref:System.Collections.IComparer>, перечисленные в следующей таблице.  
  
|Реализация|Описание|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Сравнивает все два объекта, но выполняет сравнение строк без учета регистра.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Сравнивает все два объекта с помощью правил сортировки текущего языка и региональных параметров.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Сравнивает все два объекта, используя соглашения о сортировке инвариантного языка и региональных параметров.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Сравнивает два объекта типа `T` с использованием порядка сортировки по умолчанию для типа.|  
  
 Можно также поддерживать пользовательские сравнения, предоставляя экземпляр собственной реализации <xref:System.Collections.IComparer> в параметре `comparer`. В этом примере определяется реализация <xref:System.Collections.IComparer>, которая изменяет порядок сортировки по умолчанию и выполняет сравнение строк без учета регистра.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` — <xref:System.Array.Length%2A> `keys`.  
  
   
  
## Examples  
 В следующем примере показано, как сортировать два связанных массива, где первый массив содержит ключи, а второй массив содержит значения. Сортировка выполняется с помощью компаратора по умолчанию и пользовательского компаратора, который изменяет порядок сортировки на обратный. Обратите внимание, что результат может отличаться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="keys" /><see cref="T:System.Array" /> является многомерным.  
  
-или- 
<paramref name="items" /><see cref="T:System.Array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> не равно <see langword="null" />, а длина <paramref name="keys" /> больше длины <paramref name="items" />.  
  
-или- 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, и один или несколько элементов в <paramref name="keys" /><see cref="T:System.Array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage"><para>В .NET Framework 4 и более ранних версиях использовался только алгоритм QuickSort. QuickSort определяет недопустимые компараторы в некоторых ситуациях, в которых операция сортировки создает исключение <see cref="T:System.IndexOutOfRangeException" /> и вызывает исключение <see cref="T:System.ArgumentException" /> вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, операции сортировки, которые ранее выбросили <see cref="T:System.ArgumentException" />, не вызовут исключение, так как алгоритмы сортировки и хеапсорт не обнаруживают недопустимый компаратор. В большинстве случаев это относится к массивам, количество элементов в которых меньше или равно 16.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> для сортировки.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <summary>Сортирует элементы в диапазоне элементов одномерного массива <see cref="T:System.Array" /> с помощью реализации интерфейса <see cref="T:System.IComparable" /> каждого элемента массива <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый элемент в пределах указанного диапазона элементов в `array` должен реализовывать интерфейс <xref:System.IComparable>, чтобы иметь возможность сравнения с любым другим элементом в `array`.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как сортировать значения в <xref:System.Array> с помощью компаратора по умолчанию и пользовательского компаратора, который изменяет порядок сортировки на обратный. Обратите внимание, что результат может отличаться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в <paramref name="array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Одномерный массив <see cref="T:System.Array" />, который содержит элементы, соответствующие ключам в массиве <paramref name="keys" /><see cref="T:System.Array" />.  
  
-или- 
 Значение <see langword="null" /> для сортировки только массива <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <summary>Сортирует диапазон элементов в паре одномерных объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя реализацию интерфейса <see cref="T:System.IComparable" /> каждого ключа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys`<xref:System.Array> имеет соответствующий элемент в `items`<xref:System.Array>. При перемещении ключа во время сортировки соответствующий элемент в `items`<xref:System.Array> аналогичным образом перемещается. Таким образом, <xref:System.Array> `items`сортируются в соответствии с расположением соответствующих ключей в `keys`<xref:System.Array>.  
  
 Каждый ключ в пределах указанного диапазона элементов в `keys`<xref:System.Array> должен реализовывать интерфейс <xref:System.IComparable>, чтобы иметь возможность сравнения с любым другим ключом.  
  
 Если число элементов больше, чем ключей, можно выполнить сортировку, но элементы, не имеющие соответствующих ключей, не будут отсортированы. Невозможно выполнить сортировку, если количество ключей превышает число элементов; Это вызовет исключение <xref:System.ArgumentException>.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как сортировать два связанных массива, где первый массив содержит ключи, а второй массив содержит значения. Сортировка выполняется с помощью компаратора по умолчанию и пользовательского компаратора, который изменяет порядок сортировки на обратный. Обратите внимание, что результат может отличаться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="keys" /><see cref="T:System.Array" /> является многомерным.  
  
-или- 
Массив <paramref name="items" /><see cref="T:System.Array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="keys" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> не равно <see langword="null" />, а длина <paramref name="keys" /> больше длины <paramref name="items" />.  
  
-или- 
 <paramref name="index" /> и <paramref name="length" /> не определяют допустимый диапазон в <paramref name="keys" /><see cref="T:System.Array" />.  
  
-или- 
 <paramref name="items" /> не равно <see langword="null" />, а <paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в <paramref name="keys" /><see cref="T:System.Array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> для сортировки.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Сортирует элементы в диапазоне элементов одномерного массива <see cref="T:System.Array" />, используя указанный интерфейс <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` `null`, каждый элемент в пределах указанного диапазона элементов в `array` должен реализовывать интерфейс <xref:System.IComparable>, чтобы иметь возможность сравнения с каждым другим элементом в `array`.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 .NET Framework включает предопределенные реализации <xref:System.Collections.IComparer>, перечисленные в следующей таблице.  
  
|Реализация|Описание|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Сравнивает все два объекта, но выполняет сравнение строк без учета регистра.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Сравнивает все два объекта с помощью правил сортировки текущего языка и региональных параметров.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Сравнивает все два объекта, используя соглашения о сортировке инвариантного языка и региональных параметров.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Сравнивает два объекта типа `T` с использованием порядка сортировки по умолчанию для типа.|  
  
 Можно также поддерживать пользовательские сравнения, предоставляя экземпляр собственной реализации <xref:System.Collections.IComparer> в параметре `comparer`. В этом примере определяется класс `ReverseComparer`, который изменяет порядок сортировки по умолчанию для экземпляров типа и выполняет сравнение строк без учета регистра.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как сортировать значения в <xref:System.Array> с помощью компаратора по умолчанию и пользовательского компаратора, который изменяет порядок сортировки на обратный. Обратите внимание, что результат может отличаться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.  
  
-или- 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, и один или несколько элементов в <paramref name="array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage"><para>В .NET Framework 4 и более ранних версиях использовался только алгоритм QuickSort. QuickSort определяет недопустимые компараторы в некоторых ситуациях, в которых операция сортировки создает исключение <see cref="T:System.IndexOutOfRangeException" /> и вызывает исключение <see cref="T:System.ArgumentException" /> вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, операции сортировки, которые ранее выбросили <see cref="T:System.ArgumentException" />, не вызовут исключение, так как алгоритмы сортировки и хеапсорт не обнаруживают недопустимый компаратор. В большинстве случаев это относится к массивам, количество элементов в которых меньше или равно 16.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Одномерный массив <see cref="T:System.Array" />, который содержит элементы, соответствующие ключам в массиве <paramref name="keys" /><see cref="T:System.Array" />.  
  
-или- 
 Значение <see langword="null" /> для сортировки только массива <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Сортирует диапазон элементов в паре одномерных объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя указанный интерфейс <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys`<xref:System.Array> имеет соответствующий элемент в `items`<xref:System.Array>. При перемещении ключа во время сортировки соответствующий элемент в `items`<xref:System.Array> аналогичным образом перемещается. Таким образом, <xref:System.Array> `items`сортируются в соответствии с расположением соответствующих ключей в `keys`<xref:System.Array>.  
  
 Если `comparer` `null`, каждый ключ в пределах указанного диапазона элементов в `keys`<xref:System.Array> должен реализовывать интерфейс <xref:System.IComparable>, чтобы иметь возможность сравнения с любыми другими ключами.  
  
 Если число элементов больше, чем ключей, можно выполнить сортировку, но элементы, не имеющие соответствующих ключей, не будут отсортированы. Невозможно выполнить сортировку, если количество ключей превышает число элементов; Это вызовет исключение <xref:System.ArgumentException>.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 .NET Framework включает предопределенные реализации <xref:System.Collections.IComparer>, перечисленные в следующей таблице.  
  
|Реализация|Описание|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Сравнивает все два объекта, но выполняет сравнение строк без учета регистра.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Сравнивает все два объекта с помощью правил сортировки текущего языка и региональных параметров.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Сравнивает все два объекта, используя соглашения о сортировке инвариантного языка и региональных параметров.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Сравнивает два объекта типа `T` с использованием порядка сортировки по умолчанию для типа.|  
  
 Можно также поддерживать пользовательские сравнения, предоставляя экземпляр собственной реализации <xref:System.Collections.IComparer> в параметре `comparer`. В этом примере определяется пользовательская реализация <xref:System.Collections.IComparer>, которая изменяет порядок сортировки по умолчанию и выполняет сравнение строк без учета регистра.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как сортировать два связанных массива, где первый массив содержит ключи, а второй массив содержит значения. Сортировка выполняется с помощью компаратора по умолчанию и пользовательского компаратора, который изменяет порядок сортировки на обратный. Обратите внимание, что результат может отличаться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="keys" /><see cref="T:System.Array" /> является многомерным.  
  
-или- 
Массив <paramref name="items" /><see cref="T:System.Array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="keys" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> не равно <see langword="null" />, а нижняя граница массива <paramref name="keys" /> не соответствует нижней границе массива <paramref name="items" />.  
  
-или- 
 <paramref name="items" /> не равно <see langword="null" />, а длина <paramref name="keys" /> больше длины <paramref name="items" />.  
  
-или- 
 <paramref name="index" /> и <paramref name="length" /> не определяют допустимый диапазон в <paramref name="keys" /><see cref="T:System.Array" />.  
  
-или- 
 <paramref name="items" /> не равно <see langword="null" />, а <paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="items" /><see cref="T:System.Array" />.  
  
-или- 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, и один или несколько элементов в <paramref name="keys" /><see cref="T:System.Array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage"><para>В .NET Framework 4 и более ранних версиях использовался только алгоритм QuickSort. QuickSort определяет недопустимые компараторы в некоторых ситуациях, в которых операция сортировки создает исключение <see cref="T:System.IndexOutOfRangeException" /> и вызывает исключение <see cref="T:System.ArgumentException" /> вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, операции сортировки, которые ранее выбросили <see cref="T:System.ArgumentException" />, не вызовут исключение, так как алгоритмы сортировки и хеапсорт не обнаруживают недопустимый компаратор. В большинстве случаев это относится к массивам, количество элементов в которых меньше или равно 16.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Сортируемый одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля.</param>
        <summary>Сортирует элементы во всем массиве <see cref="T:System.Array" />, используя реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> каждого элемента массива <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый элемент `array` должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы иметь возможность сравнения с любым другим элементом в `array`.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` — <xref:System.Array.Length%2A> `array`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется перегрузка универсального метода <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ная перегрузка универсального метода. Создается массив строк без определенного порядка.  
  
 Массив отображается, сортируется и отображается снова.  
  
> [!NOTE]
>  Вызовы методов <xref:System.Array.Sort%2A> и <xref:System.Array.BinarySearch%2A> не отличаются от вызовов к неуниверсальным аналогам, поскольку Visual Basic, C#и C++ определяют тип параметра универсального типа из типа первого аргумента. Если вы используете [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы изучить MSIL, можно увидеть, что вызываемые универсальные методы вызываются.  
  
 Перегрузка <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> универсального метода затем используется для поиска двух строк, которые не находятся в массиве, а другая —. Массив и возвращаемое значение метода <xref:System.Array.BinarySearch%2A> передаются в `ShowWhere` универсальный метод, который отображает значение индекса, если строка найдена, и в противном случае элементы, которые строка поиска попадают в массив. Индекс является отрицательным, если строка не является n массивом, поэтому `ShowWhere` метод принимает побитовое дополнение (оператор ~ в C# и Visual C++, `Xor`-1 в Visual Basic) для получения индекса первого элемента в списке, который больше, чем строка поиска.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в массиве <paramref name="array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Сортируемый одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля.</param>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, используемая при сравнении элементов, или значение <see langword="null" /> для использования реализации универсального интерфейса <see cref="T:System.IComparable`1" /> каждого элемента.</param>
        <summary>Сортирует элементы в массиве <see cref="T:System.Array" />, используя указанный универсальный интерфейс <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` `null`, каждый элемент `array` должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы иметь возможность сравнения с каждым другим элементом в `array`.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` — <xref:System.Array.Length%2A> `array`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется перегрузка универсального метода <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ная перегрузка универсального метода.  
  
 В примере кода определяется альтернативный компаратор для строк с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальном интерфейсе. Функция сравнения вызывает метод <xref:System.String.CompareTo%28System.String%29>, отменяя порядок сравниваемых строк таким образом, чтобы строки были в высоком и низком уровне, а не в высоком.  
  
 Массив отображается, сортируется и отображается снова. Для использования метода <xref:System.Array.BinarySearch%2A> массивы должны быть отсортированы.  
  
> [!NOTE]
>  Вызовы методов <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> не отличаются от вызовов к неуниверсальным аналогам, поскольку Visual Basic, C#и C++ определяют тип параметра универсального типа из типа первого аргумента. Если вы используете [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы изучить MSIL, можно увидеть, что вызываемые универсальные методы вызываются.  
  
 Перегрузка <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> универсального метода затем используется для поиска двух строк, которые не находятся в массиве, а другая —. Массив и возвращаемое значение метода <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> передаются в `ShowWhere` универсальный метод, который отображает значение индекса, если строка найдена, и в противном случае элементы, которые строка поиска попадают в массив. Индекс является отрицательным, если строка не является n массивом, поэтому `ShowWhere` метод принимает побитовое дополнение (оператор ~ в C# и Visual C++, `Xor`-1 в Visual Basic) для получения индекса первого элемента в списке, который больше, чем строка поиска.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, и один или несколько элементов в массиве <paramref name="array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <exception cref="T:System.ArgumentException">Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <block subset="none" type="usage"><para>В .NET Framework 4 и более ранних версиях использовался только алгоритм QuickSort. QuickSort определяет недопустимые компараторы в некоторых ситуациях, в которых операция сортировки создает исключение <see cref="T:System.IndexOutOfRangeException" /> и вызывает исключение <see cref="T:System.ArgumentException" /> вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, операции сортировки, которые ранее выбросили <see cref="T:System.ArgumentException" />, не вызовут исключение, так как алгоритмы сортировки и хеапсорт не обнаруживают недопустимый компаратор. В большинстве случаев это относится к массивам, количество элементов в которых меньше или равно 16.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Сортируемый одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля.</param>
        <param name="comparison"><see cref="T:System.Comparison`1" />, используемый при сравнении элементов.</param>
        <summary>Сортирует элементы массива <see cref="T:System.Array" /> с использованием указанного объекта <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` — <xref:System.Array.Length%2A> `array`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется перегрузка метода <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>.  
  
 В примере кода определяется альтернативный метод сравнения для строк с именем `CompareDinosByLength`. Этот метод работает следующим образом: во-первых, сравниваемые проверяются на`null`, а пустая ссылка считается меньше, чем значение, отличное от NULL. Во-вторых, длины строк сравниваются, а более длинная строка считается большей. В-третьих, если длины равны, используется обычное сравнение строк.  
  
 Массив строк создается и заполняется четырьмя строками без определенного порядка. Список также содержит пустую строку и пустую ссылку. Список отображается, сортируется с помощью <xref:System.Comparison%601> универсального делегата, представляющего метод `CompareDinosByLength`, и снова отображается.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="comparison" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Реализация <paramref name="comparison" /> вызвала ошибку во время сортировки. Например, <paramref name="comparison" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <block subset="none" type="usage"><para>В .NET Framework 4 и более ранних версиях использовался только алгоритм QuickSort. QuickSort определяет недопустимые компараторы в некоторых ситуациях, в которых операция сортировки создает исключение <see cref="T:System.IndexOutOfRangeException" /> и вызывает исключение <see cref="T:System.ArgumentException" /> вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, операции сортировки, которые ранее выбросили <see cref="T:System.ArgumentException" />, не вызовут исключение, так как алгоритмы сортировки и хеапсорт не обнаруживают недопустимый компаратор. В большинстве случаев это относится к массивам, количество элементов в которых меньше или равно 6.</para></block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Сортируемый одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <summary>Сортирует элементы в диапазоне элементов массива <see cref="T:System.Array" />, используя реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> каждого элемента массива <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый элемент в пределах указанного диапазона элементов в `array` должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы иметь возможность сравнения с каждым другим элементом в `array`.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется перегрузка универсального метода <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> и <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ная перегрузка универсального метода для сортировки диапазона в массиве.  
  
 В примере кода определяется альтернативный компаратор для строк с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальном интерфейсе. Функция сравнения вызывает метод <xref:System.String.CompareTo%28System.String%29>, отменяя порядок сравниваемых строк таким образом, чтобы строки были в высоком и низком уровне, а не в высоком.  
  
 В примере кода создается и отображается массив названий динозавров, состоящий из трех хербиворес, за которыми следуют три карниворес (тиранносауридс, чтобы быть точными). Перегрузка <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> универсального метода используется для сортировки последних трех элементов массива, которые затем отображаются. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ная перегрузка универсального метода используется с `ReverseCompare` для сортировки последних трех элементов в обратном порядке. Все эти динозавры снова отображаются.  
  
> [!NOTE]
>  Вызовы методов <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> не отличаются от вызовов к неуниверсальным аналогам, поскольку Visual Basic, C#и C++ определяют тип параметра универсального типа из типа первого аргумента. Если вы используете [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы изучить MSIL, можно увидеть, что вызываемые универсальные методы вызываются.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в массиве <paramref name="array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Сортируемый одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, используемая при сравнении элементов, или значение <see langword="null" /> для использования реализации универсального интерфейса <see cref="T:System.IComparable`1" /> каждого элемента.</param>
        <summary>Сортирует элементы в диапазоне элементов массива <see cref="T:System.Array" />, используя указанный универсальный интерфейс <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` `null`, каждый элемент в пределах указанного диапазона элементов в `array` должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы иметь возможность сравнения с каждым другим элементом в `array`.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется перегрузка универсального метода <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> и <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ная перегрузка универсального метода для сортировки диапазона в массиве.  
  
 В примере кода определяется альтернативный компаратор для строк с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальном интерфейсе. Функция сравнения вызывает метод <xref:System.String.CompareTo%28System.String%29>, отменяя порядок сравниваемых строк таким образом, чтобы строки были в высоком и низком уровне, а не в высоком.  
  
 В примере кода создается и отображается массив названий динозавров, состоящий из трех хербиворес, за которыми следуют три карниворес (тиранносауридс, чтобы быть точными). Перегрузка <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> универсального метода используется для сортировки последних трех элементов массива, которые затем отображаются. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ная перегрузка универсального метода используется с `ReverseCompare` для сортировки последних трех элементов в обратном порядке. Все эти динозавры снова отображаются.  
  
> [!NOTE]
>  Вызовы методов <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> не отличаются от вызовов к неуниверсальным аналогам, поскольку Visual Basic, C#и C++ определяют тип параметра универсального типа из типа первого аргумента. Если вы используете [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы изучить MSIL, можно увидеть, что вызываемые универсальные методы вызываются.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.  
  
-или- 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, и один или несколько элементов в массиве <paramref name="array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage"><para>В .NET Framework 4 и более ранних версиях использовался только алгоритм QuickSort. QuickSort определяет недопустимые компараторы в некоторых ситуациях, в которых операция сортировки создает исключение <see cref="T:System.IndexOutOfRangeException" /> и вызывает исключение <see cref="T:System.ArgumentException" /> вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, операции сортировки, которые ранее выбросили <see cref="T:System.ArgumentException" />, не вызовут исключение, так как алгоритмы сортировки и хеапсорт не обнаруживают недопустимый компаратор. В большинстве случаев это относится к массивам, количество элементов в которых меньше или равно 16.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип элементов массива ключей.</typeparam>
        <typeparam name="TValue">Тип элементов массива элементов.</typeparam>
        <param name="keys">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий элементы, соответствующие ключам в массиве <paramref name="keys" />, или значение <see langword="null" /> для сортировки только массива <paramref name="keys" />.</param>
        <summary>Сортирует пару объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> каждого ключа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys`<xref:System.Array> имеет соответствующий элемент в `items`<xref:System.Array>. При перемещении ключа во время сортировки соответствующий элемент в `items`<xref:System.Array> аналогичным образом перемещается. Таким образом, <xref:System.Array> `items`сортируются в соответствии с расположением соответствующих ключей в `keys`<xref:System.Array>.  
  
 Каждый ключ в `keys`<xref:System.Array> должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы иметь возможность сравнения с любым другим ключом.  
  
 Если число элементов больше, чем ключей, можно выполнить сортировку, но элементы, не имеющие соответствующих ключей, не будут отсортированы. Невозможно выполнить сортировку, если количество ключей превышает число элементов; Это вызовет исключение <xref:System.ArgumentException>.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше или равен 16 элементам, то используется алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` — <xref:System.Array.Length%2A> `array`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование перегрузок универсальных методов <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>и <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> для сортировки пар массивов, представляющих ключи и значения.  
  
 В примере кода определяется альтернативный компаратор для строк с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальном интерфейсе. Функция сравнения вызывает метод <xref:System.String.CompareTo%28System.String%29>, отменяя порядок сравниваемых строк таким образом, чтобы строки были в высоком и низком уровне, а не в высоком.  
  
 В примере кода создается и отображается массив названий динозавров (ключей) и массив целых чисел, представляющих максимальную длину каждого динозавра в метрах (значения). Затем массивы сортируются и отображаются несколько раз:  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> используется для сортировки обоих массивов в порядке имен динозавров в первом массиве.  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и экземпляр `ReverseCompare` используются для изменения порядка сортировки парных массивов.  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> используется для сортировки последних трех элементов обоих массивов.  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> используется для сортировки последних трех элементов обоих массивов в противоположном порядке.  
  
> [!NOTE]
>  Вызовы универсальных методов не отличаются от вызовов к неуниверсальным аналогам, поскольку Visual Basic, C#и C++ определяют тип параметра универсального типа из типа первых двух аргументов. Если вы используете [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы изучить MSIL, можно увидеть, что вызываемые универсальные методы вызываются.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> не равно <see langword="null" />, а нижняя граница массива <paramref name="keys" /> не соответствует нижней границе массива <paramref name="items" />.  
  
-или- 
 <paramref name="items" /> не равно <see langword="null" />, а длина <paramref name="keys" /> больше длины <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в <paramref name="keys" /><see cref="T:System.Array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип элементов массива ключей.</typeparam>
        <typeparam name="TValue">Тип элементов массива элементов.</typeparam>
        <param name="keys">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий элементы, соответствующие ключам в массиве <paramref name="keys" />, или значение <see langword="null" /> для сортировки только массива <paramref name="keys" />.</param>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, используемая при сравнении элементов, или значение <see langword="null" /> для использования реализации универсального интерфейса <see cref="T:System.IComparable`1" /> каждого элемента.</param>
        <summary>Сортирует пару объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя указанный универсальный интерфейс <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys`<xref:System.Array> имеет соответствующий элемент в `items`<xref:System.Array>. При перемещении ключа во время сортировки соответствующий элемент в `items`<xref:System.Array> аналогичным образом перемещается. Таким образом, <xref:System.Array> `items`сортируются в соответствии с расположением соответствующих ключей в `keys`<xref:System.Array>.  
  
 Если `comparer` `null`, каждый ключ в `keys`<xref:System.Array> должен реализовывать универсальный интерфейс <xref:System.IComparable%601> для сравнения с любым другим ключом.  
  
 Если число элементов больше, чем ключей, можно выполнить сортировку, но элементы, не имеющие соответствующих ключей, не будут отсортированы. Невозможно выполнить сортировку, если количество ключей превышает число элементов; Это вызовет исключение <xref:System.ArgumentException>.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` — <xref:System.Array.Length%2A> `array`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<XREF: System. массив. Sort %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2CSystem. Collections. Generic. IComparer% 7B %60 %600% 7D %29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>и <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> перегрузок универсальных методов для сортировки пар массивов, представляющих ключи и значения.  
  
 В примере кода определяется альтернативный компаратор для строк с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальном интерфейсе. Функция сравнения вызывает метод <xref:System.String.CompareTo%28System.String%29>, отменяя порядок сравниваемых строк таким образом, чтобы строки были в высоком и низком уровне, а не в высоком.  
  
 В примере кода создается и отображается массив названий динозавров (ключей) и массив целых чисел, представляющих максимальную длину каждого динозавра в метрах (значения). Затем массивы сортируются и отображаются несколько раз:  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> используется для сортировки обоих массивов в порядке имен динозавров в первом массиве.  
  
-   [\], TValue\<XREF: System. Array. Sort %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2CSystem. Collections. Generic. IComparer% 7B %60 %600% 7D %29 > и экземпляр `ReverseCompare` используются для изменения порядка сортировки парных массивов.  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> используется для сортировки последних трех элементов обоих массивов.  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> используется для сортировки последних трех элементов обоих массивов в противоположном порядке.  
  
> [!NOTE]
>  Вызовы универсальных методов не отличаются от вызовов к неуниверсальным аналогам, поскольку Visual Basic, C#и C++ определяют тип параметра универсального типа из типа первых двух аргументов. Если вы используете [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы изучить MSIL, можно увидеть, что вызываемые универсальные методы вызываются.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> не равно <see langword="null" />, а нижняя граница массива <paramref name="keys" /> не соответствует нижней границе массива <paramref name="items" />.  
  
-или- 
 <paramref name="items" /> не равно <see langword="null" />, а длина <paramref name="keys" /> больше длины <paramref name="items" />.  
  
-или- 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, и один или несколько элементов в <paramref name="keys" /><see cref="T:System.Array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage"><para>В .NET Framework 4 и более ранних версиях использовался только алгоритм QuickSort. QuickSort определяет недопустимые компараторы в некоторых ситуациях, в которых операция сортировки создает исключение <see cref="T:System.IndexOutOfRangeException" /> и вызывает исключение <see cref="T:System.ArgumentException" /> вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, операции сортировки, которые ранее выбросили <see cref="T:System.ArgumentException" />, не вызовут исключение, так как алгоритмы сортировки и хеапсорт не обнаруживают недопустимый компаратор. В большинстве случаев это относится к массивам, количество элементов в которых меньше или равно 16.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип элементов массива ключей.</typeparam>
        <typeparam name="TValue">Тип элементов массива элементов.</typeparam>
        <param name="keys">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий элементы, соответствующие ключам в массиве <paramref name="keys" />, или значение <see langword="null" /> для сортировки только массива <paramref name="keys" />.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <summary>Сортирует диапазон элементов в паре объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> каждого ключа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys`<xref:System.Array> имеет соответствующий элемент в `items`<xref:System.Array>. При перемещении ключа во время сортировки соответствующий элемент в `items`<xref:System.Array> аналогичным образом перемещается. Таким образом, <xref:System.Array> `items`сортируются в соответствии с расположением соответствующих ключей в `keys`<xref:System.Array>.  
  
 Каждый ключ в пределах указанного диапазона элементов в `keys`<xref:System.Array> должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы иметь возможность сравнения с любым другим ключом.  
  
 Если число элементов больше, чем ключей, можно выполнить сортировку, но элементы, не имеющие соответствующих ключей, не будут отсортированы. Невозможно выполнить сортировку, если количество ключей превышает число элементов; Это вызовет исключение <xref:System.ArgumentException>.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<XREF: System. массив. Sort %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 29 > и <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> перегрузки универсальных методов для сортировки пар массивов, представляющих ключи и значения.  
  
 В примере кода определяется альтернативный компаратор для строк с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальном интерфейсе. Функция сравнения вызывает метод <xref:System.String.CompareTo%28System.String%29>, отменяя порядок сравниваемых строк таким образом, чтобы строки были в высоком и низком уровне, а не в высоком.  
  
 В примере кода создается и отображается массив названий динозавров (ключей) и массив целых чисел, представляющих максимальную длину каждого динозавра в метрах (значения). Затем массивы сортируются и отображаются несколько раз:  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> используется для сортировки обоих массивов в порядке имен динозавров в первом массиве.  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и экземпляр `ReverseCompare` используются для изменения порядка сортировки парных массивов.  
  
-   [\], TValue\<XREF: System. Array. Sort %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 29 > используется для сортировки последних трех элементов обоих массивов.  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> используется для сортировки последних трех элементов обоих массивов в противоположном порядке.  
  
> [!NOTE]
>  Вызовы универсальных методов не отличаются от вызовов к неуниверсальным аналогам, поскольку Visual Basic, C#и C++ определяют тип параметра универсального типа из типа первых двух аргументов. Если вы используете [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы изучить MSIL, можно увидеть, что вызываемые универсальные методы вызываются.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="keys" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> не равно <see langword="null" />, а нижняя граница массива <paramref name="keys" /> не соответствует нижней границе массива <paramref name="items" />.  
  
-или- 
 <paramref name="items" /> не равно <see langword="null" />, а длина <paramref name="keys" /> больше длины <paramref name="items" />.  
  
-или- 
 <paramref name="index" /> и <paramref name="length" /> не определяют допустимый диапазон в <paramref name="keys" /><see cref="T:System.Array" />.  
  
-или- 
 <paramref name="items" /> не равно <see langword="null" />, а <paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в <paramref name="keys" /><see cref="T:System.Array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип элементов массива ключей.</typeparam>
        <typeparam name="TValue">Тип элементов массива элементов.</typeparam>
        <param name="keys">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий элементы, соответствующие ключам в массиве <paramref name="keys" />, или значение <see langword="null" /> для сортировки только массива <paramref name="keys" />.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, используемая при сравнении элементов, или значение <see langword="null" /> для использования реализации универсального интерфейса <see cref="T:System.IComparable`1" /> каждого элемента.</param>
        <summary>Сортирует диапазон элементов в паре объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя указанный универсальный интерфейс <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys`<xref:System.Array> имеет соответствующий элемент в `items`<xref:System.Array>. При перемещении ключа во время сортировки соответствующий элемент в `items`<xref:System.Array> аналогичным образом перемещается. Таким образом, <xref:System.Array> `items`сортируются в соответствии с расположением соответствующих ключей в `keys`<xref:System.Array>.  
  
 Если `comparer` `null`, каждый ключ в пределах указанного диапазона элементов в `keys`<xref:System.Array> должен реализовывать универсальный интерфейс <xref:System.IComparable%601>, чтобы иметь возможность сравнения с любыми другими ключами.  
  
 Если число элементов больше, чем ключей, можно выполнить сортировку, но элементы, не имеющие соответствующих ключей, не будут отсортированы. Невозможно выполнить сортировку, если количество ключей превышает число элементов; Это вызовет исключение <xref:System.ArgumentException>.  
  
 Если сортировка не выполнена успешно, результаты будут неопределенными.  
  
 Этот метод использует алгоритм сортировки гибридности (интросорт) следующим образом:  
  
-   Если размер секции меньше 16 элементов или равен ему, он использует алгоритм [сортировки вставки](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Если количество секций превышает 2 * log<sup>n</sup>, где *n* — это диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм [QuickSort](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 Для массивов, отсортированных с помощью алгоритмов Хеапсорт и QuickSort, в худшем случае этот метод является операцией O (`n` log `n`), где `n` `length`.  
  
   
  
## Examples  
 В следующем примере кода показаны <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>и [\], TValue\<XREF: System. массив. Sort %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Collections. Generic. IComparer% 7B %60 %600% 7D %29 > перегрузок универсальных методов для сортировки пар массивов, представляющих ключи и значения.  
  
 В примере кода определяется альтернативный компаратор для строк с именем `ReverseCompare`, который реализует `IComparer<string>`(`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальном интерфейсе. Функция сравнения вызывает метод <xref:System.String.CompareTo%28System.String%29>, отменяя порядок сравниваемых строк таким образом, чтобы строки были в высоком и низком уровне, а не в высоком.  
  
 В примере кода создается и отображается массив названий динозавров (ключей) и массив целых чисел, представляющих максимальную длину каждого динозавра в метрах (значения). Затем массивы сортируются и отображаются несколько раз:  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> используется для сортировки обоих массивов в порядке имен динозавров в первом массиве.  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и экземпляр `ReverseCompare` используются для изменения порядка сортировки парных массивов.  
  
-   Перегрузка <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> используется для сортировки последних трех элементов обоих массивов.  
  
-   [\], TValue\<XREF: System. массив. Sort %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Collections. Generic. IComparer% 7B %60 %600% 7D %29 > используется для сортировки последних трех элементов обоих массивов в обратном порядке.  
  
> [!NOTE]
>  Вызовы универсальных методов не отличаются от вызовов к неуниверсальным аналогам, поскольку Visual Basic, C#и C++ определяют тип параметра универсального типа из типа первых двух аргументов. Если вы используете [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы изучить MSIL, можно увидеть, что вызываемые универсальные методы вызываются.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="keys" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> не равно <see langword="null" />, а нижняя граница массива <paramref name="keys" /> не соответствует нижней границе массива <paramref name="items" />.  
  
-или- 
 <paramref name="items" /> не равно <see langword="null" />, а длина <paramref name="keys" /> больше длины <paramref name="items" />.  
  
-или- 
 <paramref name="index" /> и <paramref name="length" /> не определяют допустимый диапазон в <paramref name="keys" /><see cref="T:System.Array" />.  
  
-или- 
 <paramref name="items" /> не равно <see langword="null" />, а <paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="items" /><see cref="T:System.Array" />.  
  
-или- 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, и один или несколько элементов в <paramref name="keys" /><see cref="T:System.Array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage"><para>В .NET Framework 4 и более ранних версиях использовался только алгоритм QuickSort. QuickSort определяет недопустимые компараторы в некоторых ситуациях, в которых операция сортировки создает исключение <see cref="T:System.IndexOutOfRangeException" /> и вызывает исключение <see cref="T:System.ArgumentException" /> вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, операции сортировки, которые ранее выбросили <see cref="T:System.ArgumentException" />, не вызовут исключение, так как алгоритмы сортировки и хеапсорт не обнаруживают недопустимый компаратор. В большинстве случаев это относится к массивам, количество элементов в которых меньше или равно 16.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект, с помощью которого можно синхронизировать доступ к коллекции <see cref="T:System.Array" />.</summary>
        <value>Объект, который может использоваться для синхронизации доступа к <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство реализует интерфейс <xref:System.Collections.ICollection?displayProperty=nameWithType>.  
  
 .NET Framework классы, основанные на <xref:System.Array>, предоставляют собственную синхронизированную версию коллекции с помощью свойства <xref:System.Array.SyncRoot%2A>.  
  
 Классы, использующие массивы, могут также реализовать собственную синхронизацию с помощью свойства <xref:System.Array.SyncRoot%2A>. Синхронизирующий код должен выполнять операции с `SyncRoot` коллекции, а не непосредственно в коллекции. Это обеспечивает правильную работу коллекций, являющихся производными других объектов. В частности, он поддерживает правильную синхронизацию с другими потоками, которые могут одновременно изменять коллекцию. Обратите внимание, что некоторые реализации <xref:System.Array.SyncRoot%2A> могут возвращать сам <xref:System.Array>.  
  
 Перечисление по коллекции не является потокобезопасной процедурой. Даже если коллекция синхронизирована, другие потоки могут ее изменить, что приведет к тому, что перечислитель создаст исключение. Для обеспечения потокобезопасности при перечислении можно либо заблокировать коллекцию на все время перечисления, либо перехватывать исключения, возникающие в результате изменений, внесенных другими потоками.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как заблокировать массив во время перечисления во всем перечислении с помощью свойства <xref:System.Array.SyncRoot%2A>.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Array" />.</summary>
        <value>Количество элементов в коллекции.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее, является ли доступ к коллекции <see cref="T:System.Array" /> синхронизированным (потокобезопасным).</summary>
        <value>Значение true, если доступ к коллекции <see cref="T:System.Array" /> является синхронизированным (потокобезопасным); в противном случае — значение false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект, с помощью которого можно синхронизировать доступ к коллекции <see cref="T:System.Array" />.</summary>
        <value>Объект, который может использоваться для синхронизации доступа к <see cref="T:System.Array" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который должен быть добавлен в коллекцию <see cref="T:System.Collections.IList" />.</param>
        <summary>При вызове этого метода всегда возникает исключение <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Добавление значений в массив не поддерживается. Возвращаемое значение отсутствует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обычно <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType>ная реализация добавляет элемент в коллекцию. Однако, поскольку массивы имеют фиксированный размер (свойство <xref:System.Array.IsFixedSize%2A> всегда возвращает `true`), этот метод всегда создает исключение <xref:System.NotSupportedException>.  
  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> имеет фиксированный размер.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все элементы из коллекции <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.IList" /> доступен только для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который требуется найти в текущем списке. Элемент, который требуется найти, для ссылочных типов может быть равен <see langword="null" />.</param>
        <summary>Определяет, входит ли элемент в коллекцию <see cref="T:System.Collections.IList" />.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> найден в коллекции <see cref="T:System.Collections.IList" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который требуется найти в текущем списке.</param>
        <summary>Определяет индекс заданного элемента в списке <see cref="T:System.Collections.IList" />.</summary>
        <returns>Индекс значения, если оно найдено в списке; в противном случае — значение, равное -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Индекс, по которому требуется вставить элемент <paramref name="value" />.</param>
        <param name="value">Вставляемый объект.</param>
        <summary>Вставляет элемент в список <see cref="T:System.Collections.IList" /> по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> не является допустимым индексом в <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.IList" /> доступен только для чтения.  
  
-или- 
<see cref="T:System.Collections.IList" /> имеет фиксированный размер.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> — пустая ссылка в списке <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, имеет ли объект <see cref="T:System.Array" /> фиксированный размер.</summary>
        <value>Значение true, если коллекция <see cref="T:System.Array" /> имеет фиксированный размер; в противном случае — значение false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое определяет, является ли коллекция <see cref="T:System.Array" /> доступной только для чтения.</summary>
        <value>Значение true, если коллекция <see cref="T:System.Array" /> доступна только для чтения; в противном случае — значение false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Индекс элемента, который необходимо получить или задать.</param>
        <summary>Возвращает или задает элемент по указанному индексу.</summary>
        <value>Элемент, расположенный по указанному индексу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="index" /> больше или равно значению свойства <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">Текущий массив <see cref="T:System.Array" /> не имеет ровно одного измерения.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который необходимо удалить из коллекции <see cref="T:System.Collections.IList" />.</param>
        <summary>Удаляет первое вхождение указанного объекта из коллекции <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.IList" /> доступен только для чтения.  
  
-или- 
<see cref="T:System.Collections.IList" /> имеет фиксированный размер.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Индекс элемента, который должен быть удален.</param>
        <summary>Удаляет элемент <see cref="T:System.Collections.IList" />, расположенный по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Индекс не является допустимым индексом в <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.IList" /> доступен только для чтения.  
  
-или- 
<see cref="T:System.Collections.IList" /> имеет фиксированный размер.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Объект для сравнения с текущим экземпляром.</param>
        <param name="comparer">Объект, который сравнивает текущий объект и объект <paramref name="other" />.</param>
        <summary>Определяет позицию текущего объекта коллекции относительно другого объекта в порядке сортировки (находится перед другим объектов, на одной позиции с ним или после другого объекта).</summary>
        <returns>Целое число, определяющее, как соотносятся между собой текущий объект коллекции и другой объект. Возможные соотношения показаны в следующей таблице.  
  
 <list type="table"><listheader><term> Возвращаемое значение 
 </term><description> Описание 
 </description></listheader><item><term> -1 
 </term><description> Текущий экземпляр стоит перед объектом <paramref name="other" />.  
  
 </description></item><item><term> 0 
 </term><description> Текущий экземпляр и объект <paramref name="other" /> равны.  
  
 </description></item><item><term> 1 
 </term><description> Текущий экземпляр стоит после объекта <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IStructuralComparable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Объект для сравнения с текущим экземпляром.</param>
        <param name="comparer">Объект, определяющий, равны ли текущий экземпляр и объект <paramref name="other" />.</param>
        <summary>Определяет, равен ли объект текущему экземпляру.</summary>
        <returns>Значение <see langword="true" />, если эти два объекта равны; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="comparer">Объект, вычисляющий хэш-код текущего объекта.</param>
        <summary>Возвращает хэш-код текущего экземпляра.</summary>
        <returns>Хэш-код для текущего экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, который необходимо проверить на соответствие условиям.</param>
        <param name="match">Предикат, определяющий условия, на соответствие которым проверяются элементы.</param>
        <summary>Определяет, все ли элементы массива удовлетворяют условиям указанного предиката.</summary>
        <returns>Значение <see langword="true" />, если каждый элемент массива <paramref name="array" /> удовлетворяет условиям заданного предиката; в противном случае — значение <see langword="false" />. Если элементы в массиве отсутствуют, возвращается значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> является делегатом для метода, который возвращает`true`, если переданный ему объект соответствует условиям, определенным в делегате.  Элементы `array` по отдельности передаются <xref:System.Predicate%601>, а обработка останавливается, когда делегат возвращает `false` для любого элемента.  
  
 Этот метод является операцией O (`n`), где `n` является <xref:System.Array.Length%2A>ом `array`.  
  
   
  
## Examples  
 В следующем примере определяется, является ли последний символ каждого элемента в массиве строк числом. Он создает два строковых массива. Первый массив включает в себя обе строки, заканчивающиеся алфавитными символами, и строки, заканчивающиеся числовыми символами. Второй массив состоит только из строк, которые заканчиваются числовыми символами. В примере также определяется метод `EndWithANumber`, сигнатура которого соответствует делегату <xref:System.Predicate%601>. В примере каждый массив передается в <xref:System.Array.TrueForAll%2A> метод вместе с делегатом, который представляет метод `EndsWithANumber`.  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 Следующий пример похож на первый, за исключением того, что он передает строковый массив в <xref:System.Array.TrueForAll%2A> метод вместе с лямбда-выражением, определяющим, заканчивается ли конкретный элемент массива строковым представлением числа.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 В обоих случаях метод <xref:System.Array.TrueForAll%2A> возвращает `false`, как только он встречает первый элемент массива, который не заканчивается числом. В противном случае он возвращает `true` после итерации всех элементов в массиве.  
  
> [!NOTE]
>  Как показано в обоих примерах C# , в и Visual Basic нет необходимости явно создавать делегат `Predicate<string>` (`Predicate(Of String)` в Visual Basic). Эти языки выводят правильный делегат из контекста и создают его автоматически.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
