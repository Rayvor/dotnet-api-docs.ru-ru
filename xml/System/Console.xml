<Type Name="Console" FullName="System.Console">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8ecce71b2343159a350f88a47436d716ece79c34" /><Meta Name="ms.sourcegitcommit" Value="cfc0e4215fd0d259582ada2141878befd7c3c8c6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="07/12/2019" /><Meta Name="ms.locfileid" Value="67855624" /></Metadata><TypeSignature Language="C#" Value="public static class Console" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Console extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Console" />
  <TypeSignature Language="VB.NET" Value="Public Class Console" />
  <TypeSignature Language="C++ CLI" Value="public ref class Console abstract sealed" />
  <TypeSignature Language="F#" Value="type Console = class" />
  <AssemblyInfo>
    <AssemblyName>System.Console</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет стандартные потоки для консольных приложений: входной, выходной и поток сообщений об ошибках. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль является окном операционной системы, где пользователи работают с операционной системой или с помощью текстовых консольное приложение, введя ввода текста с клавиатуры и при чтении вывода текста в окне терминала на компьютере. Например в операционной системе Windows, консоль называется окно командной строки и принимает команды MS-DOS. <xref:System.Console> Класс обеспечивает базовую поддержку для приложений, которые считывают символы из и вывести их на консоль.  
  
 Сведения о разработке с помощью <xref:System.Console> класса, в следующих разделах:  
  
-   [Потоки консольного ввода-вывода](#Streams)  
  
-   [Буфер экрана и окно консоли](#Buffer)  
  
-   [Поддержка Юникода для консоли](#Unicode)  
  
-   [Стандартные операции](#Operations)  
  
-   [Заметки о .NET core](#Core)  
  
<a name="Streams"></a>   
## <a name="console-io-streams"></a>Потоки консольного ввода-вывода  
 При запуске консольного приложения, операционная система автоматически связывает три потока ввода-вывода с помощью консоли: стандартный входной поток, в стандартный выходной поток и в стандартный поток вывода ошибок. Ваше приложение может считывать входные данные пользователя из стандартного входного потока; запись обычные данные в стандартный выходной поток; и записи данных об ошибке в стандартный выходной поток ошибок. Эти потоки представлены в приложении в виде значения <xref:System.Console.In%2A?displayProperty=nameWithType>, <xref:System.Console.Out%2A?displayProperty=nameWithType>, и <xref:System.Console.Error%2A?displayProperty=nameWithType> свойства.  
  
 По умолчанию значение <xref:System.Console.In%2A> свойство <xref:System.IO.TextReader?displayProperty=nameWithType> объект, представляющий клавиатуры и значения <xref:System.Console.Out%2A> и <xref:System.Console.Error%2A> свойства являются <xref:System.IO.TextWriter?displayProperty=nameWithType> объекты, представляющие окно консоли. Тем не менее эти свойства можно задать в потоки, которые не представляют собой окно консоли или клавиатуре; Например можно задать эти свойства в потоки, которые представляют файлы. Чтобы перенаправить стандартного ввода, стандартный поток вывода или стандартный поток ошибок, вызовите <xref:System.Console.SetIn%2A?displayProperty=nameWithType>, <xref:System.Console.SetOut%2A?displayProperty=nameWithType>, или <xref:System.Console.SetError%2A?displayProperty=nameWithType> метода, соответственно. Операций ввода-вывода, использующих эти потоки, синхронизируются, что означает, что может считывать из нескольких потоков, или записи данных в потоки. Это означает, что методы, которые обычно асинхронные, такие как <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType>, выполняются синхронно, если объект представляет поток консоли.  
  
> [!NOTE]
>  Не используйте <xref:System.Console> класс для отображения выходных данных в автоматическом режиме приложениях, например серверных приложений. Вызовы методов, например <xref:System.Console.Write%2A?displayProperty=nameWithType> и <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> не оказывают влияния в приложениях графического пользовательского интерфейса.  
  
 <xref:System.Console> члены класса, которые работают нормально, когда основной поток направляется на консоль может создания исключения, если поток перенаправлен, например, в файл. В приложениях для перехвата <xref:System.IO.IOException?displayProperty=nameWithType> исключения, если перенаправление стандартного потока. Можно также использовать <xref:System.Console.IsOutputRedirected%2A>, <xref:System.Console.IsInputRedirected%2A>, и <xref:System.Console.IsErrorRedirected%2A> свойства, чтобы определить, перенаправляется ли стандартный поток перед выполнением операции, которая создает <xref:System.IO.IOException?displayProperty=nameWithType> исключение.  
  
 Иногда полезно явным образом вызывать члены объектов потока, представленного <xref:System.Console.In%2A>, <xref:System.Console.Out%2A>, и <xref:System.Console.Error%2A> свойства. Например, по умолчанию <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> метод считывает входные данные из стандартного входного потока. Аналогичным образом <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> метод записывает данные в стандартный выходной поток данных следуют строки по умолчанию завершения, который является символ возврата каретки и перевода строки («\r\n»). Тем не менее <xref:System.Console> класс не предоставляет соответствующий метод для записи данных в стандартный выходной поток ошибок или свойства для изменения признака конца строки для данных, записанных в поток.  
  
 Эту проблему можно решить, задав <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> свойство <xref:System.Console.Out%2A> или <xref:System.Console.Error%2A> свойства другого признака конца строки. Например следующая инструкция C# устанавливает признака конца строки для стандартный поток вывода ошибок для двух символ возврата каретки и перевода последовательностей строки:  
  
 `Console.Error.NewLine = "\r\n\r\n";`  
  
 Затем можно явным образом вызвать <xref:System.IO.TextWriter.WriteLine%2A> метод объекта error выходной поток, как в следующей инструкции C#:  
  
 `Console.Error.WriteLine();`  
  
<a name="Buffer"></a>   
## <a name="screen-buffer-and-console-window"></a>Буфер экрана и окно консоли  
 Тесно связанные признаки консоли не буфера экрана и окно консоли. Текст фактически чтения или записи в потоки, принадлежащие консоли, но могут быть чтения или записи в область, владельцем консоли, который называется буфера экрана. Буфера экрана является атрибутом консоли и организованы в виде прямоугольной сетки строк и столбцов, где каждый пересечения сетки или знакоместа, могут содержать символ. Каждый символ имеет собственный цвет переднего плана, и каждая ячейка символ имеет собственный цвет фона.  
  
 Буфера экрана просматривается через прямоугольную область, называемую в окно консоли. В окне консоли является еще одним атрибутом консоли; Это не сама консоль, которая является окном операционной системы. В окне консоли организованы в строки и столбцы, меньше или равен размеру буфера экрана и могут быть перемещены в виде буфера экрана. Если буфера экрана больше, чем в окне консоли, консоль автоматически отображаются полосы прокрутки, поэтому может быть перемещен в окне консоли через буферной области экрана.  
  
 Курсор указывает положение буфера экрана, где в настоящее время чтения или записи текста. Курсор можно скрывать или делать видимыми, и можно изменить высоту. Если курсор видим, положение окна консоли перемещается автоматически, чтобы он всегда в представлении.  
  
 Источником для координаты ячейки символа в буфере экрана является верхний левый угол и положение курсора и окна консоли измеряется относительно начала координат. Используйте индексы (с нуля), чтобы указать позиций; то есть необходимо укажите самая верхняя строка как строки и крайний слева столбец как столбец 0. Максимальное значение для строк и столбцов индексов — <xref:System.Int16.MaxValue?displayProperty=nameWithType>.  
  
<a name="Unicode"></a>   
## <a name="unicode-support-for-the-console"></a>Поддержка Юникода для консоли  
 В общем случае консоль считывает входные данные и записывает выходные данные с помощью текущей кодовой странице консоли, который определяет национальную настройку системы по умолчанию. Кодовая страница может обрабатывать только подмножество доступных символов Юникода, поэтому при попытке отображения символов, которые не сопоставлены с использованием конкретной кодовой страницы, консоль не сможет отобразить все символы или отражать их. Приведенный ниже пример иллюстрирует данную проблему. Предпринимается попытка отобразить символы кириллицы алфавита от U + 0410 U + 044F на консоль. При выполнении примера в системе, которая использует консоль кодовую страницу 437, каждый символ заменяется знак вопроса (?), так как символы в кодовой странице 437 не сопоставляются символы кириллицы.  
  
 [!code-csharp[System.Console.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/unicode1.cs#1)]
 [!code-vb[System.Console.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/unicode1.vb#1)]  
  
 В дополнение к поддержке кодовых страниц, <xref:System.Console> класс поддерживает кодирование с помощью UTF-8 <xref:System.Text.UTF8Encoding> класса. Начиная с .NET Framework 4.5, <xref:System.Console> класс также поддерживает кодирование с помощью UTF-16 <xref:System.Text.UnicodeEncoding> класса. Для отображения символов Юникода в консоль. можно задать <xref:System.Console.OutputEncoding%2A> значение <xref:System.Text.UTF8Encoding> или <xref:System.Text.UnicodeEncoding>.  
  
 Поддержка символов Юникода требует кодировщик для распознавания конкретный символ Юникода, а также шрифт, который имеет глифов, необходимых для отображения этого символа. Чтобы успешно отображать символы Юникода в консоль, шрифта консоли должно быть присвоено не растровых или шрифта TrueType, например Consolas и Lucida Console. В следующем примере показано, как можно программно изменить шрифт из растровый шрифт для и Lucida Console.  
  
 [!code-csharp[System.Console.Class.Unsafe#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class.unsafe/cs/setfont1.cs#3)]
 [!code-vb[System.Console.Class.Unsafe#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class.unsafe/vb/setfont1.vb#3)]  
  
 Тем не менее шрифты TrueType можно отобразить только подмножества глифов. Например шрифт Lucida Console отображает только 643 из примерно 64 000 доступны символы от U + 0021 до U + FB02. Чтобы увидеть, что символы определенного шрифта поддерживает, откройте **шрифты** апплета панели управления выберите **поиска символа** параметр и выберите шрифт, установленный символ которого вы хотите изучить в  **Шрифт** список **символов** окна.  
  
 Windows использует связь шрифтов, чтобы отобразить глифы, которые не доступны в определенном шрифте. Сведения о связь шрифтов для отображения дополнительные наборы символов, см. в разделе [Глобализация шаг за шагом: Шрифты](https://go.microsoft.com/fwlink/?LinkId=229111). В подразделе реестра HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink определяются связанных шрифтов. Каждой записи, связанные с этого подраздела соответствует имя базового шрифта, и его значение является массивом строк, определяет файлы шрифтов и шрифтов, которые связаны с базового шрифта. Каждый элемент массива определяет связанный шрифта и принимает форму *шрифта файла*,*имя шрифта*. В следующем примере показано, как программным способом можно определить связанные с именем найден в файле simsun.ttc, отображающий упрощенное Хан символов шрифта SimSun шрифта.  
  
 [!code-csharp[System.Console.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/fontlink1.cs#2)]
 [!code-vb[System.Console.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/fontlink1.vb#2)]  
  
 Поддержка Юникода для консоли имеет следующие ограничения:  
  
-   Кодировка UTF-32, не поддерживается. Единственные поддерживаемые кодировки: UTF-8 и UTF-16, которые представлены Юникода <xref:System.Text.UTF8Encoding> и <xref:System.Text.UnicodeEncoding> классы, соответственно.  
  
-   Двунаправленный вывод не поддерживается.  
  
-   Отображение символов за пределами базовой многоязыковой плоскости (т. е суррогатных пар) не поддерживается, даже если они определены в файле связанных шрифтов.  
  
-   Отображение символов в сложных сценариях не поддерживается.  
  
-   Объединение последовательностей символов (то есть символы, состоящие из базового знака и один или несколько несамостоятельных символов), отображаются как отдельные символы. Чтобы обойти это ограничение, вы можете нормализовать строку для отображения, вызвав <xref:System.String.Normalize%2A?displayProperty=nameWithType> метод перед отправкой вывод на консоль. В следующем примере строка, содержащая символ объединения последовательности 0061 U + U + 0308 выводится на консоль, как два символа, прежде чем нормализуется выходной строки, а также как один символ после <xref:System.String.Normalize%2A?displayProperty=nameWithType> вызывается метод.  
  
     [!code-csharp[System.Console.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/normalize1.cs#5)]
     [!code-vb[System.Console.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/normalize1.vb#5)]  
  
     Обратите внимание, что нормализации приемлемым решением является только в том случае, если последовательность символов в стандарте для составными форму, которая соответствует конкретному combining содержит символ Юникода.  
  
-   Если шрифт предоставляет глиф для кодовую точку в области частного использования, этот глиф будет отображаться. Тем не менее так как символы в области частного использования зависят от приложения, это может оказаться ожидаемый глифа.  
  
 В следующем примере отображается диапазона символов Юникода в консоль. Пример принимает три параметра командной строки: начало диапазона для отображения, конец диапазона для отображения и следует ли использовать текущая кодировка консоли (`false`) или кодировку UTF-16 (`true`). Предполагается, что консоль использует шрифт TrueType.  
  
 [!code-csharp[System.Console.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/example3.cs#4)]
 [!code-vb[System.Console.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/example3.vb#4)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Стандартные операции  
 <xref:System.Console> Класс содержит следующие методы для чтения ввода в консоли и записи выходных данных консоли:  
  
-   Перегрузки <xref:System.Console.ReadKey%2A> метод считывать отдельный символ.  
  
-   <xref:System.Console.ReadLine%2A> Метод считывает всю строку входных данных.  
  
-   <xref:System.Console.Write%2A> Перегрузок метода преобразования экземпляра типа значения, массив символов или набор объектов в форматированном или неформатированном виде строку и затем написать эту строку в консоль.  
  
-   Набор параллельный <xref:System.Console.WriteLine%2A> же строку в качестве выходных данных перегрузки метода <xref:System.Console.Write%2A> перегрузки, а также добавлять признака конца строки.  
  
 <xref:System.Console> Класс также содержит методы и свойства для выполнения следующих операций:  
  
-   Возвращает или задает размер буфера экрана. <xref:System.Console.BufferHeight%2A> И <xref:System.Console.BufferWidth%2A> свойства позволяют получить или задать буфера высоту и ширину, соответственно и <xref:System.Console.SetBufferSize%2A> метод позволяет задать размер буфера в одном вызове метода.  
  
-   Возвращает или задает размер окна консоли. <xref:System.Console.WindowHeight%2A> И <xref:System.Console.WindowWidth%2A> свойства позволяют получить или задать ширину и высоту окна соответственно и <xref:System.Console.SetWindowSize%2A> метод позволяет задать размер окна в одном вызове метода.  
  
-   Возвращает или задает размер курсора. <xref:System.Console.CursorSize%2A> Указывает высоту курсора в символьной ячейке.  
  
-   Возвращает или задает позицию окна консоли относительно буфера экрана. <xref:System.Console.WindowTop%2A> И <xref:System.Console.WindowLeft%2A> свойства позволяют получить или задать верхняя строка и крайний слева столбец буфера экрана, который отображается в окне консоли и <xref:System.Console.SetWindowPosition%2A> метод позволяет задавать эти значения в одном вызове метода.  
  
-   Возвращает или задает положение курсора путем получения или установки <xref:System.Console.CursorTop%2A> и <xref:System.Console.CursorLeft%2A> свойства, или набора положение курсора путем вызова <xref:System.Console.SetCursorPosition%2A> метод.  
  
-   Переместить или удалить данные в буфере экрана путем вызова <xref:System.Console.MoveBufferArea%2A> или <xref:System.Console.Clear%2A> метод.  
  
-   Возвращает или задает цвет фона и цвета с помощью <xref:System.Console.ForegroundColor%2A> и <xref:System.Console.BackgroundColor%2A> свойства, или возвращается к их по умолчанию цвета фона и переднего плана, вызвав <xref:System.Console.ResetColor%2A> метод.  
  
-   Воспроизвести звуковой сигнал через динамик консоли, вызвав <xref:System.Console.Beep%2A> метод.  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>Примечания по [!INCLUDE[net_core](~/includes/net-core-md.md)]  
 В .NET Framework на рабочем столе <xref:System.Console> класс использует кодировка, возвращенная `GetConsoleCP` и `GetConsoleOutputCP`, который обычно является кодовой страницы кодировки. Например, в системах, языком и региональными параметрами является английский (США), кодовую страницу 437 представлена кодировку, используемую по умолчанию. Однако в [!INCLUDE[net_core](~/includes/net-core-md.md)] может быть доступен только ограниченный набор кодировок. Если это так, <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> используется в качестве кодировки по умолчанию для консоли.  
  
 Если приложение зависит от конкретных кодовых страниц, вы можете по-прежнему сделать их доступными, выполнив указанные ниже *перед* вызова любых <xref:System.Console> методов:  
  
1.  Добавьте в проект ссылку на сборку System.Text.Encoding.CodePages.dll.  
  
2.  Получите объект <xref:System.Text.EncodingProvider> из свойства <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>.  
  
3.  Передайте объект <xref:System.Text.EncodingProvider> в метод <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>, чтобы сделать доступными дополнительные кодировки, поддерживаемые поставщиком кодировки.  
  
 <xref:System.Console> Класс будет автоматически использовать кодировку системы по умолчанию вместо UTF8, при условии, что вы зарегистрировали поставщик кодировки перед вызовом любых <xref:System.Console> методов вывода.  
  
   
  
## Examples  
 Ниже приведен пример, как считать данные из и записывать данные в стандартный входным и выходным потоками. Обратите внимание, что эти потоки можно перенаправить с помощью <xref:System.Console.SetIn%2A> и <xref:System.Console.SetOut%2A> методы.  
  
 [!code-cpp[Classic Console Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Console Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Console Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Console Example/CS/source.cs#1)]
 [!code-vb[Classic Console Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Console Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor BackgroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.BackgroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BackgroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor BackgroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundColor : ConsoleColor with get, set" Usage="System.Console.BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет фона консоли.</summary>
        <value>Значение из перечисления , задающее фоновый цвет консоли, то есть цвет, на фоне которого выводятся символы. Значением по умолчанию является Black.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изменение <xref:System.Console.BackgroundColor%2A> свойство затрагивает только выходные данные, которые записываются после изменения цвета фона ячеек отдельный символ. Чтобы изменить цвет фона окна консоли в целом, установите <xref:System.Console.BackgroundColor%2A> свойство и вызвать <xref:System.Console.Clear%2A> метод. Ниже приведен пример.  
  
 [!code-csharp[System.Console.BackgroundColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.backgroundcolor/cs/backgroundcolor1.cs#1)]
 [!code-vb[System.Console.BackgroundColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.backgroundcolor/vb/backgroundcolor1.vb#1)]  
  
 Возвращает операцию get для приложения на основе Windows, в котором существует консоли, <xref:System.ConsoleColor.Black?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере сохраняется значения <xref:System.ConsoleColor> перечисления в массив и сохраняет текущие значения <xref:System.Console.BackgroundColor%2A> и <xref:System.Console.ForegroundColor%2A> свойства к переменным. Затем он изменяет цвет переднего плана для каждого цвета в <xref:System.ConsoleColor> перечисления, за исключением того, как цвет, соответствующий текущий фон и изменяет цвет фона для каждого цвета в <xref:System.ConsoleColor> перечисления за исключением цвет, который соответствует текущий переднего плана. (Если цвет переднего плана является таким же, как цвет фона, текст не отображается.) Наконец, он вызывает <xref:System.Console.ResetColor%2A> метод, чтобы восстановить исходные цвета консоли.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Цвет, указанный в операции SET, не является допустимым членом <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Beep">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Воспроизводит звуковой сигнал через динамик консоли.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="System.Console.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Воспроизводит звуковой сигнал через динамик консоли.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию воспроизводит звуковой сигнал с частотой 800 Гц и длительностью 200 миллисекунд.  
  
> [!NOTE]
>  <xref:System.Console.Beep%2A> Метод не поддерживается на 64-разрядные выпуски Windows Vista и Windows XP.  
  
 <xref:System.Console.Beep%2A> Создает оболочку для вызова Windows [подавать функция](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Ли <xref:System.Console.Beep%2A> создает звука в версиях Windows до Windows 7 зависит от наличия микросхемы 8254 программируемый интервальный таймер. Начиная с Windows 7, зависит от звуковое устройство по умолчанию.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.Beep%2A> метод. В примере, принимает значение от 1 до 9 в качестве аргумента командной строки и воспроизводит звуковой сигнал соответствующее количество раз.  
  
 [!code-cpp[console.beep#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep/CPP/beep.cpp#1)]
 [!code-csharp[console.beep#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep/CS/beep.cs#1)]
 [!code-vb[console.beep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep/VB/beep.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.HostProtectionException">Этот метод выполнен на сервере, например SQL Server, который не разрешает доступ к интерфейсу пользователя.</exception>
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep (int frequency, int duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep(int32 frequency, int32 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep (frequency As Integer, duration As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep(int frequency, int duration);" />
      <MemberSignature Language="F#" Value="static member Beep : int * int -&gt; unit" Usage="System.Console.Beep (frequency, duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frequency" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="duration" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="frequency">Частота сигнала в диапазоне от 37 до 32767 Гц.</param>
        <param name="duration">Длительность сигнала в миллисекундах.</param>
        <summary>Воспроизводит звуковой сигнал заданной частоты и длительности через динамик консоли.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Beep%2A> Создает оболочку для вызова Windows [подавать функция](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Ли <xref:System.Console.Beep%2A> создает звука в версиях Windows до Windows 7 зависит от наличия микросхемы 8254 программируемый интервальный таймер. Начиная с Windows 7, зависит от звуковое устройство по умолчанию.  
  
> [!NOTE]
>  <xref:System.Console.Beep%2A> Метод не поддерживается на 64-разрядные выпуски Windows Vista и Windows XP.  
  
   
  
## Examples  
 В этом примере показано <xref:System.Console.Beep%2A> метод, воспроизводя первый несколько заметок песни через динамик консоли.  
  
 [!code-cpp[console.beep2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep2/CPP/b2.cpp#1)]
 [!code-csharp[console.beep2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep2/CS/b2.cs#1)]
 [!code-vb[console.beep2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep2/VB/b2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="frequency" /> меньше 37 или больше 32767 Гц.  
  
-или- 
 <paramref name="duration" /> меньше или равно нулю.</exception>
        <exception cref="T:System.Security.HostProtectionException">Этот метод выполнен на сервере, например SQL Server, который не разрешает доступ к консоли.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="BufferHeight">
      <MemberSignature Language="C#" Value="public static int BufferHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferHeight : int with get, set" Usage="System.Console.BufferHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту буферной области.</summary>
        <value>Текущая высота буферной области в строках.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство определяет количество строк (или строки), сохраненного в буфере, к которому обращаются режим окно консоли. Напротив <xref:System.Console.WindowHeight%2A> свойство определяет количество строк, отображаемых в окне консоли в любой момент времени. Если количество строк, фактически записанных в буфер превышает число строк, определенного параметром <xref:System.Console.WindowHeight%2A> свойства, окно может прокручиваться по вертикали, чтобы он отображал непрерывного количества строк, которые равны <xref:System.Console.WindowHeight%2A> свойство и находятся в любом месте в буфере.  
  
 Если операции задания уменьшает значение <xref:System.Console.BufferHeight%2A> свойства верхней строки удаляются. Например если число строк уменьшается с 300 до 250, от 0 до 49 строки удаляются и существующий 50 до 299 становятся "строки" строк 0 до 249.  
  
   
  
## Examples  
 В этом примере показано <xref:System.Console.BufferHeight%2A> и <xref:System.Console.BufferWidth%2A> свойства. В примере сообщается размеры окна операционной системы, задать размер буфера 300 строк и столбцов 85.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше или равно нулю.  
  
- или - 
Значение, заданное для операции set, больше или равно <see cref="F:System.Int16.MaxValue" />.  
  
-или- 
Значение в операции задания меньше суммы <see cref="P:System.Console.WindowTop" /> + <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BufferWidth">
      <MemberSignature Language="C#" Value="public static int BufferWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferWidth : int with get, set" Usage="System.Console.BufferWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ширину буферной области.</summary>
        <value>Текущая ширина буферной области в столбцах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если операции задания уменьшающую значение элемента <xref:System.Console.BufferWidth%2A> свойство, крайний правый столбцы будут удалены. Например если количество столбцов уменьшается с 80 до 60, 60 до 79 каждой строки столбцы удаляются.  
  
   
  
## Examples  
 В этом примере показано <xref:System.Console.BufferHeight%2A> и <xref:System.Console.BufferWidth%2A> свойства. В примере сообщается размеры окна операционной системы, задать размер буфера 300 строк и столбцов 85.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше или равно нулю.  
  
- или - 
Значение, заданное для операции set, больше или равно <see cref="F:System.Int16.MaxValue" />.  
  
-или- 
Значение в операции задания меньше суммы <see cref="P:System.Console.WindowLeft" /> + <see cref="P:System.Console.WindowWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelKeyPress">
      <MemberSignature Language="C#" Value="public static event ConsoleCancelEventHandler CancelKeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ConsoleCancelEventHandler CancelKeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Console.CancelKeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event CancelKeyPress As ConsoleCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event ConsoleCancelEventHandler ^ CancelKeyPress;" />
      <MemberSignature Language="F#" Value="member this.CancelKeyPress : ConsoleCancelEventHandler " Usage="member this.CancelKeyPress : System.ConsoleCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает при одновременном нажатии клавиши-модификатора <see cref="F:System.ConsoleModifiers.Control" /> (Ctrl) и либо клавиши консоли <see cref="F:System.ConsoleKey.C" /> (C), либо клавиши Break (Ctrl+C или Ctrl+Break).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие используется в сочетании с <xref:System.ConsoleCancelEventHandler?displayProperty=nameWithType> и <xref:System.ConsoleCancelEventArgs?displayProperty=nameWithType>. <xref:System.Console.CancelKeyPress> Событие позволяет перехватывать сигнал Ctrl + C, чтобы обработчик событий можно решить, следует ли продолжить выполнение или завершение консольное приложение. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Когда пользователь нажимает сочетание клавиш Ctrl + C или Ctrl + Break, <xref:System.Console.CancelKeyPress> события и приложения <xref:System.ConsoleCancelEventHandler> выполняется обработчик событий. Обработчик событий передается <xref:System.ConsoleCancelEventArgs> объект, имеющий два полезных свойств:  
  
-   <xref:System.ConsoleCancelEventArgs.SpecialKey%2A>, который позволяет определить, был ли вызван обработчик, в результате пользователь, нажав клавиши Ctrl + C (свойство имеет значение <xref:System.ConsoleSpecialKey.ControlC?displayProperty=nameWithType>) или Ctrl + Break (свойство имеет значение <xref:System.ConsoleSpecialKey.ControlBreak?displayProperty=nameWithType>).  
  
-   <xref:System.ConsoleCancelEventArgs.Cancel%2A>, который позволяет определить, как приложение следует ответить пользователю нажав клавиши Ctrl + C или Ctrl + Break. По умолчанию <xref:System.ConsoleCancelEventArgs.Cancel%2A> свойство `false`, какая причины программа выполнения для прерывания при выходе из обработчика событий. Изменение свойства на `true` указывает, что приложения должны продолжать выполнение.  
  
> [!TIP]
>  Если приложение имеет простые требования, можно использовать <xref:System.Console.TreatControlCAsInput%2A> свойство вместо этого события. Установив это свойство в `false`, убедитесь, что приложение всегда завершает работу, если пользователь нажимает сочетание клавиш Ctrl + C. При установке для него `true`, убедитесь, что нажатие клавиш Ctrl + C не, чтобы закрыть приложение.  
  
 Обработчик событий для этого события выполняется в потоке пула потоков.  
  
   
  
## Examples  
 В следующем примере показано, как <xref:System.Console.CancelKeyPress> используется событие. При нажатии клавиши Ctrl + C, операции чтения прерывается и `myHandler` вызывается обработчик событий. После входа в обработчик событий <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> свойство `false`, что означает, что текущий процесс будет прерван при завершает обработчик событий. Тем не менее, обработчик событий задает <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> свойства `true`, что означает, что процесс не завершится и возобновится операции чтения.  
  
 [!code-cpp[console.cancelkeypress#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cancelkeypress/cpp/ckp.cpp#1)]
 [!code-csharp[console.cancelkeypress#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cancelkeypress/cs/ckp.cs#1)]
 [!code-vb[console.cancelkeypress#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cancelkeypress/vb/ckp.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.ConsoleCancelEventArgs" />
        <altmember cref="T:System.ConsoleCancelEventHandler" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
      </Docs>
    </Member>
    <Member MemberName="CapsLock">
      <MemberSignature Language="C#" Value="public static bool CapsLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CapsLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.CapsLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CapsLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CapsLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CapsLock : bool" Usage="System.Console.CapsLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, включен или отключен режим CAPS LOCK клавиатуры.</summary>
        <value>Значение <see langword="true" />, если режим CAPS LOCK включен; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Операция получения вызывается в операционной системе, отличной от Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear();" />
      <MemberSignature Language="F#" Value="static member Clear : unit -&gt; unit" Usage="System.Console.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет из буфера консоли и ее окна отображаемую информацию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью <xref:System.Console.Clear%2A> метод эквивалентен вызова операционной системы MS-DOS `cls` команду в окне командной строки. При <xref:System.Console.Clear%2A> вызове метода, курсор автоматически перемещается в левый верхний угол окна и содержимое буфера экрана задаются в пустые значения, с помощью текущего фоновые цвета фона.  
  
> [!NOTE]
>  Попытка вызова <xref:System.Console.Clear%2A> вызывает метод, когда вывод консольного приложения перенаправляется в файл <xref:System.IO.IOException>. Чтобы избежать этого, всегда заключайте вызов <xref:System.Console.Clear%2A> метод в `try`...`catch` блок.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Console.Clear%2A> метод, чтобы удалить консоль, перед выполнением цикла, предлагает пользователю выбрать цвет фона и переднего плана и введите строку для отображения. Если пользователь решил не выйти из программы, будут восстановлены исходные переднего плана и фонового цвета консоли и <xref:System.Console.Clear%2A> метод вызывается снова, прежде чем повторного выполнения цикла.  
  
 [!code-csharp[System.Console.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.clear/cs/clear1.cs#1)]
 [!code-vb[System.Console.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.clear/vb/clear1.vb#1)]  
  
 Пример основан на `GetKeyPress` метод для проверки пользователя Выбор цвета переднего плана и фона.  
  
 В этом примере показано <xref:System.Console.CursorLeft%2A> и <xref:System.Console.CursorTop%2A> свойства и <xref:System.Console.SetCursorPosition%2A> и <xref:System.Console.Clear%2A> методы. Пример помещает курсор, который определяет, где произойдет следующая запись, чтобы нарисовать символ 5, 5 символов прямоугольником, используя сочетание «+», "&#124;«, и «-» строки. Обратите внимание на то, что прямоугольник можно нарисовать с меньшим количеством шагов, используя сочетание других строк.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
      </Docs>
    </Member>
    <Member MemberName="CursorLeft">
      <MemberSignature Language="C#" Value="public static int CursorLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorLeft : int with get, set" Usage="System.Console.CursorLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию столбца курсора в буферной области.</summary>
        <value>Текущая позиция курсора в столбцах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере показано <xref:System.Console.CursorLeft%2A> и <xref:System.Console.CursorTop%2A> свойства и <xref:System.Console.SetCursorPosition%2A> и <xref:System.Console.Clear%2A> методы. Пример помещает курсор, который определяет, где произойдет следующая запись, чтобы нарисовать символ 5, 5 символов прямоугольником, используя сочетание «+», "&#124;«, и «-» строки. Обратите внимание на то, что прямоугольник можно нарисовать с меньшим количеством шагов, используя сочетание других строк.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше нуля.  
  
- или - 
Значение в операции задания больше или равно <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorSize">
      <MemberSignature Language="C#" Value="public static int CursorSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorSize" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorSize : int with get, set" Usage="System.Console.CursorSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту курсора в символьной ячейке.</summary>
        <value>Размер курсора, выраженный как процент от высоты символьной ячейки. Данное свойство принимает значения в диапазоне от 1 до 100.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Внешний вид курсора меняется от горизонтальную линию в нижней части ячейки, когда свойство имеет значение 1, до полного заполнения ячейки, когда значение свойства равно 100.  
  
   
  
## Examples  
 В этом примере показано <xref:System.Console.CursorSize%2A> свойство. В примере выполняется увеличение размера курсора при каждом клавиши консоли нажата, а затем восстанавливает курсор становится равным исходному размеру перед завершением работы.  
  
 [!code-cpp[console.cursorsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorsize/CPP/csize.cpp#1)]
 [!code-csharp[console.cursorsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorsize/CS/csize.cs#1)]
 [!code-vb[console.cursorsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorsize/VB/csize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное в операции задания, меньше 1 или больше 100.</exception>
        <exception cref="T:System.Security.SecurityException">Данный пользователь не имеет разрешения на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorTop">
      <MemberSignature Language="C#" Value="public static int CursorTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorTop : int with get, set" Usage="System.Console.CursorTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию строки курсора в буферной области.</summary>
        <value>Текущая позиция курсора в строках.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере показано <xref:System.Console.CursorLeft%2A> и <xref:System.Console.CursorTop%2A> свойства и <xref:System.Console.SetCursorPosition%2A> и <xref:System.Console.Clear%2A> методы. Пример помещает курсор, который определяет, где произойдет следующая запись, чтобы нарисовать символ 5, 5 символов прямоугольником, используя сочетание «+», "&#124;«, и «-» строки. Обратите внимание на то, что прямоугольник можно нарисовать с меньшим количеством шагов, используя сочетание других строк.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше нуля.  
  
- или - 
Значение в операции задания больше или равно <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorVisible">
      <MemberSignature Language="C#" Value="public static bool CursorVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CursorVisible" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorVisible" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CursorVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CursorVisible : bool with get, set" Usage="System.Console.CursorVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, видим ли курсор.</summary>
        <value>Значение <see langword="true" />, если курсор видим; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере показано <xref:System.Console.CursorVisible%2A> свойство. В примере создается курсор отображается, если в первом столбце входных данных является символом «+» или невидимым, если входные данные "-" символов.  
  
 [!code-cpp[console.cursorvis#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorvis/CPP/vis.cpp#1)]
 [!code-csharp[console.cursorvis#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorvis/CS/vis.cs#1)]
 [!code-vb[console.cursorvis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorvis/VB/vis.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция получения вызывается в операционной системе, отличной от Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Error" />
      <MemberSignature Language="DocId" Value="P:System.Console.Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Error As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Error { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.TextWriter" Usage="System.Console.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает стандартный выходной поток сообщений об ошибках.</summary>
        <value>Объект <see cref="T:System.IO.TextWriter" />, предоставляющий стандартный поток вывода ошибок.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это стандартный поток ошибок присваивается консоли по умолчанию. Его можно установить в другой поток с <xref:System.Console.SetError%2A> метод. После перенаправляется в стандартный поток ошибок, может быть получена путем вызова <xref:System.Console.OpenStandardError%2A> метод.  
  
 В консольных приложениях информационные выходные данные которого часто перенаправляется в файл, поток через стандартную ошибку <xref:System.Console.Error%2A> свойство может использоваться для отображения сведений на консоль, даже если вывод перенаправляется. В следующем примере отображаются таблицы продуктов для 10 чисел во время, начиная с 1. После каждого набора из 10 чисел <xref:System.Console.Error%2A> свойство позволяет запрашивать у пользователя, следует ли отображать следующего набора. Если стандартный вывод перенаправляется в файл, пользователь по-прежнему предлагается ли подпрограмма должна создавать следующий набор продуктов.  
  
 [!code-csharp[System.Console.Error#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.error/cs/error1.cs#1)]
 [!code-vb[System.Console.Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.error/vb/error1.vb#1)]  
  
   
  
## Examples  
 Следующий пример — это служебная программа командной строки, с именем ExpandTabs, которая заменяет символы табуляции в текстовом файле четырех пробелов, значения, определяемого `tabSize` переменной. Он перенаправляет стандартный ввод и вывод выполняет потоковую передачу файлов, но использует <xref:System.Console.Error%2A> свойство для записи в стандартный поток ошибок на консоль. Его можно запустить из командной строки, указав имя файла, содержащего символы табуляции и имя выходного файла.  
  
 [!code-cpp[Console-EXPANDTABSEX#1](~/samples/snippets/cpp/VS_Snippets_CLR/Console-EXPANDTABSEX/CPP/expandtabsex.cpp#1)]
 [!code-csharp[Console-EXPANDTABSEX#1](~/samples/snippets/csharp/VS_Snippets_CLR/Console-EXPANDTABSEX/CS/expandtabsex.cs#1)]
 [!code-vb[Console-EXPANDTABSEX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Console-EXPANDTABSEX/VB/expandtabsex.vb#1)]  
  
 Следующий пример является средство просмотра простой текстовый файл, отображающее содержимое один или несколько текстовых файлов в консоль. Если аргументы командной строки, или если отсутствуют файлы, передаваемые в качестве аргументов командной строки, в примере вызывается <xref:System.Console.SetError%2A> вызывает метод, чтобы перенаправить сведения об ошибке в файл <xref:System.Console.OpenStandardError%2A> метод находится в процессе повторного запроса в стандартную ошибку потоковую передачу и указывает, что сведения об ошибке были записаны в файл.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Обратите внимание, что <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> свойству `true` до повторного запроса в поток ошибок. Это гарантирует, что выходные данные в консоль немедленно а не в буфер.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ForegroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor ForegroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor ForegroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.ForegroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ForegroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor ForegroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.ForegroundColor : ConsoleColor with get, set" Usage="System.Console.ForegroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет фона консоли.</summary>
        <value>Значение из перечисления <see cref="T:System.ConsoleColor" />, задающее фоновый цвет текста консоли, то есть цвет, которым выводятся символы. По умолчанию задано значение Gray.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращает операцию get для приложения на основе Windows, в котором существует консоли, <xref:System.ConsoleColor.Gray>.  
  
   
  
## Examples  
 В следующем примере проверяется, является ли цвет фона консоли черной, и если это так, он изменяет цвет фона на красный, а черный цвет переднего плана.  
  
 [!code-csharp[System.ConsoleColor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/Example2.cs#2)] 
 [!code-vb[System.ConsoleColor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/Example2.vb#2)]  
  
 В следующем примере сохраняется значения <xref:System.ConsoleColor> перечисления в массив и сохраняет текущие значения <xref:System.Console.BackgroundColor%2A> и <xref:System.Console.ForegroundColor%2A> свойства к переменным. Затем он изменяет цвет переднего плана для каждого цвета в <xref:System.ConsoleColor> перечисления, за исключением того, как цвет, соответствующий текущий фон и изменяет цвет фона для каждого цвета в <xref:System.ConsoleColor> перечисления за исключением цвет, который соответствует текущий переднего плана. (Если цвет переднего плана является таким же, как цвет фона, текст не отображается.) Наконец, он вызывает <xref:System.Console.ResetColor%2A> метод, чтобы восстановить исходные цвета консоли.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Цвет, указанный в операции SET, не является допустимым членом <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="In">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader In { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextReader In" />
      <MemberSignature Language="DocId" Value="P:System.Console.In" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property In As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextReader ^ In { System::IO::TextReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.In : System.IO.TextReader" Usage="System.Console.In" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает стандартный входной поток.</summary>
        <value>Объект <see cref="T:System.IO.TextReader" />, представляющий стандартный входной поток.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство имеет значение для стандартного входного потока по умолчанию. Это свойство может задаваться в другой поток с <xref:System.Console.SetIn%2A> метод.  
  
 Операции чтения в стандартный входной поток выполняться синхронно. То есть они заблокирован до завершения указанной операции чтения. Это справедливо даже если асинхронный метод, такой как <xref:System.IO.TextReader.ReadLineAsync%2A>, вызывается для <xref:System.IO.TextReader> объект, возвращаемый <xref:System.Console.In%2A> свойство.  
  
   
  
## Examples  
 В следующем примере показано использование `In` свойство.  
  
 [!code-cpp[consolein#1](~/samples/snippets/cpp/VS_Snippets_CLR/consolein/CPP/consolein.cpp#1)]
 [!code-csharp[consolein#1](~/samples/snippets/csharp/VS_Snippets_CLR/consolein/CS/consolein.cs#1)]
 [!code-vb[consolein#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/consolein/VB/consolein.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Console.OpenStandardInput" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="InputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding InputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding InputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.InputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property InputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ InputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputEncoding : System.Text.Encoding with get, set" Usage="System.Console.InputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает кодировку консоли, используемую при чтении входных данных.</summary>
        <value>Кодировка консоли, используемая при чтении ввода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль использует кодировку ввода для преобразования ввода с клавиатуры в соответствующий символ. Кодировка ввода включает кодовую страницу, которая сопоставляет 256 кодов клавиш к отдельным символам. Разные кодовые страницы включают разные специальные символы, как правило, настроенные для языка или группы языков.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], операция получения свойство может возвращать кэшированное значение, а не на консоль текущей кодировки входных данных. Это может произойти, если значение <xref:System.Console.InputEncoding%2A> свойство изменяется каким-либо образом, отличный от присвоения <xref:System.Console.InputEncoding%2A> свойство, например вызов Windows `SetConsoleCP` или с помощью `chcp` команду с помощью сценария PowerShell.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение свойства в операции задания — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Во время выполнения этой операции произошла ошибка.</exception>
        <exception cref="T:System.Security.SecurityException">У приложения нет разрешения на выполнение этой операции.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для чтения и записи для окон верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="IsErrorRedirected">
      <MemberSignature Language="C#" Value="public static bool IsErrorRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsErrorRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsErrorRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsErrorRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsErrorRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsErrorRedirected : bool" Usage="System.Console.IsErrorRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, был ли перенаправлен выходной поток ошибок от стандартного потока ошибок.</summary>
        <value>Значение<see langword="true" /> , если выходные сообщения об ошибках перенаправляются; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="IsInputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsInputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsInputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsInputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsInputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsInputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputRedirected : bool" Usage="System.Console.IsInputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, был ли перенаправлены ли входные данные от стандартного входного потока.</summary>
        <value>Значение <see langword="true" />, если входные данные перенаправляются; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
        <altmember cref="M:System.Console.OpenStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="IsOutputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsOutputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsOutputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsOutputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsOutputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsOutputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOutputRedirected : bool" Usage="System.Console.IsOutputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, был ли перенаправлены выходные данные от стандартного выходного потока.</summary>
        <value>Значение<see langword="true" /> , если выходные данные перенаправляются; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="KeyAvailable">
      <MemberSignature Language="C#" Value="public static bool KeyAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool KeyAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Console.KeyAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property KeyAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool KeyAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyAvailable : bool" Usage="System.Console.KeyAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, доступно ли нажатие клавиши во входном потоке.</summary>
        <value>Значение <see langword="true" />, если нажатие клавиши доступно; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства возвращается немедленно; то есть <xref:System.Console.KeyAvailable%2A> свойство не блокирует входных данных, пока не станет доступна клавиши.  
  
 Используйте <xref:System.Console.KeyAvailable%2A> свойство в сочетании с единственным <xref:System.Console.ReadKey%2A> метод, не <xref:System.Console.Read%2A> или <xref:System.Console.ReadLine%2A> методы.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.Console.KeyAvailable%2A> свойства цикл, который выполняется, пока не нажата клавиша.  
  
 [!code-cpp[console.keyavailable#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.keyavailable/CPP/ka.cpp#1)]
 [!code-csharp[console.keyavailable#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.keyavailable/CS/ka.cs#1)]
 [!code-vb[console.keyavailable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.keyavailable/VB/ka.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.InvalidOperationException">Стандартный ввод перенаправляется в файл вместо клавиатуры.</exception>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowHeight">
      <MemberSignature Language="C#" Value="public static int LargestWindowHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LargestWindowHeight : int" Usage="System.Console.LargestWindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальное число строк окна консоли с учетом текущего шрифта и разрешения экрана.</summary>
        <value>Максимально возможная высота окна консоли измеряется в строках.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowWidth">
      <MemberSignature Language="C#" Value="public static int LargestWindowWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowWidth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LargestWindowWidth : int" Usage="System.Console.LargestWindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальное число столбцов окна консоли с учетом текущего шрифта и разрешения экрана.</summary>
        <value>Максимально возможная ширина окна консоли измеряется в столбцах.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveBufferArea">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует заданную исходную область буфера экрана в заданную область назначения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceTop" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceWidth" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceHeight" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetLeft" Type="System.Int32" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetTop" Type="System.Int32" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Крайний слева столбец исходной области.</param>
        <param name="sourceTop">Самая верхняя строка исходной области.</param>
        <param name="sourceWidth">Общее число столбцов в исходной области.</param>
        <param name="sourceHeight">Общее число строк в исходной области.</param>
        <param name="targetLeft">Крайний слева столбец области назначения.</param>
        <param name="targetTop">Самая верхняя строка области назначения.</param>
        <summary>Копирует заданную исходную область буфера экрана в заданную область назначения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если параметры источника и назначения задают позицию за пределами границ текущего буфера экрана, копируется только часть исходной области, которая помещается в область назначения. То есть исходной области обрезается по размеру текущего буфера экрана.  
  
 <xref:System.Console.MoveBufferArea%2A> Метод копирует исходной области в области назначения. Если область назначения не пересекается исходной области, исходной области заполняется пробелами с использованием текущих цветов переднего плана и фона. В противном случае не заполняется пересекающиеся части исходной области.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько параметров имеют значение меньше нуля.  
  
-или- 
 Значение параметра <paramref name="sourceLeft" /> или <paramref name="targetLeft" /> больше или равно значению <see cref="P:System.Console.BufferWidth" />.  
  
-или- 
 Значение параметра <paramref name="sourceTop" /> или <paramref name="targetTop" /> больше или равно значению <see cref="P:System.Console.BufferHeight" />.  
  
- или - 
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> больше или равно <see cref="P:System.Console.BufferHeight" />.  
  
-или- 
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> больше или равно <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop, char sourceChar, valuetype System.ConsoleColor sourceForeColor, valuetype System.ConsoleColor sourceBackColor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Char,System.ConsoleColor,System.ConsoleColor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer, sourceChar As Char, sourceForeColor As ConsoleColor, sourceBackColor As ConsoleColor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int * char * ConsoleColor * ConsoleColor -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, sourceChar, sourceForeColor, sourceBackColor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceTop" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceWidth" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceHeight" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetLeft" Type="System.Int32" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetTop" Type="System.Int32" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceChar" Type="System.Char" Index="6" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceForeColor" Type="System.ConsoleColor" Index="7" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceBackColor" Type="System.ConsoleColor" Index="8" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Крайний слева столбец исходной области.</param>
        <param name="sourceTop">Самая верхняя строка исходной области.</param>
        <param name="sourceWidth">Общее число столбцов в исходной области.</param>
        <param name="sourceHeight">Общее число строк в исходной области.</param>
        <param name="targetLeft">Крайний слева столбец области назначения.</param>
        <param name="targetTop">Самая верхняя строка области назначения.</param>
        <param name="sourceChar">Символ, используемый для заполнения исходной области.</param>
        <param name="sourceForeColor">Цвет текста, используемый для заполнения исходной области.</param>
        <param name="sourceBackColor">Цвет фона, используемый для заполнения исходной области.</param>
        <summary>Копирует заданную исходную область буфера экрана в заданную область назначения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если параметры источника и назначения задают позицию за пределами текущего буфера экрана, копируется только часть исходной области, которая помещается в область назначения. То есть исходной области обрезается по размеру текущего буфера экрана.  
  
 <xref:System.Console.MoveBufferArea%2A> Метод копирует исходной области в области назначения. Если область назначения не пересекается исходной области, исходная область заполняется символ, заданный параметром `sourceChar`, с помощью цветов, заданных в `sourceForeColor` и `sourceBackColor`. В противном случае не заполняется пересекающиеся части исходной области.  
  
 <xref:System.Console.MoveBufferArea%2A> Метод операция не выполняется, если `sourceWidth` или `sourceHeight` равно нулю.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько параметров имеют значение меньше нуля.  
  
- или - 
 Значение параметра <paramref name="sourceLeft" /> или <paramref name="targetLeft" /> больше или равно значению <see cref="P:System.Console.BufferWidth" />.  
  
-или- 
 Значение параметра <paramref name="sourceTop" /> или <paramref name="targetTop" /> больше или равно значению <see cref="P:System.Console.BufferHeight" />.  
  
- или - 
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> больше или равно <see cref="P:System.Console.BufferHeight" />.  
  
-или- 
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> больше или равно <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.ArgumentException">Один или более параметров цвета не являются членами перечисления <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NumberLock">
      <MemberSignature Language="C#" Value="public static bool NumberLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool NumberLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.NumberLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NumberLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool NumberLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.NumberLock : bool" Usage="System.Console.NumberLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, включен или отключен режим NUM LOCK клавиатуры.</summary>
        <value>Значение <see langword="true" />, если клавиша NUM LOCK включена; значение <see langword="false" />, если клавиша NUM LOCK выключена.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Операция получения вызывается в операционной системе, отличной от Windows.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardError">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает стандартный поток сообщений об ошибках.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError();" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает стандартный поток сообщений об ошибках.</summary>
        <returns>Стандартный поток сообщений об ошибках.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного запроса в стандартный поток ошибок, после его изменения <xref:System.Console.SetError%2A> метод.  
  
   
  
## Examples  
 Следующий пример является средство просмотра простой текстовый файл, отображающее содержимое один или несколько текстовых файлов в консоль. Если аргументы командной строки, или если отсутствуют файлы, передаваемые в качестве аргументов командной строки, в примере вызывается <xref:System.Console.SetError%2A> вызывает метод, чтобы перенаправить сведения об ошибке в файл <xref:System.Console.OpenStandardError%2A> метод находится в процессе повторного запроса в стандартную ошибку потоковую передачу и указывает, что сведения об ошибке были записаны в файл.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Обратите внимание, что <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> свойству `true` до повторного запроса в поток ошибок. Это гарантирует, что выходные данные в консоль немедленно а не в буфер.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Размер буфера внутреннего потока.</param>
        <summary>Получает стандартный поток сообщений об ошибках, для которого установлен заданный размер буфера.</summary>
        <returns>Стандартный поток сообщений об ошибках.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного запроса в стандартный поток ошибок, после его изменения <xref:System.Console.SetError%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="bufferSize" /> не больше нуля.</exception>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardInput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает стандартный входной поток.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает стандартный входной поток.</summary>
        <returns>Стандартный входной поток.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного запроса стандартного входного потока после его изменения <xref:System.Console.SetIn%2A> метод.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование `OpenStandardInput` свойство.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Размер буфера внутреннего потока.</param>
        <summary>Получает стандартный входной поток, для которого установлен заданный размер буфера.</summary>
        <returns>Стандартный входной поток.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного запроса в стандартный выходной поток, после его изменения <xref:System.Console.SetIn%2A> метод.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование `OpenStandardInput` свойство.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="bufferSize" /> не больше нуля.</exception>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardOutput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает стандартный выходной поток.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает стандартный выходной поток.</summary>
        <returns>Стандартный выходной поток.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного запроса в стандартный выходной поток, после его изменения <xref:System.Console.SetOut%2A> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Console.OpenStandardOutput%2A>. Он заменяет 4 последовательных пробела в строке символом табуляции. Чтобы запустить его, необходимо указать два аргумента командной строки. Первый аргумент — это имя существующего текстового файла, в который требуется перенаправить стандартный входной поток. Второй аргумент — это имя файла, в который требуется перенаправить стандартный выходной поток. Не требуется, чтобы этот файл существовал. Если да, его содержимое будут перезаписано.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Размер буфера внутреннего потока.</param>
        <summary>Получает стандартный выходной поток, для которого установлен заданный размер буфера.</summary>
        <returns>Стандартный выходной поток.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного запроса в стандартный выходной поток, после его изменения <xref:System.Console.SetOut%2A> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Console.OpenStandardOutput%2A>. Он заменяет 4 последовательных пробела в строке символом табуляции. Чтобы запустить его, необходимо указать два аргумента командной строки. Первый аргумент — это имя существующего текстового файла, в который требуется перенаправить стандартный входной поток. Второй аргумент — это имя файла, в который требуется перенаправить стандартный выходной поток. Не требуется, чтобы этот файл существовал. Если да, его содержимое будут перезаписано.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="bufferSize" /> не больше нуля.</exception>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Out">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Out { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Out" />
      <MemberSignature Language="DocId" Value="P:System.Console.Out" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Out As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Out { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Out : System.IO.TextWriter" Usage="System.Console.Out" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает стандартный выходной поток.</summary>
        <value>Объект <see cref="T:System.IO.TextWriter" />, представляющий стандартный выходной поток.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство имеет значение в стандартный выходной поток по умолчанию. Это свойство может задаваться в другой поток с <xref:System.Console.SetOut%2A> метод.  
  
 Обратите внимание, что вызовы `Console.Out.WriteLine` метода — вызовы в соответствующий <xref:System.Console.WriteLine%2A> методы.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Console.Out%2A> свойство для отображения массив, содержащий имена файлов в текущем каталоге приложения, чтобы на стандартное устройство вывода. Затем задает стандартный вывод в файл с именем Files.txt и содержит список элементов массива в файл. Наконец он задает выходные данные в стандартный выходной поток и снова не отображает элементы массива стандартное устройство вывода.  
  
 [!code-csharp[System.Console.Out#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.out/cs/out1.cs#1)]
 [!code-vb[System.Console.Out#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.out/vb/out1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OutputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding OutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding OutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.OutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ OutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OutputEncoding : System.Text.Encoding with get, set" Usage="System.Console.OutputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает кодировку консоли, используемую при записи выходных данных.</summary>
        <value>Кодировка консоли, используемая при записи вывода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль использует кодировку вывода для преобразования символов, записываемых приложением, в соответствующие символы отображения консоли. Кодовая страница по умолчанию, который использует консоль определяется языкового стандарта системы.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], операция получения свойство может возвращать кэшированное значение вместо текущая кодировка выходной консоли. Это может произойти, если значение <xref:System.Console.OutputEncoding%2A> свойство изменяется каким-либо образом, отличный от присвоения <xref:System.Console.OutputEncoding%2A> свойство, например вызов Windows `SetConsoleOutputCP` функции.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение свойства в операции задания — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Во время выполнения этой операции произошла ошибка.</exception>
        <exception cref="T:System.Security.SecurityException">У приложения нет разрешения на выполнение этой операции.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для чтения и записи для окон верхнего уровня и подокнах.  Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Кодировок Юникода <see cref="T:System.Console" /> класс поддерживает кодирование с помощью UTF-8 <see cref="T:System.Text.UTF8Encoding" /> класса и, начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], он поддерживает кодирование с помощью UTF-16 <see cref="T:System.Text.UnicodeEncoding" /> класса. Кодировка UTF-32 с <see cref="T:System.Text.UTF32Encoding" /> класс не поддерживается. Попытка задать выходных данных кодировку UTF-32 вызывает <see cref="T:System.IO.IOException" />.  
  
Обратите внимание на то, что успешно отображение символов Юникода в консоль требуется следующее: 
-Консоли необходимо использовать шрифт TrueType, например Lucida Console или Consolas, для отображения символов.  
  
-Шрифта, используемого этим консоли необходимо определить конкретного глиф или глифов для отображения. Консоль можно воспользоваться преимуществами связь для отображения глифов из связанных шрифтов, если базового шрифта не содержит определение для Этот глиф шрифтов.  
  
Дополнительные сведения о поддержке Юникода в кодировку, консоли, см. в разделе «Юникода поддержки для консоль» в <see cref="T:System.Console" /> класса.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Read" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Read();" />
      <MemberSignature Language="F#" Value="static member Read : unit -&gt; int" Usage="System.Console.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Читает следующий символ из стандартного входного потока.</summary>
        <returns>Следующий символ из входного потока или значение минус единица (-1), если доступных для чтения символов не осталось.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Read%2A> Метод блокируется до ввода входных символов; она завершается при нажатии клавиши <xref:System.ConsoleKey.Enter> ключ. Нажатие клавиши ВВОД добавляет последовательность завершения зависящая от платформы строка во входные данные (например, Windows присоединяет последовательность перевода строки возврат каретки). Последующие вызовы <xref:System.Console.Read%2A> метод получения вашего входной один символ за раз. После получения последнего персонажа <xref:System.Console.Read%2A> блокирует возврат еще раз, и цикл повторяется.  
  
> [!IMPORTANT]
>  <xref:System.Console.ReadLine%2A> Метод, или <xref:System.Console.KeyAvailable%2A> свойство и <xref:System.Console.ReadKey%2A> метод предпочтительнее <xref:System.Console.Read%2A> метод.  
  
 Обратите внимание на то, что метод не возвращает -1, если только вы выполните одно из следующих действий:  
  
-   Клавишу <xref:System.ConsoleModifiers.Control> клавиши-модификатора и <xref:System.ConsoleKey.Z> клавиши консоли (Ctrl + Z), который сигнализирует условие конец файла.  
  
-   Нажмите клавишу с эквивалентным ключом, сигнализирующее о условие конец файла, например функциональная клавиша F6 в Windows.  
  
-   Перенаправление потока входных данных к источнику, например, текстовый файл, который имеет Фактический символ окончания файла.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.Read%2A> метод.  
  
 [!code-cpp[console.read#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.read/CPP/read.cpp#1)]
 [!code-csharp[console.read#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.read/CS/read.cs#1)]
 [!code-vb[console.read#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.read/VB/read.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadKey">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает следующий нажатый пользователем символ или функциональную клавишу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey () As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey();" />
      <MemberSignature Language="F#" Value="static member ReadKey : unit -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает следующий нажатый пользователем символ или функциональную клавишу. Нажатая клавиша отображается в окне консоли.</summary>
        <returns>Объект, описывающий константу <see cref="T:System.ConsoleKey" /> и символ Юникода (при наличии), соответствующий нажатой клавише консоли. Этот объект <see cref="T:System.ConsoleKeyInfo" /> также описывает в битовой комбинации значений <see cref="T:System.ConsoleModifiers" />, нажимались ли клавиши-модификаторы (одна или несколько) Shift, Alt или Ctrl одновременно с клавишей консоли.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadKey%2A> Метод ожидает, то есть блоки на выдающем поток <xref:System.Console.ReadKey%2A> метод, пока не нажата символ или функциональную клавишу. Символ или функциональную клавишу может быть нажата в сочетании с одной или нескольких Alt, Ctrl или Shift клавиши-модификаторы. Тем не менее, нажав клавиши-модификатора сама по себе не приведет к <xref:System.Console.ReadKey%2A> метод для возврата.  
  
 В зависимости от приложения, может потребоваться использовать <xref:System.Console.ReadKey%2A> в сочетании с <xref:System.Console.KeyAvailable%2A> свойство.  
  
 <xref:System.Console.ReadKey%2A> Метод выполняет чтение с клавиатуры, даже если стандартный ввод перенаправляется в файл с <xref:System.Console.SetIn%2A> метод.  
  
   
  
## Examples  
 Один из наиболее распространенных использует <xref:System.Console.ReadKey> является метод для остановки выполнения программы, пока пользователь нажимает клавишу и завершает или отображает дополнительное окно информации приложения. В следующем примере используется <xref:System.Console.ReadKey> метод для ожидания нажатия пользователем клавиши ВВОД перед завершением работы приложения.  
  
 [!code-csharp[System.Console.ReadKey#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey1.cs#1)]
 [!code-vb[System.Console.ReadKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey1.vb#1)]  
  
 Обратите внимание, что данная перегруженная версия <xref:System.Console.ReadKey%2A> метод по умолчанию отображает все отображаемые ключи, пользователь нажимает на консоль. Чтобы отключить их, вызовите <xref:System.Console.ReadKey%2A> метод с `intercept` аргумент `true`.  
  
 В следующем примере используется <xref:System.Console.ReadKey> метод для отображения сведений о какой ключ нажатой клавише. 
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Console.In" /> перенаправлено из потока, отличного от консоли.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey (bool intercept);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey(bool intercept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey (intercept As Boolean) As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey(bool intercept);" />
      <MemberSignature Language="F#" Value="static member ReadKey : bool -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey intercept" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intercept" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="intercept">Определяет, следует ли отображать нажатую клавишу в окне консоли. Значение <see langword="true" />, чтобы не отображать нажатую клавишу; в противном случае — значение <see langword="false" />.</param>
        <summary>Получает следующий нажатый пользователем символ или функциональную клавишу. Нажатая клавиша может быть отображена в окне консоли.</summary>
        <returns>Объект, описывающий константу <see cref="T:System.ConsoleKey" /> и символ Юникода (при наличии), соответствующий нажатой клавише консоли. Этот объект <see cref="T:System.ConsoleKeyInfo" /> также описывает в битовой комбинации значений <see cref="T:System.ConsoleModifiers" />, нажимались ли клавиши-модификаторы (одна или несколько) Shift, Alt или Ctrl одновременно с клавишей консоли.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadKey%2A> Метод ожидает, то есть блоки на выдающем поток <xref:System.Console.ReadKey%2A> метод, пока не нажата символ или функциональную клавишу. Символ или функциональную клавишу может быть нажата в сочетании с одной или нескольких Alt, Ctrl или Shift клавиши-модификаторы. Тем не менее, нажав клавиши-модификатора сама по себе не приведет к <xref:System.Console.ReadKey%2A> метод для возврата.  
  
 Если `intercept` параметр `true`, нажатая клавиша перехватывается и не отображается в окне консоли; в противном случае отображается нажатую клавишу.  
  
 В зависимости от приложения, может потребоваться использовать <xref:System.Console.ReadKey%2A> в сочетании с <xref:System.Console.KeyAvailable%2A> свойство.  
  
 <xref:System.Console.ReadKey%2A> Метод выполняет чтение с клавиатуры, даже если стандартный ввод перенаправляется в файл с <xref:System.Console.SetIn%2A> метод.  
  
   
  
## Examples  
 Один из наиболее распространенных использует <xref:System.Console.ReadKey%2A> является метод для остановки выполнения программы, пока пользователь нажимает клавишу и завершает или отображает дополнительное окно информации приложения. В следующем примере используется <xref:System.Console.ReadKey%28System.Boolean%29> метод для ожидания нажатия пользователем клавиши ВВОД перед завершением работы приложения. Обратите внимание на то, что, если пользователь нажимает любую другую клавишу, его не повторяется в консоль.  
  
 [!code-csharp[System.Console.ReadKey#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey2.cs#2)]
 [!code-vb[System.Console.ReadKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey2.vb#2)]  
  
 В следующем примере используется <xref:System.Console.ReadKey%28System.Boolean%29> метод для отображения сведений о нажатой пользователем, но этот ключ, чтобы консоль не клавиши.  
  
 [!code-cpp[console.readkey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey2/CPP/rkbool.cpp#1)]
 [!code-csharp[console.readkey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey2/CS/rkbool.cs#1)]
 [!code-vb[console.readkey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey2/VB/rkbool.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Console.In" /> перенаправлено из потока, отличного от консоли.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public static string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="static member ReadLine : unit -&gt; string" Usage="System.Console.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает следующую строку символов из стандартного входного потока.</summary>
        <returns>Следующая строка символов из входного потока или значение <see langword="null" />, если больше нет доступных строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadLine%2A> Метод считывает строку из стандартного входного потока. (Для определения строки, см. в абзаце после перечисленные ниже.) Это означает следующее.  
  
-   Если стандартная устройство ввода клавиатуры, <xref:System.Console.ReadLine%2A> метод блокируется, пока пользователь нажимает клавишу **ввод** ключ.  
  
     Один из наиболее распространенных использует <xref:System.Console.ReadLine%2A> метод — приостанавливать выполнение программы до очистки консоль и отображение новых сведений к нему, или предложить пользователю нажать клавишу ВВОД перед завершением работы приложения. Это показано в следующем примере.  
  
     [!code-cpp[System.Console.ReadLine#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/ReadLineSimple.cpp#6)]
     [!code-csharp[System.Console.ReadLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLineSimple.cs#6)]
     [!code-vb[System.Console.ReadLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLineSimple.vb#6)]  
  
-   Если стандартный ввод перенаправляется в файл <xref:System.Console.ReadLine%2A> метод считывает строки текста из файла. Например вот текстовый файл с именем ReadLine1.txt:  
  
    ```  
  
    This is the first line.  
    This is the second line.  
    This is the third line.  
    This is the fourth line.  
  
    ```  
  
     В следующем примере используется <xref:System.Console.ReadLine%2A> метод для чтения входных данных, который перенаправляется из файла. Операции чтения заканчивается, когда метод возвращает `null`, означающее, что строки не остаются для чтения.  
  
     [!code-csharp[System.Console.ReadLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine3.cs#3)]
     [!code-vb[System.Console.ReadLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine3.vb#3)]  
  
     После компиляции в примере для исполняемого файла именованный ReadLine1.exe, можно запустить его из командной строки с помощью синтаксиса  
  
    ```  
    ReadLine1 < ReadLine1.txt  
    ```  
  
     чтение содержимого файла и отобразить их на консоль.  
  
 Строка определяется как последовательность символов, за которым следует символ возврата каретки (шестнадцатеричный код 0x000d), перевод строки (шестнадцатеричное представление 0x000a) или значение <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> свойства. Возвращаемая строка не содержит знаков конца строки. По умолчанию этот метод считывает входные данные из входного буфера до 256 символов. Поскольку к ним относятся <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> символы, метод может считывать строки, содержащие до 254 символов. Для считывания больше строк, вызвать <xref:System.Console.OpenStandardInput%28System.Int32%29> метод.  
  
 <xref:System.Console.ReadLine%2A> Метод выполняется синхронно. То есть он блокируется, пока прочтении строки или нажатии сочетания клавиш Ctrl + Z. <xref:System.Console.In%2A> Возвращает <xref:System.IO.TextReader> объект, представляющий стандартный входной поток и имеет оба синхронной <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType> метод и асинхронную <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> метод. Тем не менее, при использовании в качестве консоли в стандартный входной поток, <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> выполняется синхронно, а не асинхронно и возвращает `Task<String>` только после завершения операции чтения.  
  
 Если этот метод вызывает исключение <xref:System.OutOfMemoryException> исключение, позиция средства чтения в базовом <xref:System.IO.Stream> объекта увеличивается на число знаков, которое может читать метод, но знаки, уже считанные во внутренний <xref:System.Console.ReadLine%2A> являются буфера удаляются. Так как невозможно изменить позицию средства чтения в потоке, символами, считанными уже неустранимой и может осуществляться только при повторной инициализации <xref:System.IO.TextReader>. Если начальная позиция в потоке неизвестна или поток не поддерживает поиск, базовый <xref:System.IO.Stream> также должна быть повторно инициализирована. Чтобы избежать такой ситуации и создать надежный код, следует использовать <xref:System.Console.KeyAvailable%2A> свойство и <xref:System.Console.ReadKey%2A> метод и store считанные знаки в предварительно выделенный буфер.  
  
 Если символ Ctrl + Z нажата, когда метод является считывание входных данных из консоли, метод возвращает `null`. Это позволяет пользователю, чтобы дополнительные сочетания входных данных при <xref:System.Console.ReadLine%2A> метод вызывается в цикле. Следующий пример иллюстрирует этот сценарий.  
  
 [!code-cpp[System.Console.ReadLine#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/readline2.cpp#1)]
 [!code-csharp[System.Console.ReadLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine2.cs#1)]
 [!code-vb[System.Console.ReadLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine2.vb#1)]  
  
   
  
## Examples  
 В следующем примере требуется два аргумента командной строки: имя существующего текстового файла и имя файла для записи выходных данных. Открывает существующий текстовый файл и перенаправляет стандартный ввод с клавиатуры к этому файлу. Также перенаправляет стандартные выходные данные из консоли, в выходном файле. Затем он использует <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> метод для считывания каждой строки в файле, заменяет каждый последовательность из четырех пробелов символом табуляции, а также использует <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> метод для записи результата в выходной файл.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для выделения буфера под возвращаемую строку.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Количество символов в следующей строке больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="ResetColor">
      <MemberSignature Language="C#" Value="public static void ResetColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ResetColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetColor();" />
      <MemberSignature Language="F#" Value="static member ResetColor : unit -&gt; unit" Usage="System.Console.ResetColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Устанавливает для цветов фона и текста консоли их значения по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Цвета переднего плана и фона, восстанавливаются цвета, которые существовали во время начала текущего процесса. Дополнительные сведения см. в разделе <xref:System.Console.ForegroundColor%2A> и <xref:System.Console.BackgroundColor%2A> свойства.  
  
   
  
## Examples  
 В следующем примере сохраняется значения <xref:System.ConsoleColor> перечисления в массив и сохраняет текущие значения <xref:System.Console.BackgroundColor%2A> и <xref:System.Console.ForegroundColor%2A> свойства к переменным. Затем он изменяет цвет переднего плана для каждого цвета в <xref:System.ConsoleColor> перечисления, за исключением того, как цвет, соответствующий текущий фон и изменяет цвет фона для каждого цвета в <xref:System.ConsoleColor> перечисления за исключением цвет, который соответствует текущий переднего плана. (Если цвет переднего плана является таким же, как цвет фона, текст не отображается.) Наконец, он вызывает <xref:System.Console.ResetColor%2A> метод, чтобы восстановить исходные цвета консоли.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetBufferSize">
      <MemberSignature Language="C#" Value="public static void SetBufferSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBufferSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetBufferSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBufferSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBufferSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetBufferSize : int * int -&gt; unit" Usage="System.Console.SetBufferSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="height" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="width">Ширина области буфера в столбцах.</param>
        <param name="height">Высота буферной области измеряется строками.</param>
        <summary>Устанавливает заданные значения высоты и ширины буферной области экрана.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, и <xref:System.Console.CursorVisible%2A> свойства; и <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, и <xref:System.Console.ReadKey%2A> методы. В примере рисуется сетку в буфере экрана, на основе ширины буфера экрана. Затем в примере перемещается окно консоли, в ответ, к которому стрелка вверх, нажатия клавиш консоли стрелка вниз, Стрелка влево или Стрелка вправо. Сетка помогает см. в разделе Перемещение окна консоли относительно буфера экрана.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="height" /> или <paramref name="width" /> меньше или равно нулю.  
  
- или - 
 Значение параметра <paramref name="height" /> или <paramref name="width" /> больше или равно значению <see cref="F:System.Int16.MaxValue" />.  
  
-или- 
 <paramref name="width" /> меньше <see cref="P:System.Console.WindowLeft" /> + <see cref="P:System.Console.WindowWidth" />.  
  
-или- 
 <paramref name="height" /> меньше <see cref="P:System.Console.WindowTop" /> + <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCursorPosition">
      <MemberSignature Language="C#" Value="public static void SetCursorPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCursorPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetCursorPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCursorPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCursorPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetCursorPosition : int * int -&gt; unit" Usage="System.Console.SetCursorPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="top" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Позиция столбца курсора. Столбцы нумеруются как слева направо, начинается с 0.</param>
        <param name="top">Позиция строки курсора. Строки пронумерованы сверху вниз, начиная с 0.</param>
        <summary>Устанавливает положение курсора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Console.SetCursorPosition%2A> метод, чтобы указать, где следующей операции записи в окне консоли, чтобы начать. Если заданная позиция курсора находится вне области, видимой в данный момент в окне консоли, начало координат этого окна автоматически изменяется для отображения курсора.  
  
 Курсор автоматически перемещается в следующую позицию символа, каждый раз символ записывается в окно консоли. Если курсор находится в правую нижнюю позицию окна консоли, следующая операция записи вызовет окно консоли для прокрутки, то курсор остается видимой. Если вы хотите записать символ в правую нижнюю позицию без окне консоли прокрутить, используйте <xref:System.Console.MoveBufferArea%2A> метод для перехода к этой позиции символа.  
  
   
  
## Examples  
 В этом примере показано <xref:System.Console.CursorLeft%2A> и <xref:System.Console.CursorTop%2A> свойства и <xref:System.Console.SetCursorPosition%2A> и <xref:System.Console.Clear%2A> методы. Пример помещает курсор, который определяет, где произойдет следующая запись, чтобы нарисовать символ 5, 5 символов прямоугольником, используя сочетание «+», "&#124;«, и «-» строки. Обратите внимание на то, что прямоугольник можно нарисовать с меньшим количеством шагов, используя сочетание других строк.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="left" /> или <paramref name="top" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="left" /> больше или равно значению свойства <see cref="P:System.Console.BufferWidth" />.  
  
- или - 
 Значение <paramref name="top" /> больше или равно <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetError">
      <MemberSignature Language="C#" Value="public static void SetError (System.IO.TextWriter newError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetError(class System.IO.TextWriter newError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetError(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetError (newError As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetError(System::IO::TextWriter ^ newError);" />
      <MemberSignature Language="F#" Value="static member SetError : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetError newError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newError" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newError">Поток, являющийся новым стандартным потоком сообщений об ошибках.</param>
        <summary>Присваивает свойству <see cref="P:System.Console.Error" /> указанный объект <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Console.Error%2A> свойству стандартный поток вывода ошибок.  
  
 Объект <xref:System.IO.StreamWriter> , инкапсулирующий <xref:System.IO.FileStream> может использоваться для отправки сообщений об ошибках в файл.  
  
   
  
## Examples  
 Приведенный ниже показано, как перенаправлять стандартный поток ошибок в файл.  
  
 [!code-cpp[System.Console.SetError#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.SetError/cpp/seterror1.cpp#1)]
 [!code-csharp[System.Console.SetError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.SetError/cs/SetError1.cs#1)]
 [!code-vb[System.Console.SetError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.SetError/vb/SetError1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="newError" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="P:System.Console.Error" />
      </Docs>
    </Member>
    <Member MemberName="SetIn">
      <MemberSignature Language="C#" Value="public static void SetIn (System.IO.TextReader newIn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIn(class System.IO.TextReader newIn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetIn(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIn (newIn As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIn(System::IO::TextReader ^ newIn);" />
      <MemberSignature Language="F#" Value="static member SetIn : System.IO.TextReader -&gt; unit" Usage="System.Console.SetIn newIn" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newIn" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="newIn">Поток, являющийся новым стандартным входным потоком.</param>
        <summary>Присваивает свойству <see cref="P:System.Console.In" /> указанный объект <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Console.In%2A> свойству стандартного входного потока.  
  
 Объект <xref:System.IO.StreamReader> , инкапсулирующий <xref:System.IO.FileStream> может использоваться для получения входных данных из файла.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Console.SetIn%2A>. Он заменяет 4 последовательных пробела в строке символом табуляции. Чтобы запустить его, необходимо указать два аргумента командной строки. Первый аргумент — это имя существующего текстового файла, в который требуется перенаправить стандартный входной поток. Второй аргумент — это имя файла, в который требуется перенаправить стандартный выходной поток. Не требуется, чтобы этот файл существовал. Если да, его содержимое будут перезаписано.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="newIn" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextReader" />
        <altmember cref="P:System.Console.In" />
      </Docs>
    </Member>
    <Member MemberName="SetOut">
      <MemberSignature Language="C#" Value="public static void SetOut (System.IO.TextWriter newOut);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetOut(class System.IO.TextWriter newOut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetOut(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetOut (newOut As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetOut(System::IO::TextWriter ^ newOut);" />
      <MemberSignature Language="F#" Value="static member SetOut : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetOut newOut" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newOut" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newOut">Модуль записи текста, который должен использовать в качестве нового стандартного потока вывода.</param>
        <summary>Присваивает свойству <see cref="P:System.Console.Out" /> указанный объект <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Console.Out%2A> свойству в стандартный выходной поток.  
  
 Объект <xref:System.IO.StreamWriter> , инкапсулирующий <xref:System.IO.FileStream> может использоваться для отправки выходных данных в файл. Например:  
  
 [!code-cpp[System.Console.SetOut#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.setout/cpp/source.cpp#1)]
 [!code-csharp[System.Console.SetOut#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.setout/cs/source.cs#1)]
 [!code-vb[System.Console.SetOut#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.setout/vb/source.vb#1)]  
  
 Фактический объект, возвращенный <xref:System.Console.Out%2A> возможно создание синхронизированной оболочки заданный модуль записи текста.
  
## Examples  
 В следующем примере показано использование метода <xref:System.Console.SetOut%2A>. Он заменяет 4 последовательных пробела в строке символом табуляции. Чтобы запустить его, необходимо указать два аргумента командной строки. Первый аргумент — это имя существующего текстового файла, в который требуется перенаправить стандартный входной поток. Второй аргумент — это имя файла, в который требуется перенаправить стандартный выходной поток. Не требуется, чтобы этот файл существовал. Если да, его содержимое будут перезаписано.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="newOut" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="SetWindowPosition">
      <MemberSignature Language="C#" Value="public static void SetWindowPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetWindowPosition : int * int -&gt; unit" Usage="System.Console.SetWindowPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="top" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Позиция столбца верхнего левого угла окна консоли.</param>
        <param name="top">Позиция строки левого верхнего угла окна консоли.</param>
        <summary>Задает позицию окна консоли относительно буфера экрана.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В окне операционной системы отображаются в окне консоли, и в окне консоли отобразятся часть буфера экрана. <xref:System.Console.SetWindowPosition%2A> Метод влияет на позицию окна консоли относительно буфера экрана, но не влияет на позицию окна операционной системы относительно рабочего стола.  
  
 Окна консоли и операционной системы обычно не влияют друг с другом. Тем не менее если не удается отобразить буфера экрана в границах текущего окна консоли, операционная система автоматически добавляет полосы прокрутки окна операционной системы. В этом случае перемещение полос прокрутки окна операционной системы влияет на позицию окна консоли, и перемещение окна консоли с <xref:System.Console.SetWindowPosition%2A> метод влияет на положение полос прокрутки окна операционной системы.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, и <xref:System.Console.CursorVisible%2A> свойства; и <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, и <xref:System.Console.ReadKey%2A> методы. В примере рисуется сетку в буфере экрана, на основе ширины буфера экрана. Затем в примере перемещается окно консоли, в ответ, к которому стрелка вверх, нажатия клавиш консоли стрелка вниз, Стрелка влево или Стрелка вправо. Сетка помогает см. в разделе Перемещение окна консоли относительно буфера экрана.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="left" /> или <paramref name="top" /> меньше нуля.  
  
- или - 
 <paramref name="left" /> + <see cref="P:System.Console.WindowWidth" /> больше <see cref="P:System.Console.BufferWidth" />.  
  
-или- 
 <paramref name="top" /> + <see cref="P:System.Console.WindowHeight" /> больше <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetWindowSize">
      <MemberSignature Language="C#" Value="public static void SetWindowSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetWindowSize : int * int -&gt; unit" Usage="System.Console.SetWindowSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="height" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="width">Ширина окна консоли измеряется столбцами.</param>
        <param name="height">Высота окна консоли измеряется строками.</param>
        <summary>Устанавливает заданные значения высоты и ширины окна консоли.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере показано <xref:System.Console.SetWindowSize%2A> метод и <xref:System.Console.WindowWidth%2A> и <xref:System.Console.WindowHeight%2A> свойства. Необходимо запустить пример, чтобы просмотреть полный эффект от изменения размера окна консоли.  
  
 В примере выводятся размеры окна консоли, установленные на 85 столбцов и строк 43, а затем ожидает нажатия клавиши. При нажатии любой клавиши, размеры окна консоли уменьшаются вдвое, выводятся новые размеры, и в этом примере ожидается другой клавиши. Наконец при нажатии любой клавиши, восстанавливаются исходные размеры окна консоли и кода данного примера завершается.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="width" /> или <paramref name="height" /> меньше или равно нулю.  
  
- или - 
 Сумма <paramref name="width" /> и <see cref="P:System.Console.WindowLeft" /> либо сумма  <paramref name="height" /> и <see cref="P:System.Console.WindowTop" /> больше или равна <see cref="F:System.Int16.MaxValue" />.  
  
-или- 
 Значение параметра <paramref name="width" /> или <paramref name="height" /> больше ширины или высоты окна максимально возможной при текущем разрешении и шрифте консоли.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public static string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string Title" />
      <MemberSignature Language="DocId" Value="P:System.Console.Title" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Console.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает заголовок для отображения в строке заголовка консоли.</summary>
        <value>Строка для отображения в строке заголовка консоли. Максимальная длина строки заголовка — 24500 символов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере показано <xref:System.Console.Title%2A> свойство. В примере содержится заголовок текущей окна операционной системы, ожидает нажатия клавиш, а затем отображает новый заголовок.  
  
 [!code-cpp[console.title#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.title/CPP/mytitle.cpp#1)]
 [!code-csharp[console.title#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.title/CS/mytitle.cs#1)]
 [!code-vb[console.title#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.title/VB/mytitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В операции get длина полученного заголовка превышает 24 500 символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">В операции set указанный заголовок длиннее 24500 символов.</exception>
        <exception cref="T:System.ArgumentNullException">Для операции set задан заголовок <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция получения вызывается в операционной системе, отличной от Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TreatControlCAsInput">
      <MemberSignature Language="C#" Value="public static bool TreatControlCAsInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool TreatControlCAsInput" />
      <MemberSignature Language="DocId" Value="P:System.Console.TreatControlCAsInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property TreatControlCAsInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool TreatControlCAsInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TreatControlCAsInput : bool with get, set" Usage="System.Console.TreatControlCAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, интерпретируется ли комбинация клавиши-модификатора <see cref="F:System.ConsoleModifiers.Control" /> и клавиши консоли <see cref="F:System.ConsoleKey.C" /> (Ctrl+C) как обычный ввод или как прерывание, которое обрабатывается операционной системой.</summary>
        <value>Значение <see langword="true" />, если сочетание клавиш CTRL+C интерпретируется как обычный ввод; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение <xref:System.Console.TreatControlCAsInput%2A> свойство `false` и нажатии Ctrl + C, нажатые клавиши не сохраняются во входном буфере и операционная система не завершит текущего выполняемого процесса. Это значение по умолчанию.  
  
> [!CAUTION]
>  Используйте это свойство осмотрительно, так как задание значения `true` имеет серьезные последствия. Большинство пользователи ожидают, что сочетание клавиш Ctrl + C для остановки консольное приложение. При отключении последствия Ctrl + C, пользователю придется использовать для завершения работы приложения, который является менее знакомым сочетание клавиш Ctrl + Break.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.TreatControlCAsInput%2A> свойство.  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Не удалось получить или задать режим ввода входного буфера консоли.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="F:System.ConsoleModifiers.Control" />
        <altmember cref="F:System.ConsoleKey.C" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public static int WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowHeight : int with get, set" Usage="System.Console.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту области окна консоли.</summary>
        <value>Высота окна консоли измеряется строками.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Попытка задать значение <xref:System.Console.WindowHeight%2A> свойства, если вывод перенаправляется создает исключение <xref:System.ArgumentOutOfRangeException> или <xref:System.IO.IOException> исключение. Чтобы избежать исключения, можно задать значение это свойства только в том случае, если <xref:System.Console.IsOutputRedirected%2A> возвращает `false`.  
  
   
  
## Examples  
 В этом примере показано <xref:System.Console.SetWindowSize%2A> метод и <xref:System.Console.WindowWidth%2A> и <xref:System.Console.WindowHeight%2A> свойства. Необходимо запустить пример, чтобы просмотреть полный эффект от изменения размера окна консоли.  
  
 В примере выводятся размеры окна консоли, установленные на 85 столбцов и строк 43, затем ожидает нажатия клавиш. При нажатии любой клавиши, размеры окна консоли уменьшаются вдвое, выводятся новые размеры, и в этом примере ожидается другой клавиши. Наконец при нажатии любой клавиши восстанавливаются исходные размеры окна консоли и кода данного примера завершается.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение свойства <see cref="P:System.Console.WindowWidth" /> или <see cref="P:System.Console.WindowHeight" /> не больше 0.  
  
- или - 
Сумма значений свойств <see cref="P:System.Console.WindowHeight" /> и <see cref="P:System.Console.WindowTop" /> больше или равна <see cref="F:System.Int16.MaxValue" />.  
  
-или- 
Значение свойства <see cref="P:System.Console.WindowWidth" /> или <see cref="P:System.Console.WindowHeight" /> больше максимально возможной ширины или высоты окна для текущего разрешения экрана и шрифта консоли.</exception>
        <exception cref="T:System.IO.IOException">Ошибка при чтении или записи данных.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowLeft">
      <MemberSignature Language="C#" Value="public static int WindowLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowLeft : int with get, set" Usage="System.Console.WindowLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию левого края области окна консоли относительно буфера экрана.</summary>
        <value>Позиция левого края области окна консоли измеряется столбцами.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль представляет прямоугольное окно в большей области буфера. Окна и буфер измеряются по вертикали по их количеству строк и по горизонтали по их количеству столбцов. Размеры буферной области определяются <xref:System.Console.BufferHeight%2A> и <xref:System.Console.BufferWidth%2A> свойства. Размеры области консоли определяются <xref:System.Console.WindowHeight%2A> и <xref:System.Console.WindowWidth%2A> свойства. <xref:System.Console.WindowLeft%2A> Свойство определяет, какой столбец буферной области отображается в первом столбце окна консоли. Значение <xref:System.Console.WindowLeft%2A> свойства варьируются от 0 до <xref:System.Console.BufferWidth%2A>  -  <xref:System.Console.WindowWidth%2A>. Попытка задать его значение за пределами этого диапазона возникает исключение <xref:System.ArgumentOutOfRangeException>.  
  
 При первом открытии окна консоли, значение по умолчанию <xref:System.Console.WindowLeft%2A> свойство является ноль, означающий, что первый столбец, показанный в консоли соответствует первый столбец (столбец нулевой позиции) в буферной области. Ширина по умолчанию в окне консоли и области буфера равна 80 столбцов. Это означает, что <xref:System.Console.WindowLeft%2A> свойство может быть изменено только в том случае, если окно консоли станет уже или области буфера.  
  
 Обратите внимание, что если ширина буферной области превышает ширину окна консоли, а значение <xref:System.Console.WindowLeft%2A> свойство изменяется автоматически в том случае, когда пользователь использует полосу горизонтальной прокрутки для определения отношения к буферной области.  
  
 Попытка задать значение <xref:System.Console.WindowLeft%2A> свойство, если вывод перенаправлено вызывает <xref:System.IO.IOException> исключение. Чтобы избежать возникновения исключения, можно задать значение это свойства только в том случае, если <xref:System.Console.IsOutputRedirected%2A> возвращает `false`.  
  
   
  
## Examples  
 В следующем примере открывается окно консоли столбец 80 и определяет область буфера шириной 120 столбцов. Отображает сведения об окне и размер буфера и ожидает нажатия пользователем клавиши Стрелка влево или Стрелка вправо. В первом случае он уменьшает значение <xref:System.Console.WindowLeft%2A> свойство на единицу, если результат является допустимым значением. В последнем случае оно увеличивается значение <xref:System.Console.WindowLeft%2A> свойство на единицу, если результат должен быть допустимым. Обратите внимание, что пример не должен обрабатывать <xref:System.ArgumentOutOfRangeException>, так как он проверяет, что значение, присваиваемое <xref:System.Console.WindowLeft%2A> свойство не является отрицательным и не приводит к сумме <xref:System.Console.WindowLeft%2A> и <xref:System.Console.WindowWidth%2A> свойства к превышению <xref:System.Console.BufferWidth%2A> значение свойства.  
  
 [!code-cpp[System.Console.WindowLeft#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.windowleft/cpp/windowleft1.cpp#1)]
 [!code-csharp[System.Console.WindowLeft#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.windowleft/cs/windowleft1.cs#1)]
 [!code-vb[System.Console.WindowLeft#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.windowleft/vb/windowleft1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">В операции над множеством назначаемое значение меньше нуля.  
  
- или - 
Как результат назначения, свойство <see cref="P:System.Console.WindowLeft" /> плюс свойство <see cref="P:System.Console.WindowWidth" /> превысят свойство <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка при чтении или записи данных.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowTop">
      <MemberSignature Language="C#" Value="public static int WindowTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTop : int with get, set" Usage="System.Console.WindowTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию верхнего края области окна консоли относительно буфера экрана.</summary>
        <value>Позиция верхнего края области окна консоли измеряется строками.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль представляет прямоугольное окно в большей области буфера. Окна и буфер измеряются по вертикали по их количеству строк и по горизонтали по их количеству столбцов. Размеры буферной области определяются <xref:System.Console.BufferHeight%2A> и <xref:System.Console.BufferWidth%2A> свойства. Размеры области консоли определяются <xref:System.Console.WindowHeight%2A> и <xref:System.Console.WindowWidth%2A> свойства. <xref:System.Console.WindowTop%2A> Свойство определяет, какая строка буферной области отображается в первом столбце окна консоли. Значение <xref:System.Console.WindowTop%2A> свойства варьируются от 0 до <xref:System.Console.BufferHeight%2A>  -  <xref:System.Console.WindowHeight%2A>. Попытка задать его значение за пределами этого диапазона возникает исключение <xref:System.ArgumentOutOfRangeException>.  
  
 Попытка задать значение <xref:System.Console.WindowTop%2A> свойство, если вывод перенаправлено вызывает <xref:System.IO.IOException> исключение. Чтобы избежать возникновения исключения, можно задать значение это свойства только в том случае, если <xref:System.Console.IsOutputRedirected%2A> возвращает `false`.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, и <xref:System.Console.CursorVisible%2A> свойства; и <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, и <xref:System.Console.ReadKey%2A> методы. В примере рисуется сетку в буфере экрана, на основе ширины буфера экрана. Затем в примере перемещается окно консоли, в ответ, к которому стрелка вверх, нажатия клавиш консоли стрелка вниз, Стрелка влево или Стрелка вправо. Сетка помогает см. в разделе Перемещение окна консоли относительно буфера экрана.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">В операции над множеством назначаемое значение меньше нуля.  
  
- или - 
Как результат назначения, свойство <see cref="P:System.Console.WindowTop" /> плюс свойство <see cref="P:System.Console.WindowHeight" /> превысят свойство <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка при чтении или записи данных.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public static int WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowWidth : int with get, set" Usage="System.Console.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ширину окна консоли.</summary>
        <value>Ширина окна консоли измеряется столбцами.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Попытка задать значение <xref:System.Console.WindowWidth%2A> свойства, если вывод перенаправляется создает исключение <xref:System.ArgumentOutOfRangeException> или <xref:System.IO.IOException> исключение. Чтобы избежать исключения, можно задать значение это свойства только в том случае, если <xref:System.Console.IsOutputRedirected%2A> возвращает `false`.  
  
   
  
## Examples  
 В этом примере показано <xref:System.Console.SetWindowSize%2A> метод и <xref:System.Console.WindowWidth%2A> и <xref:System.Console.WindowHeight%2A> свойства. Необходимо запустить пример, чтобы просмотреть полный эффект от изменения размера окна консоли.  
  
 В примере выводятся размеры окна консоли, установленные на 85 столбцов и строк 43, затем ожидает нажатия клавиш. При нажатии любой клавиши, размеры окна консоли уменьшаются вдвое, выводятся новые размеры, и в этом примере ожидается другой клавиши. Наконец при нажатии любой клавиши восстанавливаются исходные размеры окна консоли и кода данного примера завершается.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение свойства <see cref="P:System.Console.WindowWidth" /> или <see cref="P:System.Console.WindowHeight" /> не больше 0.  
  
- или - 
Сумма значений свойств <see cref="P:System.Console.WindowHeight" /> и <see cref="P:System.Console.WindowTop" /> больше или равна <see cref="F:System.Int16.MaxValue" />.  
  
- или - 
Значение свойства <see cref="P:System.Console.WindowWidth" /> или <see cref="P:System.Console.WindowHeight" /> больше максимально возможной ширины или высоты окна для текущего разрешения экрана и шрифта консоли.</exception>
        <exception cref="T:System.IO.IOException">Ошибка при чтении или записи данных.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает текстовое представление заданного значения или значений в стандартный выходной поток.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(bool value);" />
      <MemberSignature Language="F#" Value="static member Write : bool -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает текстовое представление заданного логического значения в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>, возвращающего значение <xref:System.Boolean.TrueString?displayProperty=nameWithType> или <xref:System.Boolean.FalseString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(char value);" />
      <MemberSignature Language="F#" Value="static member Write : char -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает значение заданного знака Юникода в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member Write : char[] -&gt; unit" Usage="System.Console.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив знаков Юникода.</param>
        <summary>Записывает заданный массив знаков Юникода в стандартный выходной поток.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Write : decimal -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения <see cref="T:System.Decimal" /> в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(double value);" />
      <MemberSignature Language="F#" Value="static member Write : double -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения двойной точности с плавающей запятой в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Double.ToString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int value);" />
      <MemberSignature Language="F#" Value="static member Write : int -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 32-битового целого числа со знаком в стандартный поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Int32.ToString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(long value);" />
      <MemberSignature Language="F#" Value="static member Write : int64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 64-битового целого числа со знаком в стандартный поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Int64.ToString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : obj -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Записываемое значение или <see langword="null" />.</param>
        <summary>Записывает текстовое представление заданного объекта в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `value` является `null`, ничего не записывается, и исключение не создается. В противном случае `ToString` метод `value` вызывается для получения строкового представления, и результирующая строка записывается в стандартный выходной поток.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(float value);" />
      <MemberSignature Language="F#" Value="static member Write : single -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения одинарной точности с плавающей запятой в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Single.ToString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : string -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает заданное строковое значение в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение равно `null`, ничего не записывается в стандартный выходной поток.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint32 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 32-битового целого числа без знака в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 64-битового целого числа без знака в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj -&gt; unit" Usage="System.Console.Write (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Объект для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовое представление заданного объекта в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствовать объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент формата текстовое представление значения соответствующего объекта.  
  
 Синтаксис элемента формата `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, которое указывает, Обязательный индекса, длины и выравнивание форматированный текст и необязательная строка символов описателя формата, определяющих, как значение соответствующего объекта имеет формат.  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о описатели стандартного числового формата, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Custom Date и Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере с помощью метода `WriteLine` демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)] 
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере показано использование метода <xref:System.Console.Write%2A>.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj[] -&gt; unit" Usage="System.Console.Write (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-1.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg">Массив объектов для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовое представление заданного массива объектов в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствовать объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент формата текстовое представление значения соответствующего объекта.  
  
 Синтаксис элемента формата `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, которое указывает, Обязательный индекса, длины и выравнивание форматированный текст и необязательная строка символов описателя формата, определяющих, как значение соответствующего объекта имеет формат.  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о описатели стандартного числового формата, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Custom Date и Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 `arg` Параметр является массивом параметров. Аргументы могут передаваться в метод как массив или список пять или более элементов. В примерах показаны обе формы вызова метода.  
  
   
  
## Examples  
 В следующем примере определяется `Person` класса ряд свойств, которые предоставляют сведения о пользователе. Его `GetDescription` метод возвращает массив, содержащий все значения свойств, кроме одного. Затем в примере используется массив, возвращаемый `GetDescription` метод для отображения значений объекта Person.  
  
 [!code-csharp[System.Console.Write#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams1.cs#1)]
 [!code-vb[System.Console.Write#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams1.vb#1)]  
  
 Обратите внимание, что в примере вызывается <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29> метод вместо <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29> метод, так как он пытается отобразить значение `Person.Remarks` свойства в той же строке. Чтобы сделать это, он проверяет значение <xref:System.Console.CursorLeft%2A> и <xref:System.Console.WindowWidth%2A> свойства, чтобы определить, является достаточно места для замечания по размеру.  Если имеется, он отображает строку. В противном случае он записывает строки, отступы три пробела и отображает замечание.  
  
 Следующий пример идентичен первому, за исключением того, что он передает список пяти элементов в качестве `arg` аргумента вместо массива параметров.  
  
 [!code-csharp[System.Console.Write#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams2.cs#2)]
 [!code-vb[System.Console.Write#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="format" /> или <paramref name="arg" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Этот метод не вызывается кодом C++. Компилятор C++ разрешает вызовы к [System.Console.Write](xref:System.Console.Write*) , которые включают строку и список четырех или более параметров объекта как вызов <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />. Он разрешает вызовы к [System.Console.Write](xref:System.Console.Write*) строки и массив объектов, которые включают как вызов <see cref="M:System.Console.Write(System.String,System.Object)" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Write : char[] * int * int -&gt; unit" Usage="System.Console.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив знаков Юникода.</param>
        <param name="index">Начальная позиция в массиве <paramref name="buffer" />.</param>
        <param name="count">Количество символов для записи.</param>
        <summary>Записывает заданный дочерний массив знаков Юникода в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод записывает `count` символов, начиная с позиции `index` из `buffer` в стандартный выходной поток.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Сумма значений параметров <paramref name="index" /> и <paramref name="count" /> указывает на позицию вне массива <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием параметра <paramref name="format" />.</param>
        <param name="arg1">Второй объект для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовые представления заданных объектов в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствовать объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент формата текстовое представление значения соответствующего объекта.  
  
 Синтаксис элемента формата `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, которое указывает, Обязательный индекса, длины и выравнивание форматированный текст и необязательная строка символов описателя формата, определяющих, как значение соответствующего объекта имеет формат.  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о описатели стандартного числового формата, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Custom Date и Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере с помощью метода `WriteLine` демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием параметра <paramref name="format" />.</param>
        <param name="arg1">Второй объект для записи с использованием <paramref name="format" />.</param>
        <param name="arg2">Третий объект для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовые представления заданных объектов в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствовать объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент формата текстовое представление значения соответствующего объекта.  
  
 Синтаксис элемента формата `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, которое указывает, Обязательный индекса, длины и выравнивание форматированный текст и необязательная строка символов описателя формата, определяющих, как значение соответствующего объекта имеет формат.  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о описатели стандартного числового формата, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Custom Date и Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере с помощью метода `WriteLine` демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием параметра <paramref name="format" />.</param>
        <param name="arg1">Второй объект для записи с использованием <paramref name="format" />.</param>
        <param name="arg2">Третий объект для записи с использованием <paramref name="format" />.</param>
        <param name="arg3">Четвертый объект для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовое представление заданных объектов и список параметров переменной длины в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот интерфейс API CLS-несовместим. CLS-совместимая альтернатива — <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Компиляторы C# и Visual Basic автоматически разрешать вызов этого метода, как вызов <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствовать объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент формата текстовое представление значения соответствующего объекта.  
  
 Синтаксис элемента формата `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, которое указывает, Обязательный индекса, длины и выравнивание форматированный текст и необязательная строка символов описателя формата, определяющих, как значение соответствующего объекта имеет формат.  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о описатели стандартного числового формата, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Custom Date и Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование переменных параметров с <xref:System.Console.Write%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> метод. Метод вызывается со строкой составного формата и пять элементов формата.  
  
 [!code-cpp[System.Console.Write#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.write/cpp/con_write.cpp#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Этот метод помечен атрибутом <see langword="vararg" /> ключевое слово, которое означает, что он поддерживает переменное количество параметров. Метод может вызываться из Visual C++, но он не может вызываться из кода C# или Visual Basic. Компиляторы C# и Visual Basic разрешить вызовы <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" /> как вызов <see cref="M:System.Console.Write(System.String,System.Object[])" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает указанные данные с текущим признаком конца строки в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Знак завершения строки по умолчанию является строкой, значение которого равно возврат каретки, перевода строки («\r\n» в C# или `vbCrLf` в Visual Basic). Признак конца строки можно изменить, задав <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> свойство <xref:System.Console.Out%2A> свойство в другую строку.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine();" />
      <MemberSignature Language="F#" Value="static member WriteLine : unit -&gt; unit" Usage="System.Console.WriteLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Записывает текущий признак конца строки в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Знак завершения строки по умолчанию является строкой, значение которого равно возврат каретки, перевода строки («\r\n» в C# или `vbCrLf` в Visual Basic). Признак конца строки можно изменить, задав <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> свойство <xref:System.Console.Out%2A> свойство в другую строку. Иллюстрация приведена в примере.  
  
   
  
## Examples  
 В примере изменяется признак конца строки со значением по умолчанию «\r\n» или `vbCrLf` для «\r\n\r\n» или `vbCrLf`  +  `vbCrLf`. Затем он вызывает <xref:System.Console.WriteLine> и <xref:System.Console.WriteLine%28System.String%29> методы для отображения вывода на консоль.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="P:System.IO.TextWriter.NewLine" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(bool value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : bool -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного логического значения с текущим признаком конца строки в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 Следующий пример создает десять случайных целых чисел, а также использует <xref:System.Console.WriteLine%28System.Boolean%29?displayProperty=nameWithType> метод, чтобы указать, являются ли они даже.  
  
 [!code-cpp[System.Console.WriteLine#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_boolean1.cpp#4)]
 [!code-csharp[System.Console.WriteLine#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_boolean1.cs#4)]
 [!code-vb[System.Console.WriteLine#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_boolean1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(char value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает заданный знак Юникода, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятор совет, который вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходное сумму чаевых и общую сумму. Пример — это консольное приложение, которое требует от пользователя ввести сумму исходной издержек в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] -&gt; unit" Usage="System.Console.WriteLine buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив знаков Юникода.</param>
        <summary>Записывает заданный массив знаков Юникода, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : decimal -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление указанного значения <see cref="T:System.Decimal" />, за которым следует текущий знак завершения строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятор совет, который вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходное сумму чаевых и общую сумму. Пример — это консольное приложение, которое требует от пользователя ввести сумму исходной издержек в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(double value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : double -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения двойной точности с плавающей запятой, за которым следует признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Double.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятор совет, который вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходное сумму чаевых и общую сумму. Пример — это консольное приложение, которое требует от пользователя ввести сумму исходной издержек в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 32-битового целого числа со знаком, за которым следует текущий знак завершения строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Int32.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятор совет, который вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходное сумму чаевых и общую сумму. Пример — это консольное приложение, которое требует от пользователя ввести сумму исходной издержек в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(long value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 64-битового целого числа со знаком, за которым следует текущий знак завершения строки, в стандартный поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Int64.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятор совет, который вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходное сумму чаевых и общую сумму. Пример — это консольное приложение, которое требует от пользователя ввести сумму исходной издержек в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : obj -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного объекта, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `value` имеет значение `null`, записывается только признак конца строки. В противном случае `ToString` метод `value` вызывается для получения строкового представления, и результирующая строка записывается в стандартный выходной поток.  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Console.WriteLine%28System.Object%29> метод для отображения каждого значения в массиве объектов на консоль.  
  
 [!code-cpp[System.Console.WriteLine#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_obj1.cpp#3)]
 [!code-csharp[System.Console.WriteLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_obj1.cs#3)]
 [!code-vb[System.Console.WriteLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_obj1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(float value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : single -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения одинарной точности с плавающей запятой, за которым следует признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Single.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятор совет, который вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходное сумму чаевых и общую сумму. Пример — это консольное приложение, которое требует от пользователя ввести сумму исходной издержек в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает заданное строковое значение, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение равно `null`, записывается только признак конца строки, в стандартный выходной поток.  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine> метод.  
  
   
  
## Examples  
 В примере изменяется признак конца строки со значением по умолчанию «\r\n» или `vbCrLf` для «\r\n\r\n» или `vbCrLf`  +  `vbCrLf`. Затем он вызывает <xref:System.Console.WriteLine> и <xref:System.Console.WriteLine%28System.String%29> методы для отображения вывода на консоль.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint32 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 32-битового целого числа без знака, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятор совет, который вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходное сумму чаевых и общую сумму. Пример — это консольное приложение, которое требует от пользователя ввести сумму исходной издержек в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 64-битового целого числа без знака, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятор совет, который вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходное сумму чаевых и общую сумму. Пример — это консольное приложение, которое требует от пользователя ввести сумму исходной издержек в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Объект для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовое представление заданного объекта, за которым следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствовать объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент формата текстовое представление значения соответствующего объекта.  
  
 Синтаксис элемента формата `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, которое указывает, Обязательный индекса, длины и выравнивание форматированный текст и необязательная строка символов описателя формата, определяющих, как значение соответствующего объекта имеет формат.  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о описатели стандартного числового формата, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Custom Date и Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> метод для отображения пяти случайным образом <xref:System.Boolean> значения.  
  
 [!code-csharp[System.Console.WriteLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine6.cs#6)]
 [!code-vb[System.Console.WriteLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine6.vb#6)]  
  
 В следующем примере вызывается <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> метод для отображения текущей даты.   Обратите внимание, что элемент формат `format` аргумент использует «D» [стандартных форматов даты и времени строковое](~/docs/standard/base-types/standard-date-and-time-format-strings.md) для отображения даты в длинном формате даты текущего языка и региональных параметров.  
  
 [!code-csharp[System.Console.WriteLine#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine7.cs#7)]
 [!code-vb[System.Console.WriteLine#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine7.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj[] -&gt; unit" Usage="System.Console.WriteLine (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-1.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg">Массив объектов для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовые представления заданного массива объектов, за которым следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствовать объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент формата текстовое представление значения соответствующего объекта.  
  
 Синтаксис элемента формата `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, которое указывает, Обязательный индекса, длины и выравнивание форматированный текст и необязательная строка символов описателя формата, определяющих, как значение соответствующего объекта имеет формат.  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о описатели стандартного числового формата, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Custom Date и Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере представлен калькулятор совет, который вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходное сумму чаевых и общую сумму. Пример — это консольное приложение, которое требует от пользователя ввести сумму исходной издержек в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="format" /> или <paramref name="arg" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Этот метод не вызывается кодом C++. Компилятор C++ разрешает вызовы к [System.Console.WriteLine](xref:System.Console.WriteLine*) , которые включают строку и список четырех или более параметров объекта как вызов <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />. Он разрешает вызовы к [System.Console.WriteLine](xref:System.Console.WriteLine*) строки и массив объектов, которые включают как вызов <see cref="M:System.Console.WriteLine(System.String,System.Object)" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] * int * int -&gt; unit" Usage="System.Console.WriteLine (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив знаков Юникода.</param>
        <param name="index">Начальная позиция в массиве <paramref name="buffer" />.</param>
        <param name="count">Количество символов для записи.</param>
        <summary>Записывает заданный подмассив знаков Юникода, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод записывает `count` символов, начиная с позиции `index` из `buffer` в стандартный выходной поток.  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Сумма значений параметров <paramref name="index" /> и <paramref name="count" /> указывает на позицию вне массива <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием параметра <paramref name="format" />.</param>
        <param name="arg1">Второй объект для записи с использованием параметра <paramref name="format" />.</param>
        <summary>Записывает текстовые представления заданных объектов, за которыми следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствовать объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент формата текстовое представление значения соответствующего объекта.  
  
 Синтаксис элемента формата `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, которое указывает, Обязательный индекса, длины и выравнивание форматированный текст и необязательная строка символов описателя формата, определяющих, как значение соответствующего объекта имеет формат.  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о описатели стандартного числового формата, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Custom Date и Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере представлен калькулятор совет, который вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходное сумму чаевых и общую сумму. Пример — это консольное приложение, которое требует от пользователя ввести сумму исходной издержек в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием параметра <paramref name="format" />.</param>
        <param name="arg1">Второй объект для записи с использованием <paramref name="format" />.</param>
        <param name="arg2">Третий объект для записи с использованием параметра <paramref name="format" />.</param>
        <summary>Записывает текстовые представления заданных объектов, за которыми следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствовать объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент формата текстовое представление значения соответствующего объекта.  
  
 Синтаксис элемента формата `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, которое указывает, Обязательный индекса, длины и выравнивание форматированный текст и необязательная строка символов описателя формата, определяющих, как значение соответствующего объекта имеет формат.  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о описатели стандартного числового формата, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Custom Date и Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере представлен калькулятор совет, который вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходное сумму чаевых и общую сумму. Пример — это консольное приложение, которое требует от пользователя ввести сумму исходной издержек в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием параметра <paramref name="format" />.</param>
        <param name="arg1">Второй объект для записи с использованием <paramref name="format" />.</param>
        <param name="arg2">Третий объект для записи с использованием <paramref name="format" />.</param>
        <param name="arg3">Четвертый объект для записи с использованием параметра <paramref name="format" />.</param>
        <summary>Записывает текстовые представления заданных объектов и список параметров переменной длины, за которыми следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот интерфейс API CLS-несовместим. CLS-совместимая альтернатива — <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Компиляторы C# и Visual Basic автоматически разрешать вызов этого метода, как вызов <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствовать объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент формата текстовое представление значения соответствующего объекта.  
  
 Синтаксис элемента формата `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, которое указывает, Обязательный индекса, длины и выравнивание форматированный текст и необязательная строка символов описателя формата, определяющих, как значение соответствующего объекта имеет формат.  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о описатели стандартного числового формата, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Custom Date и Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о знак завершения строки, см. в разделе "Примечания" <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование переменных аргументов с <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> метод. Метод вызывается со строкой составного формата и пять элементов формата.  
  
 [!code-cpp[System.Console.WriteLine#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_vararg.cpp#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасные окна верхнего уровня и подокнах. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Этот метод помечен атрибутом <see langword="vararg" /> ключевое слово, которое означает, что он поддерживает переменное количество параметров. Метод может вызываться из Visual C++, но он не может вызываться из кода C# или Visual Basic. Компиляторы C# и Visual Basic разрешить вызовы <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" /> как вызов <see cref="M:System.Console.WriteLine(System.String,System.Object[])" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
  </Members>
</Type>
