<Type Name="Console" FullName="System.Console">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8ecce71b2343159a350f88a47436d716ece79c34" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70671586" /></Metadata><TypeSignature Language="C#" Value="public static class Console" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Console extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Console" />
  <TypeSignature Language="VB.NET" Value="Public Class Console" />
  <TypeSignature Language="C++ CLI" Value="public ref class Console abstract sealed" />
  <TypeSignature Language="F#" Value="type Console = class" />
  <AssemblyInfo>
    <AssemblyName>System.Console</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет стандартные потоки для консольных приложений: входной, выходной и поток сообщений об ошибках. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль — это окно операционной системы, в котором пользователи взаимодействуют с операционной системой или текстовым консольным приложением, вводя ввод текста с помощью клавиатуры компьютера и считывая текстовые данные из терминала компьютера. Например, в операционной системе Windows консоль называется окном командной строки и принимает команды MS-DOS. <xref:System.Console> Класс предоставляет базовую поддержку для приложений, считывающих символы из и записывающих символы в консоль.  
  
 Сведения о разработке с помощью <xref:System.Console> класса см. в следующих разделах:  
  
-   [Консольные потоки ввода-вывода](#Streams)  
  
-   [Буфер экрана и окно консоли](#Buffer)  
  
-   [Поддержка Юникода для консоли](#Unicode)  
  
-   [Общие операции](#Operations)  
  
-   [Заметки .NET Core](#Core)  
  
<a name="Streams"></a>   
## <a name="console-io-streams"></a>Консольные потоки ввода-вывода  
 При запуске консольного приложения операционная система автоматически связывает три потока ввода-вывода с консолью: стандартный входной поток, стандартный поток вывода и стандартный поток вывода ошибок. Приложение может считывать данные, введенные пользователем из стандартного входного потока. запись обычных данных в стандартный выходной поток; и записывают данные об ошибках в стандартный поток вывода ошибок. Эти потоки представлены в приложении в виде значений <xref:System.Console.In%2A?displayProperty=nameWithType>свойств, <xref:System.Console.Out%2A?displayProperty=nameWithType>и <xref:System.Console.Error%2A?displayProperty=nameWithType> .  
  
 По <xref:System.Console.In%2A> умолчанию значением свойства <xref:System.Console.Out%2A> <xref:System.IO.TextReader?displayProperty=nameWithType> является объект, представляющий клавиатуру, а значения свойств и <xref:System.Console.Error%2A> являются <xref:System.IO.TextWriter?displayProperty=nameWithType> объектами, представляющими окно консоли. Однако эти свойства можно задать для потоков, не представляющих окно консоли или клавиатуру. Например, эти свойства можно задать для потоков, представляющих файлы. Чтобы перенаправить стандартный входной, стандартный вывод или стандартный поток ошибок, вызовите <xref:System.Console.SetIn%2A?displayProperty=nameWithType>метод <xref:System.Console.SetOut%2A?displayProperty=nameWithType>, или <xref:System.Console.SetError%2A?displayProperty=nameWithType> соответственно. Операции ввода-вывода, использующие эти потоки, синхронизируются, что означает, что несколько потоков могут считывать или записывать данные в потоки. Это означает, что обычно асинхронные методы, такие как <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType>, выполняются синхронно, если объект представляет поток консоли.  
  
> [!NOTE]
>  Не используйте <xref:System.Console> класс для вывода выходных данных в автоматических приложениях, таких как серверные приложения. Вызовы методов, таких как <xref:System.Console.Write%2A?displayProperty=nameWithType> и <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> , не влияют на приложения GUI.  
  
 <xref:System.Console>члены класса, работающие нормально, когда базовый поток направляется на консоль, могут вызывать исключение, если поток перенаправляется, например, в файл. Запрограммировать приложение для <xref:System.IO.IOException?displayProperty=nameWithType> перехвата исключений при перенаправлении стандартного потока. Кроме того <xref:System.Console.IsOutputRedirected%2A>, можно использовать свойства <xref:System.Console.IsInputRedirected%2A>, и <xref:System.Console.IsErrorRedirected%2A> , чтобы определить, перенаправляется ли стандартный поток перед выполнением операции, вызывающей <xref:System.IO.IOException?displayProperty=nameWithType> исключение.  
  
 Иногда бывает полезно явно вызывать члены объектов потока, представленные <xref:System.Console.In%2A>свойствами, <xref:System.Console.Out%2A>и <xref:System.Console.Error%2A> . Например, по умолчанию <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> метод считывает входные данные из стандартного входного потока. Аналогичным образом <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> метод записывает данные в стандартный поток вывода, после чего за данными следует строка завершения строки по умолчанию, которая является возвратом каретки и переводом строки ("\r\n"). <xref:System.Console> Однако класс не предоставляет соответствующий метод для записи данных в стандартный поток вывода ошибок или свойство для изменения строки завершения строки для данных, записываемых в этот поток.  
  
 Эту проблему можно решить, установив <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> свойство <xref:System.Console.Out%2A> или <xref:System.Console.Error%2A> в другую строку завершения строки. Например, следующая C# инструкция задает строку завершения строки для стандартного потока вывода ошибок в два символа возврата каретки и перевода строки:  
  
 `Console.Error.NewLine = "\r\n\r\n";`  
  
 Затем можно явно вызвать <xref:System.IO.TextWriter.WriteLine%2A> метод объекта потока вывода ошибок, как показано в следующей C# инструкции:  
  
 `Console.Error.WriteLine();`  
  
<a name="Buffer"></a>   
## <a name="screen-buffer-and-console-window"></a>Буфер экрана и окно консоли  
 Двумя тесно связанными функциями консоли являются буфер экрана и окно консоли. Текст на самом деле считывается из потоков, принадлежащих консоли, и записывается в нее, но читается или записывается в область, принадлежащую консоли, которая называется буфером экрана. Буфер экрана является атрибутом консоли и организован в виде прямоугольной сетки строк и столбцов, где каждое пересечение сетки или символьная ячейка может содержать символ. Каждый символ имеет собственный цвет переднего плана, а каждая символьная ячейка имеет собственный цвет фона.  
  
 Буфер экрана просматривается через прямоугольную область, называемую окном консоли. Окно консоли — это еще один атрибут консоли; Это не сама консоль, которая является окном операционной системы. Окно консоли упорядочивается по строкам и столбцам, меньше или равно размеру буфера экрана и может быть перемещено для просмотра различных областей базового буфера экрана. Если буфер экрана больше, чем окно консоли, консоль автоматически отображает полосы прокрутки, чтобы окно консоли можно было переместить в область буфера экрана.  
  
 Курсор указывает позицию буфера экрана, в которой текст в данный момент считывается или записывается. Курсор можно скрыть или сделать видимым, и его высоту можно изменить. Если курсор является видимым, то расположение окна консоли перемещается автоматически, поэтому курсор всегда находится в представлении.  
  
 Источник координат ячейки символа в буфере экрана — верхний левый угол, а положения курсора и окна консоли измеряются относительно этого источника. Для указания позиций используйте индексы, начинающиеся с нуля. то есть, укажите самую верхнюю строку в виде строки 0, а самый левый столбец — в столбце 0. Максимальное значение для индексов строк и столбцов равно <xref:System.Int16.MaxValue?displayProperty=nameWithType>.  
  
<a name="Unicode"></a>   
## <a name="unicode-support-for-the-console"></a>Поддержка Юникода для консоли  
 Как правило, консоль считывает ввод и запись выходных данных с помощью текущей кодовой страницы консоли, которую по умолчанию определяет языковой стандарт системы. Кодовая страница может обрабатывать только подмножество доступных символов Юникода, поэтому при попытке отобразить символы, не сопоставленные определенной кодовой страницей, консоль не сможет отобразить все символы или представить их точно. Приведенный ниже пример иллюстрирует данную проблему. Он пытается отобразить символы кириллицы в алфавите от U + 0410 до U + 044F в консоли. Если запустить пример в системе, которая использует кодовую страницу консоли 437, каждый символ заменяется вопросительным знаком (?), поскольку символы кириллицы не сопоставляются с символами в кодовой странице 437.  
  
 [!code-csharp[System.Console.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/unicode1.cs#1)]
 [!code-vb[System.Console.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/unicode1.vb#1)]  
  
 Помимо поддержки кодовых страниц, <xref:System.Console> класс поддерживает кодировку UTF-8 <xref:System.Text.UTF8Encoding> с классом. Начиная с .NET Framework 4,5, <xref:System.Console> класс также поддерживает кодировку UTF-16 <xref:System.Text.UnicodeEncoding> с классом. Для вывода символов Юникода на консоль. для свойства <xref:System.Console.OutputEncoding%2A>  задается <xref:System.Text.UnicodeEncoding>значение или. <xref:System.Text.UTF8Encoding>  
  
 Для поддержки символов Юникода кодировщику необходимо распознать определенный символ Юникода, а также шрифт, который содержит глифы, необходимые для визуализации этого символа. Для успешного вывода символов Юникода на консоль в качестве шрифта консоли необходимо задать нерастровый или TrueType-шрифт, такой как consolas или ЛуЦида Console. В следующем примере показано, как можно программным способом изменить шрифт с растрового шрифта на консоль ЛуЦида.  
  
 [!code-csharp[System.Console.Class.Unsafe#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class.unsafe/cs/setfont1.cs#3)]
 [!code-vb[System.Console.Class.Unsafe#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class.unsafe/vb/setfont1.vb#3)]  
  
 Однако шрифты TrueType могут отображать только подмножество глифов. Например, шрифт консоли ЛуЦида отображает только 643 из приблизительно 64 000 символов от U + 0021 до U + FB02. Чтобы узнать, какие символы поддерживает конкретный шрифт, откройте приложение **шрифты** на панели управления, выберите параметр **найти символ** и выберите шрифт, набор символов которого необходимо проверить в списке **шрифтов** **таблицы символов** . окно.  
  
 Windows использует связывание шрифтов для отображаемых глифов, недоступных в определенном шрифте. Дополнительные сведения о связывании шрифтов для вывода дополнительных наборов символов см. в разделе глобализация пошаговых [действий: шрифты](https://go.microsoft.com/fwlink/?LinkId=229111). Связанные шрифты определяются в подразделе реестра HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Нт\куррентверсион\фонтлинк\системлинк. Каждая запись, связанная с этим подразделом, соответствует имени базового шрифта, а его значение — массив строк, который определяет файлы шрифтов и шрифты, связанные с базовым шрифтом. Каждый член массива определяет связанный шрифт и принимает форму *Font-File-Name*и*Font-Name*. В следующем примере показано, как программным способом определить связанный шрифт с именем SimSun, найденный в файле шрифтов с именем simsun. ТТК, который отображает упрощенные символы типа "символ".  
  
 [!code-csharp[System.Console.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/fontlink1.cs#2)]
 [!code-vb[System.Console.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/fontlink1.vb#2)]  
  
 Поддержка Юникода для консоли имеет следующие ограничения.  
  
-   Кодировка UTF-32 не поддерживается. Поддерживаются только кодировки Юникода UTF-8 и UTF-16, которые представлены <xref:System.Text.UTF8Encoding> классами и <xref:System.Text.UnicodeEncoding> соответственно.  
  
-   Двунаправленный вывод не поддерживается.  
  
-   Отображение символов за пределами базовой многоязычной плоскости (т. е. суррогатных пар) не поддерживается, даже если они определены в связанном файле шрифта.  
  
-   Отображение символов в сложных скриптах не поддерживается.  
  
-   Объединение последовательностей символов (то есть символов, которые состоят из базового символа и одного или нескольких Объединенных символов), отображается в виде отдельных символов. Чтобы обойти это ограничение, можно нормализовать строку для отображения, вызвав <xref:System.String.Normalize%2A?displayProperty=nameWithType> метод перед отправкой выходных данных в консоль. В следующем примере строка, содержащая объединенную последовательность символов u + 0061 u + 0308, отображается в консоли как два символа до нормализации выходной строки и как один символ после <xref:System.String.Normalize%2A?displayProperty=nameWithType> вызова метода.  
  
     [!code-csharp[System.Console.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/normalize1.cs#5)]
     [!code-vb[System.Console.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/normalize1.vb#5)]  
  
     Обратите внимание, что нормализация является приемлемым решением, только если Стандарт Юникода для символа содержит предварительно сформированную форму, соответствующую определенной последовательности Объединенных символов.  
  
-   Если шрифт содержит глиф для кодовой точки в области личных использований, этот глиф будет отображаться. Однако, поскольку символы в частной области использования относятся к конкретному приложению, это может быть не ожидаемый глиф.  
  
 В следующем примере на консоль выводится диапазон символов Юникода. Пример принимает три параметра командной строки: начало отображаемого диапазона, конец отображаемого диапазона и необходимость использования текущей кодировки консоли (`false`) или кодировки UTF-16 (`true`). Предполагается, что в консоли используется шрифт TrueType.  
  
 [!code-csharp[System.Console.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/example3.cs#4)]
 [!code-vb[System.Console.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/example3.vb#4)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Общие операции  
 <xref:System.Console> Класс содержит следующие методы для чтения входных данных консоли и записи вывода на консоль:  
  
-   Перегрузки <xref:System.Console.ReadKey%2A> метода считывают отдельный символ.  
  
-   <xref:System.Console.ReadLine%2A> Метод считывает всю строку входных данных.  
  
-   Перегрузки <xref:System.Console.Write%2A> метода преобразуют экземпляр типа значения, массив символов или набор объектов в форматированную или неформатированную строку, а затем записывают эту строку в консоль.  
  
-   Параллельный набор <xref:System.Console.WriteLine%2A> перегрузок метода выводит ту же строку <xref:System.Console.Write%2A> , что и перегрузки, но также добавляет строку завершения строки.  
  
 <xref:System.Console> Класс также содержит методы и свойства для выполнения следующих операций:  
  
-   Возвращает или задает размер буфера экрана. Свойства <xref:System.Console.BufferHeight%2A> <xref:System.Console.SetBufferSize%2A> и <xref:System.Console.BufferWidth%2A> позволяют получить или задать высоту и ширину буфера соответственно, а метод позволяет задать размер буфера в одном вызове метода.  
  
-   Возвращает или задает размер окна консоли. Свойства <xref:System.Console.WindowHeight%2A> <xref:System.Console.SetWindowSize%2A> и <xref:System.Console.WindowWidth%2A> позволяют получить или задать высоту и ширину окна соответственно, а метод позволяет задать размер окна в одном вызове метода.  
  
-   Возвращает или задает размер курсора. <xref:System.Console.CursorSize%2A> Свойство задает высоту курсора в ячейке символа.  
  
-   Возвращает или задает расположение окна консоли относительно буфера экрана. Свойства <xref:System.Console.WindowTop%2A> <xref:System.Console.SetWindowPosition%2A> и <xref:System.Console.WindowLeft%2A> позволяют получить или задать верхнюю строку и крайний левый столбец буфера экрана, который отображается в окне консоли, а метод позволяет задать эти значения в одном вызове метода.  
  
-   Возвращает или задает позицию курсора, получая или задавая <xref:System.Console.CursorTop%2A> свойства и <xref:System.Console.CursorLeft%2A> , или установите позицию курсора, вызвав <xref:System.Console.SetCursorPosition%2A> метод.  
  
-   Переместите или очистите данные в буфере экрана, вызвав <xref:System.Console.MoveBufferArea%2A> метод <xref:System.Console.Clear%2A> или.  
  
-   Возвращает или задает цвет переднего плана и фона с помощью <xref:System.Console.ForegroundColor%2A> свойств <xref:System.Console.BackgroundColor%2A> и или сбросьте фон и передний план на цвет <xref:System.Console.ResetColor%2A> по умолчанию, вызвав метод.  
  
-   Воспроизведение звука звукового сигнала с помощью динамика консоли путем вызова <xref:System.Console.Beep%2A> метода.  
  
<a name="Core"></a>   
## <a name="includenet_coreincludesnet-core-mdmd-notes"></a>Примечания по [!INCLUDE[net_core](~/includes/net-core-md.md)]  
 В .NET Framework на рабочем столе <xref:System.Console> класс использует кодировку, `GetConsoleCP` возвращенную и `GetConsoleOutputCP`, которая обычно является кодировкой кодовой страницы. Например, в системах, в которых используется английский язык (США), кодовая страница 437 используется по умолчанию. Однако в [!INCLUDE[net_core](~/includes/net-core-md.md)] может быть доступен только ограниченный набор кодировок. В этом случае <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> используется в качестве кодировки по умолчанию для консоли.  
  
 Если приложение зависит от конкретных кодировок кодовых страниц, вы все равно можете сделать их доступными, выполнив следующие действия *перед* вызовом <xref:System.Console> методов.  
  
1.  Добавьте в проект ссылку на сборку System.Text.Encoding.CodePages.dll.  
  
2.  Получите объект <xref:System.Text.EncodingProvider> из свойства <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>.  
  
3.  Передайте объект <xref:System.Text.EncodingProvider> в метод <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>, чтобы сделать доступными дополнительные кодировки, поддерживаемые поставщиком кодировки.  
  
 Класс будет автоматически использовать системную кодировку по умолчанию, а не UTF8, при условии, что поставщик кодирования зарегистрирован до <xref:System.Console> вызова методов вывода. <xref:System.Console>  
  
   
  
## Examples  
 В следующем примере показано, как считывать данные из стандартных входных и выходных потоков и записывать их в них. Обратите внимание, что эти потоки можно перенаправить с <xref:System.Console.SetIn%2A> помощью <xref:System.Console.SetOut%2A> методов и.  
  
 [!code-cpp[Classic Console Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Console Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Console Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Console Example/CS/source.cs#1)]
 [!code-vb[Classic Console Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Console Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor BackgroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.BackgroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BackgroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor BackgroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundColor : ConsoleColor with get, set" Usage="System.Console.BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет фона консоли.</summary>
        <value>Значение из перечисления , задающее фоновый цвет консоли, то есть цвет, на фоне которого выводятся символы. Значением по умолчанию является Black.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изменение <xref:System.Console.BackgroundColor%2A> свойства влияет только на вывод, который записывается в отдельные ячейки символов после изменения цвета фона. Чтобы изменить цвет фона окна консоли в целом, установите <xref:System.Console.BackgroundColor%2A> свойство и <xref:System.Console.Clear%2A> вызовите метод. Ниже приведен пример.  
  
 [!code-csharp[System.Console.BackgroundColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.backgroundcolor/cs/backgroundcolor1.cs#1)]
 [!code-vb[System.Console.BackgroundColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.backgroundcolor/vb/backgroundcolor1.vb#1)]  
  
 Операция Get для приложения Windows, в котором консоль не существует, возвращает <xref:System.ConsoleColor.Black?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере значения <xref:System.ConsoleColor> перечисления сохраняются в массиве, а текущие значения <xref:System.Console.BackgroundColor%2A> свойств и <xref:System.Console.ForegroundColor%2A> сохраняются в переменных. Затем он изменяет цвет переднего плана на каждый цвет в <xref:System.ConsoleColor> перечислении, за исключением цвета, соответствующего текущему фону, и изменяет цвет фона на каждый цвет <xref:System.ConsoleColor> в перечислении, за исключением цвета, соответствующего текущий передний план. (Если цвет переднего плана совпадает с цветом фона, текст не отображается.) Наконец, он вызывает <xref:System.Console.ResetColor%2A> метод для восстановления исходных цветов консоли.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Цвет, указанный в операции SET, не является допустимым членом <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Beep">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Воспроизводит звуковой сигнал через динамик консоли.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="System.Console.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Воспроизводит звуковой сигнал через динамик консоли.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию звуковой сигнал воспроизводится с частотой 800 Гц в течение 200 миллисекунд.  
  
> [!NOTE]
>  Этот <xref:System.Console.Beep%2A> метод не поддерживается в 64-разрядных выпусках Windows Vista и Windows XP.  
  
 <xref:System.Console.Beep%2A>заключает в оболочку вызов функции Windows [Beep](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Создает <xref:System.Console.Beep%2A> ли звук на версиях Windows, прежде чем Windows 7 будет зависеть от наличия микросхемы интервала таймера 8254. Начиная с Windows 7, это зависит от звукового устройства по умолчанию.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.Beep%2A> метод. Пример принимает число от 1 до 9 в качестве аргумента командной строки и воспроизводит звуковой сигнал в соответствии с количеством попыток.  
  
 [!code-cpp[console.beep#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep/CPP/beep.cpp#1)]
 [!code-csharp[console.beep#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep/CS/beep.cs#1)]
 [!code-vb[console.beep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep/VB/beep.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.HostProtectionException">Этот метод выполнен на сервере, например SQL Server, который не разрешает доступ к интерфейсу пользователя.</exception>
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep (int frequency, int duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep(int32 frequency, int32 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep (frequency As Integer, duration As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep(int frequency, int duration);" />
      <MemberSignature Language="F#" Value="static member Beep : int * int -&gt; unit" Usage="System.Console.Beep (frequency, duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frequency" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="duration" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="frequency">Частота сигнала в диапазоне от 37 до 32767 Гц.</param>
        <param name="duration">Длительность сигнала в миллисекундах.</param>
        <summary>Воспроизводит звуковой сигнал заданной частоты и длительности через динамик консоли.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Beep%2A>заключает в оболочку вызов функции Windows [Beep](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Создает <xref:System.Console.Beep%2A> ли звук на версиях Windows, прежде чем Windows 7 будет зависеть от наличия микросхемы интервала таймера 8254. Начиная с Windows 7, это зависит от звукового устройства по умолчанию.  
  
> [!NOTE]
>  Этот <xref:System.Console.Beep%2A> метод не поддерживается в 64-разрядных выпусках Windows Vista и Windows XP.  
  
   
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.Beep%2A> метод, воспроизводящий первые несколько примечаний песни с помощью динамика консоли.  
  
 [!code-cpp[console.beep2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep2/CPP/b2.cpp#1)]
 [!code-csharp[console.beep2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep2/CS/b2.cs#1)]
 [!code-vb[console.beep2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep2/VB/b2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="frequency" /> меньше 37 или больше 32767 Гц.  
  
- или - 
 <paramref name="duration" /> меньше или равно нулю.</exception>
        <exception cref="T:System.Security.HostProtectionException">Этот метод выполнен на сервере, например SQL Server, который не разрешает доступ к консоли.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="BufferHeight">
      <MemberSignature Language="C#" Value="public static int BufferHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferHeight : int with get, set" Usage="System.Console.BufferHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту буферной области.</summary>
        <value>Текущая высота буферной области в строках.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство определяет количество строк (или строк), хранящихся в буфере, к которому обращается окно режима консоли. Напротив, <xref:System.Console.WindowHeight%2A> свойство определяет количество строк, которые фактически отображаются в окне консоли в любое определенное время. Если число строк, фактически записанных в буфер, превышает число строк, определяемое <xref:System.Console.WindowHeight%2A> свойством, окно можно прокручивать по вертикали, чтобы отображалось непрерывное число строк, равное <xref:System.Console.WindowHeight%2A> свойству и расположенным в любом месте буфера.  
  
 Если операция задания уменьшает значение <xref:System.Console.BufferHeight%2A> свойства, самые направляющие удаляются. Например, если число строк уменьшается с 300 до 250, строки от 0 до 49 удаляются, а существующие строки с 50 по 299 становятся строками от 0 до 249.  
  
   
  
## Examples  
 В <xref:System.Console.BufferHeight%2A> этом примере демонстрируются <xref:System.Console.BufferWidth%2A> свойства и. В примере выводится список измерений окна операционной системы, для которых задан размер буфера 300 строк и 85 столбцов.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше или равно нулю.  
  
- или - 
Значение, заданное для операции set, больше или равно <see cref="F:System.Int16.MaxValue" />.  
  
-или- 
Значение в операции задания меньше суммы <see cref="P:System.Console.WindowTop" /> + <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BufferWidth">
      <MemberSignature Language="C#" Value="public static int BufferWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferWidth : int with get, set" Usage="System.Console.BufferWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ширину буферной области.</summary>
        <value>Текущая ширина буферной области в столбцах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если операция задания уменьшает значение <xref:System.Console.BufferWidth%2A> свойства, крайние правые столбцы удаляются. Например, если число столбцов уменьшается с 80 до 60, столбцы с 60 по 79 каждой строки удаляются.  
  
   
  
## Examples  
 В <xref:System.Console.BufferHeight%2A> этом примере демонстрируются <xref:System.Console.BufferWidth%2A> свойства и. В примере выводится список измерений окна операционной системы, для которых задан размер буфера 300 строк и 85 столбцов.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше или равно нулю.  
  
- или - 
Значение, заданное для операции set, больше или равно <see cref="F:System.Int16.MaxValue" />.  
  
- или - 
Значение в операции задания меньше суммы <see cref="P:System.Console.WindowLeft" /> + <see cref="P:System.Console.WindowWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelKeyPress">
      <MemberSignature Language="C#" Value="public static event ConsoleCancelEventHandler CancelKeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ConsoleCancelEventHandler CancelKeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Console.CancelKeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event CancelKeyPress As ConsoleCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event ConsoleCancelEventHandler ^ CancelKeyPress;" />
      <MemberSignature Language="F#" Value="member this.CancelKeyPress : ConsoleCancelEventHandler " Usage="member this.CancelKeyPress : System.ConsoleCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает при одновременном нажатии клавиши-модификатора <see cref="F:System.ConsoleModifiers.Control" /> (Ctrl) и либо клавиши консоли <see cref="F:System.ConsoleKey.C" /> (C), либо клавиши Break (Ctrl+C или Ctrl+Break).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие используется в сочетании с <xref:System.ConsoleCancelEventHandler?displayProperty=nameWithType> и. <xref:System.ConsoleCancelEventArgs?displayProperty=nameWithType> Это <xref:System.Console.CancelKeyPress> событие позволяет консольному приложению перехватывать сигналы CTRL + C, чтобы обработчик событий мог решить, следует ли продолжать выполнение или завершение. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Когда пользователь нажимает сочетание клавиш CTRL + C или Ctrl + Break, <xref:System.Console.CancelKeyPress> возникает событие и выполняется обработчик <xref:System.ConsoleCancelEventHandler> событий приложения. Обработчику событий передается <xref:System.ConsoleCancelEventArgs> объект, который имеет два полезных свойства:  
  
-   <xref:System.ConsoleCancelEventArgs.SpecialKey%2A>, который позволяет определить, был ли обработчик вызван в результате нажатия клавиш CTRL + C (значение свойства — <xref:System.ConsoleSpecialKey.ControlC?displayProperty=nameWithType>) или Ctrl + Break (значение свойства — <xref:System.ConsoleSpecialKey.ControlBreak?displayProperty=nameWithType>).  
  
-   <xref:System.ConsoleCancelEventArgs.Cancel%2A>, который позволяет определить, как приложение должно реагировать на пользователя, нажав клавиши CTRL + C или Ctrl + Break. По умолчанию <xref:System.ConsoleCancelEventArgs.Cancel%2A> свойство имеет `false`значение, которое приводит к завершению выполнения программы при выходе из обработчика событий. Изменение его свойства на `true` указывает, что приложение должно продолжать выполнение.  
  
> [!TIP]
>  Если приложение имеет простые требования, вместо этого события можно использовать <xref:System.Console.TreatControlCAsInput%2A> свойство. Установив для `false`этого свойства значение, можно гарантировать, что приложение всегда завершает работу, если пользователь нажмет клавиши CTRL + C. Если задать для `true`него значение, то вы не сможете завершить работу приложения, нажав клавиши CTRL + C.  
  
 Обработчик событий для этого события выполняется в потоке пула потоков.  
  
   
  
## Examples  
 В следующем примере показано, <xref:System.Console.CancelKeyPress> как используется событие. При нажатии клавиш CTRL + C операция чтения прерывается и `myHandler` вызывается обработчик событий. При входе в обработчик <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> событий свойство имеет `false`значение, которое означает, что текущий процесс завершится после завершения работы обработчика событий. Однако обработчик событий задает <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> для `true`свойства значение, которое означает, что процесс не завершится и операция чтения будет возобновлена.  
  
 [!code-cpp[console.cancelkeypress#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cancelkeypress/cpp/ckp.cpp#1)]
 [!code-csharp[console.cancelkeypress#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cancelkeypress/cs/ckp.cs#1)]
 [!code-vb[console.cancelkeypress#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cancelkeypress/vb/ckp.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.ConsoleCancelEventArgs" />
        <altmember cref="T:System.ConsoleCancelEventHandler" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
      </Docs>
    </Member>
    <Member MemberName="CapsLock">
      <MemberSignature Language="C#" Value="public static bool CapsLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CapsLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.CapsLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CapsLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CapsLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CapsLock : bool" Usage="System.Console.CapsLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, включен или отключен режим CAPS LOCK клавиатуры.</summary>
        <value>Значение <see langword="true" />, если режим CAPS LOCK включен; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Операция получения вызывается в операционной системе, отличной от Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear();" />
      <MemberSignature Language="F#" Value="static member Clear : unit -&gt; unit" Usage="System.Console.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет из буфера консоли и ее окна отображаемую информацию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Использование метода эквивалентно вызову команды MS-DOS `cls` в окне командной строки. <xref:System.Console.Clear%2A> При вызове <xref:System.Console.Clear%2A> метода курсор автоматически прокручивается к левому верхнему углу окна, а содержимое буфера экрана устанавливается в пустое значение с использованием текущих фоновых цветов переднего плана.  
  
> [!NOTE]
>  Попытка вызвать <xref:System.Console.Clear%2A> метод, когда выходные данные консольного приложения перенаправляется в файл, <xref:System.IO.IOException>вызывает исключение. Чтобы избежать этого, всегда заключайте вызов <xref:System.Console.Clear%2A> метода `try`в...`catch` блок.  
  
   
  
## Examples  
 В следующем примере <xref:System.Console.Clear%2A> метод очищает консоль перед выполнением цикла, предложит пользователю выбрать цвет переднего плана и фона и ввести строку для вывода. Если пользователь решил не выходить из программы, восстанавливаются исходные цвета и цвет фона консоли, а <xref:System.Console.Clear%2A> метод вызывается снова перед повторным выполнением цикла.  
  
 [!code-csharp[System.Console.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.clear/cs/clear1.cs#1)]
 [!code-vb[System.Console.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.clear/vb/clear1.vb#1)]  
  
 В этом примере используется `GetKeyPress` метод для проверки выбора пользователем переднего плана и цвета фона.  
  
 В <xref:System.Console.CursorLeft%2A> этом примере демонстрируются <xref:System.Console.CursorTop%2A> свойства и, а <xref:System.Console.SetCursorPosition%2A> также <xref:System.Console.Clear%2A> методы и. В примере размещается курсор, который определяет, где будет выполняться следующая запись, чтобы нарисовать 5-символьный прямоугольник на 5 символов, используя сочетание строк "+&#124;", "" и "-". Обратите внимание, что прямоугольник может быть нарисован с меньшим количеством шагов, используя сочетание других строк.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
      </Docs>
    </Member>
    <Member MemberName="CursorLeft">
      <MemberSignature Language="C#" Value="public static int CursorLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorLeft : int with get, set" Usage="System.Console.CursorLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию столбца курсора в буферной области.</summary>
        <value>Текущая позиция курсора в столбцах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В <xref:System.Console.CursorLeft%2A> этом примере демонстрируются <xref:System.Console.CursorTop%2A> свойства и, а <xref:System.Console.SetCursorPosition%2A> также <xref:System.Console.Clear%2A> методы и. В примере размещается курсор, который определяет, где будет выполняться следующая запись, чтобы нарисовать 5-символьный прямоугольник на 5 символов, используя сочетание строк "+&#124;", "" и "-". Обратите внимание, что прямоугольник может быть нарисован с меньшим количеством шагов, используя сочетание других строк.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше нуля.  
  
-или- 
Значение в операции задания больше или равно <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorSize">
      <MemberSignature Language="C#" Value="public static int CursorSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorSize" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorSize : int with get, set" Usage="System.Console.CursorSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту курсора в символьной ячейке.</summary>
        <value>Размер курсора, выраженный как процент от высоты символьной ячейки. Данное свойство принимает значения в диапазоне от 1 до 100.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Внешний вид курсора зависит от горизонтальной линии в нижней части ячейки, когда значение свойства равно 1, чтобы полностью заполнить ячейку, если значение свойства равно 100.  
  
   
  
## Examples  
 В <xref:System.Console.CursorSize%2A> этом примере демонстрируется свойство. Этот пример увеличивает размер курсора при каждом нажатии клавиши консоли, а затем восстанавливает курсор до исходного размера перед завершением работы.  
  
 [!code-cpp[console.cursorsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorsize/CPP/csize.cpp#1)]
 [!code-csharp[console.cursorsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorsize/CS/csize.cs#1)]
 [!code-vb[console.cursorsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorsize/VB/csize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное в операции задания, меньше 1 или больше 100.</exception>
        <exception cref="T:System.Security.SecurityException">Данный пользователь не имеет разрешения на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorTop">
      <MemberSignature Language="C#" Value="public static int CursorTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorTop : int with get, set" Usage="System.Console.CursorTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию строки курсора в буферной области.</summary>
        <value>Текущая позиция курсора в строках.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В <xref:System.Console.CursorLeft%2A> этом примере демонстрируются <xref:System.Console.CursorTop%2A> свойства и, а <xref:System.Console.SetCursorPosition%2A> также <xref:System.Console.Clear%2A> методы и. В примере размещается курсор, который определяет, где будет выполняться следующая запись, чтобы нарисовать 5-символьный прямоугольник на 5 символов, используя сочетание строк "+&#124;", "" и "-". Обратите внимание, что прямоугольник может быть нарисован с меньшим количеством шагов, используя сочетание других строк.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше нуля.  
  
- или - 
Значение в операции задания больше или равно <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorVisible">
      <MemberSignature Language="C#" Value="public static bool CursorVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CursorVisible" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorVisible" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CursorVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CursorVisible : bool with get, set" Usage="System.Console.CursorVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, видим ли курсор.</summary>
        <value>Значение <see langword="true" />, если курсор видим; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В <xref:System.Console.CursorVisible%2A> этом примере демонстрируется свойство. В примере курсор становится видимым, если первый столбец входных данных является символом "+" или невидимым, если входные данные являются символом "-".  
  
 [!code-cpp[console.cursorvis#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorvis/CPP/vis.cpp#1)]
 [!code-csharp[console.cursorvis#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorvis/CS/vis.cs#1)]
 [!code-vb[console.cursorvis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorvis/VB/vis.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция получения вызывается в операционной системе, отличной от Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Error" />
      <MemberSignature Language="DocId" Value="P:System.Console.Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Error As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Error { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.TextWriter" Usage="System.Console.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает стандартный выходной поток сообщений об ошибках.</summary>
        <value>Объект <see cref="T:System.IO.TextWriter" />, предоставляющий стандартный поток вывода ошибок.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот стандартный поток ошибок по умолчанию задан для консоли. Для него можно задать другой поток с <xref:System.Console.SetError%2A> помощью метода. После перенаправления стандартного потока ошибок его можно получить, вызвав <xref:System.Console.OpenStandardError%2A> метод.  
  
 В консольных приложениях, информационный вывод которых часто перенаправляется в файл, стандартный поток ошибок, доступный через <xref:System.Console.Error%2A> свойство, можно использовать для вывода информации на консоль, даже если выходные данные перенаправляются. В следующем примере отображаются таблицы продуктов для 10 чисел за раз, начиная с 1. После каждого набора из 10 чисел <xref:System.Console.Error%2A> свойство используется для запроса пользователя, следует ли отображать следующий набор. Если стандартный вывод перенаправляется в файл, пользователь по-прежнему запрашивает, должен ли подпрограмма создать следующий набор продуктов.  
  
 [!code-csharp[System.Console.Error#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.error/cs/error1.cs#1)]
 [!code-vb[System.Console.Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.error/vb/error1.vb#1)]  
  
   
  
## Examples  
 Следующий пример представляет собой служебную программу командной строки с именем експандтабс, которая заменяет символы табуляции в текстовом файле с четырьмя пробелами и значением `tabSize` , определенным переменной. Он перенаправляет стандартные входные и выходные потоки в файлы, но использует <xref:System.Console.Error%2A> свойство для записи стандартного потока ошибок в консоль. Его можно запустить из командной строки, указав имя файла, содержащего символы табуляции, и имя выходного файла.  
  
 [!code-cpp[Console-EXPANDTABSEX#1](~/samples/snippets/cpp/VS_Snippets_CLR/Console-EXPANDTABSEX/CPP/expandtabsex.cpp#1)]
 [!code-csharp[Console-EXPANDTABSEX#1](~/samples/snippets/csharp/VS_Snippets_CLR/Console-EXPANDTABSEX/CS/expandtabsex.cs#1)]
 [!code-vb[Console-EXPANDTABSEX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Console-EXPANDTABSEX/VB/expandtabsex.vb#1)]  
  
 Следующий пример представляет собой простое средство просмотра текстовых файлов, которое отображает содержимое одного или нескольких текстовых файлов на консоли. Если аргументы командной строки отсутствуют или какие-либо файлы, переданные как аргументы командной строки, не существуют, в примере вызывается <xref:System.Console.SetError%2A> метод для перенаправления сведений об ошибках в файл, <xref:System.Console.OpenStandardError%2A> вызывает метод в процессе повторного получения стандартной ошибки. Stream и указывает, что сведения об ошибке записаны в файл.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Обратите внимание <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> , что `true` перед повторным получением потока ошибок свойство имеет значение. Это гарантирует, что выходные данные будут отправляться в консоль немедленно, а не помещены в буфер.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ForegroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor ForegroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor ForegroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.ForegroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ForegroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor ForegroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.ForegroundColor : ConsoleColor with get, set" Usage="System.Console.ForegroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет фона консоли.</summary>
        <value>Значение из перечисления <see cref="T:System.ConsoleColor" />, задающее фоновый цвет текста консоли, то есть цвет, которым выводятся символы. По умолчанию задано значение Gray.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операция Get для приложения Windows, в котором консоль не существует, возвращает <xref:System.ConsoleColor.Gray>.  
  
   
  
## Examples  
 В следующем примере проверяется, является ли цвет фона консоли черным и, если это так, он изменяет цвет фона на красный, а цвет переднего плана — на черный.  
  
 [!code-csharp[System.ConsoleColor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/Example2.cs#2)] 
 [!code-vb[System.ConsoleColor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/Example2.vb#2)]  
  
 В следующем примере значения <xref:System.ConsoleColor> перечисления сохраняются в массиве, а текущие значения <xref:System.Console.BackgroundColor%2A> свойств и <xref:System.Console.ForegroundColor%2A> сохраняются в переменных. Затем он изменяет цвет переднего плана на каждый цвет в <xref:System.ConsoleColor> перечислении, за исключением цвета, соответствующего текущему фону, и изменяет цвет фона на каждый цвет <xref:System.ConsoleColor> в перечислении, за исключением цвета, соответствующего текущий передний план. (Если цвет переднего плана совпадает с цветом фона, текст не отображается.) Наконец, он вызывает <xref:System.Console.ResetColor%2A> метод для восстановления исходных цветов консоли.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Цвет, указанный в операции SET, не является допустимым членом <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="In">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader In { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextReader In" />
      <MemberSignature Language="DocId" Value="P:System.Console.In" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property In As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextReader ^ In { System::IO::TextReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.In : System.IO.TextReader" Usage="System.Console.In" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает стандартный входной поток.</summary>
        <value>Объект <see cref="T:System.IO.TextReader" />, представляющий стандартный входной поток.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию для этого свойства задан стандартный входной поток. Этому свойству можно задать другой поток с помощью <xref:System.Console.SetIn%2A> метода.  
  
 Операции чтения для стандартного входного потока выполняются синхронно. То есть они блокируются до завершения указанной операции чтения. Это справедливо, даже если <xref:System.IO.TextReader.ReadLineAsync%2A> <xref:System.IO.TextReader> для объекта, возвращаемого <xref:System.Console.In%2A> свойством, вызывается асинхронный метод, например.  
  
   
  
## Examples  
 В следующем примере показано использование `In` свойства.  
  
 [!code-cpp[consolein#1](~/samples/snippets/cpp/VS_Snippets_CLR/consolein/CPP/consolein.cpp#1)]
 [!code-csharp[consolein#1](~/samples/snippets/csharp/VS_Snippets_CLR/consolein/CS/consolein.cs#1)]
 [!code-vb[consolein#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/consolein/VB/consolein.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Console.OpenStandardInput" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="InputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding InputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding InputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.InputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property InputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ InputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputEncoding : System.Text.Encoding with get, set" Usage="System.Console.InputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает кодировку консоли, используемую при чтении входных данных.</summary>
        <value>Кодировка консоли, используемая при чтении ввода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль использует входную кодировку для преобразования ввода с клавиатуры в соответствующий символ. Входная кодировка включает кодовую страницу, которая сопоставляет коды символов клавиатуры 256 с отдельными символами. Разные кодовые страницы включают разные специальные символы, как правило, настроенные для языка или группы языков.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], операция получения свойства может возвращать кэшированное значение вместо текущей входной кодировки консоли. Это может произойти <xref:System.Console.InputEncoding%2A> , если значение свойства изменено другими способами, отличными от присваивания <xref:System.Console.InputEncoding%2A> свойству, например вызову функции `chcp` Windows `SetConsoleCP` или использованию команды из скрипта PowerShell.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение свойства в операции задания — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Во время выполнения этой операции произошла ошибка.</exception>
        <exception cref="T:System.Security.SecurityException">У приложения нет разрешения на выполнение этой операции.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для чтения и записи в окна и подокна верхнего уровня. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="IsErrorRedirected">
      <MemberSignature Language="C#" Value="public static bool IsErrorRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsErrorRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsErrorRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsErrorRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsErrorRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsErrorRedirected : bool" Usage="System.Console.IsErrorRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, был ли перенаправлен выходной поток ошибок от стандартного потока ошибок.</summary>
        <value>Значение<see langword="true" /> , если выходные сообщения об ошибках перенаправляются; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="IsInputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsInputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsInputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsInputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsInputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsInputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputRedirected : bool" Usage="System.Console.IsInputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, был ли перенаправлены ли входные данные от стандартного входного потока.</summary>
        <value>Значение <see langword="true" />, если входные данные перенаправляются; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
        <altmember cref="M:System.Console.OpenStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="IsOutputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsOutputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsOutputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsOutputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsOutputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsOutputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOutputRedirected : bool" Usage="System.Console.IsOutputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, был ли перенаправлены выходные данные от стандартного выходного потока.</summary>
        <value>Значение<see langword="true" /> , если выходные данные перенаправляются; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="KeyAvailable">
      <MemberSignature Language="C#" Value="public static bool KeyAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool KeyAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Console.KeyAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property KeyAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool KeyAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyAvailable : bool" Usage="System.Console.KeyAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, доступно ли нажатие клавиши во входном потоке.</summary>
        <value>Значение <see langword="true" />, если нажатие клавиши доступно; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства возвращается немедленно; Это значит, <xref:System.Console.KeyAvailable%2A> что свойство не блокирует входные данные до тех пор, пока не будет нажата клавиша.  
  
 Используйте свойство в сочетании <xref:System.Console.ReadKey%2A> только с методом, а не <xref:System.Console.Read%2A> с методами  <xref:System.Console.ReadLine%2A> или. <xref:System.Console.KeyAvailable%2A>  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Console.KeyAvailable%2A> свойства для создания цикла, который выполняется до нажатия клавиши.  
  
 [!code-cpp[console.keyavailable#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.keyavailable/CPP/ka.cpp#1)]
 [!code-csharp[console.keyavailable#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.keyavailable/CS/ka.cs#1)]
 [!code-vb[console.keyavailable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.keyavailable/VB/ka.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.InvalidOperationException">Стандартный ввод перенаправляется в файл вместо клавиатуры.</exception>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowHeight">
      <MemberSignature Language="C#" Value="public static int LargestWindowHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LargestWindowHeight : int" Usage="System.Console.LargestWindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальное число строк окна консоли с учетом текущего шрифта и разрешения экрана.</summary>
        <value>Максимально возможная высота окна консоли измеряется в строках.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowWidth">
      <MemberSignature Language="C#" Value="public static int LargestWindowWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowWidth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LargestWindowWidth : int" Usage="System.Console.LargestWindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальное число столбцов окна консоли с учетом текущего шрифта и разрешения экрана.</summary>
        <value>Максимально возможная ширина окна консоли измеряется в столбцах.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveBufferArea">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует заданную исходную область буфера экрана в заданную область назначения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceTop" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceWidth" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceHeight" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetLeft" Type="System.Int32" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetTop" Type="System.Int32" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Крайний слева столбец исходной области.</param>
        <param name="sourceTop">Самая верхняя строка исходной области.</param>
        <param name="sourceWidth">Общее число столбцов в исходной области.</param>
        <param name="sourceHeight">Общее число строк в исходной области.</param>
        <param name="targetLeft">Крайний слева столбец области назначения.</param>
        <param name="targetTop">Самая верхняя строка области назначения.</param>
        <summary>Копирует заданную исходную область буфера экрана в заданную область назначения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если параметры назначения и источника определяют положение, расположенное за границами текущего буфера экрана, копируется только часть исходной области, помещается в область назначения. То есть исходная область обрезается в соответствии с текущим буфером экрана.  
  
 <xref:System.Console.MoveBufferArea%2A> Метод копирует область источника в область назначения. Если область назначения не пересекается с исходной областью, исходная область заполняется пробелами с использованием текущих цветов переднего плана и фона. В противном случае пересекающаяся часть исходной области не заполняется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько параметров имеют значение меньше нуля.  
  
- или - 
 Значение параметра <paramref name="sourceLeft" /> или <paramref name="targetLeft" /> больше или равно значению <see cref="P:System.Console.BufferWidth" />.  
  
-или- 
 Значение параметра <paramref name="sourceTop" /> или <paramref name="targetTop" /> больше или равно значению <see cref="P:System.Console.BufferHeight" />.  
  
- или - 
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> больше или равно <see cref="P:System.Console.BufferHeight" />.  
  
- или - 
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> больше или равно <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop, char sourceChar, valuetype System.ConsoleColor sourceForeColor, valuetype System.ConsoleColor sourceBackColor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Char,System.ConsoleColor,System.ConsoleColor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer, sourceChar As Char, sourceForeColor As ConsoleColor, sourceBackColor As ConsoleColor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int * char * ConsoleColor * ConsoleColor -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, sourceChar, sourceForeColor, sourceBackColor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceTop" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceWidth" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceHeight" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetLeft" Type="System.Int32" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetTop" Type="System.Int32" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceChar" Type="System.Char" Index="6" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceForeColor" Type="System.ConsoleColor" Index="7" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceBackColor" Type="System.ConsoleColor" Index="8" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Крайний слева столбец исходной области.</param>
        <param name="sourceTop">Самая верхняя строка исходной области.</param>
        <param name="sourceWidth">Общее число столбцов в исходной области.</param>
        <param name="sourceHeight">Общее число строк в исходной области.</param>
        <param name="targetLeft">Крайний слева столбец области назначения.</param>
        <param name="targetTop">Самая верхняя строка области назначения.</param>
        <param name="sourceChar">Символ, используемый для заполнения исходной области.</param>
        <param name="sourceForeColor">Цвет текста, используемый для заполнения исходной области.</param>
        <param name="sourceBackColor">Цвет фона, используемый для заполнения исходной области.</param>
        <summary>Копирует заданную исходную область буфера экрана в заданную область назначения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если параметры назначения и источника задают положение, расположенное за границами текущего буфера экрана, копируется только часть исходной области, помещается в область назначения. То есть исходная область обрезается в соответствии с текущим буфером экрана.  
  
 <xref:System.Console.MoveBufferArea%2A> Метод копирует область источника в область назначения. Если область назначения не пересекается с исходной областью, область источника заполняется символом, указанным в `sourceChar`параметре, используя цвета, `sourceForeColor` заданные и `sourceBackColor`. В противном случае пересекающаяся часть исходной области не заполняется.  
  
 Метод не выполняет никаких операций, `sourceWidth` если `sourceHeight` или равен нулю. <xref:System.Console.MoveBufferArea%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько параметров имеют значение меньше нуля.  
  
- или - 
 Значение параметра <paramref name="sourceLeft" /> или <paramref name="targetLeft" /> больше или равно значению <see cref="P:System.Console.BufferWidth" />.  
  
-или- 
 Значение параметра <paramref name="sourceTop" /> или <paramref name="targetTop" /> больше или равно значению <see cref="P:System.Console.BufferHeight" />.  
  
- или - 
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> больше или равно <see cref="P:System.Console.BufferHeight" />.  
  
-или- 
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> больше или равно <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.ArgumentException">Один или более параметров цвета не являются членами перечисления <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NumberLock">
      <MemberSignature Language="C#" Value="public static bool NumberLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool NumberLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.NumberLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NumberLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool NumberLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.NumberLock : bool" Usage="System.Console.NumberLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, включен или отключен режим NUM LOCK клавиатуры.</summary>
        <value>Значение <see langword="true" />, если клавиша NUM LOCK включена; значение <see langword="false" />, если клавиша NUM LOCK выключена.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Операция получения вызывается в операционной системе, отличной от Windows.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardError">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает стандартный поток сообщений об ошибках.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError();" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает стандартный поток сообщений об ошибках.</summary>
        <returns>Стандартный поток сообщений об ошибках.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного получения стандартного потока ошибок после его изменения <xref:System.Console.SetError%2A> методом.  
  
   
  
## Examples  
 Следующий пример представляет собой простое средство просмотра текстовых файлов, которое отображает содержимое одного или нескольких текстовых файлов на консоли. Если аргументы командной строки отсутствуют или какие-либо файлы, переданные как аргументы командной строки, не существуют, в примере вызывается <xref:System.Console.SetError%2A> метод для перенаправления сведений об ошибках в файл, <xref:System.Console.OpenStandardError%2A> вызывает метод в процессе повторного получения стандартной ошибки. Stream и указывает, что сведения об ошибке записаны в файл.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Обратите внимание <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> , что `true` перед повторным получением потока ошибок свойство имеет значение. Это гарантирует, что выходные данные будут отправляться в консоль немедленно, а не помещены в буфер.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Размер буфера внутреннего потока.</param>
        <summary>Получает стандартный поток сообщений об ошибках, для которого установлен заданный размер буфера.</summary>
        <returns>Стандартный поток сообщений об ошибках.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного получения стандартного потока ошибок после его изменения <xref:System.Console.SetError%2A> методом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="bufferSize" /> не больше нуля.</exception>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardInput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает стандартный входной поток.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает стандартный входной поток.</summary>
        <returns>Стандартный входной поток.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного получения стандартного входного потока после его изменения <xref:System.Console.SetIn%2A> методом.  
  
   
  
## Examples  
 В следующем примере показано использование `OpenStandardInput` свойства.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Размер буфера внутреннего потока.</param>
        <summary>Получает стандартный входной поток, для которого установлен заданный размер буфера.</summary>
        <returns>Стандартный входной поток.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного получения стандартного потока вывода после его изменения <xref:System.Console.SetIn%2A> методом.  
  
   
  
## Examples  
 В следующем примере показано использование `OpenStandardInput` свойства.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="bufferSize" /> не больше нуля.</exception>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardOutput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает стандартный выходной поток.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает стандартный выходной поток.</summary>
        <returns>Стандартный выходной поток.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного получения стандартного потока вывода после его изменения <xref:System.Console.SetOut%2A> методом.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Console.OpenStandardOutput%2A>. Он заменяет 4 последовательных пробела в строке символом табуляции. Чтобы запустить его, необходимо указать два аргумента командной строки. Первый аргумент — это имя существующего текстового файла, в который требуется перенаправить стандартный входной поток. Второй аргумент — это имя файла, в который требуется перенаправить стандартный выходной поток. Не требуется, чтобы этот файл существовал. Если да, его содержимое будут перезаписано.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Размер буфера внутреннего потока.</param>
        <summary>Получает стандартный выходной поток, для которого установлен заданный размер буфера.</summary>
        <returns>Стандартный выходной поток.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного получения стандартного потока вывода после его изменения <xref:System.Console.SetOut%2A> методом.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Console.OpenStandardOutput%2A>. Он заменяет 4 последовательных пробела в строке символом табуляции. Чтобы запустить его, необходимо указать два аргумента командной строки. Первый аргумент — это имя существующего текстового файла, в который требуется перенаправить стандартный входной поток. Второй аргумент — это имя файла, в который требуется перенаправить стандартный выходной поток. Не требуется, чтобы этот файл существовал. Если да, его содержимое будут перезаписано.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="bufferSize" /> не больше нуля.</exception>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Out">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Out { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Out" />
      <MemberSignature Language="DocId" Value="P:System.Console.Out" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Out As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Out { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Out : System.IO.TextWriter" Usage="System.Console.Out" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает стандартный выходной поток.</summary>
        <value>Объект <see cref="T:System.IO.TextWriter" />, представляющий стандартный выходной поток.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию для этого свойства задан стандартный выходной поток. Этому свойству можно задать другой поток с помощью <xref:System.Console.SetOut%2A> метода.  
  
 Обратите внимание, `Console.Out.WriteLine` что вызовы методов эквивалентны вызовам соответствующих <xref:System.Console.WriteLine%2A> методов.  
  
   
  
## Examples  
 В следующем примере <xref:System.Console.Out%2A> свойство используется для вывода массива, содержащего имена файлов в текущем каталоге приложения, на стандартное выходное устройство. Затем он устанавливает стандартный вывод в файл с именем Files. txt и перечисляет элементы массива в файл. Наконец, он устанавливает выходные данные в стандартный выходной поток и снова отображает элементы массива для стандартного выходного устройства.  
  
 [!code-csharp[System.Console.Out#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.out/cs/out1.cs#1)]
 [!code-vb[System.Console.Out#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.out/vb/out1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OutputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding OutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding OutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.OutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ OutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OutputEncoding : System.Text.Encoding with get, set" Usage="System.Console.OutputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает кодировку консоли, используемую при записи выходных данных.</summary>
        <value>Кодировка консоли, используемая при записи вывода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль использует кодировку вывода для преобразования символов, записанных приложением, в соответствующие отображаемые символы консоли. Кодовая страница по умолчанию, используемая консолью, определяется локальом системы.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], операция получения свойства может возвращать кэшированное значение вместо текущей выходной кодировки консоли. Это может произойти, если значение <xref:System.Console.OutputEncoding%2A> свойства изменено другими способами, отличными от присваивания <xref:System.Console.OutputEncoding%2A> свойству, например вызову функции Windows `SetConsoleOutputCP` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение свойства в операции задания — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Во время выполнения этой операции произошла ошибка.</exception>
        <exception cref="T:System.Security.SecurityException">У приложения нет разрешения на выполнение этой операции.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для чтения и записи в окна и подокна верхнего уровня.  Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Для кодировок <see cref="T:System.Console" /> Юникода класс поддерживает кодировку UTF-8 <see cref="T:System.Text.UTF8Encoding" /> с классом [!INCLUDE[net_v45](~/includes/net-v45-md.md)]и, начиная с, <see cref="T:System.Text.UnicodeEncoding" /> он поддерживает кодировку UTF-16 с классом. Кодировка UTF-32 с <see cref="T:System.Text.UTF32Encoding" /> классом не поддерживается. При попытке задать кодировку вывода в кодировке UTF-32 <see cref="T:System.IO.IOException" />возникает исключение.  
  
Обратите внимание, что для успешного отображения символов Юникода на консоли необходимо следующее: 
— Для вывода символов в консоли должен использоваться шрифт TrueType, например ЛуЦида Console или consolas.  
  
— Шрифт, используемый консолью, должен определять конкретный глиф или глифы для отображения. Консоль может использовать преимущества связи шрифтов для вывода глифов из связанных шрифтов, если базовый шрифт не содержит определения для этого глифа.  
  
Дополнительные сведения о поддержке кодирования в Юникоде с помощью консоли см. в разделе "Поддержка Юникода для консоли" в <see cref="T:System.Console" /> классе.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Read" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Read();" />
      <MemberSignature Language="F#" Value="static member Read : unit -&gt; int" Usage="System.Console.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Читает следующий символ из стандартного входного потока.</summary>
        <returns>Следующий символ из входного потока или значение минус единица (-1), если доступных для чтения символов не осталось.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод блокирует свой возврат при вводе входных символов. при <xref:System.ConsoleKey.Enter> нажатии клавиши он завершается. <xref:System.Console.Read%2A> Нажатие клавиши Ввод добавляет зависимую от платформы последовательность завершения строк к входным данным (например, в Windows добавляется последовательность возврата каретки и перевода строки). Последующие вызовы <xref:System.Console.Read%2A> метода получают входные данные по одному символу за раз. После получения <xref:System.Console.Read%2A> последнего символа блокирует его возврат, и цикл повторяется.  
  
> [!IMPORTANT]
>  Метод или свойство и <xref:System.Console.ReadKey%2A> метод предпочтительнее использовать <xref:System.Console.Read%2A> метод. <xref:System.Console.KeyAvailable%2A> <xref:System.Console.ReadLine%2A>  
  
 Обратите внимание, что метод не возвращает значение-1, если не выполнить одно из следующих действий.  
  
-   Одновременно нажмите <xref:System.ConsoleModifiers.Control> клавишу-модификатор и <xref:System.ConsoleKey.Z> клавишу консоли (Ctrl + Z), которая сигнализирует о условии завершения файла.  
  
-   Нажмите эквивалентный ключ, который сигнализирует о условии окончания файла, например Клавиша F6 в Windows.  
  
-   Перенаправьте входной поток в источник, например текстовый файл, который содержит фактический символ конца файла.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.Read%2A> метод.  
  
 [!code-cpp[console.read#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.read/CPP/read.cpp#1)]
 [!code-csharp[console.read#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.read/CS/read.cs#1)]
 [!code-vb[console.read#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.read/VB/read.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadKey">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает следующий нажатый пользователем символ или функциональную клавишу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey () As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey();" />
      <MemberSignature Language="F#" Value="static member ReadKey : unit -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает следующий нажатый пользователем символ или функциональную клавишу. Нажатая клавиша отображается в окне консоли.</summary>
        <returns>Объект, описывающий константу <see cref="T:System.ConsoleKey" /> и символ Юникода (при наличии), соответствующий нажатой клавише консоли. Этот объект <see cref="T:System.ConsoleKeyInfo" /> также описывает в битовой комбинации значений <see cref="T:System.ConsoleModifiers" />, нажимались ли клавиши-модификаторы (одна или несколько) Shift, Alt или Ctrl одновременно с клавишей консоли.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод ожидает, то есть блокирует поток, <xref:System.Console.ReadKey%2A> выдающий метод, пока не будет нажата клавиша со знаком или функцией. <xref:System.Console.ReadKey%2A> Символ или клавиша может быть нажата в сочетании с одним или несколькими клавишами-модификаторами Alt, CTRL или Shift. Однако нажатие клавиши-модификатора сама по себе не <xref:System.Console.ReadKey%2A> приведет к возврату метода.  
  
 В зависимости от приложения может потребоваться использовать <xref:System.Console.ReadKey%2A> метод в сочетании <xref:System.Console.KeyAvailable%2A> со свойством.  
  
 Метод считывает данные с клавиатуры, даже если стандартные входные данные перенаправляются в файл <xref:System.Console.SetIn%2A> с методом. <xref:System.Console.ReadKey%2A>  
  
   
  
## Examples  
 Одним из наиболее распространенных <xref:System.Console.ReadKey> способов использования метода является остановка выполнения программы до тех пор, пока пользователь не нажмет клавишу и приложение не завершит работу или не отобразит дополнительное окно информации. В следующем примере <xref:System.Console.ReadKey> метод используется для ожидания нажатия пользователем клавиши ВВОД перед завершением работы приложения.  
  
 [!code-csharp[System.Console.ReadKey#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey1.cs#1)]
 [!code-vb[System.Console.ReadKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey1.vb#1)]  
  
 Обратите внимание, что эта <xref:System.Console.ReadKey%2A> перегрузка метода по умолчанию отображает все отображаемые клавиши, которые пользователь нажимает на консоль. Чтобы подавить их, вызовите <xref:System.Console.ReadKey%2A> метод `intercept` с аргументом `true`.  
  
 В следующем примере <xref:System.Console.ReadKey> метод используется для вывода сведений о том, какой ключ пользователь нажал. 
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Console.In" /> перенаправлено из потока, отличного от консоли.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey (bool intercept);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey(bool intercept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey (intercept As Boolean) As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey(bool intercept);" />
      <MemberSignature Language="F#" Value="static member ReadKey : bool -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey intercept" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intercept" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="intercept">Определяет, следует ли отображать нажатую клавишу в окне консоли. Значение <see langword="true" />, чтобы не отображать нажатую клавишу; в противном случае — значение <see langword="false" />.</param>
        <summary>Получает следующий нажатый пользователем символ или функциональную клавишу. Нажатая клавиша может быть отображена в окне консоли.</summary>
        <returns>Объект, описывающий константу <see cref="T:System.ConsoleKey" /> и символ Юникода (при наличии), соответствующий нажатой клавише консоли. Этот объект <see cref="T:System.ConsoleKeyInfo" /> также описывает в битовой комбинации значений <see cref="T:System.ConsoleModifiers" />, нажимались ли клавиши-модификаторы (одна или несколько) Shift, Alt или Ctrl одновременно с клавишей консоли.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод ожидает, то есть блокирует поток, <xref:System.Console.ReadKey%2A> выдающий метод, пока не будет нажата клавиша со знаком или функцией. <xref:System.Console.ReadKey%2A> Символ или клавиша может быть нажата в сочетании с одним или несколькими клавишами-модификаторами Alt, CTRL или Shift. Однако нажатие клавиши-модификатора сама по себе не <xref:System.Console.ReadKey%2A> приведет к возврату метода.  
  
 Если параметр имеет значение `true`, нажатая клавиша перехватывается и не отображается в окне консоли; в противном случае нажатая клавиша отображается. `intercept`  
  
 В зависимости от приложения может потребоваться использовать <xref:System.Console.ReadKey%2A> метод в сочетании <xref:System.Console.KeyAvailable%2A> со свойством.  
  
 Метод считывает данные с клавиатуры, даже если стандартные входные данные перенаправляются в файл <xref:System.Console.SetIn%2A> с методом. <xref:System.Console.ReadKey%2A>  
  
   
  
## Examples  
 Одним из наиболее распространенных <xref:System.Console.ReadKey%2A> способов использования метода является остановка выполнения программы до тех пор, пока пользователь не нажмет клавишу и приложение не завершит работу или не отобразит дополнительное окно информации. В следующем примере <xref:System.Console.ReadKey%28System.Boolean%29> метод используется для ожидания нажатия пользователем клавиши ВВОД перед завершением работы приложения. Обратите внимание, что если пользователь нажмет какой-либо другой ключ, он не будет отображаться на консоли.  
  
 [!code-csharp[System.Console.ReadKey#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey2.cs#2)]
 [!code-vb[System.Console.ReadKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey2.vb#2)]  
  
 В следующем примере <xref:System.Console.ReadKey%28System.Boolean%29> метод используется для отображения сведений о нажатой пользователем клавише без вывода этого ключа на консоль.  
  
 [!code-cpp[console.readkey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey2/CPP/rkbool.cpp#1)]
 [!code-csharp[console.readkey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey2/CS/rkbool.cs#1)]
 [!code-vb[console.readkey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey2/VB/rkbool.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Console.In" /> перенаправлено из потока, отличного от консоли.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public static string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="static member ReadLine : unit -&gt; string" Usage="System.Console.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает следующую строку символов из стандартного входного потока.</summary>
        <returns>Следующая строка символов из входного потока или значение <see langword="null" />, если больше нет доступных строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadLine%2A> Метод считывает строку из стандартного входного потока. (Определение строки см. в абзаце после следующего списка.) Это означает, что:  
  
-   Если стандартным устройством ввода является клавиатура, <xref:System.Console.ReadLine%2A> метод блокируется, пока пользователь не нажмет клавишу **Ввод** .  
  
     Одним из наиболее распространенных <xref:System.Console.ReadLine%2A> способов использования метода является приостановка выполнения программы перед очисткой консоли и отображением новых сведений, а также запрос пользователя на нажатие клавиши ВВОД перед завершением работы приложения. Это показано в следующем примере.  
  
     [!code-cpp[System.Console.ReadLine#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/ReadLineSimple.cpp#6)]
     [!code-csharp[System.Console.ReadLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLineSimple.cs#6)]
     [!code-vb[System.Console.ReadLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLineSimple.vb#6)]  
  
-   Если стандартные входные данные перенаправляются в файл, <xref:System.Console.ReadLine%2A> метод считывает строку текста из файла. Например, ниже приведен текстовый файл с именем ReadLine1. txt:  
  
    ```  
  
    This is the first line.  
    This is the second line.  
    This is the third line.  
    This is the fourth line.  
  
    ```  
  
     В следующем примере <xref:System.Console.ReadLine%2A> метод используется для чтения входных данных, перенаправляемых из файла. Операция чтения завершается, когда метод возвращает `null`значение, которое указывает, что не осталось строк для чтения.  
  
     [!code-csharp[System.Console.ReadLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine3.cs#3)]
     [!code-vb[System.Console.ReadLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine3.vb#3)]  
  
     После компиляции примера в исполняемый файл с именем ReadLine1. exe его можно запустить из командной строки с помощью синтаксиса  
  
    ```  
    ReadLine1 < ReadLine1.txt  
    ```  
  
     для чтения содержимого файла и его вывода на консоль.  
  
 Строка определяется как последовательность символов, за которыми следует символ возврата каретки (шестнадцатеричный 0x000d), символ перевода строки (шестнадцатеричный 0x000a) или значение <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> свойства. Возвращаемая строка не содержит завершающий символ (ы). По умолчанию метод считывает входные данные из входного буфера 256 символов. Так как сюда входят <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> символы, метод может считывать строки, содержащие до 254 символов. Для чтения более длинных строк вызовите <xref:System.Console.OpenStandardInput%28System.Int32%29> метод.  
  
 <xref:System.Console.ReadLine%2A> Метод выполняется синхронно. То есть он блокируется до тех пор, пока не будет прочитана линия или не будет нажата комбинация клавиш CTRL + Z. Свойство возвращает объект, представляющий стандартный входной поток с синхронным <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType> методом и асинхронным <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> методом. <xref:System.IO.TextReader> <xref:System.Console.In%2A> Однако при использовании в качестве стандартного входного потока <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> консоли выполняет синхронно, а не асинхронно и возвращает объект `Task<String>` только после завершения операции чтения.  
  
 Если этот метод создает <xref:System.OutOfMemoryException> исключение, то его расположение в базовом <xref:System.IO.Stream> объекте увеличивается на число символов, которые метод мог прочесть, но символы, уже считанные в внутренний <xref:System.Console.ReadLine%2A> буфер, являются отклоненных. Так как не удается изменить расположение модуля чтения в потоке, уже считанные символы являются невосстанавливаемыми, и доступ к ним можно получить только путем повторной <xref:System.IO.TextReader>инициализации. Если начальная позицией в потоке неизвестна или поток не поддерживает поиск, то также необходимо <xref:System.IO.Stream> повторно инициализировать базовую точку. Чтобы избежать такой ситуации и создания надежного кода, следует использовать <xref:System.Console.KeyAvailable%2A> свойство и <xref:System.Console.ReadKey%2A> метод и сохранить считанные символы в предварительно выделенном буфере.  
  
 Если нажата клавиша CTRL + Z, когда метод считывает входные данные из консоли, метод возвращает `null`значение. Это позволяет пользователю предотвратить дальнейшие вводы с <xref:System.Console.ReadLine%2A> клавиатуры при вызове метода в цикле. Этот сценарий показан в следующем примере.  
  
 [!code-cpp[System.Console.ReadLine#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/readline2.cpp#1)]
 [!code-csharp[System.Console.ReadLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine2.cs#1)]
 [!code-vb[System.Console.ReadLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine2.vb#1)]  
  
   
  
## Examples  
 В следующем примере требуются два аргумента командной строки: имя существующего текстового файла и имя файла для записи выходных данных. Он открывает существующий текстовый файл и перенаправляет стандартные входные данные с клавиатуры на этот файл. Он также перенаправляет стандартный вывод из консоли в выходной файл. Затем он использует <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> метод для считывания каждой строки в файле, заменяет каждую последовательность из четырех пробелов символом табуляции и <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> использует метод для записи результата в выходной файл.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для выделения буфера под возвращаемую строку.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Количество символов в следующей строке больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="ResetColor">
      <MemberSignature Language="C#" Value="public static void ResetColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ResetColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetColor();" />
      <MemberSignature Language="F#" Value="static member ResetColor : unit -&gt; unit" Usage="System.Console.ResetColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Устанавливает для цветов фона и текста консоли их значения по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Цвет переднего плана и фона восстанавливается до тех цветов, которые существовали в момент начала текущего процесса. Дополнительные сведения см. в <xref:System.Console.ForegroundColor%2A> разделе Свойства и. <xref:System.Console.BackgroundColor%2A>  
  
   
  
## Examples  
 В следующем примере значения <xref:System.ConsoleColor> перечисления сохраняются в массиве, а текущие значения <xref:System.Console.BackgroundColor%2A> свойств и <xref:System.Console.ForegroundColor%2A> сохраняются в переменных. Затем он изменяет цвет переднего плана на каждый цвет в <xref:System.ConsoleColor> перечислении, за исключением цвета, соответствующего текущему фону, и изменяет цвет фона на каждый цвет <xref:System.ConsoleColor> в перечислении, за исключением цвета, соответствующего текущий передний план. (Если цвет переднего плана совпадает с цветом фона, текст не отображается.) Наконец, он вызывает <xref:System.Console.ResetColor%2A> метод для восстановления исходных цветов консоли.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetBufferSize">
      <MemberSignature Language="C#" Value="public static void SetBufferSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBufferSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetBufferSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBufferSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBufferSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetBufferSize : int * int -&gt; unit" Usage="System.Console.SetBufferSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="height" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="width">Ширина области буфера в столбцах.</param>
        <param name="height">Высота буферной области измеряется строками.</param>
        <summary>Устанавливает заданные значения высоты и ширины буферной области экрана.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере демонстрируются <xref:System.Console.WindowLeft%2A>свойства <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, и <xref:System.Console.CursorVisible%2A> , и <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>и. <xref:System.Console.ReadKey%2A> метод. В примере демонстрируется рисование шаблона сетки в буфере экрана на основе ширины буфера экрана. Затем в примере перемещается окно консоли в ответ на то, что нажата клавиша Стрелка вверх, стрелка вниз, стрелка влево или стрелка вправо. Шаблон сетки помогает видеть перемещение окна консоли относительно буфера экрана.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="height" /> или <paramref name="width" /> меньше или равно нулю.  
  
- или - 
 Значение параметра <paramref name="height" /> или <paramref name="width" /> больше или равно значению <see cref="F:System.Int16.MaxValue" />.  
  
- или - 
 <paramref name="width" /> меньше <see cref="P:System.Console.WindowLeft" /> + <see cref="P:System.Console.WindowWidth" />.  
  
- или - 
 <paramref name="height" /> меньше <see cref="P:System.Console.WindowTop" /> + <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCursorPosition">
      <MemberSignature Language="C#" Value="public static void SetCursorPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCursorPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetCursorPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCursorPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCursorPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetCursorPosition : int * int -&gt; unit" Usage="System.Console.SetCursorPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="top" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Позиция столбца курсора. Столбцы нумеруются как слева направо, начинается с 0.</param>
        <param name="top">Позиция строки курсора. Строки пронумерованы сверху вниз, начиная с 0.</param>
        <summary>Устанавливает положение курсора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.SetCursorPosition%2A> Используйте метод, чтобы указать, где должна начинаться следующая операция записи в окне консоли. Если указанная положение курсора находится за пределами области, видимой в окне консоли, то источник окна автоматически изменяется, чтобы сделать курсор видимым.  
  
 Курсор автоматически перемещается к следующему положению символа каждый раз, когда символ записывается в окно консоли. Если курсор находится в нижнем правом положении окна консоли, следующая операция записи приводит к прокрутке окна консоли таким образом, чтобы курсор оставался видимым. Если вы хотите записать символ в нижнюю правую точку, не вызывая прокрутки окна консоли, используйте <xref:System.Console.MoveBufferArea%2A> метод для перемещения символа в эту точку.  
  
   
  
## Examples  
 В <xref:System.Console.CursorLeft%2A> этом примере демонстрируются <xref:System.Console.CursorTop%2A> свойства и, а <xref:System.Console.SetCursorPosition%2A> также <xref:System.Console.Clear%2A> методы и. В примере размещается курсор, который определяет, где будет выполняться следующая запись, чтобы нарисовать 5-символьный прямоугольник на 5 символов, используя сочетание строк "+&#124;", "" и "-". Обратите внимание, что прямоугольник может быть нарисован с меньшим количеством шагов, используя сочетание других строк.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="left" /> или <paramref name="top" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="left" /> больше или равно значению свойства <see cref="P:System.Console.BufferWidth" />.  
  
- или - 
 Значение <paramref name="top" /> больше или равно <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetError">
      <MemberSignature Language="C#" Value="public static void SetError (System.IO.TextWriter newError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetError(class System.IO.TextWriter newError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetError(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetError (newError As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetError(System::IO::TextWriter ^ newError);" />
      <MemberSignature Language="F#" Value="static member SetError : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetError newError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newError" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newError">Поток, являющийся новым стандартным потоком сообщений об ошибках.</param>
        <summary>Присваивает свойству <see cref="P:System.Console.Error" /> указанный объект <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Console.Error%2A> для свойства задан стандартный поток вывода ошибок.  
  
 Объект <xref:System.IO.StreamWriter> , инкапсулирующий <xref:System.IO.FileStream> , может использоваться для отправки сообщений об ошибках в файл.  
  
   
  
## Examples  
 В следующем примере показано, как перенаправить стандартный поток ошибок в файл.  
  
 [!code-cpp[System.Console.SetError#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.SetError/cpp/seterror1.cpp#1)]
 [!code-csharp[System.Console.SetError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.SetError/cs/SetError1.cs#1)]
 [!code-vb[System.Console.SetError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.SetError/vb/SetError1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="newError" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="P:System.Console.Error" />
      </Docs>
    </Member>
    <Member MemberName="SetIn">
      <MemberSignature Language="C#" Value="public static void SetIn (System.IO.TextReader newIn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIn(class System.IO.TextReader newIn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetIn(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIn (newIn As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIn(System::IO::TextReader ^ newIn);" />
      <MemberSignature Language="F#" Value="static member SetIn : System.IO.TextReader -&gt; unit" Usage="System.Console.SetIn newIn" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newIn" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="newIn">Поток, являющийся новым стандартным входным потоком.</param>
        <summary>Присваивает свойству <see cref="P:System.Console.In" /> указанный объект <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Console.In%2A> для свойства задан стандартный входной поток.  
  
 Объект <xref:System.IO.StreamReader> , инкапсулирующий <xref:System.IO.FileStream> , может использоваться для получения входных данных из файла.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Console.SetIn%2A>. Он заменяет 4 последовательных пробела в строке символом табуляции. Чтобы запустить его, необходимо указать два аргумента командной строки. Первый аргумент — это имя существующего текстового файла, в который требуется перенаправить стандартный входной поток. Второй аргумент — это имя файла, в который требуется перенаправить стандартный выходной поток. Не требуется, чтобы этот файл существовал. Если да, его содержимое будут перезаписано.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newIn" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextReader" />
        <altmember cref="P:System.Console.In" />
      </Docs>
    </Member>
    <Member MemberName="SetOut">
      <MemberSignature Language="C#" Value="public static void SetOut (System.IO.TextWriter newOut);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetOut(class System.IO.TextWriter newOut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetOut(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetOut (newOut As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetOut(System::IO::TextWriter ^ newOut);" />
      <MemberSignature Language="F#" Value="static member SetOut : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetOut newOut" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newOut" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newOut">Модуль записи текста, который должен использовать в качестве нового стандартного потока вывода.</param>
        <summary>Присваивает свойству <see cref="P:System.Console.Out" /> указанный объект <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Console.Out%2A> для свойства задан стандартный выходной поток.  
  
 Объект <xref:System.IO.StreamWriter> , инкапсулирующий <xref:System.IO.FileStream> , может использоваться для отправки выходных данных в файл. Например:  
  
 [!code-cpp[System.Console.SetOut#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.setout/cpp/source.cpp#1)]
 [!code-csharp[System.Console.SetOut#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.setout/cs/source.cs#1)]
 [!code-vb[System.Console.SetOut#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.setout/vb/source.vb#1)]  
  
 Фактический объект, возвращаемый методом, <xref:System.Console.Out%2A> может быть синхронизированной оболочкой для указанного модуля записи текста.
  
## Examples  
 В следующем примере показано использование метода <xref:System.Console.SetOut%2A>. Он заменяет 4 последовательных пробела в строке символом табуляции. Чтобы запустить его, необходимо указать два аргумента командной строки. Первый аргумент — это имя существующего текстового файла, в который требуется перенаправить стандартный входной поток. Второй аргумент — это имя файла, в который требуется перенаправить стандартный выходной поток. Не требуется, чтобы этот файл существовал. Если да, его содержимое будут перезаписано.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="newOut" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="SetWindowPosition">
      <MemberSignature Language="C#" Value="public static void SetWindowPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetWindowPosition : int * int -&gt; unit" Usage="System.Console.SetWindowPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="top" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Позиция столбца верхнего левого угла окна консоли.</param>
        <param name="top">Позиция строки левого верхнего угла окна консоли.</param>
        <summary>Задает позицию окна консоли относительно буфера экрана.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В окне операционной системы отображается окно консоли, а в окне консоли отображается часть буфера экрана. <xref:System.Console.SetWindowPosition%2A> Метод влияет на расположение окна консоли относительно буфера экрана, но не влияет на расположение окна операционной системы относительно рабочего стола.  
  
 Окна консоли и операционной системы обычно не влияют друг на друга. Однако если буфер экрана не может быть отображен в текущих границах окна консоли, операционная система автоматически добавляет полосы прокрутки в окно операционной системы. В этом случае перемещение полос прокрутки окна операционной системы влияет на расположение окна консоли и перемещение окна консоли с помощью <xref:System.Console.SetWindowPosition%2A> метода влияет на расположение полос прокрутки окна операционной системы.  
  
   
  
## Examples  
 В следующем примере демонстрируются <xref:System.Console.WindowLeft%2A>свойства <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, и <xref:System.Console.CursorVisible%2A> , и <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>и. <xref:System.Console.ReadKey%2A> метод. В примере демонстрируется рисование шаблона сетки в буфере экрана на основе ширины буфера экрана. Затем в примере перемещается окно консоли в ответ на то, что нажата клавиша Стрелка вверх, стрелка вниз, стрелка влево или стрелка вправо. Шаблон сетки помогает видеть перемещение окна консоли относительно буфера экрана.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="left" /> или <paramref name="top" /> меньше нуля.  
  
-или- 
 <paramref name="left" /> + <see cref="P:System.Console.WindowWidth" /> больше <see cref="P:System.Console.BufferWidth" />.  
  
- или - 
 <paramref name="top" /> + <see cref="P:System.Console.WindowHeight" /> больше <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetWindowSize">
      <MemberSignature Language="C#" Value="public static void SetWindowSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetWindowSize : int * int -&gt; unit" Usage="System.Console.SetWindowSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="height" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="width">Ширина окна консоли измеряется столбцами.</param>
        <param name="height">Высота окна консоли измеряется строками.</param>
        <summary>Устанавливает заданные значения высоты и ширины окна консоли.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.SetWindowSize%2A> метод, а также <xref:System.Console.WindowHeight%2A> <xref:System.Console.WindowWidth%2A> свойства и. Чтобы увидеть полный результат изменения размера окна консоли, необходимо выполнить пример.  
  
 Пример сообщает размерам окна консоли, для которых задано значение 85 столбцов и 43 строк, а затем ожидает нажатия клавиши. При нажатии любой клавиши размеры окна консоли увеличиваются вдвое, выводятся новые измерения, а в примере ожидается еще один нажатие клавиши. Наконец, при нажатии любой клавиши окно консоли восстанавливается до исходных измерений, а пример завершается.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="width" /> или <paramref name="height" /> меньше или равно нулю.  
  
- или - 
 Сумма <paramref name="width" /> и <see cref="P:System.Console.WindowLeft" /> либо сумма  <paramref name="height" /> и <see cref="P:System.Console.WindowTop" /> больше или равна <see cref="F:System.Int16.MaxValue" />.  
  
-или- 
 Значение параметра <paramref name="width" /> или <paramref name="height" /> больше ширины или высоты окна максимально возможной при текущем разрешении и шрифте консоли.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public static string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string Title" />
      <MemberSignature Language="DocId" Value="P:System.Console.Title" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Console.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает заголовок для отображения в строке заголовка консоли.</summary>
        <value>Строка для отображения в строке заголовка консоли. Максимальная длина строки заголовка — 24500 символов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В <xref:System.Console.Title%2A> этом примере демонстрируется свойство. В примере отображается текущее название окна операционной системы, Ожидание нажатия клавиши, а затем отображается новый заголовок.  
  
 [!code-cpp[console.title#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.title/CPP/mytitle.cpp#1)]
 [!code-csharp[console.title#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.title/CS/mytitle.cs#1)]
 [!code-vb[console.title#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.title/VB/mytitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В операции get длина полученного заголовка превышает 24 500 символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">В операции set указанный заголовок длиннее 24500 символов.</exception>
        <exception cref="T:System.ArgumentNullException">Для операции set задан заголовок <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция получения вызывается в операционной системе, отличной от Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TreatControlCAsInput">
      <MemberSignature Language="C#" Value="public static bool TreatControlCAsInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool TreatControlCAsInput" />
      <MemberSignature Language="DocId" Value="P:System.Console.TreatControlCAsInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property TreatControlCAsInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool TreatControlCAsInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TreatControlCAsInput : bool with get, set" Usage="System.Console.TreatControlCAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, интерпретируется ли комбинация клавиши-модификатора <see cref="F:System.ConsoleModifiers.Control" /> и клавиши консоли <see cref="F:System.ConsoleKey.C" /> (Ctrl+C) как обычный ввод или как прерывание, которое обрабатывается операционной системой.</summary>
        <value>Значение <see langword="true" />, если сочетание клавиш CTRL+C интерпретируется как обычный ввод; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение <xref:System.Console.TreatControlCAsInput%2A> свойства равно `false` и нажата клавиша CTRL + C, нажатые клавиши не сохраняются во входном буфере, а операционная система завершает выполняющийся процесс. Это значение по умолчанию.  
  
> [!CAUTION]
>  Это свойство следует `true` использовать разумно, поскольку его установка имеет такой существенный результат. Большинство пользователей предполагают, что CTRL + C прерывает работу консольного приложения. Если вы отключаете действие CTRL + C, пользователь должен не забыть использовать сочетание клавиш Ctrl + Break, чтобы завершить работу приложения, что является менее привычным сочетанием клавиш.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.TreatControlCAsInput%2A> свойство.  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Не удалось получить или задать режим ввода входного буфера консоли.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="F:System.ConsoleModifiers.Control" />
        <altmember cref="F:System.ConsoleKey.C" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public static int WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowHeight : int with get, set" Usage="System.Console.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту области окна консоли.</summary>
        <value>Высота окна консоли измеряется строками.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Попытка задать значение <xref:System.Console.WindowHeight%2A> свойства при перенаправлении <xref:System.ArgumentOutOfRangeException> вывода вызывает исключение или <xref:System.IO.IOException> . Чтобы предотвратить исключение, значение этого свойства можно задать только в <xref:System.Console.IsOutputRedirected%2A> том случае, если свойство возвращает. `false`  
  
   
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.SetWindowSize%2A> метод, а также <xref:System.Console.WindowHeight%2A> <xref:System.Console.WindowWidth%2A> свойства и. Чтобы увидеть полный результат изменения размера окна консоли, необходимо выполнить пример.  
  
 Пример сообщает размерам окна консоли, для которых задано значение 85 столбцов и 43 строк, а затем ожидает нажатия клавиши. При нажатии любой клавиши размеры окна консоли увеличиваются вдвое, выводятся новые измерения, а в примере ожидается еще один нажатие клавиши. Наконец, при нажатии любой клавиши окно консоли восстанавливается до исходных измерений, а пример завершается.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение свойства <see cref="P:System.Console.WindowWidth" /> или <see cref="P:System.Console.WindowHeight" /> не больше 0.  
  
- или - 
Сумма значений свойств <see cref="P:System.Console.WindowHeight" /> и <see cref="P:System.Console.WindowTop" /> больше или равна <see cref="F:System.Int16.MaxValue" />.  
  
- или - 
Значение свойства <see cref="P:System.Console.WindowWidth" /> или <see cref="P:System.Console.WindowHeight" /> больше максимально возможной ширины или высоты окна для текущего разрешения экрана и шрифта консоли.</exception>
        <exception cref="T:System.IO.IOException">Ошибка при чтении или записи данных.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowLeft">
      <MemberSignature Language="C#" Value="public static int WindowLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowLeft : int with get, set" Usage="System.Console.WindowLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию левого края области окна консоли относительно буфера экрана.</summary>
        <value>Позиция левого края области окна консоли измеряется столбцами.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль представляет прямоугольное окно в более крупную прямоугольную область буфера. Окно и буфер измеряются вертикально по числу строк и по горизонтали по числу столбцов. Размеры буферной области определяются <xref:System.Console.BufferHeight%2A> свойствами и. <xref:System.Console.BufferWidth%2A> Размеры области консоли определяются <xref:System.Console.WindowHeight%2A> свойствами и. <xref:System.Console.WindowWidth%2A> <xref:System.Console.WindowLeft%2A> Свойство определяет, какой столбец буферной области отображается в первом столбце окна консоли. Значение <xref:System.Console.WindowLeft%2A> свойства может находиться в диапазоне от 0 до  <xref:System.Console.BufferWidth%2A> .   -  <xref:System.Console.WindowWidth%2A> При попытке задать значение вне этого диапазона возникает исключение <xref:System.ArgumentOutOfRangeException>.  
  
 При первом открытии окна консоли значение <xref:System.Console.WindowLeft%2A> свойства по умолчанию равно нулю. Это означает, что первый столбец, отображаемый консолью, соответствует первому столбцу (столбец в позиции 0) в буферной области. Ширина по умолчанию для окна консоли и буферной области составляет 80 столбцов. Это означает, что <xref:System.Console.WindowLeft%2A> свойство может быть изменено только в том случае, если окно консоли становится более узким, или буферная область становится шире.  
  
 Обратите внимание, что если ширина буферной области превышает ширину окна консоли, значение <xref:System.Console.WindowLeft%2A> свойства автоматически корректируется, когда пользователь использует горизонтальную полосу прокрутки для определения связи окна с буферной областью.  
  
 Попытка задать значение <xref:System.Console.WindowLeft%2A> свойства при перенаправлении <xref:System.IO.IOException> вывода вызывает исключение. Чтобы предотвратить исключение, значение этого свойства можно задать только в <xref:System.Console.IsOutputRedirected%2A> том случае, если свойство возвращает. `false`  
  
   
  
## Examples  
 В следующем примере открывается окно консоли 80-столбца и определяется область буфера, которая имеет ширину 120 столбцов. Он отображает сведения о размере окон и буферов, а затем ждет нажатия пользователем клавиши со стрелкой влево или клавиши со стрелкой вправо. В первом случае значение <xref:System.Console.WindowLeft%2A> свойства уменьшается на единицу, если результат является допустимым значением. В последнем случае значение <xref:System.Console.WindowLeft%2A> свойства увеличивается на единицу, если результат будет юридическим. Обратите внимание, что в этом примере не требуется <xref:System.ArgumentOutOfRangeException>обрабатывать, так как он проверяет, что значение, присваиваемое <xref:System.Console.WindowLeft%2A> свойству, не является отрицательным и не <xref:System.Console.WindowLeft%2A> приводит к превышению <xref:System.Console.WindowWidth%2A> <xref:System.Console.BufferWidth%2A> значения свойства и. значение свойства.  
  
 [!code-cpp[System.Console.WindowLeft#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.windowleft/cpp/windowleft1.cpp#1)]
 [!code-csharp[System.Console.WindowLeft#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.windowleft/cs/windowleft1.cs#1)]
 [!code-vb[System.Console.WindowLeft#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.windowleft/vb/windowleft1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">В операции над множеством назначаемое значение меньше нуля.  
  
- или - 
Как результат назначения, свойство <see cref="P:System.Console.WindowLeft" /> плюс свойство <see cref="P:System.Console.WindowWidth" /> превысят свойство <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка при чтении или записи данных.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowTop">
      <MemberSignature Language="C#" Value="public static int WindowTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTop : int with get, set" Usage="System.Console.WindowTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию верхнего края области окна консоли относительно буфера экрана.</summary>
        <value>Позиция верхнего края области окна консоли измеряется строками.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль представляет прямоугольное окно в более крупную прямоугольную область буфера. Окно и буфер измеряются вертикально по числу строк и по горизонтали по числу столбцов. Размеры буферной области определяются <xref:System.Console.BufferHeight%2A> свойствами и. <xref:System.Console.BufferWidth%2A> Размеры области консоли определяются <xref:System.Console.WindowHeight%2A> свойствами и. <xref:System.Console.WindowWidth%2A> <xref:System.Console.WindowTop%2A> Свойство определяет, какая строка буферной области отображается в первом столбце окна консоли. Значение <xref:System.Console.WindowTop%2A> свойства может находиться в диапазоне от 0 до  <xref:System.Console.BufferHeight%2A> .   -  <xref:System.Console.WindowHeight%2A> При попытке задать значение вне этого диапазона возникает исключение <xref:System.ArgumentOutOfRangeException>.  
  
 Попытка задать значение <xref:System.Console.WindowTop%2A> свойства при перенаправлении <xref:System.IO.IOException> вывода вызывает исключение. Чтобы предотвратить исключение, значение этого свойства можно задать только в <xref:System.Console.IsOutputRedirected%2A> том случае, если свойство возвращает. `false`  
  
   
  
## Examples  
 В следующем примере демонстрируются <xref:System.Console.WindowLeft%2A>свойства <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, и <xref:System.Console.CursorVisible%2A> , и <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>и. <xref:System.Console.ReadKey%2A> метод. В примере демонстрируется рисование шаблона сетки в буфере экрана на основе ширины буфера экрана. Затем в примере перемещается окно консоли в ответ на то, что нажата клавиша Стрелка вверх, стрелка вниз, стрелка влево или стрелка вправо. Шаблон сетки помогает видеть перемещение окна консоли относительно буфера экрана.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">В операции над множеством назначаемое значение меньше нуля.  
  
- или - 
Как результат назначения, свойство <see cref="P:System.Console.WindowTop" /> плюс свойство <see cref="P:System.Console.WindowHeight" /> превысят свойство <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка при чтении или записи данных.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public static int WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowWidth : int with get, set" Usage="System.Console.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ширину окна консоли.</summary>
        <value>Ширина окна консоли измеряется столбцами.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Попытка задать значение <xref:System.Console.WindowWidth%2A> свойства при перенаправлении <xref:System.ArgumentOutOfRangeException> вывода вызывает исключение или <xref:System.IO.IOException> . Чтобы предотвратить исключение, значение этого свойства можно задать только в <xref:System.Console.IsOutputRedirected%2A> том случае, если свойство возвращает. `false`  
  
   
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.SetWindowSize%2A> метод, а также <xref:System.Console.WindowHeight%2A> <xref:System.Console.WindowWidth%2A> свойства и. Чтобы увидеть полный результат изменения размера окна консоли, необходимо выполнить пример.  
  
 Пример сообщает размерам окна консоли, для которых задано значение 85 столбцов и 43 строк, а затем ожидает нажатия клавиши. При нажатии любой клавиши размеры окна консоли увеличиваются вдвое, выводятся новые измерения, а в примере ожидается еще один нажатие клавиши. Наконец, при нажатии любой клавиши окно консоли восстанавливается до исходных измерений, а пример завершается.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение свойства <see cref="P:System.Console.WindowWidth" /> или <see cref="P:System.Console.WindowHeight" /> не больше 0.  
  
-или- 
Сумма значений свойств <see cref="P:System.Console.WindowHeight" /> и <see cref="P:System.Console.WindowTop" /> больше или равна <see cref="F:System.Int16.MaxValue" />.  
  
-или- 
Значение свойства <see cref="P:System.Console.WindowWidth" /> или <see cref="P:System.Console.WindowHeight" /> больше максимально возможной ширины или высоты окна для текущего разрешения экрана и шрифта консоли.</exception>
        <exception cref="T:System.IO.IOException">Ошибка при чтении или записи данных.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Операция задания вызывается в операционной системе, отличной от Windows.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает текстовое представление заданного значения или значений в стандартный выходной поток.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(bool value);" />
      <MemberSignature Language="F#" Value="static member Write : bool -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает текстовое представление заданного логического значения в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем вызова метода <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>, который выводит либо <xref:System.Boolean.TrueString?displayProperty=nameWithType> или <xref:System.Boolean.FalseString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(char value);" />
      <MemberSignature Language="F#" Value="static member Write : char -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает значение заданного знака Юникода в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member Write : char[] -&gt; unit" Usage="System.Console.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив знаков Юникода.</param>
        <summary>Записывает заданный массив знаков Юникода в стандартный выходной поток.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Write : decimal -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения <see cref="T:System.Decimal" /> в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем вызова метода <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(double value);" />
      <MemberSignature Language="F#" Value="static member Write : double -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения двойной точности с плавающей запятой в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.Double.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int value);" />
      <MemberSignature Language="F#" Value="static member Write : int -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 32-битового целого числа со знаком в стандартный поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.Int32.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(long value);" />
      <MemberSignature Language="F#" Value="static member Write : int64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 64-битового целого числа со знаком в стандартный поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.Int64.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : obj -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Записываемое значение или <see langword="null" />.</param>
        <summary>Записывает текстовое представление заданного объекта в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `value` имеет `null`значение, ничего не записывается и исключение не создается. В противном случае вызывается `value` метод метода для создания строкового представления, а результирующая строка записывается в стандартный выходной поток. `ToString`  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(float value);" />
      <MemberSignature Language="F#" Value="static member Write : single -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения одинарной точности с плавающей запятой в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.Single.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : string -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает заданное строковое значение в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение равно `null`, в стандартный выходной поток ничего не записывается.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint32 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 32-битового целого числа без знака в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 64-битового целого числа без знака в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj -&gt; unit" Usage="System.Console.Write (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Объект для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовое представление заданного объекта в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр содержит ноль или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования текстовым представлением значения соответствующего объекта.  
  
 Синтаксис элемента `{`формата — *index*[`,`*alignment*] [`:`*FormatString*]`}`, который указывает обязательный индекс, необязательная Длина и выравнивание форматированного текста, а также элемент Необязательная строка символов описателя формата, определяющая форматирование значения соответствующего объекта.  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования.  
  
-   Дополнительные сведения о функции составного форматирования, поддерживаемой такими методами <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>как, и <xref:System.Console.WriteLine%2A>некоторыми перегрузками, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата даты и времени см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата перечисления см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере с помощью метода `WriteLine` демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)] 
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере показано использование метода <xref:System.Console.Write%2A>.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj[] -&gt; unit" Usage="System.Console.Write (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-1.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg">Массив объектов для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовое представление заданного массива объектов в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр содержит ноль или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования текстовым представлением значения соответствующего объекта.  
  
 Синтаксис элемента `{`формата — *index*[`,`*alignment*] [`:`*FormatString*]`}`, который указывает обязательный индекс, необязательная Длина и выравнивание форматированного текста, а также элемент Необязательная строка символов описателя формата, определяющая форматирование значения соответствующего объекта.  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования.  
  
-   Дополнительные сведения о функции составного форматирования, поддерживаемой такими методами <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>как, и <xref:System.Console.WriteLine%2A>некоторыми перегрузками, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата даты и времени см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата перечисления см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 `arg` Параметр является массивом параметров. Аргументы могут передаваться в метод либо как массив, либо как список из пяти или более элементов. В примерах показаны обе формы вызова метода.  
  
   
  
## Examples  
 В следующем примере определяется `Person` класс с несколькими свойствами, которые предоставляют сведения о лице. Его `GetDescription` метод возвращает массив, содержащий все значения свойств, кроме одного. Затем в примере используется массив, возвращаемый `GetDescription` методом для вывода значений объекта Person.  
  
 [!code-csharp[System.Console.Write#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams1.cs#1)]
 [!code-vb[System.Console.Write#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams1.vb#1)]  
  
 Обратите внимание, что в <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29> примере вызывается метод <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29> , а не метод, поскольку он пытается `Person.Remarks` отобразить значение свойства в той же строке. Для этого он проверяет значения <xref:System.Console.CursorLeft%2A> свойств и <xref:System.Console.WindowWidth%2A> , чтобы определить, достаточно ли места для примечания.  В этом случае отображается строка. В противном случае он записывает строку, делает отступ для трех пробелов и отображает замечание.  
  
 Следующий пример идентичен первому, за исключением того, что он предоставляет список из пяти элементов в качестве `arg` аргумента вместо массива параметров.  
  
 [!code-csharp[System.Console.Write#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams2.cs#2)]
 [!code-vb[System.Console.Write#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="format" /> или <paramref name="arg" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Этот метод не вызывается C++ кодом. Компилятор разрешает вызовы [System. Console. Write](xref:System.Console.Write*) , которые включают строку, и список из четырех или более параметров объекта в качестве вызова  <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" /> .  C++ Он разрешает вызовы к [System. Console. Write](xref:System.Console.Write*) , которые включают строку и массив объектов в качестве вызова <see cref="M:System.Console.Write(System.String,System.Object)" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Write : char[] * int * int -&gt; unit" Usage="System.Console.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив знаков Юникода.</param>
        <param name="index">Начальная позиция в массиве <paramref name="buffer" />.</param>
        <param name="count">Количество символов для записи.</param>
        <summary>Записывает заданный дочерний массив знаков Юникода в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод записывает `count` символы, начиная с `buffer` позиции `index` , к стандартному выходному потоку.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Сумма значений параметров <paramref name="index" /> и <paramref name="count" /> указывает на позицию вне массива <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием параметра <paramref name="format" />.</param>
        <param name="arg1">Второй объект для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовые представления заданных объектов в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр содержит ноль или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования текстовым представлением значения соответствующего объекта.  
  
 Синтаксис элемента `{`формата — *index*[`,`*alignment*] [`:`*FormatString*]`}`, который указывает обязательный индекс, необязательная Длина и выравнивание форматированного текста, а также элемент Необязательная строка символов описателя формата, определяющая форматирование значения соответствующего объекта.  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования.  
  
-   Дополнительные сведения о функции составного форматирования, поддерживаемой такими методами <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>как, и <xref:System.Console.WriteLine%2A>некоторыми перегрузками, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата даты и времени см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата перечисления см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере с помощью метода `WriteLine` демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием параметра <paramref name="format" />.</param>
        <param name="arg1">Второй объект для записи с использованием <paramref name="format" />.</param>
        <param name="arg2">Третий объект для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовые представления заданных объектов в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр содержит ноль или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования текстовым представлением значения соответствующего объекта.  
  
 Синтаксис элемента `{`формата — *index*[`,`*alignment*] [`:`*FormatString*]`}`, который указывает обязательный индекс, необязательная Длина и выравнивание форматированного текста, а также элемент Необязательная строка символов описателя формата, определяющая форматирование значения соответствующего объекта.  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования.  
  
-   Дополнительные сведения о функции составного форматирования, поддерживаемой такими методами <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>как, и <xref:System.Console.WriteLine%2A>некоторыми перегрузками, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата даты и времени см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата перечисления см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере с помощью метода `WriteLine` демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием параметра <paramref name="format" />.</param>
        <param name="arg1">Второй объект для записи с использованием <paramref name="format" />.</param>
        <param name="arg2">Третий объект для записи с использованием <paramref name="format" />.</param>
        <param name="arg3">Четвертый объект для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовое представление заданных объектов и список параметров переменной длины в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот интерфейс API CLS-несовместим. CLS-совместимая альтернатива — <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Компиляторы C# и Visual Basic автоматически разрешают вызов этого метода как вызов <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр содержит ноль или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования текстовым представлением значения соответствующего объекта.  
  
 Синтаксис элемента `{`формата — *index*[`,`*alignment*] [`:`*FormatString*]`}`, который указывает обязательный индекс, необязательная Длина и выравнивание форматированного текста, а также элемент Необязательная строка символов описателя формата, определяющая форматирование значения соответствующего объекта.  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования.  
  
-   Дополнительные сведения о функции составного форматирования, поддерживаемой такими методами <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>как, и <xref:System.Console.WriteLine%2A>некоторыми перегрузками, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата даты и времени см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата перечисления см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере показано использование параметров переменной с <xref:System.Console.Write%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> методом. Метод вызывается со строкой составного формата и пятью элементами формата.  
  
 [!code-cpp[System.Console.Write#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.write/cpp/con_write.cpp#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Этот метод помечен <see langword="vararg" /> ключевым словом, что означает, что он поддерживает переменное число параметров. Метод можно вызывать из Visual C++, но он не может быть вызван из C# кода или Visual Basic. Компиляторы C# и Visual Basic разрешают вызовы в <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" /> как вызовы. <see cref="M:System.Console.Write(System.String,System.Object[])" /></para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает указанные данные с текущим признаком конца строки в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Признак конца строки по умолчанию — это строка, значением которой является символ возврата каретки, за которым следует символ перевода C#строки ( `vbCrLf` "\r\n" в или Visual Basic). Можно изменить признак конца строки, присвоив <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> свойству <xref:System.Console.Out%2A> свойства значение другой строки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine();" />
      <MemberSignature Language="F#" Value="static member WriteLine : unit -&gt; unit" Usage="System.Console.WriteLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Записывает текущий признак конца строки в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Признак конца строки по умолчанию — это строка, значением которой является символ возврата каретки, за которым следует символ перевода C#строки ( `vbCrLf` "\r\n" в или Visual Basic). Можно изменить признак конца строки, присвоив <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> свойству <xref:System.Console.Out%2A> свойства значение другой строки. Иллюстрация приведена в примере.  
  
   
  
## Examples  
 В этом примере символ конца строки изменяется с значения по умолчанию "\r\n" `vbCrLf` или на "\р\н\р\н" `vbCrLf`или   +  .  `vbCrLf` Затем он вызывает <xref:System.Console.WriteLine> методы и <xref:System.Console.WriteLine%28System.String%29> для вывода выходных данных на консоль.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="P:System.IO.TextWriter.NewLine" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(bool value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : bool -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного логического значения с текущим признаком конца строки в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере создается десять случайных целых чисел и используется <xref:System.Console.WriteLine%28System.Boolean%29?displayProperty=nameWithType> метод, чтобы указать, являются ли они четными.  
  
 [!code-cpp[System.Console.WriteLine#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_boolean1.cpp#4)]
 [!code-csharp[System.Console.WriteLine#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_boolean1.cs#4)]
 [!code-vb[System.Console.WriteLine#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_boolean1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(char value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает заданный знак Юникода, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере показан калькулятор TIP, который вычисляет 18% кончика и использует <xref:System.Console.WriteLine%2A> метод для вывода суммы исходной оплаты, количества подсказок и общей суммы. В качестве примера можно использовать консольное приложение, которое требует, чтобы пользователь предоставил сумму исходного счета в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] -&gt; unit" Usage="System.Console.WriteLine buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив знаков Юникода.</param>
        <summary>Записывает заданный массив знаков Юникода, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : decimal -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление указанного значения <see cref="T:System.Decimal" />, за которым следует текущий знак завершения строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере показан калькулятор TIP, который вычисляет 18% кончика и использует <xref:System.Console.WriteLine%2A> метод для вывода суммы исходной оплаты, количества подсказок и общей суммы. В качестве примера можно использовать консольное приложение, которое требует, чтобы пользователь предоставил сумму исходного счета в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(double value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : double -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения двойной точности с плавающей запятой, за которым следует признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.Double.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере показан калькулятор TIP, который вычисляет 18% кончика и использует <xref:System.Console.WriteLine%2A> метод для вывода суммы исходной оплаты, количества подсказок и общей суммы. В качестве примера можно использовать консольное приложение, которое требует, чтобы пользователь предоставил сумму исходного счета в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 32-битового целого числа со знаком, за которым следует текущий знак завершения строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.Int32.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере показан калькулятор TIP, который вычисляет 18% кончика и использует <xref:System.Console.WriteLine%2A> метод для вывода суммы исходной оплаты, количества подсказок и общей суммы. В качестве примера можно использовать консольное приложение, которое требует, чтобы пользователь предоставил сумму исходного счета в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(long value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 64-битового целого числа со знаком, за которым следует текущий знак завершения строки, в стандартный поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.Int64.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере показан калькулятор TIP, который вычисляет 18% кончика и использует <xref:System.Console.WriteLine%2A> метод для вывода суммы исходной оплаты, количества подсказок и общей суммы. В качестве примера можно использовать консольное приложение, которое требует, чтобы пользователь предоставил сумму исходного счета в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : obj -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного объекта, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `value` имеет значение `null`, записывается только признак конца строки. В противном случае вызывается `value` метод метода для создания строкового представления, а результирующая строка записывается в стандартный выходной поток. `ToString`  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Console.WriteLine%28System.Object%29> метод для вывода каждого значения в массиве объектов на консоль.  
  
 [!code-cpp[System.Console.WriteLine#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_obj1.cpp#3)]
 [!code-csharp[System.Console.WriteLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_obj1.cs#3)]
 [!code-vb[System.Console.WriteLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_obj1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(float value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : single -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения одинарной точности с плавающей запятой, за которым следует признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.Single.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере показан калькулятор TIP, который вычисляет 18% кончика и использует <xref:System.Console.WriteLine%2A> метод для вывода суммы исходной оплаты, количества подсказок и общей суммы. В качестве примера можно использовать консольное приложение, которое требует, чтобы пользователь предоставил сумму исходного счета в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает заданное строковое значение, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение равно `null`, в стандартный выходной поток записывается только признак конца строки.  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine> "Примечания" метода.  
  
   
  
## Examples  
 В этом примере символ конца строки изменяется с значения по умолчанию "\r\n" `vbCrLf` или на "\р\н\р\н" `vbCrLf`или   +  .  `vbCrLf` Затем он вызывает <xref:System.Console.WriteLine> методы и <xref:System.Console.WriteLine%28System.String%29> для вывода выходных данных на консоль.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint32 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 32-битового целого числа без знака, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере показан калькулятор TIP, который вычисляет 18% кончика и использует <xref:System.Console.WriteLine%2A> метод для вывода суммы исходной оплаты, количества подсказок и общей суммы. В качестве примера можно использовать консольное приложение, которое требует, чтобы пользователь предоставил сумму исходного счета в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 64-битового целого числа без знака, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` создается путем <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> вызова метода.  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере показан калькулятор TIP, который вычисляет 18% кончика и использует <xref:System.Console.WriteLine%2A> метод для вывода суммы исходной оплаты, количества подсказок и общей суммы. В качестве примера можно использовать консольное приложение, которое требует, чтобы пользователь предоставил сумму исходного счета в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Объект для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовое представление заданного объекта, за которым следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр содержит ноль или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования текстовым представлением значения соответствующего объекта.  
  
 Синтаксис элемента `{`формата — *index*[`,`*alignment*] [`:`*FormatString*]`}`, который указывает обязательный индекс, необязательная Длина и выравнивание форматированного текста, а также элемент Необязательная строка символов описателя формата, определяющая форматирование значения соответствующего объекта.  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования.  
  
-   Дополнительные сведения о функции составного форматирования, поддерживаемой такими методами <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>как, и <xref:System.Console.WriteLine%2A>некоторыми перегрузками, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата даты и времени см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата перечисления см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> метод для вывода пяти генерируемых <xref:System.Boolean> случайным образом значений.  
  
 [!code-csharp[System.Console.WriteLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine6.cs#6)]
 [!code-vb[System.Console.WriteLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine6.vb#6)]  
  
 В следующем примере вызывается <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> метод для вывода текущей даты.   Обратите внимание, что элемент форматирования `format` в аргументе использует [строку стандартного формата даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) "D" для вывода даты в полном формате даты текущего языка и региональных параметров.  
  
 [!code-csharp[System.Console.WriteLine#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine7.cs#7)]
 [!code-vb[System.Console.WriteLine#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine7.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj[] -&gt; unit" Usage="System.Console.WriteLine (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-1.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg">Массив объектов для записи с использованием <paramref name="format" />.</param>
        <summary>Записывает текстовые представления заданного массива объектов, за которым следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр содержит ноль или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования текстовым представлением значения соответствующего объекта.  
  
 Синтаксис элемента `{`формата — *index*[`,`*alignment*] [`:`*FormatString*]`}`, который указывает обязательный индекс, необязательная Длина и выравнивание форматированного текста, а также элемент Необязательная строка символов описателя формата, определяющая форматирование значения соответствующего объекта.  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования.  
  
-   Дополнительные сведения о функции составного форматирования, поддерживаемой такими методами <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>как, и <xref:System.Console.WriteLine%2A>некоторыми перегрузками, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата даты и времени см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата перечисления см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере показан калькулятор TIP, который вычисляет 18% кончика и использует <xref:System.Console.WriteLine%2A> метод для вывода суммы исходной оплаты, количества подсказок и общей суммы. В качестве примера можно использовать консольное приложение, которое требует, чтобы пользователь предоставил сумму исходного счета в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="format" /> или <paramref name="arg" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Этот метод не вызывается C++ кодом. Компилятор разрешает вызовы к [System. Console. WriteLine](xref:System.Console.WriteLine*) , которые включают строку и список из четырех или более параметров объекта в качестве вызова  <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" /> .  C++ Он разрешает вызовы к [System. Console. WriteLine](xref:System.Console.WriteLine*) , которые включают строку и массив объектов в качестве вызова <see cref="M:System.Console.WriteLine(System.String,System.Object)" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] * int * int -&gt; unit" Usage="System.Console.WriteLine (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив знаков Юникода.</param>
        <param name="index">Начальная позиция в массиве <paramref name="buffer" />.</param>
        <param name="count">Количество символов для записи.</param>
        <summary>Записывает заданный подмассив знаков Юникода, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод записывает `count` символы, начиная с `buffer` позиции `index` , к стандартному выходному потоку.  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Сумма значений параметров <paramref name="index" /> и <paramref name="count" /> указывает на позицию вне массива <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием параметра <paramref name="format" />.</param>
        <param name="arg1">Второй объект для записи с использованием параметра <paramref name="format" />.</param>
        <summary>Записывает текстовые представления заданных объектов, за которыми следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр содержит ноль или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования текстовым представлением значения соответствующего объекта.  
  
 Синтаксис элемента `{`формата — *index*[`,`*alignment*] [`:`*FormatString*]`}`, который указывает обязательный индекс, необязательная Длина и выравнивание форматированного текста, а также элемент Необязательная строка символов описателя формата, определяющая форматирование значения соответствующего объекта.  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования.  
  
-   Дополнительные сведения о функции составного форматирования, поддерживаемой такими методами <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>как, и <xref:System.Console.WriteLine%2A>некоторыми перегрузками, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата даты и времени см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата перечисления см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере показан калькулятор TIP, который вычисляет 18% кончика и использует <xref:System.Console.WriteLine%2A> метод для вывода суммы исходной оплаты, количества подсказок и общей суммы. В качестве примера можно использовать консольное приложение, которое требует, чтобы пользователь предоставил сумму исходного счета в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием параметра <paramref name="format" />.</param>
        <param name="arg1">Второй объект для записи с использованием <paramref name="format" />.</param>
        <param name="arg2">Третий объект для записи с использованием параметра <paramref name="format" />.</param>
        <summary>Записывает текстовые представления заданных объектов, за которыми следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр содержит ноль или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования текстовым представлением значения соответствующего объекта.  
  
 Синтаксис элемента `{`формата — *index*[`,`*alignment*] [`:`*FormatString*]`}`, который указывает обязательный индекс, необязательная Длина и выравнивание форматированного текста, а также элемент Необязательная строка символов описателя формата, определяющая форматирование значения соответствующего объекта.  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования.  
  
-   Дополнительные сведения о функции составного форматирования, поддерживаемой такими методами <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>как, и <xref:System.Console.WriteLine%2A>некоторыми перегрузками, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата даты и времени см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата перечисления см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере показан калькулятор TIP, который вычисляет 18% кончика и использует <xref:System.Console.WriteLine%2A> метод для вывода суммы исходной оплаты, количества подсказок и общей суммы. В качестве примера можно использовать консольное приложение, которое требует, чтобы пользователь предоставил сумму исходного счета в качестве параметра командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием параметра <paramref name="format" />.</param>
        <param name="arg1">Второй объект для записи с использованием <paramref name="format" />.</param>
        <param name="arg2">Третий объект для записи с использованием <paramref name="format" />.</param>
        <param name="arg3">Четвертый объект для записи с использованием параметра <paramref name="format" />.</param>
        <summary>Записывает текстовые представления заданных объектов и список параметров переменной длины, за которыми следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот интерфейс API CLS-несовместим. CLS-совместимая альтернатива — <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Компиляторы C# и Visual Basic автоматически разрешают вызов этого метода как вызов <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр содержит ноль или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объекту в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования текстовым представлением значения соответствующего объекта.  
  
 Синтаксис элемента `{`формата — *index*[`,`*alignment*] [`:`*FormatString*]`}`, который указывает обязательный индекс, необязательная Длина и выравнивание форматированного текста, а также элемент Необязательная строка символов описателя формата, определяющая форматирование значения соответствующего объекта.  
  
 .NET Framework обеспечивает обширную поддержку форматирования, которая подробно описана в следующих разделах форматирования.  
  
-   Дополнительные сведения о функции составного форматирования, поддерживаемой такими методами <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>как, и <xref:System.Console.WriteLine%2A>некоторыми перегрузками, см. в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения о спецификаторах числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата даты и времени см. в разделе [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения о спецификаторах формата перечисления см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о признаке конца строки см. в разделе <xref:System.Console.WriteLine%2A> "Примечания" метода, который не принимает параметров.  
  
   
  
## Examples  
 В следующем примере показано использование переменных аргументов с <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> методом. Метод вызывается со строкой составного формата и пятью элементами формата.  
  
 [!code-cpp[System.Console.WriteLine#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_vararg.cpp#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безнадежных окон верхнего уровня и подокон. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Этот метод помечен <see langword="vararg" /> ключевым словом, что означает, что он поддерживает переменное число параметров. Метод можно вызывать из Visual C++, но он не может быть вызван из C# кода или Visual Basic. Компиляторы C# и Visual Basic разрешают вызовы в <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" /> как вызовы. <see cref="M:System.Console.WriteLine(System.String,System.Object[])" /></para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
  </Members>
</Type>
