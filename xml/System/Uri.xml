<Type Name="Uri" FullName="System.Uri">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e649ba459699c8d8dce050cc82d1227aa262e9e6" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70372174" /></Metadata><TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Uri = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Обеспечивает объектное представление универсального кода ресурсов (URI), а также простой доступ к его частям.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Универсальный код ресурса (URI) — это компактное представление ресурса, доступного приложению в интрасети или Интернете. <xref:System.Uri> Класс определяет свойства и методы для обработки URI, включая синтаксический анализ, сравнение и объединение. Свойства класса доступны только для чтения. чтобы создать изменяемый объект, <xref:System.UriBuilder> используйте класс. <xref:System.Uri>  
  
 Относительные URI (например, "/new/index.htm") должны быть расширены по отношению к базовому универсальному коду ресурса (URI), чтобы они были абсолютными. <xref:System.Uri.MakeRelative%2A> Метод предоставляется для преобразования абсолютных URI в относительные URI при необходимости.  
  
 <xref:System.Uri> Конструкторы не отключают строки URI, если строка представляет собой URI правильного формата, включая идентификатор схемы.  
  
 <xref:System.Uri> Свойства возвращают каноническое представление данных в escape-кодировке, при этом все символы со значениями Юникода, превышающими 127, заменяются их шестнадцатеричными эквивалентами. Чтобы разместить URI в канонической форме, <xref:System.Uri> конструктор выполняет следующие действия:  
  
-   Преобразует схему URI в нижний регистр.  
  
-   Преобразует имя узла в нижний регистр.  
  
-   Если имя узла является IPv6-адресом, используется канонический IPv6-адрес. ScopeId и другие необязательные данные IPv6 удаляются.  
  
-   Удаляет значения по умолчанию и пустые номера портов.
  
-   Преобразует неявные пути к файлам без схемы file://(например, "К:\ми\филе") в явные пути к файлам с помощью схемы file://.
  
-   Экранированные символы (также известные как процентные октеты) без зарезервированного назначения декодируются (также называются неэкранированными). К этим незарезервированным символам относятся прописные и строчные буквы (% 41-% 5A и% 61-% 7А), десятичные цифры (% 30 –% 39), дефис (% 2D), точка (% 2E), символ подчеркивания (% 5F) и тильда (% 7E).

-   Каноникализес путь для иерархических URI путем сжатия последовательностей, таких как/./,/.. /и//(вне зависимости от того, экранирована ли последовательность). Обратите внимание, что некоторые схемы, для которых эти последовательности не сжимаются.
  
-   Для иерархических URI, если узел не завершается косой чертой (/), он добавляется.  
  
-   По умолчанию все зарезервированные символы в URI преобразуются в соответствии с RFC 2396. Это поведение меняется, если включен международный анализ международных идентификаторов ресурсов или международного доменного имени. в этом случае зарезервированные символы в URI будут экранированы в соответствии с RFC 3986 и RFC 3987.

 В рамках канонизации в конструкторе для некоторых схем, сегментов и пустых сегментов (/./,/.. /и//) сжимаются (иными словами, они удаляются). Схемы, для которых в коде URI будут сжиматься эти последовательности, включают HTTP, HTTPS, TCP, net. pipe и net. TCP. Для некоторых других схем эти последовательности не сжимаются. Вот как эта процедура сжатия выглядит на практике.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 При выполнении этого кода он возвращает следующие выходные данные, при необходимости экранированные последовательности не экранированы, если это необходимо, а затем сжатие.

```  
http://myUrl/  
/  
```  
  
 Вы можете преобразовать содержимое <xref:System.Uri> класса из ссылки URI в escape-кодировке в доступную для чтения ссылку на URI с <xref:System.Uri.ToString%2A> помощью метода. Обратите внимание, что некоторые зарезервированные символы по-прежнему могут <xref:System.Uri.ToString%2A> быть экранированы в выходных данных метода. Это необходимо для поддержки однозначной реконструкции URI из значения, <xref:System.Uri.ToString%2A>возвращаемого.  
  
 Некоторые URI включают в себя идентификатор фрагмента или запрос либо и то, и другое. Идентификатор фрагмента — это любой текст, следующий за знаком решетки (#), не включая знак номера; текст фрагмента сохраняется в <xref:System.Uri.Fragment%2A> свойстве. Сведения о запросе — это любой текст, следующий за вопросительным знаком (?) в URI; текст запроса хранится в <xref:System.Uri.Query%2A> свойстве.  
  
 В .NET Framework версии 1,1, если строка, указанная в конструкторе, содержит неизвестную схему и "\\c:", класс универсального кода ресурса (URI) вставляет символ "//" после двоеточия. Например, URI `xyz:c:\abc` преобразуется в `xyz://c:/abc`. В .NET Framework версии 2,0 это поведение было удалено, а пример строки преобразуется в `xyz:c:/abc`.  
  
> [!NOTE]
>  Класс URI поддерживает использование IP-адресов в четырех нотациях для протокола IPv4 и двоеточие в шестнадцатеричном формате для протокола IPv6. Не забудьте заключить IPv6-адрес в квадратные скобки, как в http://[:: 1].  
  
## <a name="international-resource-identifier-support"></a>Поддержка международных идентификаторов ресурсов  
 Веб-адреса обычно выражаются с помощью универсальных идентификаторов ресурсов, состоящих из очень ограниченного набора символов:  
  
-   буквы верхнего и нижнего регистра английского алфавита в кодировке ASCII;  
  
-   цифры от 0 до 9;  
  
-   небольшое количество других символов ASCII.  
  
 Спецификации URI задокументированы в RFC 2396, RFC 2732, RFC 3986 и RFC 3987, опубликованных IETF.  
  
 По мере расширения Интернета потребность в идентификации ресурсов на языках, отличных от английского, становится все более насущной. Идентификаторы, которые способствуют удовлетворению этой потребности и позволяют использовать символы, не принадлежащие к кодировке ASCII (символы из кодировок Unicode/ISO 10646), называются международными кодами ресурсов (IRI). Спецификации IRI документально зафиксированы в стандарте RFC 3987, опубликованном IETF. Использование IRI позволяет применять в URL символы Юникода.  
  
 Существующий <xref:System.Uri> класс был расширен в .NET Framework v 3.5, 3,0 с пакетом обновления 1 (SP1) и 2,0 SP1, чтобы обеспечить поддержку IRI на основе RFC 3987. Пользователи .NET Framework версий до версии 4,5 не увидят каких бы то ни было изменений в поведении .NET Framework 2,0, если они специально не включают IRI. Это обеспечивает совместимость приложений с предыдущими версиями платформы .NET Framework.  
  
 Чтобы включить поддержку IRI, необходимо следующее изменение:  
  
-   Укажите, следует ли применять синтаксический анализ международного доменного имени (IDN) к доменному имени и следует ли применять правила синтаксического анализа IRI. Это можно сделать в *Machine. config* или в файле *app. config* . Например, добавьте следующее:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Для пользователей .NET Framework 4,5 и более поздних версий поддержка IRI всегда включена. Синтаксический анализ IRI нельзя изменить с помощью файла *config* .  
  
 При включенном IDN метки в Юникоде в доменном имени будут преобразованы в аналоги в кодировке Punicode. Имена Punicode содержат только символы ASCII и всегда начинаются с префикса "xn--". Это сделано для того, чтобы поддерживать существующие DNS-серверы в интрасети, так как большинство DNS-серверов поддерживает только символы ASCII (см. RFC 3940).  
  
 Включение IRI и IDN влияет на значение свойства <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType>. Включение IRI и IDN может также привести к изменению принципа действия методов <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A> и <xref:System.Uri.IsWellFormedOriginalString%2A>.  
  
 Существует три возможных значения для IDN в зависимости от используемых DNS-серверов.  
  
-   IDN включен = ALL  
  
     При этом значении имена доменов из Юникода будут преобразовываться в их эквиваленты в Punycode (IDN-имена).  
  
-   IDN включен = Аллексцептинтранет  
  
     Это значение преобразует все доменные имена Юникода, которые не находятся в локальной интрасети, для использования эквивалентов в Punycode (IDN-имен). В этом случае для обработки международных имен в локальной интрасети DNS-серверы, используемые для интрасети, должны поддерживать разрешение имен Юникода.  
  
-   IDN включен = None  
  
     При этом значении имена доменов в Юникоде не будут преобразовываться в их эквиваленты в Punycode. Это значение по умолчанию, которое согласуется с поведением .NET Framework 2,0.  
  
 Если анализ IRI включен (элемент iriParsing enabled = `true`) нормализация и проверка символов выполняются в соответствии с последними правилами IRI в RFC 3986 и RFC 3987. Если синтаксический анализ IRI отключен, нормализация и проверка символов выполняются в соответствии с RFC 2396 и RFC 2732 (для литералов IPv6).  В версиях .NET Framework до версии 4,5 значение по умолчанию — `false`. В .NET Framework версии 4,5 и более поздних значение по умолчанию — `true`, а включенное состояние синтаксического анализа IRI не может быть изменено параметрами в файле *конфигурации* .  
  
 Обработку IRI и IDN <xref:System.Uri> в классе также можно контролировать <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>с помощью классов параметров конфигурации <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, и <xref:System.Configuration.UriSection?displayProperty=nameWithType> . Параметр <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> включает или отключает обработку IRI в классе <xref:System.Uri>. Параметр <xref:System.Configuration.IdnElement?displayProperty=nameWithType> включает или отключает обработку IDN в классе <xref:System.Uri>. Параметр <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> также косвенно управляет IDN. Обработка IRI должна быть включена для обработки IDN. Если IRI-система не включена, то обработка IDN данных будет происходить по умолчанию, когда режим платформы .NET Framework 2.0 является совместимым и имена IDN не используются.  
  
 Параметр конфигурации для <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> и <xref:System.Configuration.IdnElement?displayProperty=nameWithType> будет считан один раз при создании первого <xref:System.Uri?displayProperty=nameWithType> класса. Изменения, внесенные в параметры конфигурации после этого, игнорируются.  
  
 Расширен был также и класс <xref:System.GenericUriParser?displayProperty=nameWithType>, который теперь позволяет создавать настраиваемые средства синтаксического анализа, поддерживающие IRI и IDN. Поведение объекта <xref:System.GenericUriParser?displayProperty=nameWithType> задается путем передачи побитового сочетания значений, доступных в перечислении <xref:System.GenericUriParserOptions?displayProperty=nameWithType>, конструктору <xref:System.GenericUriParser?displayProperty=nameWithType>. Тип <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType> указывает на то, что средство синтаксического анализа поддерживает правила анализа, определенные стандартом RFC 3987 для международных кодов ресурсов (IRI). Используется ли IRI, зависит от описанных выше значений конфигурации.  
  
 Тип <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType> указывает на то, что средство синтаксического анализа поддерживает анализ международных доменных имен (IDN) узлов. Используется ли IDN, зависит от описанных выше значений конфигурации.  
  
## <a name="implicit-file-path-support"></a>Поддержка неявных путей к файлам
 <xref:System.Uri>также может использоваться для представления путей локальной файловой системы. Эти пути можно *явно* представить в URI, которые начинаются со схемы file://, и *неявно* в URI, которые не имеют схемы file://. В качестве конкретного примера допустимы следующие два URI, которые представляют один и тот же путь к файлу:
```csharp
Uri uri1 = new Uri("C:/test/path/file.txt") // Implicit file path.
Uri uri2 = new Uri("file:///C:/test/path/file.txt") // Explicit file path.
```
 Эти неявные пути к файлам не соответствуют спецификации URI, поэтому их следует избегать, если это возможно. При использовании .NET Core в системах на базе UNIX неявные пути к файлам могут быть особенно проблематичными, поскольку абсолютный неявный путь к файлу не *различается* из относительного пути. При наличии <xref:System.Uri> такой неоднозначности по умолчанию интерпретируется путь как абсолютный URI.
  
## <a name="performance-considerations"></a>Особенности производительности  
 Если вы используете файл * Web. config *, содержащий URI для инициализации приложения, необходимо дополнительное время для обработки URI, если их идентификаторы схем являются нестандартными. В этом случае следует инициализировать затронутые части приложения, когда требуются URI, а не во время начала.  
  
   
  
## Examples  
 В следующем примере создается экземпляр <xref:System.Uri> класса, который используется для <xref:System.Net.WebRequest> создания экземпляра.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>Из-за проблем безопасности приложение должно соблюдать осторожность при приеме <see cref="T:System.Uri" /> экземпляров из ненадежных источников и со <paramref name="dontEscape" /> значением <see langword="true" />. Чтобы проверить допустимость строки URI, вызовите <see cref="M:System.Uri.IsWellFormedOriginalString" /> метод.</para></block>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
    <related type="Article" href="https://msdn.microsoft.com/library/35883fe9-2d09-4d8b-80ca-cf23a941e459">Изменения пространства имен System.Uri в версии 2.0</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b5e994c3-3535-4aff-8e1b-b69be22e9a22">Поддержка международных идентификаторов ресурсов в System. Урисистем. URI</related>
    <related type="Article" href="~/docs/framework/network-programming/index.md">Сетевое программирование в .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberSignature Language="F#" Value="new Uri : string -&gt; Uri" Usage="new System.Uri uriString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">Строка, позволяющая идентифицировать ресурсы, которые должны быть представлены с помощью экземпляра <see cref="T:System.Uri" />. Обратите внимание на то, что IPv6-адрес в строковой форме должен заключаться в скобки. Пример: "http://[2607:f8b0:400d:c06::69]".</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> с заданным универсальным кодом ресурса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает <xref:System.Uri> экземпляр из строки URI. Он анализирует URI, помещает его в канонический формат и делает все необходимые escape-кодировки.  
  
 Этот конструктор не гарантирует, что объект <xref:System.Uri> ссылается на доступный ресурс.  
  
 Этот конструктор предполагает, что `string` параметр ссылается на абсолютный URI и эквивалентен <xref:System.Uri.%23ctor%2A> вызову конструктора с <xref:System.UriKind> <xref:System.UriKind.Absolute>параметром. Если параметр, передаваемый в конструктор, является относительным URI, то этот конструктор <xref:System.UriFormatException>выдаст исключение. `string`  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр с URI. `http://www.contoso.com/`  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> — <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.</para>
          </block>Параметр 
          <paramref name="uriString" /> пуст.  
  
-или- 
Схема, указанная в <paramref name="uriString" />, неправильно сформирована. См. раздел <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
- или - 
 <paramref name="uriString" /> содержит слишком много знаков косой черты.  
  
-или- 
Пароль, указанный в <paramref name="uriString" />, является недопустимым.  
  
- или - 
Имя узла, указанное в <paramref name="uriString" />, является недопустимым.  
  
- или - 
Имя файла, указанное в <paramref name="uriString" />, является недопустимым.  
  
- или - 
Имя пользователя, указанное в <paramref name="uriString" />, является недопустимым.  
  
- или - 
Имя узла или центра, указанное в <paramref name="uriString" />, не может заканчиваться обратной косой чертой.  
  
- или - 
Номер порта, указанный в <paramref name="uriString" />, является недопустимым или не поддается анализу.  
  
- или - 
Длина <paramref name="uriString" /> превышает 65 519 символов.  
  
- или - 
Длина схемы, заданной в <paramref name="uriString" />, превышает 1023 символа.  
  
-или- 
Имеется недопустимая последовательность символов в <paramref name="uriString" />.  
  
- или - 
Путь MS-DOS, заданный в <paramref name="uriString" />, должен начинаться с c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new Uri : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Uri" Usage="new System.Uri (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Экземпляр класса <see cref="T:System.Runtime.Serialization.SerializationInfo" /> содержит сведения, необходимые для сериализации нового экземпляра <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Экземпляр класса <see cref="T:System.Runtime.Serialization.StreamingContext" /> содержит источник сериализованного потока, связанного с новым экземпляром <see cref="T:System.Uri" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> на основе указанных экземпляров классов <see cref="T:System.Runtime.Serialization.SerializationInfo" /> и <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор реализует <xref:System.Runtime.Serialization.ISerializable> интерфейс <xref:System.Uri> для класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="serializationInfo" /> содержит универсальный код ресурса (URI) <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">Параметр <paramref name="serializationInfo" /> содержит пустой универсальный код ресурса (URI).  
  
- или - 
Указанная схема неправильно сформирована. См. раздел <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
-или- 
Универсальный код ресурса (URI) содержит слишком много знаков косой черты.  
  
-или- 
Пароль, указанный в универсальном коде ресурса (URI), является недопустимым.  
  
- или - 
Имя узла, указанное в универсальном коде ресурса (URI), является недопустимым.  
  
-или- 
Имя файла, указанное в универсальном коде ресурса (URI), является недопустимым.  
  
-или- 
Имя пользователя, указанное в универсальном коде ресурса (URI), является недопустимым.  
  
-или- 
Имя узла или центра, указанное в универсальном коде ресурса (URI), не может заканчиваться обратной косой чертой.  
  
- или - 
Номер порта, указанный в универсальном коде ресурса (URI), является недопустимым или не поддается анализу.  
  
-или- 
Длина универсального кода ресурса (URI) превышает 65 519 символов.  
  
- или - 
Длина схемы, заданной в универсальном коде ресурса (URI), превышает 1023 символа.  
  
- или - 
Имеется недопустимая последовательность символов в универсальном коде ресурса (URI).  
  
- или - 
Путь MS-DOS, заданный в универсальном коде ресурса (URI), должен начинаться с c:\\\\.</exception>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Сериализация XML и SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : string * bool -&gt; Uri" Usage="new System.Uri (uriString, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="dontEscape" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="uriString">Строка, позволяющая идентифицировать ресурсы, которые должны быть представлены с помощью экземпляра <see cref="T:System.Uri" />. Обратите внимание на то, что IPv6-адрес в строковой форме должен заключаться в скобки. Пример: "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="dontEscape">Значение <see langword="true" />, если параметр <paramref name="uriString" /> полностью преобразовывается в escape-последовательность; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> с указанным универсальным кодом ресурса и явным управлением преобразованием в escape-последовательность.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает <xref:System.Uri> экземпляр из строки URI. Он анализирует URI и помещает его в каноническом формате.  
  
 `dontEscape` Параметр определяет, преобразуются ли зарезервированные символы в escape-последовательности. Этот параметр должен быть установлен в `true` значение только в том случае, если вы уверены, что все зарезервированные символы в URI были экранированы. Установка значения `true` для URI, который не был полностью экранированным, может привести к непредвиденному поведению. Настоятельно рекомендуется всегда присвоить этому параметру `false`значение.  
  
 Если `dontEscape` для`false`задано значение, конструктор преобразует все зарезервированные символы, проверяя все вхождения процента (%) за ними следует допустимая escape-последовательность. Если последовательность символов, следующая за процентом, недопустима, процент заменяется на% 25.  
  
 Этот конструктор не гарантирует, что объект <xref:System.Uri> ссылается на доступный ресурс.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр для URI. `http://www.contoso.com/Hello%20World.htm` Так как содержащийся URI полностью экранирован и находится в канонической форме, `dontEscape` параметр может иметь `true`значение.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="uriString" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">Параметр <paramref name="uriString" /> является пустым или содержит только пробелы.  
  
- или - 
Схема, указанная в параметре <paramref name="uriString" />, является недопустимой.  
  
- или - 
 <paramref name="uriString" /> содержит слишком много знаков косой черты.  
  
-или- 
Пароль, указанный в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя узла, указанное в <paramref name="uriString" />, является недопустимым.  
  
- или - 
Имя файла, указанное в <paramref name="uriString" />, является недопустимым.  
  
- или - 
Имя пользователя, указанное в <paramref name="uriString" />, является недопустимым.  
  
- или - 
Имя узла или центра, указанное в <paramref name="uriString" />, не может заканчиваться обратной косой чертой.  
  
- или - 
Номер порта, указанный в <paramref name="uriString" />, является недопустимым или не поддается анализу.  
  
-или- 
Длина <paramref name="uriString" /> превышает 65 519 символов.  
  
- или - 
Длина схемы, заданной в <paramref name="uriString" />, превышает 1023 символа.  
  
- или - 
Имеется недопустимая последовательность символов в <paramref name="uriString" />.  
  
- или - 
Путь MS-DOS, заданный в <paramref name="uriString" />, должен начинаться с c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="new Uri : string * UriKind -&gt; Uri" Usage="new System.Uri (uriString, uriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uriKind" Type="System.UriKind" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uriString">Строка, позволяющая идентифицировать ресурсы, которые должны быть представлены с помощью экземпляра <see cref="T:System.Uri" />. Обратите внимание на то, что IPv6-адрес в строковой форме должен заключаться в скобки. Пример: "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="uriKind">Указывает, содержится ли в строке универсального кода ресурса относительный универсальный код ресурса, абсолютный универсальный код ресурса или неопределенный вариант.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> с заданным универсальным кодом ресурса. Этот конструктор позволяет указать, содержится ли в строке универсального кода ресурса относительный универсальный код ресурса, абсолютный универсальный код ресурса или неопределенный вариант.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Относительные и абсолютные URI имеют разные ограничения для своего формата. Например, для относительных URI не требуется схема или центр. Значение, указанное в `uriKind` , должно соответствовать типу `uriString`переданного URI. Однако если <xref:System.UriKind.RelativeOrAbsolute> указан параметр, строка URI может быть относительным или абсолютным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="uriKind" /> недопустим.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> — <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.</para>
          </block>
          <paramref name="uriString" /> содержит относительный URI, и <paramref name="uriKind" /> — <see cref="F:System.UriKind.Absolute" />.  
  
или 
 <paramref name="uriString" /> содержит абсолютный URI, и <paramref name="uriKind" /> — <see cref="F:System.UriKind.Relative" />.  
  
или 
 Параметр <paramref name="uriString" /> пуст.  
  
- или - 
Схема, указанная в <paramref name="uriString" />, неправильно сформирована. См. раздел <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
-или- 
 <paramref name="uriString" /> содержит слишком много знаков косой черты.  
  
- или - 
Пароль, указанный в <paramref name="uriString" />, является недопустимым.  
  
- или - 
Имя узла, указанное в <paramref name="uriString" />, является недопустимым.  
  
- или - 
Имя файла, указанное в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя пользователя, указанное в <paramref name="uriString" />, является недопустимым.  
  
- или - 
Имя узла или центра, указанное в <paramref name="uriString" />, не может заканчиваться обратной косой чертой.  
  
- или - 
Номер порта, указанный в <paramref name="uriString" />, является недопустимым или не поддается анализу.  
  
- или - 
Длина <paramref name="uriString" /> превышает 65 519 символов.  
  
- или - 
Длина схемы, заданной в <paramref name="uriString" />, превышает 1023 символа.  
  
- или - 
Имеется недопустимая последовательность символов в <paramref name="uriString" />.  
  
- или - 
Путь MS-DOS, заданный в <paramref name="uriString" />, должен начинаться с c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">Базовый универсальный код ресурса.</param>
        <param name="relativeUri">Относительный универсальный код ресурса, добавляемый к базовому.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> на основе заданного базового универсального кода ресурса и строки относительного универсального кода ресурса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает <xref:System.Uri> экземпляр, `baseUri` комбинируя и `relativeUri`. Если `relativeUri` является абсолютным URI (содержащий схему, имя узла и, при необходимости <xref:System.Uri> , номер порта), экземпляр создается только `relativeUri`с помощью.  
 
 <xref:System.Uri> `baseUri` `/api/` `/api`Если содержит относительные части (например,), то относительная часть должна завершаться косой чертой (например,), если относительная часть должна сохраняться в созданном виде. `baseUri` 

 Кроме того, если `relativeUri` начинается с косой черты, то она заменит любую относительную часть`baseUri`

 Этот конструктор не гарантирует, что объект <xref:System.Uri> ссылается на доступный ресурс.  
  
   
  
## Examples  
 В следующем примере <xref:System.Uri> создается новый экземпляр класса путем объединения относительных URI `http://www.contoso.com` и `catalog/shownew.htm` для формирования абсолютного URI `http://www.contoso.com/catalog/shownew.htm`.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> не является абсолютным экземпляром <see cref="T:System.Uri" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.</para>
          </block>
URI, сформированный путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, пуст или содержит только пробелы.  
  
- или - 
Схема, заданная в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимой.  
  
- или - 
URI, сформированный путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, содержит слишком много косых черт.  
  
- или - 
Пароль, заданный в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимой.  
  
-или- 
Имя узла, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
-или- 
Имя файла, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
- или - 
Имя пользователя, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
- или - 
Имя узла или центра, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, не может заканчиваться обратной косой чертой.  
  
- или - 
Номер порта, заданный в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым или не поддается анализу.  
  
- или - 
Длина URI, сформированного путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, превышает 65 519 знаков.  
  
- или - 
Длина схемы, заданной в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, превышает 1023 знака.  
  
- или - 
Имеется недопустимая последовательность символов в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />.  
  
-или- 
Путь MS-DOS, заданный в <paramref name="uriString" />, должен начинаться с c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * Uri -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="relativeUri" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="baseUri">Абсолютный <see cref="T:System.Uri" />, являющийся основой для нового экземпляра <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Экземпляр относительного <see cref="T:System.Uri" />, объединяемый с объектом <paramref name="baseUri" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> на основе сочетания заданного базового экземпляра <see cref="T:System.Uri" /> и относительного экземпляра <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает новый <xref:System.Uri> экземпляр, объединяя абсолютный <xref:System.Uri> экземпляр `baseUri`с относительным <xref:System.Uri> экземпляром `relativeUri`. Если `relativeUri` — это абсолютный <xref:System.Uri> экземпляр (содержащий схему, имя узла и, при необходимости, номер <xref:System.Uri> порта), экземпляр создается только `relativeUri`с помощью.  
 
 <xref:System.Uri> `baseUri` `/api/` `/api`Если содержит относительные части (например,), то относительная часть должна завершаться косой чертой (например,), если относительная часть должна сохраняться в созданном виде. `baseUri` 

 Кроме того, если `relativeUri` начинается с косой черты, то она заменит любую относительную часть`baseUri`
 
 Этот конструктор не гарантирует, что объект <xref:System.Uri> ссылается на доступный ресурс.  
  
   
  
## Examples  
 В этом примере создается абсолютный <xref:System.Uri> `absoluteUri`экземпляр, `relativeUri`и относительный <xref:System.Uri> экземпляр. Затем в <xref:System.Uri> этих двух `combinedUri`экземплярах создается новый экземпляр.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="baseUri" /> не является абсолютным экземпляром <see cref="T:System.Uri" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="baseUri" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> не является абсолютным экземпляром <see cref="T:System.Uri" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.</para>
          </block>
URI, сформированный путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, пуст или содержит только пробелы.  
  
-или- 
Схема, заданная в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимой.  
  
- или - 
URI, сформированный путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, содержит слишком много косых черт.  
  
-или- 
Пароль, заданный в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимой.  
  
-или- 
Имя узла, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
- или - 
Имя файла, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
- или - 
Имя пользователя, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
- или - 
Имя узла или центра, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, не может заканчиваться обратной косой чертой.  
  
- или - 
Номер порта, заданный в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым или не поддается анализу.  
  
- или - 
Длина URI, сформированного путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, превышает 65 519 знаков.  
  
-или- 
Длина схемы, заданной в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, превышает 1023 знака.  
  
-или- 
Имеется недопустимая последовательность символов в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />.  
  
- или - 
Путь MS-DOS, заданный в <paramref name="uriString" />, должен начинаться с c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string * bool -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="relativeUri" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="dontEscape" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="baseUri">Базовый универсальный код ресурса.</param>
        <param name="relativeUri">Относительный универсальный код ресурса, добавляемый к базовому.</param>
        <param name="dontEscape">Значение <see langword="true" />, если параметр <paramref name="uriString" /> полностью преобразовывается в escape-последовательность; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> на основе заданных базового и относительного универсального кода ресурса с явным управлением преобразованием в escape-последовательность.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает <xref:System.Uri> экземпляр путем объединения `baseUri` и `relativeUri`. Если переданный `relativeUri` URI является абсолютным URI (содержащий схему, имя узла и, при необходимости <xref:System.Uri> , номер порта), экземпляр создается только `relativeUri`с помощью.  
  
 `dontEscape` Параметр определяет, преобразуются ли зарезервированные символы в escape-последовательности. Этот параметр должен быть установлен в `true` значение только в том случае, если вы уверены, что все зарезервированные символы в URI были экранированы. Установка значения `true` для URI, который не был полностью экранированным, может привести к непредвиденному поведению. Настоятельно рекомендуется всегда присвоить этому параметру `false`значение. Если `dontEscape` для`false`задано значение, конструктор преобразует все зарезервированные символы, проверяя все вхождения процента (%) за ними следует допустимая escape-последовательность. Если последовательность символов, следующая за процентом, недопустима, процент заменяется на% 25.  
  
 Этот конструктор не гарантирует, что объект <xref:System.Uri> ссылается на доступный ресурс.  
  
   
  
## Examples  
 В следующем примере создается новый экземпляр <xref:System.Uri> класса путем объединения относительных URI `http://www.contoso.com` и `Hello%20World.htm` для формирования абсолютного URI.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="baseUri" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> не является абсолютным экземпляром <see cref="T:System.Uri" />.</exception>
        <exception cref="T:System.UriFormatException">URI, сформированный путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, пуст или содержит только пробелы.  
  
-или- 
Схема, заданная в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимой.  
  
- или - 
URI, сформированный путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, содержит слишком много косых черт.  
  
- или - 
Пароль, заданный в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимой.  
  
- или - 
Имя узла, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
- или - 
Имя файла, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
-или- 
Имя пользователя, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
- или - 
Имя узла или центра, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, не может заканчиваться обратной косой чертой.  
  
- или - 
Номер порта, заданный в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым или не поддается анализу.  
  
- или - 
Длина URI, сформированного путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, превышает 65 519 знаков.  
  
-или- 
Длина схемы, заданной в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, превышает 1023 знака.  
  
- или - 
Имеется недопустимая последовательность символов в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />.  
  
-или- 
Путь MS-DOS, заданный в <paramref name="uriString" />, должен начинаться с c:\\\\.</exception>
        <block subset="none" type="usage"><para>Из-за проблем с безопасностью приложение не должно вызывать этот конструктор со строками URI из ненадежных источников и со <paramref name="dontEscape" /> <see langword="true" />значением. Кроме того, можно проверить допустимость строки URI, вызвав <see cref="M:System.Uri.IsWellFormedOriginalString" /> метод перед вызовом этого конструктора.</para></block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsolutePath : string" Usage="System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает абсолютный путь универсального кода ресурса.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий абсолютный путь к ресурсу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.AbsolutePath%2A> Свойство содержит сведения о пути, которые сервер использует для разрешения запросов к информации. Обычно это путь к необходимой информации в файловой системе сервера, хотя он также может указывать на приложение или сценарий, который должен быть запущен сервером для предоставления информации.  
  
 Сведения о пути не включают в себя схему, имя узла или часть URI запроса.  
  
   
  
## Examples  
 В следующем примере путь/catalog/shownew.htm записывается в консоль.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsoluteUri : string" Usage="System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает абсолютный универсальный код ресурса.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий весь универсальный код ресурса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство включает весь URI, хранящийся <xref:System.Uri> в экземпляре, включая все фрагменты и строки запросов. <xref:System.Uri.AbsoluteUri%2A>  
  
   
  
## Examples  
 В следующем примере выполняется запись полного содержимого <xref:System.Uri> экземпляра в консоль. В приведенном примере `http://www.contoso.com/catalog/shownew.htm?date=today` записывается в консоль.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает для сервера службу доменных имен (DNS) или IP-адрес и номер порта.</summary>
        <value>Строка <see cref="T:System.String" />, содержащая компонент центра универсального кода ресурса, представленного этим экземпляром.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Authority%2A> Свойство обычно является именем узла DNS или IP-адресом сервера. Это свойство может включать номер порта службы, если он отличается от порта по умолчанию для URI. <xref:System.Uri.Authority%2A> Если компонент содержит зарезервированные символы, они будут экранированы в строковом значении, возвращаемом этим свойством.  
  
   
  
## Examples  
 Следующий пример записывает имя узла (`www.contoso.com`) и номер порта (8080) сервера в консоль.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberSignature Language="F#" Value="abstract member Canonicalize : unit -&gt; unit&#xA;override this.Canonicalize : unit -&gt; unit" Usage="uri.Canonicalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразует сохраненный во внутреннем хранилище универсальный код ресурса в каноническую форму.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Внутренне сохраняет каноническую версию URI.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а этот метод допустимо использовать только для абсолютных URI.</exception>
        <exception cref="T:System.UriFormatException">Формат URI неправильный.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member CheckHostName : string -&gt; UriHostNameType" Usage="System.Uri.CheckHostName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя узла, подлежащее проверке. Это может быть IPv4- или IPv6-адрес или имя узла в Интернете.</param>
        <summary>Определяет, является ли указанное имя узла допустимым DNS-именем.</summary>
        <returns>Объект <see cref="T:System.UriHostNameType" />, указывающий тип имени узла. Если не удается определить тип имени узла или если имя узла имеет значение <see langword="null" /> или строку нулевой длины, этот метод возвращает <see cref="F:System.UriHostNameType.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.CheckHostName%2A> Метод проверяет соответствие имени узла требованиям для допустимого имени узла в Интернете. Однако он не выполняет поиск имени узла для проверки существования узла.  
  
   
  
## Examples  
 В следующем примере проверяется, является ли имя узла допустимым.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberSignature Language="F#" Value="static member CheckSchemeName : string -&gt; bool" Usage="System.Uri.CheckSchemeName schemeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">Имя схемы, подлежащее проверке.</param>
        <summary>Определяет, является ли допустимым указанное имя схемы.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если имя схемы допустимо; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод проверяет правильность имени схемы по умолчанию в соответствии с RFC 2396. Если включен синтаксический анализ международных идентификаторов ресурсов (IRI) или международного доменного имени (IDN), этот метод проверяет правильность имени схемы в соответствии с RFC 3986. Имя схемы должно начинаться с буквы и должно содержать только буквы, цифры и символы ".", "+" или "-".  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" для <xref:System.Uri> класса.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и проверяется, является ли имя схемы допустимым.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberSignature Language="F#" Value="abstract member CheckSecurity : unit -&gt; unit&#xA;override this.CheckSecurity : unit -&gt; unit" Usage="uri.CheckSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызов этого метода ни на что не влияет.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : Uri * Uri * UriComponents * UriFormat * StringComparison -&gt; int" Usage="System.Uri.Compare (uri1, uri2, partsToCompare, compareFormat, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uri2" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="compareFormat" Type="System.UriFormat" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri1">Первая коллекция <see cref="T:System.Uri" />.</param>
        <param name="uri2">Второй объект <see cref="T:System.Uri" />.</param>
        <param name="partsToCompare">Побитовое сочетание значений <see cref="T:System.UriComponents" />, которые задают сравниваемые части <paramref name="uri1" /> и <paramref name="uri2" />.</param>
        <param name="compareFormat">Одно из значений <see cref="T:System.UriFormat" />, которое задает преобразование символов в escape-последовательность, используемую при сравнении компонентов универсального кода ресурса.</param>
        <param name="comparisonType">Одно из значений <see cref="T:System.StringComparison" />.</param>
        <summary>Сравнивает указанные части двух универсальных кодов ресурса, используя заданные правила сравнения.</summary>
        <returns>Значение типа <see cref="T:System.Int32" />, указывающее на лексическую связь между сравниваемыми компонентами <see cref="T:System.Uri" />.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Значение 
 </description></listheader><item><term> Меньше нуля 
 </term><description>Значение <paramref name="uri1" /> меньше <paramref name="uri2" />.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="uri1" /> равняется <paramref name="uri2" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description>Значение <paramref name="uri1" /> больше значения <paramref name="uri2" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если оба `uri1` и `uri2` имеют `null`значение, этот метод возвращает 0. При сравнении значений URI относительный URI всегда меньше, чем абсолютный URI, а URI, не равный null, всегда больше, чем URI null. В `uri1` `uri2` `null` случаях, когда и, и не являются относительными URI или обоими абсолютными URI, метод выполняет сравнение. <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DnsSafeHost : string" Usage="System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя узла, которое после преобразования в неэкранированную форму, если это необходимо, можно безопасно использовать для разрешения DNS.</summary>
        <value>Значение <see cref="T:System.String" /> типа, содержащее часть URI в формате, подходящем для разрешения DNS, или исходную строку узла, если она уже подходит для разрешения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для IPv6-адресов удаляются квадратные скобки ([]) <xref:System.Net.IPAddress.ScopeId%2A> и устанавливается свойство, если оно было указано при создании экземпляра.

Если для создания этого экземпляра использовался экранированная строка (например, `"http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"`), днссафехост возвращает экранированную строку. Разэкранирование любой строки, возвращенной из `DnsSafeHost` , перед использованием этой строки для разрешения DNS (см. пример). Если для создания этого экземпляра использовалась недопустимая строка без экранирования (например, "http://[fe80:: 200:39ff: fe36:1a2d% 4]/темп/ексампле.хтм"), то Днссафехост возвращает неэкранированную строку.
  
 <xref:System.Uri.DnsSafeHost%2A> Свойство зависит от параметров конфигурации, как описано далее в этом разделе. Приложения Магазина Windows не могут изменять параметры конфигурации, что может привести к непротиворечивым результатам при использовании <xref:System.Uri.DnsSafeHost%2A>. Свойство предоставляется в качестве предпочтительного варианта использования <xref:System.Uri.DnsSafeHost%2A>, так как <xref:System.Uri.IdnHost%2A> всегда гарантируется безопасность DNS, независимо от текущих параметров *app. config* . <xref:System.Uri.IdnHost%2A>  
  
 <xref:System.Uri.DnsSafeHost%2A> Свойство было расширено в .NET Framework v 3.5, 3,0 с пакетом обновления 1 (SP1) и 2,0 SP1, чтобы обеспечить поддержку международного идентификатора ресурса (IRI) на основе RFC 3987. Пользователи не увидят никаких функциональных изменений, внесенных после платформы .NET Framework 2.0, пока специально не включат поддержку IRI. Это обеспечивает совместимость приложений с предыдущими версиями платформы .NET Framework.  
  
 Чтобы включить поддержку IRI, требуются следующие два изменения:  
  
1.  Добавьте следующую строку в файл *Machine. config* в каталоге .NET Framework 2,0.  
  
     \<имя раздела = "URI" Type = "System. Configuration. Урисектион, система, версия = 2.0.0.0, культура = нейтральная, PublicKeyToken = b77a5c561934e089»"/>  
  
2.  Укажите, следует ли применять синтаксический анализ международного доменного имени (IDN) к доменному имени и следует ли применять правила синтаксического анализа IRI. Это можно сделать в *Machine. config* или в файле *app. config* . Например, добавьте следующее:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 При включенном IDN метки в Юникоде в доменном имени будут преобразованы в аналоги в кодировке Punicode. Имена Punicode содержат только символы ASCII и всегда начинаются с префикса "xn--". Это сделано для того, чтобы поддерживать существующие DNS-серверы в интрасети, так как большинство DNS-серверов поддерживает только символы ASCII (см. RFC 3940).  
  
 Включение IDN влияет только на значение <xref:System.Uri.DnsSafeHost%2A> свойства.  
  
 Существует три возможных значения для IDN в зависимости от используемых DNS-серверов.  
  
-   IDN включен = ALL  
  
     При этом значении имена доменов из Юникода будут преобразовываться в их эквиваленты в Punycode (IDN-имена).  
  
-   IDN включен = Аллексцептинтранет  
  
     При этом значении имена всех внешних доменов из Юникода будут преобразовываться в их эквиваленты в Punycode (IDN-имена). В этом случае, чтобы обрабатывать международные имена в локальной интрасети, DNS-серверы, которые используются для интрасети, должны поддерживать имена в Юникоде.  
  
-   IDN включен = None  
  
     При этом значении имена доменов в Юникоде не будут преобразовываться в их эквиваленты в Punycode. Это значение по умолчанию, которое согласуется с поведением .NET Framework 2,0.  
  
 Включение синтаксического анализа IRI (элемент iriParsing enabled `true`=) выполняет нормализацию и проверку символов в соответствии с последними правилами IRI в RFC 3987. Значение по умолчанию `false` — и будет выполнять нормализацию и проверку символов в соответствии с RFC 2396 и RFC 2732 (для литералов IPv6).  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" для <xref:System.Uri> класса.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр из строки. Он иллюстрирует разницу между значением, возвращаемым из <xref:System.Uri.Host%2A>, которое возвращает имя узла или адрес, указанный в URI, и значение <xref:System.Uri.DnsSafeHost%2A>, возвращаемое методом, которое возвращает адрес, который можно использовать в разрешении DNS.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 Как описано в разделе Примечания, перед его разрешением изменяйте экран перед именем узла. Можно использовать <xref:System.Uri.UnescapeDataString%2A> метод для отмены экранирования имени узла, и его можно разрешить, <xref:System.Net.Dns.GetHostEntry%2A> вызвав метод.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uri.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">Экземпляр <see cref="T:System.Uri" /> или универсальный код ресурса, который требуется сравнить с текущим экземпляром.</param>
        <summary>Сравнивает два экземпляра <see cref="T:System.Uri" /> на предмет их равенства.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если два экземпляра представляют один универсальный код ресурса; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод сравнивает два экземпляра, не обращаясь к частям пользователя (<xref:System.Uri.UserInfo%2A>) и фрагментам<xref:System.Uri.Fragment%2A>(), которые они могут содержать. <xref:System.Uri.Equals%2A> Например, при наличии `http://www.contoso.com/index.htm#search` URI и `http://user:password@www.contoso.com/index.htm`метод возвратит `true`значение <xref:System.Uri.Equals%2A> .  
  
 Если один <xref:System.Uri> экземпляр сформирован с именем узла в Юникоде, а `comparand` параметр содержит <xref:System.Uri> экземпляр или идентификатор, сформированный с именем узла, <xref:System.Uri.Equals%2A> имеющим эквивалентное имя узла Punycode, возвращается `true` значение включается только в том случае, если включена поддержка международного идентификатора ресурса (IRI) и международного доменного имени (IDN). Имена Punicode содержат только символы ASCII и всегда начинаются с префикса "xn--".  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" для <xref:System.Uri> класса.  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1, параметр <xref:System.Uri.Query%2A> также игнорируется.  
  
> [!NOTE]
>  <xref:System.Uri.Equals%2A> Метод можно переопределить в производном классе. Будьте внимательны, так как вредоносная сущность может изменить метод. Не следует использовать этот метод для выполнения проверок безопасности, если не известно, что этот экземпляр получен из надежного источника.  
  
   
  
## Examples  
 Этот пример создает два <xref:System.Uri> экземпляра из строк и сравнивает их, чтобы определить, представляют ли они одно и то же значение. `address1`и `address2` одинаковы, <xref:System.Uri.Fragment%2A> так как часть для этого сравнения игнорируется. Результат записывается в консоль.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">значение, чтобы предотвратить наследование <see cref="T:System.Uri" />от частично доверенного кода от. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberSignature Language="F#" Value="abstract member Escape : unit -&gt; unit&#xA;override this.Escape : unit -&gt; unit" Usage="uri.Escape " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразует все небезопасные или зарезервированные символы в компонент пути, используя шестнадцатеричное представление.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">Переданный из конструктора URI недопустим. Это исключение может произойти, если в URI содержится слишком много символов или URI является относительным.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeDataString : string -&gt; string" Usage="System.Uri.EscapeDataString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Строка, которую нужно преобразовать в escape-представление.</param>
        <summary>Преобразует строку в ее escape-представление.</summary>
        <returns>Структура <see cref="T:System.String" />, содержащая escape-представление структуры <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Uri.EscapeDataString%2A> метод преобразует все символы, кроме незарезервированных символов RFC 2396, в их шестнадцатеричное представление. Если включен синтаксический анализ международных идентификаторов ресурсов (IRI) или международного доменного имени (IDN), <xref:System.Uri.EscapeDataString%2A> метод преобразует все символы, кроме незарезервированных символов RFC 3986, в их шестнадцатеричное представление. Перед экранированием все символы Юникода преобразуются в формат UTF-8.  
  
 В этом методе `stringToEscape` предполагается, что не содержит escape-последовательностей.  
  
 По умолчанию строка преобразуется в соответствии с RFC 2396. Если включен синтаксический анализ международных идентификаторов ресурсов (IRI) или международного доменного имени (IDN), строка преобразуется в соответствии с RFC 3986 и RFC 3987. Определения зарезервированных и незарезервированных символов см. в этих документах RFC.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" для <xref:System.Uri> класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="stringToEscape" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.</para>
          </block>  
  
 Длина <paramref name="stringToEscape" /> превышает 32 766 символов.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member EscapeString : string -&gt; string" Usage="System.Uri.EscapeString str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Строка, подлежащая преобразованию в escape-представление.</param>
        <summary>Преобразует строку в ее escape-представление.</summary>
        <returns>Escape-представление строки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.EscapeString%2A> Метод преобразует зарезервированные символы RFC 2396 и все символы с символьным значением больше 127 в шестнадцатеричное представление. Перед экранированием все символы Юникода преобразуются в формат UTF-8.  
  
 По умолчанию строка преобразуется в соответствии с RFC 2396. Если включен синтаксический анализ международных идентификаторов ресурсов (IRI) или международного доменного имени (IDN), строка преобразуется в соответствии с RFC 3986 и RFC 3987.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" для <xref:System.Uri> класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeUriString : string -&gt; string" Usage="System.Uri.EscapeUriString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Строка, которую нужно преобразовать в escape-представление.</param>
        <summary>Преобразует строку универсального кода ресурса в ее escape-представление.</summary>
        <returns>Структура <see cref="T:System.String" />, содержащая escape-представление структуры <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод для подготовки неэкранированной строки URI в качестве параметра <xref:System.Uri.%23ctor%2A> конструктора. <xref:System.Uri.EscapeUriString%2A>  
  
 По умолчанию <xref:System.Uri.EscapeUriString%2A> метод преобразует все символы, кроме незарезервированных символов RFC 2396, в их шестнадцатеричное представление. Если включен синтаксический анализ международных идентификаторов ресурсов (IRI) или международного доменного имени (IDN), <xref:System.Uri.EscapeUriString%2A> метод преобразует все символы, кроме незарезервированных символов RFC 3986, в их шестнадцатеричное представление. Перед экранированием все символы Юникода преобразуются в формат UTF-8.  
  
 В этом методе `stringToEscape` предполагается, что не содержит escape-последовательностей.  
  
 По умолчанию строка преобразуется в соответствии с RFC 2396. Если включен синтаксический анализ международных идентификаторов ресурсов (IRI) или международного доменного имени (IDN), строка преобразуется в соответствии с RFC 3986 и RFC 3987. Определения зарезервированных и незарезервированных символов см. в этих документах RFC.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" для <xref:System.Uri> класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="stringToEscape" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.</para>
          </block>  
  
 Длина <paramref name="stringToEscape" /> превышает 32 766 символов.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Fragment : string" Usage="System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает escape-последовательность фрагмента универсального кода ресурса.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий любые сведения о фрагменте универсального кода ресурса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Fragment%2A> Свойство получает любой текст, следующий за маркером фрагмента (#) в URI, включая сам маркер фрагмента. При наличии URI `http://www.contoso.com/index.htm#main` <xref:System.Uri.Fragment%2A> свойство возвратит #main.  
  
 Свойство не учитывается <xref:System.Uri.Equals%2A> при сравнении. <xref:System.Uri.Fragment%2A>  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и записываются сведения о фрагменте на консоль.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberSignature Language="F#" Value="static member FromHex : char -&gt; int" Usage="System.Uri.FromHex digit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="digit">Шестнадцатеричная цифра (0-9, a-f, A-F), подлежащая преобразованию.</param>
        <summary>Получает десятичное значение шестнадцатеричной цифры.</summary>
        <returns>Значение типа <see cref="T:System.Int32" />, содержащее число от 0 до 15, соответствующее указанной шестнадцатеричной цифре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.FromHex%2A> Метод преобразует символ, представляющий шестнадцатеричную цифру (0-9, a – f, a-f), в его десятичное значение (от 0 до 15). Если `digit` не является допустимой шестнадцатеричной цифрой <xref:System.ArgumentException> , возникает исключение.  
  
   
  
## Examples  
 В следующем примере определяется, является ли символ шестнадцатеричным символом, и, если это так, записывает соответствующее десятичное значение в консоль.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение <paramref name="digit" /> не представляет допустимую шестнадцатеричную цифру (0-9, a-f, A-F).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberSignature Language="F#" Value="member this.GetComponents : UriComponents * UriFormat -&gt; string" Usage="uri.GetComponents (components, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.UriFormat" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="components">Побитовое сочетание значений <see cref="T:System.UriComponents" />, позволяющее определить, какие части текущего экземпляра будут возвращены вызывающему оператору.</param>
        <param name="format">Одно из значений <see cref="T:System.UriFormat" />, позволяющее управлять преобразованием специальных знаков в escape-последовательности.</param>
        <summary>Получает заданные компоненты текущего экземпляра, используя указанное для специальных знаков escape-преобразование.</summary>
        <returns>Объект <see cref="T:System.String" />, содержащий компоненты.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UriComponents.Query>Компоненты, <xref:System.UriComponents.Fragment>, ,<xref:System.UriComponents.UserInfo>, ,<xref:System.UriComponents.Path> и невключаютразделитель.<xref:System.UriComponents.Port> <xref:System.UriComponents.Scheme> <xref:System.UriComponents.Host> Можно объединить <xref:System.UriComponents.KeepDelimiter> флаг (с помощью побитового оператора OR) с любым из этих значений, чтобы получить значение с разделителем. Для всех остальных <xref:System.UriComponents> значений и сочетаний значений разделители включаются в возвращаемое значение.  
  
 Компоненты возвращаются в том порядке, в котором они отображаются в URI. Например, если <xref:System.UriComponents.Scheme> задано значение, оно отображается первым.  
  
 Если включена поддержка международного идентификатора ресурса (IRI) и международного доменного имени (IDN), число символов, <xref:System.String> возвращаемых при увеличении, увеличивается. Имена в Punycode, используемые для поддержки IRI, содержат только символы ASCII и всегда начинаются с префикса XN--. Если IRI и IDN включены, то в <xref:System.Uri.GetComponents%2A> методе правильно обрабатываются суррогатные символы Юникода.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" для <xref:System.Uri> класса.  
  
> [!NOTE]
>  <xref:System.UriFormat.Unescaped> <xref:System.Uri.%23ctor%2A> <xref:System.Uri>Если метод вызывается с `format` параметром, которому задано значение, то нельзя использовать возвращаемое значение в качестве аргумента конструктора для создания эквивалентного метода. <xref:System.Uri.GetComponents%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="components" /> не является сочетанием допустимых значений <see cref="T:System.UriComponents" />.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий <see cref="T:System.Uri" /> не является абсолютным URI. Относительные URI в этом методе использовать нельзя.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uri.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает хэш-код для универсального кода ресурса.</summary>
        <returns>Значение типа <see cref="T:System.Int32" />, содержащее хэш-значение, созданное для этого универсального кода ресурса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и в консоль записывается хэш-код.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberSignature Language="F#" Value="member this.GetLeftPart : UriPartial -&gt; string" Usage="uri.GetLeftPart part" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="part">Одно из значений <see cref="T:System.UriPartial" />, которое указывает окончание возвращаемой части универсального кода ресурса.</param>
        <summary>Возвращает заданную часть экземпляра <see cref="T:System.Uri" />.</summary>
        <returns>Объект <see cref="T:System.String" />, содержащий указанную часть экземпляра <see cref="T:System.Uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод возвращает строку, содержащую крайнюю левую часть строки URI, которая заканчивается частью, заданной параметром `part`. <xref:System.Uri.GetLeftPart%2A>  
  
 <xref:System.Uri.GetLeftPart%2A>включает разделители в следующих случаях:  
  
-   <xref:System.UriPartial.Scheme>включает разделитель схем.  
  
-   <xref:System.UriPartial.Authority>не включает разделитель пути.  
  
-   <xref:System.UriPartial.Path>включает любые разделители в исходном URI вплоть до разделителя запроса или фрагмента.  
  
-   <xref:System.UriPartial.Query>включает объект <xref:System.UriPartial.Path>, а также запрос и его разделитель.  
  
 В следующих <xref:System.Uri.GetLeftPart%2A> примерах показан URI и результаты вызова с помощью <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>, <xref:System.UriPartial.Path>или <xref:System.UriPartial.Query>.  
  
|URI|Схема|Авторизации|Путь|Запрос|  
|---------|------------|---------------|----------|-----------|  
|`http://www.contoso.com/index.htm?date=today`|`http://`|`http://www.contoso.com`|`http://www.contoso.com/index.htm`|`http://www.contoso.com/index.htm?date=today`|  
|`http://www.contoso.com/index.htm#main`|`http://`|`http://www.contoso.com`|`http://www.contoso.com/index.htm`|`http://www.contoso.com/index.htm`|  
|`mailto:user@contoso.com?subject=uri`|`mailto:`|`mailto:user@contoso.com`|`mailto:user@contoso.com?subject=uri`|`<none>`|  
|`nntp://news.contoso.com/123456@contoso.com`|`nntp://`|`nntp://news.contoso.com`|`nntp://news.contoso.com/123456@contoso.com`|`nntp://news.contoso.com/123456@contoso.com`|  
|`news:123456@contoso.com`|`news:`|`news:123456@contoso.com`|`news:123456@contoso.com`|`<none>`|  
|`file://server/filename.ext`|`file://`|`file://server`|`file://server/filename.ext`|`file://server/filename.ext`|  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и записывается путь к консоли.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий экземпляр <see cref="T:System.Uri" /> не является абсолютным.</exception>
        <exception cref="T:System.ArgumentException">Указанное значение <paramref name="part" /> недопустимо.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="member this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="uri.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, который содержит сведения, требуемые для сериализации коллекции <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий исходный объект и объект назначения для сериализованного потока, связанного с коллекцией <see cref="T:System.Uri" />.</param>
        <summary>Возвращает данные, необходимые для сериализации текущего экземпляра.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования методов сериализации. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberSignature Language="F#" Value="static member HexEscape : char -&gt; string" Usage="System.Uri.HexEscape character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="character">Символ, подлежащий преобразованию в шестнадцатеричное представление.</param>
        <summary>Преобразует заданный символ в эквивалентное ему шестнадцатеричное число.</summary>
        <returns>Шестнадцатеричное представление заданного символа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере символ преобразуется в его шестнадцатеричный эквивалент и записывается в консоль.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="character" /> больше 255.</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberSignature Language="F#" Value="static member HexUnescape : string * int -&gt; char" Usage="System.Uri.HexUnescape (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="pattern">Шестнадцатеричное представление символа.</param>
        <param name="index">Место в параметре <paramref name="pattern" />, с которого начинается шестнадцатеричное представление символа.</param>
        <summary>Преобразует шестнадцатеричное представление символа в сам символ.</summary>
        <returns>Символ, представленный в шестнадцатеричной кодировке, в позиции, заданной параметром <paramref name="index" />. Если кодировка символа в позиции <paramref name="index" /> не является шестнадцатеричной, возвращается символ в позиции <paramref name="index" />. Значение параметра <paramref name="index" /> увеличивается, указывая на следующий символ после возвращенного.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующем примере кода определяется, является ли символ шестнадцатеричным кодированием, и, если да, записывает эквивалентный символ в консоль.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="index" /> меньше 0 либо больше или равно числу символов в последовательности <paramref name="pattern" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : string" Usage="System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает компонент узла этого экземпляра.</summary>
        <value>Строка <see cref="T:System.String" />, которая содержит имя узла. Обычно это DNS-имя узла или IP-адрес сервера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие <xref:System.Uri.Authority%2A> от свойства, это значение свойства не включает номер порта.  
  
   
  
## Examples  
 Следующий пример записывает имя узла (`www.contoso.com`) сервера в консоль.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberSignature Language="F#" Value="member this.HostNameType : UriHostNameType" Usage="System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип имени узла, заданного в универсальном коде ресурса.</summary>
        <value>Элемент перечисления <see cref="T:System.UriHostNameType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и <xref:System.Uri.HostNameType%2A> записывается в консоль.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IdnHost : string" Usage="System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Международное доменное имя узла, соответствующее RFC 3490, в котором используется Punycode. Строка, которую после преобразования в неэкранированную форму, если это необходимо, можно безопасно использовать для разрешения DNS.</summary>
        <value>Имя узла в формате Punycode в соответствии со стандартом IDN.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предназначено для использования сетевых протоколов нижнего уровня, которым требуется доменное имя в форме Punycode. Если код не требует конкретного формата, используйте <xref:System.Uri.Host%2A> для имени узла.  
  
 Устаревшее <xref:System.Uri.DnsSafeHost%2A> свойство зависит от параметров *app. config* , которые не могут быть изменены приложениями Магазина Windows. IdnHost предоставляется в качестве предпочтительной альтернативы использованию <xref:System.Uri.DnsSafeHost%2A>, так <xref:System.Uri.IdnHost%2A> как гарантирует, что всегда будет обеспечена безопасность DNS, независимо от текущих параметров *app. config* .  

 Если для создания этого экземпляра использовался экранированная строка (например, `"http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"`), IdnHost возвращает экранированную строку. Перед тем как использовать эту строку для разрешения DNS, необходимо отформатировать любую из escape-строк, возвращенных из IdnHost. Имейте в виду, что если для создания этого экземпляра использовалась недопустимая неэкранированная строка (например, "http://[fe80:: 200:39ff: fe36:1a2d% 4]/темп/ексампле.хтм"), то IdnHost возвращает неэкранированную строку.


 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbsoluteUri : bool" Usage="System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли экземпляр <see cref="T:System.Uri" /> абсолютным.</summary>
        <value>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если экземпляр <see cref="T:System.Uri" /> является абсолютным; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство имеет `true` значение, если строка <xref:System.Uri> или экземпляр, переданный в конструктор, могут быть проанализированы как абсолютный <xref:System.Uri> экземпляр, который содержит схему, центр и путь. В противном случае экземпляр обрабатывается как относительный и может опускать схему или другие компоненты URI. <xref:System.Uri>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsBadFileSystemCharacter : char -&gt; bool&#xA;override this.IsBadFileSystemCharacter : char -&gt; bool" Usage="uri.IsBadFileSystemCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="character">Объект <see cref="T:System.Char" /> для проверки.</param>
        <summary>Получает значение, позволяющее определить, содержит ли имя файловой системы недопустимый символ.</summary>
        <returns>Значение <see langword="true" />, если указанный символ недопустим; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот символ анализируется в соответствии с правилами для файловой системы NTFS.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.IsBaseOf : Uri -&gt; bool" Usage="uri.IsBaseOf uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri">Указанный экземпляр <see cref="T:System.Uri" />, который необходимо проверить.</param>
        <summary>Определяет, является ли текущий экземпляр <see cref="T:System.Uri" /> основой указанного экземпляра <see cref="T:System.Uri" />.</summary>
        <returns>Значение <see langword="true" />, если текущий экземпляр <see cref="T:System.Uri" /> является основой для <paramref name="uri" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A>используется для сравнения текущего <xref:System.Uri> экземпляра с указанным <xref:System.Uri> , чтобы определить, является ли этот URI базовым для указанного <xref:System.Uri>. При сравнении <xref:System.Uri> двух объектов для определения базовой связи сведения о пользователе (<xref:System.Uri.UserInfo%2A>) не оцениваются. При сравнении двух URI (uri1 и uri2) uri1 является основанием uri2, если, когда вы пропускаете все в uri2 после последней косой черты (/), два URI идентичны. http://host/path/path/file?query В следующей таблице показано, является ли базовый URI базовым для других URI.  
  
|URI|http://host/path/path/file?queryявляется основанием|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|да|  
|http://host/path/path/#fragment|да|  
|http://host/path/path/MoreDir/"|да|  
|http://host/path/path/OtherFile?Query|да|  
|http://host/path/path/|да|  
|http://host/path/path/file|да|  
|http://host/path/path|Нет|  
|http://host/path/path?query|Нет|  
|http://host/path/path#Fragment|Нет|  
|http://host/path/path2/|Нет|  
://host/path/path2/MoreDir|Нет|  
|http://host/path/File|Нет|  
  
   
  
## Examples  
 В <xref:System.Uri> этом примере создается экземпляр, представляющий базовый <xref:System.Uri> экземпляр. Затем он создает второй <xref:System.Uri> экземпляр из строки. Он вызывает <xref:System.Uri.IsBaseOf%2A> метод, чтобы определить, является ли базовый экземпляр базовым для второго экземпляра. Результат записывается в консоль.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="uri" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefaultPort : bool" Usage="System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, позволяющее определить, является ли номер порта, указанный в универсальном коде ресурса, портом данной схемы по умолчанию.</summary>
        <value>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если значение свойства <see cref="P:System.Uri.Port" /> является портом данной схемы по умолчанию; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и проверяется, использует ли он порт по умолчанию.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberSignature Language="F#" Value="static member IsExcludedCharacter : char -&gt; bool" Usage="System.Uri.IsExcludedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="character">Объект <see cref="T:System.Char" /> для проверки.</param>
        <summary>Возвращает значение, позволяющее определить, нужно ли преобразовывать указанный символ в escape-последовательность.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если указанный символ подлежит преобразованию в escape-последовательность; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFile : bool" Usage="System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, представляет ли заданный параметр <see cref="T:System.Uri" /> универсальный код ресурса файла.</summary>
        <value>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если <see cref="T:System.Uri" /> является универсальным кодом ресурса файла; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство имеет `true` значение, если <xref:System.Uri.Scheme%2A> свойство равно <xref:System.Uri.UriSchemeFile>. <xref:System.Uri.IsFile%2A>  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и определяется, является ли он универсальным кодом ресурса (URI) файла.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberSignature Language="F#" Value="static member IsHexDigit : char -&gt; bool" Usage="System.Uri.IsHexDigit character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="character">Знак, подлежащий проверке.</param>
        <summary>Определяет, является ли указанный символ допустимой шестнадцатеричной цифрой.</summary>
        <returns>Значение <see langword="true" />, если символ является допустимой шестнадцатеричной цифрой; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шестнадцатеричные цифры — это цифры от 0 до 9 и буквы A – F или a-f.  
  
   
  
## Examples  
 В следующем примере определяется, является ли символ шестнадцатеричным символом, и, если это так, записывает соответствующее десятичное значение в консоль.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberSignature Language="F#" Value="static member IsHexEncoding : string * int -&gt; bool" Usage="System.Uri.IsHexEncoding (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="pattern">Проверяемая строка.</param>
        <param name="index">Расположение в параметре <paramref name="pattern" /> для проверки на принадлежность к шестнадцатеричной кодировке.</param>
        <summary>Определяет, является ли кодировка символа шестнадцатеричной.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если кодировка <paramref name="pattern" /> в указанном положении является шестнадцатеричной; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsHexEncoding%2A> Метод проверяет Шестнадцатеричное кодирование, следующее за шаблоном "% хексхекс" в строке, где "Hex" — цифра от 0 до 9 или буква от a до F (без учета регистра).  
  
   
  
## Examples  
 В следующем примере кода определяется, является ли символ шестнадцатеричным кодированием, и, если да, записывает эквивалентный символ в консоль.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoopback : bool" Usage="System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, ссылается ли заданный <see cref="T:System.Uri" /> на локальный узел.</summary>
        <value>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если этот <see cref="T:System.Uri" /> ссылается на локальный узел; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A>Возвращает `true` , если URI, указанный при создании экземпляра, имел значение 127.0.0.1, Loopback или localhost или если URI не указал сведения об узле (например, file:///c:dir/file.txt). Все остальные URI возвращают `false`.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и определяется, ссылается ли он на локальный узел.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsReservedCharacter : char -&gt; bool&#xA;override this.IsReservedCharacter : char -&gt; bool" Usage="uri.IsReservedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="character">Объект <see cref="T:System.Char" /> для проверки.</param>
        <summary>Возвращает значение, позволяющее определить, является ли заданный символ зарезервированным знаком.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если указанный символ является зарезервированным знаком; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnc : bool" Usage="System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли заданный <see cref="T:System.Uri" /> UNC-путем.</summary>
        <value>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если экземпляр <see cref="T:System.Uri" /> является UNC-путем; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство имеет `true` значение, если указанный <xref:System.Uri> экземпляр представляет собой UNC-путь (например \\, \сервер\фолдер или file://Server/Folder). <xref:System.Uri.IsUnc%2A> Это свойство всегда возвращает `true` значение, если универсальный код ресурса (URI) имеет схему file://и указывает компонент узла.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и определяется, является ли он UNC-путем.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberSignature Language="F#" Value="member this.IsWellFormedOriginalString : unit -&gt; bool" Usage="uri.IsWellFormedOriginalString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Указывает, является ли формат строки, использовавшейся для создания данного <see cref="T:System.Uri" />, правильным и не требующим дальнейшего преобразования в escape-последовательность.</summary>
        <returns>Значение <see langword="true" />, если строка имеет правильный формат; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строка считается правильно сформированной в соответствии с RFC 2396 и RFC 2732 по умолчанию. Если включен синтаксический анализ международных идентификаторов ресурсов (IRI) или международного доменного имени (IDN), строка считается правильно сформированной в соответствии с RFC 3986 и RFC 3987.  
  
 Строка считается неправильно сформированной, в результате чего метод возвращает значение false, если выполняется одно из следующих условий.  
  
|Error|Пример|  
|-----------|-------------|  
|Строка неправильно экранирована.|`http://www.contoso.com/path???/file name`|  
|Строка является абсолютным <xref:System.Uri> , представляющим неявный <xref:System.Uri>файл.|`c:\\directory\filename`|  
|Строка представляет собой абсолютный URI, в котором отсутствует косая черта перед путем.|`file://c:/directory/filename`|  
|Строка содержит неэкранированные обратные косые черты, даже если они считаются косой чертой.|`http:\\\host/path/file`|  
|Строка представляет иерархический абсолютный <xref:System.Uri> и не содержит "://".|`www.contoso.com/path/file`|  
|Средство синтаксического анализа для <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> указывает, что исходная строка не была правильно сформирована.|Пример зависит от схемы универсального кода ресурса (URI).|  
  
 По умолчанию строка, используемая для ее <xref:System.Uri> создания, считается правильно сформированной в соответствии с RFC 2396 и RFC 2732.  
  
 Если включена поддержка международного идентификатора ресурса (IRI) и международного доменного имени (IDN), то строка, используемая для ее <xref:System.Uri> создания, считается правильно сформированной в соответствии с RFC 3986 и RFC 3987. Имена в Punycode, используемые для поддержки IRI, содержат только символы ASCII и всегда начинаются с префикса XN--.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" для <xref:System.Uri> класса.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://www.ietf.org/">Веб-задача по техническому персоналу (IETF)</related>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="static member IsWellFormedUriString : string * UriKind -&gt; bool" Usage="System.Uri.IsWellFormedUriString (uriString, uriKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uriKind" Type="System.UriKind" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uriString">Строка, используемая при попытке создания объекта <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Тип объекта <see cref="T:System.Uri" /> в параметре <paramref name="uriString" />.</param>
        <summary>Указывает, является ли правильным формат данной строки, пытаясь создать на ее основе универсальный код ресурса и проверяя, не требуется ли для нее дополнительное преобразование в escape-последовательность.</summary>
        <returns>Значение <see langword="true" />, если строка имеет правильный формат; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В версиях .NET до версии 4,5 по умолчанию строка считается правильно сформированной в соответствии с RFC 2396 и RFC 2732. Если включены синтаксический анализ международных идентификаторов ресурсов (IRI) или международного доменного имени (IDN), то строка считается правильно сформированной в соответствии с RFC 3986 и RFC 3987.  
  
 Начиная с .NET 4,5, строки всегда считаются правильно сформированными в соответствии с RFC 3986 и RFC 3987 независимо от того, включены ли IRI или IDN. Однако обратите внимание, что это справедливо только для приложений, предназначенных для .NET 4,5 или более поздней версии. Приложения, предназначенные для .NET 4,0, вызывают код совместимости и работают со старым поведением (до 4,5).  
  
 Строка считается неправильно сформированной, в результате чего метод возвращает значение false, если выполняется одно из следующих условий.  
  
|Error|Пример|  
|-----------|-------------|  
|Строка неправильно экранирована.|`http://www.contoso.com/path???/file name`|  
|Строка является абсолютным <xref:System.Uri> , представляющим неявный <xref:System.Uri>файл.|`c:\\directory\filename`|  
|Строка представляет собой абсолютный URI, в котором отсутствует косая черта перед путем.|`file://c:/directory/filename`|  
|Строка содержит неэкранированные обратные косые черты, даже если они будут рассматриваться как косую черту.|`http:\\\host/path/file`|  
|Строка представляет иерархический абсолютный <xref:System.Uri> и не содержит "://"|`www.contoso.com/path/file`|  
|Средство синтаксического анализа для <xref:System.Uri.Scheme%2A> указывает, что исходная строка не была правильно сформирована.|Пример зависит от схемы универсального кода ресурса (URI).|  
|Начиная с .NET 4,5, относительные URI с двоеточием (":") в первом сегменте не считаются правильно сформированными.|`2013.05.29_14:33:41`|  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" для <xref:System.Uri> класса.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://www.ietf.org/">Веб-задача по техническому персоналу (IETF)</related>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalPath : string" Usage="System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает представление имени файла в локальной операционной системе.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий представление имени файла в локальной операционной системе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, не экранировано. Если путь распознан как путь к файлу Windows, все косые черты (/) заменяются обратной косой чертой (\\).  
  
 Для URI `file://computer/file.ext`абсолютным путем является `/file.ext` , а локальный путь — `\\computer\file.ext`.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и записывается локальный путь к консоли.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelative : Uri -&gt; string" Usage="uri.MakeRelative toUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toUri">Универсальный код ресурса для сравнения с текущим универсальным кодом ресурса.</param>
        <summary>Определяет разницу между двумя экземплярами класса <see cref="T:System.Uri" />.</summary>
        <returns>Если имена узлов и схемы данного экземпляра универсального кода ресурса и <paramref name="toUri" /> совпадают, этот метод возвращает объект <see cref="T:System.String" />, представляющий относительный универсальный код ресурса, добавление которого в конец текущего экземпляра универсального кода ресурса даст параметр <paramref name="toUri" />.  
  
Если имена узлов и схемы отличаются, этот метод возвращает объект <see cref="T:System.String" />, представляющий параметр <paramref name="toUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице показан экземпляр `toUri`универсального кода ресурса (URI) и результаты вызова метода. <xref:System.Uri.MakeRelative%2A>  
  
|Текущий экземпляр URI|`toUri`|Возвращаемое значение|  
|--------------------------|-------------|------------------|  
|`http://www.contoso.com/`|`http://www.contoso.com/test/test.htm`|`test/test.htm`|  
|`http://www.contoso.com/test1/`|`http://www.contoso.com/`|`../`|  
|`http://www.contoso.com:8000/`|`http://www.contoso.com/test/test.htm`|`http://www.contoso.com/test/test.htm`|  
|`http://username@www.contoso.com/`|`http://www.contoso.com/test1/test1.txt`|`test1/test1.txt`|  
  
 Сведения о пользователе, если они есть в URI, игнорируются.  
  
   
  
## Examples  
 В следующем примере создаются 2 <xref:System.Uri> экземпляра. Разница в сведениях о пути записывается на консоль.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toUri" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а этот метод допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelativeUri : Uri -&gt; Uri" Usage="uri.MakeRelativeUri uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri">Универсальный код ресурса для сравнения с текущим универсальным кодом ресурса.</param>
        <summary>Определяет разницу между двумя экземплярами класса <see cref="T:System.Uri" />.</summary>
        <returns>Если имя узла и схема данного экземпляра универсального кода ресурса и <paramref name="uri" /> совпадают, этот метод возвращает относительный <see cref="T:System.Uri" />, который при добавлении к его концу текущего экземпляра универсального кода ресурса превратится в <paramref name="uri" />.  
  
Если имена узлов и схемы отличаются, этот метод возвращает объект <see cref="T:System.Uri" />, представляющий параметр <paramref name="uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице показан экземпляр `toUri`универсального кода ресурса (URI) и результаты вызова метода. <xref:System.Uri.MakeRelativeUri%2A>  
  
|Текущий экземпляр URI|`toUri`|Возвращаемое значение|  
|--------------------------|-------------|------------------|  
|`http://www.contoso.com/`|`http://www.contoso.com/test/test.htm`|`test/test.htm`|  
|`http://www.contoso.com/test1/`|`http://www.contoso.com/`|`../`|  
|`http://www.contoso.com:8000/`|`http://www.contoso.com/test/test.htm`|`http://www.contoso.com/test/test.htm`|  
|`http://username@www.contoso.com/`|`http://www.contoso.com/test1/test1.txt`|`test1/test1.txt`|  
  
 Сведения о пользователе, если они есть в URI, игнорируются.  
  
   
  
## Examples  
 В следующем примере создаются 2 <xref:System.Uri> экземпляра. Разница в сведениях о пути записывается на консоль.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="uri" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Uri * Uri -&gt; bool" Usage="uri1 = uri2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uri2" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri1">Экземпляр <see cref="T:System.Uri" /> для сравнения с <paramref name="uri2" />.</param>
        <param name="uri2">Экземпляр <see cref="T:System.Uri" /> для сравнения с <paramref name="uri1" />.</param>
        <summary>Определяет, равны ли значения двух экземпляров <see cref="T:System.Uri" />.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если экземпляры <see cref="T:System.Uri" /> эквивалентны; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка использует <xref:System.Uri.Equals%2A> метод, чтобы определить, эквивалентны <xref:System.Uri> ли два экземпляра. <xref:System.Uri.UserInfo%2A>и <xref:System.Uri.Fragment%2A> при выполнении этого сравнения содержимое игнорируется.  
  
   
  
## Examples  
 Этот пример создает три <xref:System.Uri> экземпляра из строк и сравнивает их, чтобы определить, представляют ли они одно и то же значение. `Address1`и `Address2` одинаковы, <xref:System.Uri.Fragment%2A> так как часть для этого сравнения игнорируется. Результат записывается в консоль.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Uri * Uri -&gt; bool" Usage="System.Uri.op_Inequality (uri1, uri2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uri2" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri1">Экземпляр <see cref="T:System.Uri" /> для сравнения с <paramref name="uri2" />.</param>
        <param name="uri2">Экземпляр <see cref="T:System.Uri" /> для сравнения с <paramref name="uri1" />.</param>
        <summary>Определяет, не равны ли значения двух экземпляров <see cref="T:System.Uri" />.</summary>
        <returns>Значение <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если два экземпляра <see cref="T:System.Uri" /> не равны; в противном случае — значение <see langword="false" />. Если значение одного из параметров равно <see langword="null" />, этот метод возвращает значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка использует <xref:System.Uri.Equals%2A> метод, чтобы определить, являются ли <xref:System.Uri> два экземпляра эквивалентными. <xref:System.Uri.UserInfo%2A>и <xref:System.Uri.Fragment%2A> при выполнении этого сравнения содержимое игнорируется.  
  
   
  
## Examples  
 Этот пример создает три <xref:System.Uri> экземпляра из строк и сравнивает их, чтобы определить, представляют ли они одно и то же значение. `Address2`и `Address3` не совпадают, так как `Address3` содержит объект <xref:System.Uri.Query%2A> , не найденный в `Address2`. Результат записывается в консоль.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalString : string" Usage="System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает исходную строку универсального кода ресурса, переданную в конструктор <see cref="T:System.Uri" />.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий точный универсальный код ресурса, указанный при создании этого экземпляра; в противном случае — <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если URI, указанный в конструкторе, содержал начальные или конечные пробелы, эти пробелы сохраняются.  
  
 Значение, возвращаемое этим свойством, <xref:System.Uri.ToString%2A> отличается <xref:System.Uri.AbsoluteUri%2A>от и. <xref:System.Uri.ToString%2A>Возвращает форму URI в каноническом виде без экранирования. <xref:System.Uri.AbsoluteUri%2A>Возвращает каноническое экранирование URI.  
  
 Если включена поддержка международного идентификатора ресурса (IRI) и международного доменного имени (IDN), возвращает <xref:System.Uri.OriginalString%2A> исходную ненормализованную строку с именем узла Punycode, если она использовалась для <xref:System.Uri> инициализации экземпляра. Имена Punicode содержат только символы ASCII и всегда начинаются с префикса "xn--".  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" для <xref:System.Uri> класса.  
  
 При сериализации <xref:System.Uri> <xref:System.Uri.OriginalString%2A> объекта объект не сохраняется. В процессе сериализации используется полностью экранированное и каноническое <xref:System.Uri.AbsoluteUri%2A> свойство при сериализации. Для, содержащего IPv6-адрес, адрес IPv6 и идентификатор области включаются в <xref:System.Uri> сериализованный объект. <xref:System.Uri>  
  
   
  
## Examples  
 В следующем примере создается новый <xref:System.Uri> экземпляр из строки. Он иллюстрирует разницу между значением, возвращаемым из <xref:System.Uri.OriginalString%2A>, которое возвращает строку, переданную в конструктор, и из <xref:System.Uri.ToString%2A>вызова метода, который возвращает каноническую форму строки.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; unit&#xA;override this.Parse : unit -&gt; unit" Usage="uri.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Анализирует универсальный код ресурса текущего экземпляра и проверяет, действительно ли этот код содержит все обязательные части допустимого универсального кода ресурса.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">Переданный из конструктора URI недопустим.</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathAndQuery : string" Usage="System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает свойства <see cref="P:System.Uri.AbsolutePath" /> и <see cref="P:System.Uri.Query" />, разделенные вопросительным знаком (?).</summary>
        <value>Объект <see cref="T:System.String" />, содержащий свойства <see cref="P:System.Uri.AbsolutePath" /> и <see cref="P:System.Uri.Query" />, разделенные вопросительным знаком (?).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.PathAndQuery%2A> Свойство содержит абсолютный путь на сервере и сведения о запросе, отправленные с запросом. Оно идентично объединению <xref:System.Uri.AbsolutePath%2A> свойств и <xref:System.Uri.Query%2A> .  
  
 По <xref:System.Uri.PathAndQuery%2A> умолчанию свойство преобразуется в соответствии с RFC 2396. Если включен синтаксический анализ международных идентификаторов ресурсов (IRI) или международного доменного имени (IDN), <xref:System.Uri.PathAndQuery%2A> свойство преобразуется в соответствии с RFC 3986 и RFC 3987.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" для <xref:System.Uri> класса.  
  
   
  
## Examples  
 В следующем примере сведения о пути URI (/catalog/shownew.htm) и запросе (Дата = сегодня) записываются в консоль.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Port : int" Usage="System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает номер порта данного универсального кода ресурса.</summary>
        <value>Значение типа <see cref="T:System.Int32" />, в котором содержится номер порта для данного универсального кода ресурса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Номер порта определяет порт протокола, используемый для связи с сервером, на который ссылается URI. Если порт не указан как часть URI, <xref:System.Uri.Port%2A> свойство возвращает значение по умолчанию для протокола. Если номер порта по умолчанию отсутствует, это свойство возвращает значение-1.  
  
   
  
## Examples  
 В следующем примере показана запись номера порта URI в консоль. В этом случае значением является номер порта по умолчанию для HTTP, порт 80.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Query : string" Usage="System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает любые сведения запроса, включенные в заданный универсальный код ресурса.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий какие-либо сведения запроса, включенные в заданный универсальный код ресурса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Query%2A> Свойство содержит любые сведения о запросе, содержащиеся в URI. Сведения о запросе отделены от сведений о пути на вопросительный знак (?) и заменяются на конец URI. Возвращаемые сведения о запросе включают в себя начальный вопросительный знак.  
  
 По умолчанию сведения о запросе преобразуются в соответствии с RFC 2396. Если включен синтаксический анализ международных идентификаторов ресурсов (IRI) или международного доменного имени (IDN), сведения о запросе преобразуются в соответствии с RFC 3986 и RFC 3987.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" для <xref:System.Uri> класса.  
  
   
  
## Examples  
 В следующем примере на консоль записывается запрос? Date = Today.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя схемы для данного универсального кода ресурса.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий схему для данного универсального кода ресурса, преобразованного в нижний регистр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство возвращает схему, используемую для <xref:System.Uri> инициализации экземпляра. <xref:System.Uri.Scheme%2A> Это свойство не указывает, что схема, используемая для инициализации <xref:System.Uri> экземпляра, распознана.  
  
 В следующей таблице приведены примеры некоторых возможных значений, <xref:System.Uri.Scheme%2A> возвращаемых свойством.  
  
|Схема|Описание|  
|------------|-----------------|  
|файл|Ресурс — это файл на локальном компьютере.|  
|ftp|Доступ к ресурсу осуществляется по протоколу FTP.|  
|gopher|Доступ к ресурсу осуществляется по протоколу Gopher.|  
|http|Доступ к ресурсу осуществляется по протоколу HTTP.|  
|https|Доступ к ресурсу осуществляется через протокол HTTP, зашифрованный с помощью SSL.|  
|LDAP|Доступ к ресурсу осуществляется по протоколу LDAP.|  
|mailto|Ресурс является адресом электронной почты и доступен по протоколу SMTP.|  
|net.pipe|Доступ к ресурсу осуществляется через именованный канал.|  
|net.tcp|Доступ к ресурсу осуществляется из конечной точки TCP.|  
|news|Доступ к ресурсу осуществляется по протоколу NNTP.|  
|Разверните|Доступ к ресурсу осуществляется по протоколу NNTP.|  
|telnet|Доступ к ресурсу осуществляется по протоколу TELNET.|  
|uuid|Доступ к ресурсу осуществляется по уникальному имени конечной точки UUID для взаимодействия со службой.|  
  
   
  
## Examples  
 В следующем примере имя схемы (http) записывается в консоль для `http://www.contoso.com/` URI.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable SchemeDelimiter : string" Usage="System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет символы, отделяющие схему протокола передачи данных от адресной части универсального кода ресурса. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается строка из <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>и адреса. Затем <xref:System.Uri> экземпляр создается из строки.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Segments : string[]" Usage="System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает массив, содержащий сегменты пути, которые образуют указанный универсальный код ресурса.</summary>
        <value>Массив <see cref="T:System.String" />, содержащий сегменты пути, которые образуют указанный универсальный код ресурса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Segments%2A> Свойство возвращает массив строк, содержащий "сегменты" (подстроки), которые формируют абсолютный путь универсального кода ресурса (URI). Первый сегмент получается путем синтаксического анализа абсолютного пути от первого символа до тех пор, пока не будет достигнута косая черта (/) или конец пути. Каждый дополнительный сегмент начинается с первого символа после предыдущего сегмента и завершается следующей косой чертой или концом пути. (Абсолютный путь URI содержит все параметры после узла и порта, а также перед запросом и фрагментом.)  
  
 В следующем примере показан абсолютный путь и сегменты для двух URI. Во втором примере показано, что фрагмент и запрос не являются частью абсолютного пути и, следовательно, не являются сегментами.  
  
 Абсолютный URI:  
 `http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm`
  
 Абсолютный путь:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Сегментов  
 - /
 - Главы
 - Chapter1/
 - Священ
 - Section1. htm  
  
 Абсолютный URI:  
 `http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO`
  
 Абсолютный путь:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Сегментов  
 - /
 - Главы
 - Chapter1/
 - Священ
 - Section1. htm  
  
 Обратите внимание, что поскольку абсолютный путь начинается с "/", первый сегмент содержит его и ничего другого.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр с тремя сегментами и отображаются сегменты на экране.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, который содержит сведения, требуемые для сериализации коллекции <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий исходный объект и объект назначения для сериализованного потока, связанного с коллекцией <see cref="T:System.Uri" />.</param>
        <summary>Возвращает данные, необходимые для сериализации текущего экземпляра.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования методов сериализации. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uri.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает каноническое строковое представление заданного экземпляра <see cref="T:System.Uri" />.</summary>
        <returns>Экземпляр <see cref="T:System.String" />, содержащий каноническое представление экземпляра <see cref="T:System.Uri" /> без преобразования в escape-последовательность. В escape-последовательность преобразовываются только знаки #, ? и %.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строка, возвращаемая этим методом, не содержит сведений о портах, если порт является портом по умолчанию для схемы.  
  
> [!NOTE]
>  Строка, возвращаемая <xref:System.Uri.ToString%2A> методом, может содержать управляющие символы, которые могут повредить состояние консольного приложения. Можно использовать <xref:System.Uri.GetComponents%2A> метод <xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType> с форматом для удаления управляющих символов из возвращаемой строки.  
  
   
  
## Examples  
 В следующем примере создается новый <xref:System.Uri> экземпляр из строки. Он иллюстрирует разницу между значением, возвращаемым из <xref:System.Uri.OriginalString%2A>, которое возвращает строку, переданную в конструктор, и из <xref:System.Uri.ToString%2A>вызова метода, который возвращает каноническую форму строки.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">значение, чтобы предотвратить наследование <see cref="T:System.Uri" />от частично доверенного кода от. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр <see cref="T:System.Uri" />. Не создает исключение, если не удается создать <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : string * UriKind * Uri -&gt; bool" Usage="System.Uri.TryCreate (uriString, uriKind, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uriKind" Type="System.UriKind" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Uri" RefType="out" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uriString">Объект типа <see cref="T:System.String" />, представляющий объект <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Тип универсального кода ресурса.</param>
        <param name="result">При возврате этим методом он содержит сконструированный <see cref="T:System.Uri" />.</param>
        <summary>Создает новый <see cref="T:System.Uri" />, используя заданный экземпляр <see cref="T:System.String" /> и <see cref="T:System.UriKind" />.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если <see cref="T:System.Uri" /> успешно создан; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод возвращает `true`, новый <xref:System.Uri> объект находится в `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * string * Uri -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="relativeUri" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Uri" RefType="out" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="baseUri">Базовый <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Относительный <see cref="T:System.Uri" />, представленный в виде <see cref="T:System.String" />, для добавления к базовому <see cref="T:System.Uri" />.</param>
        <param name="result">При возврате данным методом содержит <see cref="T:System.Uri" />, составленный из значений <paramref name="baseUri" /> и <paramref name="relativeUri" />. Этот параметр передается неинициализированным.</param>
        <summary>Создает новый <see cref="T:System.Uri" />, используя заданные экземпляры базового и относительного <see cref="T:System.String" />.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если <see cref="T:System.Uri" /> успешно создан; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод возвращает `true`, новый <xref:System.Uri> объект находится в `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * Uri * Uri -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="relativeUri" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Uri" RefType="out" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="baseUri">Базовый <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Относительный <see cref="T:System.Uri" /> для добавления к базовому <see cref="T:System.Uri" />.</param>
        <param name="result">При возврате данным методом содержит <see cref="T:System.Uri" />, составленный из значений <paramref name="baseUri" /> и <paramref name="relativeUri" />. Этот параметр передается неинициализированным.</param>
        <summary>Создает новый <see cref="T:System.Uri" />, используя заданные экземпляры базового и относительного <see cref="T:System.Uri" />.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если <see cref="T:System.Uri" /> успешно создан; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод возвращает `true`, новый <xref:System.Uri> объект находится в `result`.  
  
 Этот метод создает универсальный код ресурса (URI), помещает его в каноническую форму и проверяет его. При возникновении необработанного исключения этот метод перехватывает его. Если вы хотите создать <xref:System.Uri> исключения и Get, используйте один <xref:System.Uri.%23ctor%2A> из конструкторов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="baseUri" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member Unescape : string -&gt; string&#xA;override this.Unescape : string -&gt; string" Usage="uri.Unescape path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Преобразуемый объект <see cref="T:System.String" />.</param>
        <summary>Преобразует указанную строку, заменив все escape-последовательности их представлениями, к которым не было применено escape-преобразование.</summary>
        <returns>Объект <see cref="T:System.String" />, содержащий значение параметра <paramref name="path" />, не преобразованное в escape-последовательность.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberSignature Language="F#" Value="static member UnescapeDataString : string -&gt; string" Usage="System.Uri.UnescapeDataString stringToUnescape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">Строка, для которой нужно отменить преобразование в escape-представление.</param>
        <summary>Отменяет преобразование строки в escape-представление.</summary>
        <returns>Структура <see cref="T:System.String" />, содержащая структуру <paramref name="stringToUnescape" />, для которой было отменено escape-преобразование.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать с осторожностью. Без экранирования строки, которая ранее была неэкранированной, может привести к неоднозначности и ошибкам.  
  
 Многие веб-браузеры пропускают пробелы внутри URI в символы плюса ("+"). Однако метод UnescapeDataString не преобразует символы плюса в пробелы, так как это поведение не является стандартным для всех схем URI.  
  
   
  
## Examples  
 В следующем примере кода код URI преобразуется в escape-последовательность, а затем все символы плюса ("+") преобразуются в пробелы.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToUnescape" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFile : string" Usage="System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что универсальный код ресурса является указателем на файл. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В .NET Framework версии 1,1`file:///path`универсальный код ресурса (URI) был переведен в "`file:/path`". Это исправлено для версии 2,0.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и определяется, является <xref:System.Uri.UriSchemeFile>ли схема.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFtp : string" Usage="System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса доступен по протоколу FTP. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и определяется, является <xref:System.Uri.UriSchemeFtp>ли схема.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeGopher : string" Usage="System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса доступен по протоколу Gopher. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и определяется, является <xref:System.Uri.UriSchemeGopher>ли схема.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttp : string" Usage="System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса доступен по протоколу HTTP. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и определяется, является <xref:System.Uri.UriSchemeHttp>ли схема.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttps : string" Usage="System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса доступен по протоколу HTTPS. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и определяется, является <xref:System.Uri.UriSchemeHttps>ли схема.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeMailto : string" Usage="System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса представляет адрес электронной почты и доступен по протоколу SMTP. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и определяется, является <xref:System.Uri.UriSchemeMailto>ли схема.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetPipe : string" Usage="System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что доступ к универсальному коду ресурса осуществляется через схему NetPipe, используемую Windows Communication Foundation (WCF). Это поле доступно только для чтения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetTcp : string" Usage="System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что доступ к универсальному коду ресурса осуществляется через схему NetTcp, используемую Windows Communication Foundation (WCF). Это поле доступно только для чтения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNews : string" Usage="System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса представляет группу новостей Интернета и доступен по протоколу NNTP. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и определяется, является <xref:System.Uri.UriSchemeNews>ли схема.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNntp : string" Usage="System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса представляет группу новостей Интернета и доступен по протоколу NNTP. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ошибки анализа <xref:System.Uri> NNTP в .NET Framework версии 1,1 исправлены.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и определяется, является <xref:System.Uri.UriSchemeNntp>ли схема.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserEscaped : bool" Usage="System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что строка универсального кода ресурса не была полностью преобразована в escape-последовательность перед созданием экземпляра класса <see cref="T:System.Uri" />.</summary>
        <value>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если при создании экземпляра <paramref name="dontEscape" /> для параметра <see langword="true" /> было задано значение <see cref="T:System.Uri" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство устанавливается в значение `dontEscape` , <xref:System.Uri> чтобы указать, что строка, используемая для создания экземпляра, была полностью экранирована перед передачей в конструктор; то есть параметру вызова конструктора было присвоено `true` <xref:System.Uri.UserEscaped%2A> значение `true`.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и определяется, был ли он полностью экранирован при создании.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInfo : string" Usage="System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя пользователя, пароль или другие связанные с пользователем сведения, которые соответствуют заданному универсальному коду ресурса.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий сведения о пользователе, связанные с данным универсальным кодом ресурса. Возвращаемое значение не содержит знак "@", зарезервированный для отделения части универсального кода ресурса, в которой указываются сведения о пользователе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, обычно имеет формат "имя_пользователя: пароль".  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр и записываются сведения о пользователе в консоль.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
