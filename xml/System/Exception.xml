<Type Name="Exception" FullName="System.Exception">
  <Metadata><Meta Name="ms.openlocfilehash" Value="982c48cb4df4baf1eb52eafe07c62c028e3863a6" /><Meta Name="ms.sourcegitcommit" Value="5c332e8417c001736f7e2f33a84791feebba2cd7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="07/30/2019" /><Meta Name="ms.locfileid" Value="68632589" /></Metadata><TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет ошибки, происходящие во время выполнения приложения.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс является базовым классом для всех исключений. При возникновении ошибки система или выполняемое в настоящее время приложение сообщает о нем, вызывая исключение, которое содержит сведения об ошибке. После возникновения исключения оно обрабатывается приложением или обработчиком исключений по умолчанию.  
  
 Содержание  
  
 [Ошибки и исключения](#Errors)   
 [Блоки try/catch](#TryCatch)   
 [Функции типов исключений](#Features)   
 [Свойства класса Exception](#Properties)   
 [Вопросы производительности](#Performance)   
 [Повторное создание исключения](#Rethrow)   
 [Выбор стандартных исключений](#Standard)   
 [Реализация пользовательских исключений](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>Ошибки и исключения  
 Ошибки времени выполнения могут возникать по разным причинам. Однако не все ошибки должны обрабатываться как исключения в коде. Ниже приведены некоторые категории ошибок, которые могут возникать во время выполнения, и соответствующие способы реагирования на них.  
  
-   **Ошибки использования.** Ошибка использования представляет ошибку в логике программы, которая может привести к исключению. Однако эта ошибка должна быть решена не посредством обработки исключений, но путем изменения неисправного кода. Например, переопределение <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метода в следующем примере предполагает `obj` , что аргумент всегда должен иметь значение, отличное от NULL.  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     Исключение, которое возникает, `obj` `null` если можно устранить, изменив исходный код, <xref:System.Object.Equals%2A?displayProperty=nameWithType> чтобы явно проверить наличие значения null перед вызовом переопределения, а затем повторной компиляцией. <xref:System.NullReferenceException> В следующем примере содержится исправленный исходный код, обрабатывающий `null` аргумент.  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     Вместо использования обработки исключений для ошибок использования можно использовать <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> метод для обнаружения ошибок использования в отладочных сборках <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> и метод для обнаружения ошибок использования в сборках отладки и выпуска. Дополнительные сведения см. в разделе [Утверждения в управляемом коде](/visualstudio/debugger/assertions-in-managed-code).  
  
-   **Ошибки программы.** Ошибка программы — это ошибка во время выполнения, которую не всегда можно избежать путем написания кода без ошибок.  
  
     В некоторых случаях ошибка программы может отражать ожидаемое или предполагаемое состояние ошибки. В этом случае может потребоваться избежать использования обработки исключений для устранения ошибок программы, а затем повторить операцию. Например, если пользователь должен ввести дату в определенном формате, можно проанализировать строку даты, вызвав <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> метод, который <xref:System.Boolean> возвращает значение, указывающее, была ли операция анализа успешной, вместо использования <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>метод, который вызывает <xref:System.FormatException> исключение, если строку даты невозможно <xref:System.DateTime> преобразовать в значение. Аналогично, если пользователь пытается открыть несуществующий файл, можно сначала вызвать <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> метод, чтобы проверить, существует ли файл, и, если нет, запросить у пользователя, нужно ли ему создать его.  
  
     В других случаях ошибка программы отражает непредвиденное условие ошибки, которое может быть обработано в коде. Например, даже если проверено, что файл существует, он может быть удален до его открытия или поврежден. В этом случае попытка открыть файл путем создания экземпляра <xref:System.IO.StreamReader> объекта или <xref:System.IO.File.Open%2A> вызова метода может вызвать <xref:System.IO.FileNotFoundException> исключение. В таких случаях для восстановления после ошибки следует использовать обработку исключений.  
  
-   **Сбои системы.** Сбой системы — это ошибка времени выполнения, которая не может быть обработана программно понятным образом. Например, любой метод может вызвать <xref:System.OutOfMemoryException> исключение, если среда CLR не может выделить дополнительную память. Обычно системные сбои не обрабатываются с помощью обработки исключений. Вместо этого можно использовать событие, например <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> , и <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> вызвать метод для регистрации сведений об исключениях и уведомить пользователя об ошибке до завершения работы приложения.  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Блоки try/catch  
 Среда CLR предоставляет модель обработки исключений, основанную на представлении исключений в виде объектов, а также разделении кода программы и кода обработки исключений на `try` блоки и `catch` блоки. Может существовать один или несколько `catch` блоков, каждый из которых предназначен для обработки определенного типа исключений, или один блок, предназначенный для перехвата более конкретного исключения, чем у другого блока.  
  
 Если приложение обрабатывает исключения, происходящие во время выполнения блока кода приложения, код должен быть помещен в `try` оператор и `try` называться блоком. Код приложения, обрабатывающий исключения, созданные `try` блоком, помещается `catch` в `catch` оператор и называется блоком. С блоком `catch` связано ноль или более блоков, и каждый `catch` блок включает фильтр типа, который определяет типы исключений, которые он обрабатывает. `try`  
  
 Когда в `try` блоке возникает исключение, система ищет связанные `catch` блоки в том порядке, в котором они отображаются в коде приложения, `catch` пока не обнаружит блок, обрабатывающий исключение. Блок обрабатывает исключение типа `T` , если фильтр типа блока catch указывает `T` или любой тип, `T` производный от. `catch` Система прекратит поиск после того, как обнаружит первый `catch` блок, обрабатывающий исключение. По этой причине в коде `catch` приложения блок, обрабатывающий тип, должен быть указан `catch` перед блоком, обрабатывающим его базовые типы, как показано в примере, который следует за этим разделом. Блок catch, дескрипторы `System.Exception` которого указаны последними.  
  
 Если ни один из `catch` блоков, связанных с текущим `try` блоком, не обрабатывает исключение, а `try` текущий блок вложен в `catch` другие `try` блоки в текущем вызове, блоки, связанные со следующим выполняется поиск включающего блока. `try` Если блок `catch` для исключения не найден, система выполняет поиск предыдущего уровня вложенности в текущем вызове. Если в `catch` текущем вызове не найдено ни одного блока для исключения, исключение передается вверх по стеку вызовов, а в предыдущем кадре стека выполняется `catch` Поиск блока, обрабатывающего исключение. Поиск в стеке вызовов продолжится до тех пор, пока не будет обработано исключение или пока в стеке вызовов не будут существовать кадры. Если начало стека вызовов достигается без поиска `catch` блока, обрабатывающего исключение, обработчик исключений по умолчанию обрабатывает его и завершает работу приложения.  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>Функции типов исключений  
 Типы исключений поддерживают следующие функции.  
  
-   Понятный для человека текст, описывающий ошибку. При возникновении исключения среда выполнения предоставляет доступ к текстовому сообщению для информирования пользователя о характере ошибки и предложения действия для решения проблемы. Это текстовое сообщение хранится в <xref:System.Exception.Message%2A> свойстве объекта исключения. Во время создания объекта исключения можно передать в конструктор текстовую строку для описания сведений об этом конкретном исключении. Если для конструктора не задан аргумент сообщения об ошибке, используется сообщение об ошибке по умолчанию. Дополнительные сведения см. в описании свойства <xref:System.Exception.Message%2A>.  
  
-   Состояние стека вызовов при возникновении исключения. <xref:System.Exception.StackTrace%2A> Свойство содержит трассировку стека, которую можно использовать для определения места возникновения ошибки в коде. В трассировке стека перечислены все вызываемые методы и номера строк в исходном файле, где выполняются вызовы.  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>Свойства класса Exception  
 <xref:System.Exception.Message%2A> <xref:System.Exception.Source%2A> <xref:System.Exception.HResult%2A> <xref:System.Exception.StackTrace%2A> <xref:System.Exception.HelpLink%2A> <xref:System.Exception.InnerException%2A>Класс включает ряд свойств, помогающих определить расположение кода, тип, файл справки и причину исключения:,,,,,, <xref:System.Exception> <xref:System.Exception.TargetSite%2A>и .<xref:System.Exception.Data%2A>  
  
 Если между двумя или более исключениями существует связь с причинами <xref:System.Exception.InnerException%2A> , это свойство поддерживает эти сведения. Внешнее исключение создается в ответ на это внутреннее исключение. Код, обрабатывающий внешнее исключение, может использовать сведения из предыдущего внутреннего исключения для более адекватной обработки ошибки. Дополнительные сведения об исключении могут храниться в виде коллекции пар "ключ-значение" в <xref:System.Exception.Data%2A> свойстве.  
  
 Строка сообщения об ошибке, которая передается конструктору во время создания объекта исключения, должна быть локализована и может быть предоставлена из файла ресурсов с <xref:System.Resources.ResourceManager> помощью класса. Дополнительные сведения о локализованных ресурсах см. в разделах [Создание вспомогательных сборок](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) и [Упаковка и развертывание ресурсов](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) .  
  
 Чтобы предоставить пользователю подробные сведения о причине возникновения исключения, <xref:System.Exception.HelpLink%2A> свойство может содержать URL-адрес (или URN) файла справки.  
  
 <xref:System.Exception> Класс использует COR_E_EXCEPTION HRESULT, имеющий значение 0x80131500.  
  
 Список начальных значений свойств для экземпляра <xref:System.Exception> класса см. в <xref:System.Exception.%23ctor%2A> разделе конструкторы.  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>Особенности производительности  
 Создание или обработка исключения требует значительного количества системных ресурсов и времени выполнения. Вызывайте исключения только для обработки действительно неисключительных условий, а не для обработки прогнозируемых событий или управления потоком. Например, в некоторых случаях, например при разработке библиотеки классов, разумно создать исключение, если аргумент метода является недопустимым, так как предполагается, что метод будет вызываться с допустимыми параметрами. Недопустимый аргумент метода, если он не является результатом ошибки использования, означает, что возникла непредвиденная ошибка. И наоборот, не вызывайте исключение, если ввод пользователя является недопустимым, так как вы можете рассчитывать, что пользователи иногда вводят недопустимые данные. Вместо этого предоставьте механизм повторных попыток, чтобы пользователи могли ввести допустимые входные данные. Кроме того, не следует использовать исключения для обработки ошибок использования. Вместо этого используйте [утверждения](/visualstudio/debugger/assertions-in-managed-code) для обнаружения и исправления ошибок использования.  
  
 Кроме того, не вызывайте исключение, если достаточно кода возврата; не преобразуйте код возврата в исключение; и не перехватывают исключение, игнорируйте его, а затем продолжайте обработку.  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>Повторное создание исключения  
 Во многих случаях обработчик исключений просто хочет передать исключение в вызывающий объект. Чаще всего это происходит в следующих случаях.  
  
-   Библиотека классов, которая, в свою очередь, заключает вызовы методов в библиотеку классов .NET Framework или другие библиотеки классов.  
  
-   Приложение или библиотека, вызывающая неустранимое исключение. Обработчик исключений может зарегистрировать исключение, а затем повторно создать исключение.  
  
 Чтобы повторно создать исключение, рекомендуется просто использовать оператор [throw](~/docs/csharp/language-reference/keywords/throw.md) в C# и инструкцию [throw](~/docs/visual-basic/language-reference/statements/throw-statement.md) в Visual Basic без включения выражения. Это гарантирует, что все сведения стека вызовов сохраняются при распространении исключения вызывающему объекту. Это показано в следующем примере. Метод расширения строки ( `FindOccurrences`) заключает в <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> оболочку один или несколько вызовов без проверки своих аргументов заранее.  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 Затем вызывающий объект `FindOccurrences` вызывается дважды. Во втором вызове `FindOccurrences`вызывающий объект передает в `null` качестве <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> строки поиска, в результате чего метод создает <xref:System.ArgumentNullException> исключение. Это исключение обрабатывается `FindOccurrences` методом и передается обратно вызывающему объекту. Поскольку оператор throw используется без выражения, выходные данные в примере показывают, что стек вызовов сохранен.  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 Напротив, если исключение создается повторно с помощью метода  
  
```csharp
throw e;
```  
  
```vb  
Throw e  
```  
  
 , полный стек вызовов не сохраняется, и в примере создается следующий результат:  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 Немного более громоздкий альтернативой является вызов нового исключения и сохранение сведений стека вызовов исходного исключения во внутреннем исключении. Затем вызывающий объект может использовать <xref:System.Exception.InnerException%2A> свойство нового исключения для получения кадра стека и других сведений об исходном исключении. В этом случае оператор Throw будет следующим:  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 Пользовательский код, обрабатывающий исключение, должен иметь представление о том <xref:System.Exception.InnerException%2A> , что свойство содержит сведения об исходном исключении, как показано в следующем обработчике исключений.  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>Выбор стандартных исключений  
 Если необходимо создать исключение, часто можно использовать существующий тип исключения в .NET Framework вместо реализации пользовательского исключения. В этих двух условиях следует использовать стандартный тип исключений.  
  
-   Создается исключение, вызванное ошибкой использования (то есть ошибкой в логике программы, выполняемой разработчиком, вызывающим метод). Как правило, создается исключение <xref:System.ArgumentException>, например <xref:System.InvalidOperationException>, <xref:System.ArgumentNullException>, или <xref:System.NotSupportedException>. Строка, предоставляемая конструктору объекта исключения при создании объекта исключения, должна описывать ошибку, чтобы разработчик мог ее исправить. Дополнительные сведения см. в описании свойства <xref:System.Exception.Message%2A>.  
  
-   Вы обрабатываете ошибку, которая может быть передана вызывающему объекту с существующим исключением .NET Framework. Рекомендуется создавать наиболее производное исключение. Например, если метод требует, чтобы аргумент был допустимым членом типа перечисления, следует вызвать <xref:System.ComponentModel.InvalidEnumArgumentException> исключение (самый производный класс), а не. <xref:System.ArgumentException>  
  
 В следующей таблице перечислены распространенные типы исключений и условия их создания.  
  
|Исключение|Условие|  
|---------------|---------------|  
|<xref:System.ArgumentException>|Непустой аргумент, передаваемый в метод, является недопустимым.|  
|<xref:System.ArgumentNullException>|Аргумент, передаваемый в метод, — `null`.|  
|<xref:System.ArgumentOutOfRangeException>|Аргумент находится за пределами диапазона допустимых значений.|  
|<xref:System.IO.DirectoryNotFoundException>|Недопустимая часть пути к каталогу.|  
|<xref:System.DivideByZeroException>|Знаменатель в операции деления или <xref:System.Decimal> целого числа равен нулю.|  
|<xref:System.IO.DriveNotFoundException>|Диск недоступен или не существует.|  
|<xref:System.IO.FileNotFoundException>|Файл не существует.|  
|<xref:System.FormatException>|Значение не находится в соответствующем формате для преобразования из строки методом преобразования, например `Parse`.|  
|<xref:System.IndexOutOfRangeException>|Индекс находится за пределами границ массива или коллекции.|  
|<xref:System.InvalidOperationException>|Вызов метода недопустим в текущем состоянии объекта.|  
|<xref:System.Collections.Generic.KeyNotFoundException>|Не удается найти указанный ключ для доступа к элементу в коллекции.|  
|<xref:System.NotImplementedException>|Метод или операция не реализованы.|  
|<xref:System.NotSupportedException>|Метод или операция не поддерживается.|  
|<xref:System.ObjectDisposedException>|Операция выполняется над объектом, который был ликвидирован.|  
|<xref:System.OverflowException>|Арифметическое, приведение или операция преобразования приводят к переполнению.|  
|<xref:System.IO.PathTooLongException>|Длина пути или имени файла превышает максимальную длину, определенную системой.|  
|<xref:System.PlatformNotSupportedException>|Операция не поддерживается на текущей платформе.|  
|<xref:System.RankException>|В метод передается массив с неправильным числом измерений.|  
|<xref:System.TimeoutException>|Срок действия интервала времени, выделенного для операции, истек.|  
|<xref:System.UriFormatException>|Используется недопустимый универсальный код ресурса (URI).|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>Реализация пользовательских исключений  
 В следующих случаях использование существующего исключения .NET Framework для обработки состояния ошибки неадекватно:  
  
-   Если исключение отражает уникальную ошибку программы, которая не может быть сопоставлена с существующим исключением .NET Framework.  
  
-   Если для исключения требуется обработка, которая отличается от обработки, подходящей для существующего исключения .NET Framework, или исключение должно быть неоднозначной из аналогичного исключения. Например, если при синтаксическом анализе <xref:System.ArgumentOutOfRangeException> числового представления строки, находящейся за пределами диапазона целевого целочисленного типа, возникает исключение, то не нужно использовать то же исключение для ошибки, полученной от вызывающей стороны, не предоставляющей соответствующие ограниченные значения при вызове метода.  
  
 <xref:System.Exception> Класс является базовым классом всех исключений в .NET Framework. Многие производные классы основываются на наследуемом поведении членов <xref:System.Exception> класса; они не переопределяют <xref:System.Exception>члены, а также не определяют уникальные члены.  
  
 Определение собственного класса исключений:  
  
1.  Определите класс, наследующий от <xref:System.Exception>. При необходимости определите все уникальные элементы, необходимые для класса, чтобы предоставить дополнительные сведения об исключении. Например, <xref:System.ArgumentException> класс <xref:System.ArgumentException.ParamName%2A> включает свойство, указывающее имя параметра, аргумент которого вызывал исключение, <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> а <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> свойство содержит свойство, указывающее интервал времени ожидания.  
  
2.  При необходимости переопределите все унаследованные члены, функциональность которых требуется изменить или изменить. Обратите внимание, что большинство существующих <xref:System.Exception> производных классов не переопределяют поведение наследуемых членов.  
  
3.  Определите, является ли пользовательский объект исключения сериализуемым. Сериализация позволяет сохранять сведения об исключении и позволяет совместно использовать данные исключений сервером и прокси клиента в контексте удаленного взаимодействия. Чтобы сделать объект исключения сериализуемым, пометьте его <xref:System.SerializableAttribute> атрибутом.  
  
4.  Определите конструкторы класса исключений. Как правило, классы исключений имеют один или несколько следующих конструкторов:  
  
    -   <xref:System.Exception.%23ctor>, который использует значения по умолчанию для инициализации свойств нового объекта исключения.  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>, который инициализирует новый объект исключения с указанным сообщением об ошибке.  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, который инициализирует новый объект исключения с указанным сообщением об ошибке и внутренним исключением.  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>— `protected` это конструктор, инициализирующий новый объект исключения из сериализованных данных. Этот конструктор следует реализовать, если вы решили сделать объект исключения сериализуемым.  
  
 В следующем примере показано использование класса пользовательского исключения. Он определяет `NotPrimeException` исключение, которое создается, когда клиент пытается получить последовательность простых чисел, указав начальный номер, который не является простым. Исключение определяет новое свойство `NonPrime`, которое возвращает непростое число, которое привело к исключению. <xref:System.Runtime.Serialization.SerializationInfo> Помимо реализации защищенного конструктора без параметров и конструктора с `NotPrimeException` параметрами и <xref:System.Runtime.Serialization.StreamingContext> для сериализации, класс `NonPrime` определяет три дополнительных конструктора для поддержки свойства.  Каждый конструктор вызывает конструктор базового класса, а также сохраняет значение непростого числа. Класс также помечается <xref:System.SerializableAttribute>атрибутом. `NotPrimeException`  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 `PrimeNumberGenerator` Класс, показанный в следующем примере, использует Сиеве из ератоссенес для вычисления последовательности простых чисел из 2 в предел, заданный клиентом при вызове его конструктора класса. Метод возвращает все простые числа, которые больше или равны указанному нижнему пределу, но `NotPrimeException` выдает исключение, если нижний предел не является простым числом. `GetPrimesFrom`  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 В следующем примере выполняется два вызова `GetPrimesFrom` метода с непростыми числами, один из которых пересекают границы домена приложения. В обоих случаях исключение вызывается и успешно обрабатывается в клиентском коде.  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>среда выполнения Windows и[!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 В [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] для[!INCLUDE[win8](~/includes/win8-md.md)]некоторые сведения об исключении обычно теряются при распространении исключения через кадры стека non-.NET Framework. Начиная с [!INCLUDE[net_v451](~/includes/net-v451-md.md)] версии и [!INCLUDE[win81](~/includes/win81-md.md)]среда CLR по-своему использует исходный <xref:System.Exception> объект, который был создан, если это исключение не было изменено в кадре стека non-.NET Framework.  
  
   
  
## Examples  
 В следующем примере показан `catch` блок, определенный для обработки <xref:System.ArithmeticException> ошибок. Этот `catch` блок также <xref:System.DivideByZeroException> перехватывает ошибки, так <xref:System.DivideByZeroException> как является производным от <xref:System.ArithmeticException> и не `catch` существует блока, явно <xref:System.DivideByZeroException> определенного для ошибок.  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">Обработка и создание исключений</related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Упаковка и развертывание ресурсов в приложениях для настольных систем</related>
    <related type="Article" href="https://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">Утверждения в управляемом коде</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Exception" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Exception" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует свойство <xref:System.Exception.Message%2A> нового экземпляра, используя системное сообщение, которое описывает ошибку и учитывает текущий язык и региональные параметры системы.  
  
 Все производные классы должны предоставлять этот конструктор без параметров. В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.Exception>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Пустая ссылка (`Nothing` в Visual Basic).|  
|<xref:System.Exception.Message%2A>|Локализованное описание, предоставляемое системой.|  
  
   
  
## Examples  
 В следующем примере кода создается производный `Exception` объект, использующий предопределенное сообщение. В коде демонстрируется использование конструктора без параметров для производного класса и базового `Exception` класса.  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение, описывающее ошибку.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Exception" /> с указанным сообщением об ошибке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует <xref:System.Exception.Message%2A> свойство нового экземпляра с `message` помощью параметра. Если параметр имеет `null`значение, это <xref:System.Exception.%23ctor%2A> то же самое, что и вызов конструктора. `message`  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.Exception>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Пустая ссылка (`Nothing` в Visual Basic).|  
|<xref:System.Exception.Message%2A>|Строка сообщения об ошибке.|  
  
   
  
## Examples  
 Следующий пример кода является производным `Exception` для определенного условия. В коде демонстрируется использование конструктора, который принимает в качестве параметра сообщение, указанное вызывающим объектом, как для производного класса, так и `Exception` для базового класса.  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, хранящий сериализованные данные объекта, относящиеся к выдаваемому исключению.</param>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий контекстные сведения об источнике или назначении.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Exception" /> с сериализованными данными.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный конструктор вызывается в процессе десериализации для воссоздания объекта исключения, переданного в потоке. Дополнительные сведения см. в разделе [сериализация XML и SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
   
  
## Examples  
 В следующем примере кода определяется производный сериализуемый `Exception` класс. Код вызывает ошибку деления на 0, а затем создает экземпляр производного исключения с помощью конструктора (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>). Код сериализует экземпляр в файл, десериализует его в новое исключение, которое оно создает, а затем перехватывает и отображает данные исключения.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="info" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Имя класса — <see langword="null" />, или значение свойства <see cref="P:System.Exception.HResult" /> равно нулю (0).</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Сериализация XML и SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение об ошибке, указывающее причину создания исключения.</param>
        <param name="innerException">Исключение, вызвавшее текущее исключение, или указатель null (<see langword="Nothing" /> в Visual Basic), если внутреннее исключение не задано.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Exception" /> указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее данное исключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Исключение, созданное как прямой результат предыдущего исключения, должно содержать в свойстве <xref:System.Exception.InnerException%2A> ссылку на предыдущее исключение. Свойство <xref:System.Exception.InnerException%2A> возвращает то же значение, которое передается конструктору, или пустую ссылку (`Nothing` в Visual Basic), если свойство <xref:System.Exception.InnerException%2A> не предоставляет конструктору значение внутреннего исключения.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.Exception>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Ссылка на внутреннее исключение.|  
|<xref:System.Exception.Message%2A>|Строка сообщения об ошибке.|  
  
   
  
## Examples  
 Следующий пример кода является производным `Exception` для определенного условия. В коде демонстрируется использование конструктора, который принимает сообщение и внутреннее исключение как параметры как для производного класса, так и для базового `Exception` класса.  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию пар ключ/значение, предоставляющие дополнительные сведения об исключении, определяемые пользователем.</summary>
        <value>Объект, который реализует интерфейс <see cref="T:System.Collections.IDictionary" /> и содержит в себе коллекцию пар "ключ-значение". По умолчанию является пустой коллекцией.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте объект, возвращаемый свойством, для хранения и получения дополнительных сведений, относящихся к исключению. <xref:System.Exception.Data%2A> <xref:System.Collections.IDictionary?displayProperty=nameWithType> Сведения представляются в виде произвольного числа пар "ключ-значение", определяемых пользователем. Ключевым компонентом каждой пары «ключ-значение» обычно является идентифицирующая строка, тогда как компонент value пары может быть любым типом объекта.  
  
## <a name="keyvalue-pair-security"></a>Безопасность пар "ключ — значение"  
 Пары "ключ-значение", хранящиеся в коллекции, <xref:System.Exception.Data%2A> возвращаемой свойством, не являются безопасными. Если приложение вызывает вложенную последовательность подпрограмм и каждая подпрограммы содержит обработчики исключений, результирующий стек вызовов содержит иерархию этих обработчиков исключений. Если подпрограммы более низкого уровня выдают исключение, любой обработчик исключений верхнего уровня в иерархии стека вызовов может считывать и (или) изменять пары "ключ-значение", хранящиеся в коллекции любым другим обработчиком исключений. Это означает, что вы должны гарантировать, что информация в парах "ключ-значение" не является конфиденциальной и что приложение будет работать правильно, если информация в парах "ключ-значение" повреждена.  
  
## <a name="key-conflicts"></a>Конфликты ключей  
 Конфликт ключей возникает, когда разные обработчики исключений задают один и тот же ключ для доступа к паре «ключ-значение». Будьте внимательны при разработке приложения, поскольку следствием конфликта ключей является то, что обработчики исключений низкого уровня могут случайно взаимодействовать с обработчиками исключений более высокого уровня, и это взаимодействие может привести к незаметному возникновению ошибок программы. Тем не менее, если вы соблюдаем осторожность, можно использовать конфликты ключей для улучшения приложения.  
  
## <a name="avoiding-key-conflicts"></a>Предотвращение конфликтов ключей  
 Избегайте конфликтов ключей, принимая соглашение об именовании для создания уникальных ключей для пар "ключ-значение". Например, соглашение об именовании может дать ключ, состоящий из имени приложения, разделенного точками, метода, который предоставляет дополнительные сведения о паре, и уникальный идентификатор.  
  
 Предположим, что два приложения, именуемые Products и поставщики, имеют метод с именем Sales. Метод Sales в приложении Products предоставляет идентификационный номер (единицу складского учета или номер SKU) продукта. Метод Sales в приложении поставщики предоставляет идентификационный номер или идентификатор безопасности поставщика. Следовательно, в соглашении об именовании в этом примере выдаются ключи «Products. Sales. SKU» и «поставщики. Sales. SID».  
  
## <a name="exploiting-key-conflicts"></a>Использование конфликтов ключей  
 Конфликты ключей эксплойтов с помощью наличия одного или нескольких специальных, предопределенных ключей для управления обработкой. Предположим, что в одном сценарии обработчик исключений высшего уровня в иерархии стека вызовов перехватывает все исключения, порождаемые обработчиками исключений низкого уровня. Если пара ключ/значение с особым ключом существует, обработчик исключений высокого уровня форматирует оставшиеся пары "ключ-значение" в <xref:System.Collections.IDictionary> объекте нестандартным образом. в противном случае остальные пары "ключ-значение" форматируются обычным способом.  
  
 Теперь предположим, что в другом сценарии обработчик исключений на каждом уровне иерархии стека вызовов перехватывает исключение, выдаваемое следующим обработчиком исключений более низкого уровня. Кроме того, каждый обработчик исключений знает, что коллекция, возвращаемая <xref:System.Exception.Data%2A> свойством, содержит набор пар "ключ-значение", доступ к которым можно получить с помощью предустановленного набора ключей.  
  
 Каждый обработчик исключений использует предустановленный набор ключей, чтобы обновить компонент значения соответствующей пары «ключ-значение» данными, уникальными для этого обработчика исключений. После завершения процесса обновления обработчик исключений создает исключение для следующего обработчика исключений более высокого уровня. Наконец, обработчик исключений самого высокого уровня обращается к парам "ключ-значение" и отображает объединенные сведения об обновлении из всех обработчиков исключений нижнего уровня.  
  
   
  
## Examples  
 В следующем примере показано, как добавлять и получать сведения с помощью <xref:System.Exception.Data%2A> свойства.  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает исключение <see cref="T:System.Exception" />, которое является корневой причиной одного или нескольких последующих исключений.</summary>
        <returns>В цепочке исключений создается первое исключение. Если свойством <see cref="P:System.Exception.InnerException" /> текущего исключения является пустая ссылка (<see langword="Nothing" /> в Visual Basic), это свойство возвращает текущее исключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Цепочка исключений состоит из набора исключений таким образом, что каждое исключение в цепочке было создано как прямой результат исключения, на который ссылается `InnerException` свойство. Для данной цепочки может существовать только одно исключение, которое является основной причиной всех других исключений в цепочке. Это исключение называется базовым исключением, а `InnerException` его свойство всегда содержит пустую ссылку.  
  
 Для всех исключений в цепочке исключений `GetBaseException` метод должен возвращать один и тот же объект (базовое исключение).  
  
 Используйте метод `GetBaseException` , если необходимо найти основную причину исключения, но не требуются сведения об исключениях, которые могли возникнуть между текущим исключением и первым исключением.  
  
   
  
## Examples  
 В следующем примере кода определяются два `Exception` производных класса. Он вызывает исключение, а затем снова создает его с каждым из производных классов. В коде показано использование `GetBaseException` метода для получения исходного исключения.  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see langword="GetBaseException" /> Метод переопределяется в классах, которым требуется управление содержимым или форматом исключения.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, хранящий сериализованные данные объекта, относящиеся к выдаваемому исключению.</param>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий контекстные сведения об источнике или назначении.</param>
        <summary>При переопределении в производном классе задает сведения об исключении для <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `GetObjectData` загружает в объект <xref:System.Runtime.Serialization.SerializationInfo> все данные объекта исключения, предназначенные для сериализации. В процессе десериализации исключение воссоздается из объекта `SerializationInfo`, переданного в потоке.  
  
   
  
## Examples  
 В следующем примере кода определяется производный сериализуемый `Exception` класс, реализующий `GetObjectData`метод, который вносит небольшие изменения в два свойства, а затем вызывает базовый класс для выполнения сериализации. В примере вызывается ошибка деления на 0, а затем создается экземпляр производного исключения. Код сериализует экземпляр в файл, десериализует его в новое исключение, которое оно создает, а затем перехватывает и отображает данные исключения.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значением параметра <paramref name="info" /> является пустая ссылка (<see langword="Nothing" /> в Visual Basic).</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает тип среды выполнения текущего экземпляра.</summary>
        <returns>Объект <see cref="T:System.Type" />, представляющий точный тип среды выполнения текущего экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод существует для поддержки инфраструктуры .NET Framework и внутренним образом вызывает фундаментальный <xref:System.Object.GetType%2A?displayProperty=nameWithType>метод. <xref:System.Exception.GetType%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает ссылку на файл справки, связанный с этим исключением.</summary>
        <value>URN или URL-адрес.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемым значением, представляющим файл справки, является URN или URL-адрес. Например, `HelpLink` значение может быть следующим:  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 В следующем примере кода создается `Exception` исключение, которое `HelpLink` задает свойство в своем конструкторе, а затем перехватывает исключение и `HelpLink`отображает.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает HRESULT — кодированное числовое значение, присвоенное определенному исключению.</summary>
        <value>Значение HRESULT.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT — это 32-разрядное значение, разделенное на три разных поля: код серьезности, код средства и код ошибки. Код серьезности указывает, представляет ли возвращаемое значение сведения, предупреждение или ошибку. Код устройства определяет область системы, ответственную за ошибку. Код ошибки — это уникальный номер, который назначается для представления исключения. Каждое исключение сопоставляется с отдельным значением HRESULT. Когда управляемый код создает исключение, среда выполнения передает HRESULT клиенту COM. Если неуправляемый код возвращает ошибку, значение HRESULT преобразуется в исключение, которое затем выдается средой выполнения. Сведения о значениях HRESULT и соответствующих .NET Framework исключениях см. [в разделе как Сопоставьте HRESULTs и Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md). Список наиболее часто встречающихся значений см. в разделе [Общие значения HRESULT](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) в документации по Windows.  
  
 Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)] <xref:System.Exception.HResult%2A> , метод задания свойства защищен, в то время как его метод получения является открытым.  В предыдущих версиях .NET Framework и метод получения, и метод задания защищены.  
  
   
  
## Examples  
 В следующем примере кода определяется производный `Exception` класс, который `HResult` задает для свойства пользовательское значение в конструкторе.  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">Практическое руководство. Сопоставление значений HRESULT и исключений</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">Общие значения HRESULT</related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает экземпляр класса <see cref="T:System.Exception" />, который вызвал текущее исключение.</summary>
        <value>Объект, описывающий ошибку, которая вызвала текущее исключение. Свойство <see cref="P:System.Exception.InnerException" /> возвращает то же значение, что было передано в конструктор <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> , или значение <see langword="null" /> , если конструктору не было передано значение внутреннего исключения. Это свойство доступно только для чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `X` исключение создается как прямой результат предыдущего исключения `Y`, <xref:System.Exception.InnerException%2A> свойство объекта `X` должно содержать ссылку на `Y`.  
  
 Свойство <xref:System.Exception.InnerException%2A> используется, чтобы получить набор исключений, ставших причиной текущего исключения.  
  
 Можно создать новое исключение, которое перехватывает предыдущее исключение. Код, обрабатывающий второе исключение, может использовать дополнительные сведения из предыдущего исключения для более адекватной обработки ошибки.  
  
 Предположим, что имеется функция, которая считывает файл и форматирует данные из этого файла. В этом примере, когда код пытается прочитать файл, <xref:System.IO.IOException> создается исключение. Функция перехватывает <xref:System.IO.IOException> и <xref:System.IO.FileNotFoundException>создает исключение. Можно сохранить <xref:System.IO.FileNotFoundException>в свойстве, включив код, который перехватывает объект <xref:System.IO.FileNotFoundException> , чтобы проверить причину первоначальной ошибки. <xref:System.Exception.InnerException%2A> <xref:System.IO.IOException>  
  
 <xref:System.Exception.InnerException%2A> Свойство, содержащее ссылку на внутреннее исключение, задается при инициализации объекта исключения.  
  
   
  
## Examples  
 В следующем примере демонстрируется создание и перехват исключения, ссылающегося на внутреннее исключение.  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает сообщение, описывающее текущее исключение.</summary>
        <value>Сообщение об ошибке с объяснением причин исключения или пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сообщения об ошибках предназначены для разработчика, который обрабатывает исключение. Текст <xref:System.Exception.Message%2A> свойства должен полностью описывать ошибку и, по возможности, также объяснить, как исправить ошибку. Обработчики исключений верхнего уровня могут отображать сообщение для конечных пользователей, поэтому следует убедиться, что оно грамматически правильно и каждое предложение сообщения заканчивается точкой. Не используйте вопросительные знаки или восклицательные точки. Если приложение использует локализованные сообщения об исключениях, следует убедиться, что они правильно переведены.  
  
> [!IMPORTANT]
>  Не раскрывайте конфиденциальные данные в сообщениях об исключениях без проверки соответствующих разрешений.  
  
 Значение <xref:System.Exception.Message%2A> свойства включается в сведения, <xref:System.Exception.ToString%2A>возвращаемые. Свойство задается только при создании объекта <xref:System.Exception>. <xref:System.Exception.Message%2A> Если в конструктор для текущего экземпляра не было предоставлено сообщение, система предоставляет сообщение по умолчанию, которое форматируется с использованием текущего языка и региональных параметров системы.  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>среда выполнения Windows и[!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 Начиная с [!INCLUDE[net_v451](~/includes/net-v451-md.md)] и [!INCLUDE[win81](~/includes/win81-md.md)], улучшена точность сообщений об ошибках из исключений, распространяемых из среда выполнения Windows типов и членов, которые не являются частью .NET Framework. В частности, сообщения об исключениях C++ из расширений визуальных компонентов (C++/CX) теперь передаются <xref:System.Exception> обратно в объекты .NET Framework.  
  
   
  
## Examples  
 В следующем примере кода возникает исключение, а затем перехватывается <xref:System.Exception> и выводится текстовое сообщение исключения <xref:System.Exception.Message%2A> с помощью свойства.
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы выдаете исключение из свойства и вам нужно ссылаться в тексте <see cref="P:System.Exception.Message" /> на заданный или полученный аргумент свойства, используйте "value" в качестве имени аргумента свойства.</para></block>
        <block subset="none" type="overrides"><para><see cref="P:System.Exception.Message" /> Свойство переопределяется в классах, требующих управления содержимым сообщений или форматом. Код приложения обычно получает доступ к этому свойству, когда ему требуется отобразить сведения об исключении, которое было перехвачено.  
  
Сообщение об ошибке должно быть локализовано.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает, когда исключение сериализовано для создания объекта состояния исключения, содержащего сериализованные данные об исключении.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект состояния исключения реализует <xref:System.Runtime.Serialization.ISafeSerializationData> интерфейс.  
  
 <xref:System.Exception.SerializeObjectState> Когда событие подписано на, исключение десериализуется и создается как пустое исключение. Конструктор исключения не выполняется, и состояние исключения также десериализуется. Затем <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> метод обратного вызова объекта состояния исключения получает уведомление, чтобы он мог отправить десериализованные данные в пустое исключение.  
  
 <xref:System.Exception.SerializeObjectState> Событие включает прозрачные типы исключений для сериализации и десериализации данных исключений. Прозрачный код может выполнять команды внутри границ набора разрешений, в котором он работает, но не может выполнять, вызывать, наследовать от или содержать критически важный код.  
  
 Если событие не подписано на, то десериализация выполняется как обычно <xref:System.Exception.%23ctor%2A> с помощью конструктора. <xref:System.Exception.SerializeObjectState>  
  
 Как правило, обработчик <xref:System.Exception.SerializeObjectState> события добавляется в конструктор исключения для предоставления его сериализации. Но поскольку конструктор не выполняется при <xref:System.Exception.SerializeObjectState> выполнении обработчика событий, сериализация десериализованного исключения может <xref:System.Runtime.Serialization.SerializationException> вызвать исключение при попытке десериализовать исключение. Чтобы избежать этого, следует также добавить обработчик для <xref:System.Exception.SerializeObjectState> события <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> в методе. Иллюстрации см. в разделе "примеры".  
  
   
  
## Examples  
 В следующем примере определяется объект `BadDivisionException` , <xref:System.Exception.SerializeObjectState> обрабатывающий событие. Он также содержит объект состояния, который является вложенной структурой с `BadDivisionExceptionState` именем, <xref:System.Runtime.Serialization.ISafeSerializationData> реализующей интерфейс.  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 `BadDivisionException` Исключение возникает при возникновении деления на ноль с плавающей запятой. Во время первого деления на ноль в примере создается `BadDivisionException` объект, сериализуется и создается исключение. При последующих делениях на ноль в примере выполняется десериализация ранее сериализованного объекта, повторная сериализация и исключение. Чтобы обеспечить сериализацию объектов, десериализацию, сериализацию и десериализацию, в примере добавляется <xref:System.Exception.SerializeObjectState> обработчик событий как `BadDivisionException` в конструкторе <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> класса, так и в реализации.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если это событие подписано и используется, все производные типы, следующие за иерархией наследования, должны реализовывать тот же механизм сериализации.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя приложения или объекта, вызывавшего ошибку.</summary>
        <value>Имя приложения или объекта, вызвавшего ошибку.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.Source%2A> Если свойство не задано явным образом, среда выполнения автоматически задает для него имя сборки, в которой возникло исключение.  
  
   
  
## Examples  
 В следующем примере создается `Exception` исключение, которое `Source` задает свойство в конструкторе, а затем перехватывает исключение и отображает `Source`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Объект должен быть объектом среды выполнения <see cref="N:System.Reflection" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает строковое представление непосредственных кадров в стеке вызова.</summary>
        <value>Строка, описывающая непосредственные фреймы стека вызова.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В стеке выполнения отслеживаются все методы, выполняемые в данный момент времени. Трассировка вызовов метода называется трассировкой стека. Список трассировки стека позволяет отслеживать стек вызовов до номера строки в методе, где возникает исключение.  
  
 <xref:System.Exception.StackTrace%2A> Свойство возвращает кадры стека вызовов, которые происходят в том месте, где было создано исключение. Сведения о дополнительных кадрах в стеке вызовов можно получить, создав новый экземпляр <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> класса и используя его <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> метод.  
  
 Среда CLR обновляет трассировку стека всякий раз, когда в коде приложения создается исключение (с помощью `throw` ключевого слова). Если исключение было повторно создано в методе, отличном от метода, в котором он был изначально вызван, трассировка стека содержит как расположение в методе, где было создано исключение, и расположение в методе, где возникло исключение. снова. Если возникло исключение, а позднее повторно выбрасывается в том же методе, трассировка стека содержит только расположение, в котором было повторно создано исключение, и не включает место первоначального возникновения исключения.  
  
 <xref:System.Exception.StackTrace%2A> Свойство может не сообщать о количестве вызовов методов, ожидаемых из-за преобразований кода, таких как встраивание, которые происходят во время оптимизации.  
  
   
  
## Examples  
 Следующий пример кода создает `Exception` исключение, а затем перехватывает его и отображает трассировку стека `StackTrace` с помощью свойства.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see langword="StackTrace" /> Свойство переопределяется в классах, требующих управления содержимым или форматом трассировки стека.  
  
По умолчанию трассировка стека записывается непосредственно перед созданием объекта исключения. Используется <see cref="P:System.Environment.StackTrace" /> для получения сведений о трассировке стека, когда исключение не создается.</para></block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает метод, создавший текущее исключение.</summary>
        <value>Метод <see cref="T:System.Reflection.MethodBase" />, выбрасывающий текущее исключение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если метод, который создает это исключение, недоступен и трассировка стека не является пустой ссылкой`Nothing` (в Visual Basic) <xref:System.Exception.TargetSite%2A> , то метод получается из трассировки стека. Если трассировка стека является нулевой ссылкой, то <xref:System.Exception.TargetSite%2A> также возвращает нулевую ссылку.  
  
> [!NOTE]
>  <xref:System.Exception.TargetSite%2A> Свойство может неточно сообщать имя метода, в котором было создано исключение, если обработчик исключений обрабатывает исключение через границы домена приложения.  
  
   
  
## Examples  
 Следующий пример кода создает `Exception` исключение, а затем перехватывает его и отображает исходный метод `TargetSite` с помощью свойства.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает и возвращает строковое представление текущего исключения.</summary>
        <returns>Строковое представление текущего исключения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A>Возвращает представление текущего исключения, которое должно быть понятным для человека. Если исключение содержит данные, зависящие от языка и региональных параметров, то `ToString` строковое представление, возвращаемое, должно учитывать текущий язык и региональные параметры системы. Хотя нет точных требований к формату возвращаемой строки, она должна попытаться отразить значение объекта, принятое пользователем.  
  
 Реализация <xref:System.Exception.ToString%2A> по умолчанию получает имя класса, который выдал текущее исключение, сообщение, результат вызова <xref:System.Exception.ToString%2A> для внутреннего исключения и результат вызова метода <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>. Если какой-либо из этих `null`членов является, его значение не включается в возвращаемую строку.  
  
 Если сообщение об ошибке отсутствует или является пустой строкой (""), сообщение об ошибке не возвращается. Имя внутреннего исключения и трассировка стека возвращаются только в том случае, если это не `null`так.  
  
 Этот метод переопределяет метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере вызывается исключение и отображается результат вызова <xref:System.Exception.ToString%2A> для этого исключения. Обратите внимание <xref:System.Exception.ToString%2A?displayProperty=nameWithType> , что метод вызывается неявно, когда экземпляр класса Exception появляется в списке <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> аргументов метода.  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
