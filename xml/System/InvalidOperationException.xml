<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9a550eb5984bf3ed381bcb8fe1f3978618ab7996" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75172717" /></Metadata><TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : SystemException" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Исключение, которое выдается при вызове метода, недопустимого для текущего состояния объекта.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> используется в случаях, когда сбой вызова метода вызван по причинам, отличным от недопустимых аргументов. Как правило, он вызывается, когда состояние объекта не поддерживает вызов метода. Например, исключение <xref:System.InvalidOperationException> вызывается такими методами, как:  
  
-   <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType>, если объекты коллекции изменяются после создания перечислителя. Дополнительные сведения см. [в разделе изменение коллекции во время итерации](#Iterating).  
  
-   <xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType>, если набор ресурсов закрыт до вызова метода.  
  
-   <xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>, если добавляемый объект или объекты приведут к неправильному структурированному XML-документу.  
  
-   Метод, который пытается управлять пользовательским интерфейсом из потока, который не является основным потоком или потоком пользовательского интерфейса.  
  
> [!IMPORTANT]
>  Поскольку исключение <xref:System.InvalidOperationException> может вызываться в самых разных обстоятельствах, важно прочитать сообщение об исключении, возвращенное свойством <xref:System.Exception.Message%2A>.  
  
 В этом разделе  
  
 [Некоторые распространенные причины исключений InvalidOperationException](#Causes)   
 [Обновление потока пользовательского интерфейса из потока, не относящегося к пользовательскому интерфейсу](#UI)  
 [Изменение коллекции во время ее итерации](#Iterating)  
 [Сортировка массива или коллекции, объекты которой невозможно сравнить](#Sorting)  
 [Приведение Nullable&lt;t&gt;, который имеет значение null, к базовому типу](#Nullable)   
 [Вызов метода System. LINQ. Enumerable для пустой коллекции](#Empty)  
 [Вызов Enumerable. Single или Enumerable. SingleOrDefault для последовательности без одного элемента](#Single)  
 [Динамическое обращение к полю домена между приложениями](#Emit)  
[Создание исключения InvalidOperationException](#Throwing)  
[Прочие сведения](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a>Некоторые распространенные причины исключений InvalidOperationException  
 В следующих разделах показано, как часто возникают ситуации, в которых в приложении <xref:System.InvalidOperationException> исключение. Способ решения проблемы зависит от конкретной ситуации. Однако чаще всего исключение возникает из ошибки разработчика, и <xref:System.InvalidOperationException> может быть ожидаемым и избегать.  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a>Обновление потока пользовательского интерфейса из потока, не относящегося к пользовательскому интерфейсу  
 Часто рабочие потоки используются для выполнения некоторой фоновой работы, включающей сбор данных, отображаемых в пользовательском интерфейсе приложения. Несмотря. Большинство платформ приложений графического пользовательского интерфейса (графический интерфейс пользователя) для .NET Framework, таких как Windows Forms и Windows Presentation Foundation (WPF), позволяют получать доступ к объектам графического пользовательского интерфейса только из потока, который создает пользовательский интерфейс и управляет им (основным потоком или потоком пользовательского интерфейса). При попытке доступа к элементу пользовательского интерфейса из потока, отличного от потока пользовательского интерфейса, выдается <xref:System.InvalidOperationException>.  Текст сообщения об исключении показан в следующей таблице.  
  
|Тип приложения|Message|  
|----------------------|-------------|  
|Приложение WPF|**Вызывающий поток не может получить доступ к этому объекту, так как он принадлежит другому потоку.**|  
|Приложение UWP|**Приложение называется интерфейсом, который был маршалирован для другого потока.**|  
|Приложение Windows Forms|**Недопустимая операция между потоками: доступ к элементу управления "TextBox1" осуществляется из потока, отличного от потока, в котором он был создан.**|  
  
 Платформы пользовательского интерфейса для .NET Framework реализуют шаблон *Dispatcher* , который включает метод для проверки того, выполняется ли вызов элемента пользовательского интерфейса в ПОТОКЕ пользовательского интерфейса, а также другие методы для планирования вызова в ПОТОКЕ пользовательского интерфейса:  
  
-   В приложениях WPF вызовите метод <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType>, чтобы определить, выполняется ли метод в потоке без пользовательского интерфейса. Он возвращает `true`, если метод работает в потоке пользовательского интерфейса и `false` в противном случае. Вызовите одну из перегрузок метода <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType>, чтобы запланировать вызов в потоке пользовательского интерфейса.  
  
-   В приложениях UWP проверьте свойство <xref:Windows.UI.Core.CoreDispatcher.HasThreadAccess?displayProperty=nameWithType>, чтобы определить, выполняется ли метод в потоке, не являющемся потоком интерфейса. Вызовите метод <xref:Windows.UI.Core.CoreDispatcher.RunAsync%2A?displayProperty=nameWithType> для выполнения делегата, который обновляет поток пользовательского интерфейса. 
  
-   В Windows Forms приложениях используйте свойство <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType>, чтобы определить, выполняется ли метод в потоке без пользовательского интерфейса. Вызовите одну из перегрузок метода <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> для выполнения делегата, который обновляет поток пользовательского интерфейса.  
  
 В следующих примерах показано исключение <xref:System.InvalidOperationException>, возникающее при попытке обновить элемент пользовательского интерфейса из потока, отличного от создавшего его потока.  Для каждого примера необходимо создать два элемента управления:  
  
-   Элемент управления "текстовое поле" с именем `textBox1`.  В Windows Forms приложении следует задать для свойства <xref:System.Windows.Forms.TextBox.Multiline%2A> значение `true`.  
  
-   Элемент управления "Кнопка" с именем `threadExampleBtn`. В примере показан обработчик `ThreadsExampleBtn_Click`для события `Click` кнопки.  
  
 В каждом случае обработчик событий `threadExampleBtn_Click` вызывает метод `DoSomeWork` дважды. Первый вызов выполняется синхронно и завершился. Но второй вызов, поскольку он выполняется асинхронно в потоке пула потоков, пытается обновить пользовательский интерфейс из потока, не относящегося к пользовательскому интерфейсу. Это приводит к возникновению исключения <xref:System.InvalidOperationException>.  
  
 Приложения WPF и UWP  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 Следующая версия метода `DoSomeWork` устраняет исключение в приложении WPF.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 Следующая версия метода `DoSomeWork` устраняет исключение в приложении UWP.  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 Приложения Windows Forms  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 Следующая версия метода `DoSomeWork` устраняет исключение в Windows Forms приложении.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a>Изменение коллекции во время ее итерации  
 Оператор `foreach` в C# операторе или `For Each` в Visual Basic используется для итерации элементов коллекции и чтения или изменения отдельных элементов. Однако его нельзя использовать для добавления или удаления элементов из коллекции. При этом создается исключение <xref:System.InvalidOperationException> с сообщением, похожее на "**коллекция была изменена; Операция перечисления не может быть выполнена ".**  
  
 В следующем примере выполняется итерация коллекции целых чисел, которая пытается добавить квадрат каждого целого числа в коллекцию. В примере создается <xref:System.InvalidOperationException> с первым вызовом метода <xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 Исключение можно устранить одним из двух способов, в зависимости от логики приложения:  
  
-   Если во время итерации необходимо добавить элементы в коллекцию, можно выполнить итерацию по индексу, используя инструкцию `for`, а не `foreach` или `For Each`. В следующем примере оператор for используется для добавления квадрата чисел из коллекции в коллекцию.  
  
     [!code-csharp[System.InvalidOperationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs#2)]
     [!code-vb[System.InvalidOperationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb#2)]  
  
     Обратите внимание, что перед перебором коллекции необходимо установить число итераций с помощью счетчика внутри цикла, который будет правильно завершать цикл, по проходу назад, от `Count`-1 до 0 или, как показано в примере, путем присвоения числового элемента в переменной и его использования для установки верхней границы цикла. В противном случае, если элемент добавляется в коллекцию при каждой итерации, будет получен бесконечный цикл.  
  
-   Если нет необходимости добавлять элементы в коллекцию во время итерации, можно сохранить элементы, добавляемые во временную коллекцию, добавленную при итерации коллекции.  В следующем примере этот подход используется для добавления квадрата чисел из коллекции в временную коллекцию, а затем для объединения коллекций в один объект массива.  
  
     [!code-csharp[System.InvalidOperationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs#3)]
     [!code-vb[System.InvalidOperationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb#3)]  
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a>Сортировка массива или коллекции, объекты которой невозможно сравнить  
 Для методов сортировки общего назначения, таких как метод <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> или метод <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType>, обычно требуется, чтобы хотя бы один из объектов был отсортирован, реализуя интерфейс <xref:System.IComparable%601> или <xref:System.IComparable>. В противном случае коллекция или массив не могут быть отсортированы, а метод создает исключение <xref:System.InvalidOperationException>. В следующем примере определяется класс `Person`, хранятся два объекта `Person` в универсальном <xref:System.Collections.Generic.List%601> объекте и выполняется попытка их сортировки. Как видно из выходных данных в примере, вызов метода <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> создает <xref:System.InvalidOperationException>.  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 Исключение можно устранить одним из трех способов:  
  
-   Если вы можете быть владельцем типа, который вы пытаетесь отсортировать (то есть при управлении его исходным кодом), можно изменить его, чтобы реализовать <xref:System.IComparable%601> или интерфейс <xref:System.IComparable>. Для этого необходимо реализовать метод <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> или <xref:System.IComparable.CompareTo%2A>. Добавление реализации интерфейса в существующий тип не является критическим изменением.  
  
     В следующем примере этот подход используется для предоставления <xref:System.IComparable%601> реализации класса `Person`. По-прежнему можно вызвать общий метод сортировки коллекции или массива и, как показано в выходных данных примера, коллекция сортируется успешно.  
  
     [!code-csharp[System.InvalidOperationException#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs#13)]
     [!code-vb[System.InvalidOperationException#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb#13)]  
  
-   Если не удается изменить исходный код для типа, который вы пытаетесь отсортировать, можно определить специальный класс сортировки, реализующий интерфейс <xref:System.Collections.Generic.IComparer%601>.  Можно вызвать перегрузку метода `Sort`, который включает параметр <xref:System.Collections.Generic.IComparer%601>. Этот подход особенно удобен, если требуется разработать специализированный класс сортировки, который может сортировать объекты на основе нескольких критериев.  
  
     В следующем примере используется подход путем разработки пользовательского класса `PersonComparer`, который используется для сортировки коллекций `Person`.  Затем он передает экземпляр этого класса в метод <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType>.  
  
     [!code-csharp[System.InvalidOperationException#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs#14)]
     [!code-vb[System.InvalidOperationException#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb#14)]  
  
-   Если не удается изменить исходный код для типа, который вы пытаетесь отсортировать, можно создать <xref:System.Comparison%601> делегат для выполнения сортировки. Сигнатура делегата —  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     В следующем примере используется подход путем определения метода `PersonComparison`, который соответствует сигнатуре делегата <xref:System.Comparison%601>.  Затем он передает этот делегат методу <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType>.  
  
     [!code-csharp[System.InvalidOperationException#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs#15)]
     [!code-vb[System.InvalidOperationException#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb#15)]  
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a>Приведение значения NULL\<T >, который имеет значение null, к базовому типу  
 Попытка приведения <xref:System.Nullable%601> значения, которое `null` его базовому типу, вызывает исключение <xref:System.InvalidOperationException> и отображает сообщение об ошибке "**объект, допускающий значение null, должен иметь значение.**  
  
 В следующем примере исключение <xref:System.InvalidOperationException> возникает при попытке выполнить итерацию массива, содержащего значение `Nullable(Of Integer)`.  
  
 [!code-csharp[System.InvalidOperationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs#4)]
 [!code-vb[System.InvalidOperationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb#4)]  
  
 Чтобы предотвратить исключение, сделайте следующее:  
  
-   Используйте свойство <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType>, чтобы выбрать только те элементы, которые не `null`.  
  
-   Вызовите одну из перегрузок <xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType>, чтобы предоставить значение по умолчанию для `null` значения.  
  
 В следующем примере оба варианта позволяют избежать возникновения исключения <xref:System.InvalidOperationException>.  
  
 [!code-csharp[System.InvalidOperationException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs#5)]
 [!code-vb[System.InvalidOperationException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb#5)]  
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a>Вызов метода System. LINQ. Enumerable для пустой коллекции  
 Методы <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>и <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> выполняют операции над последовательностью и возвращают один результат.   Некоторые перегрузки этих методов вызывают исключение <xref:System.InvalidOperationException>, если последовательность пуста, а другие перегрузки возвращают `null`. Метод <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> также вызывает исключение <xref:System.InvalidOperationException>, если последовательность содержит более одного элемента.  
  
> [!NOTE]
>  Большинство методов, которые вызывают исключение <xref:System.InvalidOperationException>, являются перегрузками. Убедитесь, что вы понимаете поведение выбранной перегрузки.  
  
 В следующей таблице перечислены сообщения об исключениях из <xref:System.InvalidOperationException> объектов исключений, создаваемых вызовами некоторых методов <xref:System.Linq.Enumerable?displayProperty=nameWithType>.  
  
|Метод|Message|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|**Последовательность не содержит элементов**|  
|`First`|**Sequence не содержит соответствующего элемента**|  
|`Single` <br /> `SingleOrDefault`|**Последовательность содержит более одного соответствующего элемента**|  
  
 Способ исключения или обойти исключение зависит от допущений приложения и от конкретного метода, который вы вызываете.  
  
-   При намеренном вызове одного из этих методов без проверки пустой последовательности предполагается, что последовательность не пуста и что пустая последовательность является непредвиденным событием. В этом случае подходит перехват или повторный вызов исключения.  
  
-   Если ошибка проверки пустой последовательности была непреднамеренной, можно вызвать одну из перегрузок перегрузки <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType>, чтобы определить, содержит ли последовательность какие-либо элементы.  
  
    > [!TIP]
    >  Вызов метода <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> перед созданием последовательности может повысить производительность, если обрабатываемые данные могут содержать большое количество элементов или операция, создающая последовательность, является дорогостоящей.  
  
-   Если вы вызвали метод, например <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>или <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, можно заменить альтернативный метод, например <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>или <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>, который возвращает значение по умолчанию вместо элемента последовательности.  
  
 В примерах содержатся дополнительные сведения.  
  
 В следующем примере метод <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> используется для вычисления среднего значения последовательности, значение которой больше 4. Поскольку значения из исходного массива не превышают 4, в последовательность не включаются значения, а метод создает исключение <xref:System.InvalidOperationException>.  
  
 [!code-csharp[System.InvalidOperationException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs#6)]
 [!code-vb[System.InvalidOperationException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb#6)]  
  
 Исключение можно устранить, вызвав метод <xref:System.Linq.Enumerable.Any%2A>, чтобы определить, содержит ли последовательность какие бы то ни было элементы перед вызовом метода, обрабатывающего последовательность, как показано в следующем примере.  
  
 [!code-csharp[System.InvalidOperationException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs#7)]
 [!code-vb[System.InvalidOperationException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb#7)]  
  
 Метод <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> возвращает первый элемент в последовательности или первый элемент последовательности, удовлетворяющий заданному условию. Если последовательность пуста и поэтому не имеет первого элемента, вызывается исключение <xref:System.InvalidOperationException>.  
  
 В следующем примере метод <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> создает исключение <xref:System.InvalidOperationException>, так как массив Дбкуериресултс не содержит элемент больше 4.  
  
 [!code-csharp[System.InvalidOperationException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs#8)]
 [!code-vb[System.InvalidOperationException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb#8)]  
  
 Можно вызвать метод <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> вместо <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, чтобы вернуть указанное значение или значения по умолчанию. Если метод не находит первый элемент в последовательности, он возвращает значение по умолчанию для этого типа данных.  Значение по умолчанию — `null` для ссылочного типа, ноль для типа данных numeric и <xref:System.DateTime.MinValue?displayProperty=nameWithType> для типа <xref:System.DateTime>.  
  
> [!NOTE]
>  Анализ значения, возвращаемого методом <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>, часто осложняется тем, что значение по умолчанию типа может быть допустимым значением в последовательности. В этом случае вы вызываете метод <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType>, чтобы определить, имеет ли последовательность допустимые члены перед вызовом метода <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>.  
  
 В следующем примере вызывается метод <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> для предотвращения исключения <xref:System.InvalidOperationException>, вызываемого в предыдущем примере.  
  
 [!code-csharp[System.InvalidOperationException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs#9)]
 [!code-vb[System.InvalidOperationException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb#9)]  
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a>Вызов Enumerable. Single или Enumerable. SingleOrDefault для последовательности без одного элемента  
 Метод <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> возвращает единственный элемент последовательности или единственный элемент последовательности, соответствующий заданному условию.    Если в последовательности нет элементов или имеется более одного элемента, метод создает исключение <xref:System.InvalidOperationException>.  
  
 Можно использовать метод <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> для возврата значения по умолчанию вместо создания исключения, если последовательность не содержит элементов. Однако метод <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> по-прежнему вызывает исключение <xref:System.InvalidOperationException>, если последовательность содержит более одного элемента.  
  
 В следующей таблице перечислены сообщения об исключениях из <xref:System.InvalidOperationException> объектов исключений, создаваемых вызовами методов <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> и <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>.  
  
|Метод|Message|  
|------------|-------------|  
|`Single`|**Sequence не содержит соответствующего элемента**|  
|`Single` <br /> `SingleOrDefault`|**Последовательность содержит более одного соответствующего элемента**|  
  
 В следующем примере вызов метода <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> создает исключение <xref:System.InvalidOperationException>, поскольку последовательность не содержит элемент больше 4.  
  
 [!code-csharp[System.InvalidOperationException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs#10)]
 [!code-vb[System.InvalidOperationException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb#10)]  
  
 В следующем примере предпринимается попытка предотвратить <xref:System.InvalidOperationException> исключение, возникающее, если последовательность пуста, вместо этого вызывается метод <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>. Однако, поскольку эта последовательность возвращает несколько элементов, значение которых больше 2, оно также вызывает исключение <xref:System.InvalidOperationException>.  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 Вызов метода <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> предполагает, что либо последовательность, либо последовательность, отвечающая указанным критериям, содержат только один элемент.  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> предполагает последовательность с нулевым или одним результатом, но больше нет. Если это предположение является предопределенной на вашей части, и эти условия не выполняются, вызовите или перехватите полученное <xref:System.InvalidOperationException> подходит. В противном случае или, если предполагается, что при некоторой частоте возникнут недопустимые условия, следует рассмотреть возможность использования другого метода <xref:System.Linq.Enumerable>, такого как <xref:System.Linq.Enumerable.FirstOrDefault%2A> или <xref:System.Linq.Enumerable.Where%2A>.  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a>Динамическое обращение к полю домена между приложениями  
 Инструкция <xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType> MSIL выдает исключение <xref:System.InvalidOperationException>, если объект, содержащий поле, адрес которого вы пытаетесь извлечь, не находится в домене приложения, в котором выполняется код. Доступ к адресу поля возможен только из домена приложения, в котором оно находится.  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a>Создание исключения InvalidOperationException  
 Исключение <xref:System.InvalidOperationException> следует вызывать только в том случае, если состояние объекта по какой-либо причине не поддерживает определенный вызов метода. Это значит, что вызов метода допустим в некоторых обстоятельствах или контекстах, но является недопустимым в других.  
  
 Если ошибка вызова метода вызвана недопустимыми аргументами, то вместо этого следует вызывать <xref:System.ArgumentException> или один из производных от него классов, <xref:System.ArgumentNullException> или <xref:System.ArgumentOutOfRangeException>.  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a>Прочие сведения  
 <xref:System.InvalidOperationException> использует COR_E_INVALIDOPERATION HRESULT, значение которого равно 0x80131509.  
  
 Список начальных значений свойств для экземпляра <xref:System.InvalidOperationException>, см. в разделе <xref:System.InvalidOperationException.%23ctor%2A> конструкторы.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Resources.ResourceSet" />
    <related type="Article" href="~/docs/standard/exceptions/index.md">Обработка и создание исключений</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.InvalidOperationException" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.InvalidOperationException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует свойство <xref:System.Exception.Message%2A> нового экземпляра, сопоставляя с ним системное сообщение, описывающее ошибку, например "не удается выполнить запрошенную операцию". В этом сообщении учитывается текущий язык и региональные параметры системы.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.InvalidOperationException>.  
  
|Свойство|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Пустая ссылка (`Nothing` в Visual Basic).|  
|<xref:System.Exception.Message%2A>|Локализованная строка сообщения об ошибке.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string -&gt; InvalidOperationException" Usage="new System.InvalidOperationException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение с описанием ошибки.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" /> с указанным сообщением об ошибке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует свойство <xref:System.Exception.Message%2A?displayProperty=nameWithType> нового исключения с помощью параметра `message`. Содержимое параметра `message` должно быть понятным пользователю. Для гарантированной локализации этой строки для текущей системной культуры необходимы сведения о том, кто вызывает этот конструктор.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.InvalidOperationException>.  
  
|Свойство|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Пустая ссылка (`Nothing` в Visual Basic).|  
|<xref:System.Exception.Message%2A>|Строка сообщения об ошибке.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InvalidOperationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="info">Объект, содержащий сериализованные данные объекта.</param>
        <param name="context">Контекстные данные об источнике или назначении.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" /> с указанными сериализованными данными.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор вызывается во время десериализации для восстановления объекта исключения, переданного в потоке. Дополнительные сведения см. в разделе [сериализация XML и SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Сериализация XML и SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string * Exception -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение об ошибке с объяснением причин исключения.</param>
        <param name="innerException">Исключение, ставшее причиной текущего исключения. Если параметр <paramref name="innerException" /> не является указателем null (<see langword="Nothing" /> в Visual Basic), то текущее исключение сгенерировано в блоке <see langword="catch" />, обрабатывающем внутреннее исключение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" /> с указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее это исключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Исключение, созданное как прямой результат предыдущего исключения, должно содержать в свойстве <xref:System.Exception.InnerException%2A> ссылку на предыдущее исключение. Свойство <xref:System.Exception.InnerException%2A> возвращает то же значение, которое передается конструктору, или пустую ссылку (`Nothing` в Visual Basic), если свойство <xref:System.Exception.InnerException%2A> не предоставляет конструктору значение внутреннего исключения.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.InvalidOperationException>.  
  
|Свойство|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Ссылка на внутреннее исключение.|  
|<xref:System.Exception.Message%2A>|Строка сообщения об ошибке.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="~/docs/standard/exceptions/index.md">Обработка и создание исключений</related>
      </Docs>
    </Member>
  </Members>
</Type>
